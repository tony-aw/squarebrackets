% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aaa6_squarebrackets_technical.R
\name{aaa6_squarebrackets_technical}
\alias{aaa6_squarebrackets_technical}
\alias{squarebrackets_technical}
\title{Additional Technical Details}
\description{
\bold{Atomic} \cr
\ifelse{html}{\figure{require_unique_names-NO-red.svg}{options: alt='[require unique names: NO]'}}{\link[=squarebrackets_technical]{require unique names: NO}} \cr
The atomic vector is the most basic class type. \cr
Matrices and Arrays are just atomic vectors with dimension attributes. \cr
All elements in an atomic vector class
must have the same atomic type
("logical", "integer", "numeric", "complex", "character" and "raw"). \cr
\cr
\bold{Factor} \cr
\ifelse{html}{\figure{require_unique_names-NO-red.svg}{options: alt='[require unique names: NO]'}}{\link[=squarebrackets_technical]{require unique names: NO}} \cr
Factors have the property that they can only store values that are defined in
their "levels" attribute; other values are not allowed, and thus result in \code{NA}s. \cr
Thus \link{sb_mod} does not coerce replacement values for factors.
This is quite different from the atomic vector classes,
which can store any value
(provided they are of the same atomic type). \cr
\cr
\bold{List} \cr
\ifelse{html}{\figure{require_unique_names-NO-red.svg}{options: alt='[require unique names: NO]'}}{\link[=squarebrackets_technical]{require unique names: NO}} \cr
Lists are recursive objects (i.e. they can be nested),
and they do not actually store values but rather store reference to other objects. \cr
Therefore \link{sb2_rec} method can be used to access recursive subsets of a list,
no matter how deep/low in hierarchy it is in the list. \cr
\cr
\bold{Data.frame-like} \cr
\ifelse{html}{\figure{require_unique_names-YES-darkgreen.svg}{options: alt='[require unique names: YES]'}}{\link[=squarebrackets_technical]{require unique names: YES}} \cr
The data.frame-like objects quite different from the previously named classes. \cr
And the different data.frame-like classes also differ from each other quite a bit -
especially in terms of sub-setting. \cr
The 'squarebrackets' R-package attempts to keep the data.frame methods as class agnostic as possible,
through the class agnostic functionality of the 'collapse' and 'data.table' R-packages. \cr
These 3 things cause some
oddities in how data.frame-like classes are treated differently from the other classes:
\itemize{
\item Whole-columns will be auto-coerced when replaced/transformed by \link{sb_mod},
but partial columns will not be auto-coerced by default.
\item The \link{sb_x} and \link{sb_rm} methods always automatically conserve all attributes
(though names and dimensions are adjusted accordingly, of course),
they are never stripped, unlike the other classes.
\item Giving a data.frame-like object with non-unique column names to the \code{sb_}-methods
returns an error.
Also, duplicating columns with \link{sb_x}
will automatically adjust the column names to make them unique. \cr \cr
}
}
