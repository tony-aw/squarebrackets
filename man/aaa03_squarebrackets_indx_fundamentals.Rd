% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aaa03_squarebrackets_indx_fundamentals.R
\name{aaa03_squarebrackets_indx_fundamentals}
\alias{aaa03_squarebrackets_indx_fundamentals}
\alias{squarebrackets_indx_fundamentals}
\title{Indexing Fundamentals}
\description{
This help page explains the fundamentals regarding how 'squarebrackets' treats indexing. \cr
Some familiarity with base R's \code{[} and \verb{[<-} operators is required to follow this help page. \cr
\cr
}
\section{Indexing Types}{

Base 'R' supports indexing through \code{logical}, \code{integer}, and \code{character} vectors. \cr
'squarebrackets' supports these also (albeit with some improvements),
but also supports some additional methods of indexing. \cr
\cr
\cr
\bold{Whole numbers} \cr
Whole numbers are the most basic form on index selection. \cr
All forms of indexing in 'squarebrackets' are internally translated to integer
(or double if\verb{ > (2^31 - 1)}) indexing first,
ensuring consistency. \cr
Indexing through integer/numeric indices in 'squarebrackets' works the same as in base 'R',
except that negative values are not allowed. \cr
So indexing starts at \code{1} and is inclusive. \cr
\cr
\cr
\bold{Logical} \cr
Selecting indices with a logical vector in 'squarebrackets' works the same as in base 'R',
except that recycling is not allowed. \cr
\cr
\cr
\bold{Characters} \cr
When selecting indices using a character vector,
base 'R' only selects the first matches in the names. \cr
'squarebrackets', however, selects all matches:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
nms <- c("a", letters[4:1], letters[1:5])
x <- 1:10
names(x) <- nms
print(x) #' `x` has multiple elements with the name "a"
#>  a  d  c  b  a  a  b  c  d  e 
#>  1  2  3  4  5  6  7  8  9 10

ii_x(x, "a") # extracts all indices with the name "a"
#> a a a 
#> 1 5 6

ii_x(x, c("a", "a")) # repeats all indices with the name "a"
#> a a a a a a 
#> 1 5 6 1 5 6
}\if{html}{\out{</div>}}

Character indices are internally translated to integer indices using
\link{match_all}. \cr
\cr
\cr
\bold{Imaginary Numbers} \cr
A \link[base]{complex} vector \code{y} is structured as \cr
\code{y = a + b * i} \cr
where \code{Re(y)} returns \code{a}, and \code{Im(y)} returns \code{b}. \cr
squarebrackets' includes support for indexing through imaginary numbers (\code{Im(y)}) of \link[base]{complex} vectors. \cr
Indexing with imaginary numbers is a generalization of indexing with regular integers. \cr
\cr
It works as follows: \cr
Imaginary numbers that are positive integers,
like \code{1:10 * 1i}, work the same as regular integers. \cr
Imaginary numbers that are negative integers,
like \code{1:10 * -1i},
index by counting backwards (i.e. from the end). \cr
Positive and negative numbers can be combined,
like \code{c(-10:1, 1:10) * 1i}. \cr
Note that \bold{only} the \code{Imaginary} part of a complex vector is used (\code{Im(y)}); \cr
the \code{Real} part (\code{Re(y)}) is \bold{ignored}. \cr
\cr
See the results of the following code as an example:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
x <- 1:30 # vector of 30 elements

ii_x(x, 1:10 * 1i) # extract first 10 elements
#>  [1]  1  2  3  4  5  6  7  8  9 10

ii_x(x, 1:10 * -1i) # extract last 10 elements
#>  [1] 30 29 28 27 26 25 24 23 22 21

ii_x(x, 10:1 * -1i) # last 10 elements, in tail()-like order
#>  [1] 21 22 23 24 25 26 27 28 29 30

ii_x(x, c(1, -1) * 1i) # extract first and last element
#> [1]  1 30
}\if{html}{\out{</div>}}

Thus complex vectors allow the user to choose between counting from the beginning,
like regular integers,
or backwards counting from the end, or a combination of both. \cr
\cr
\cr
\bold{Missing Index Argument} \cr
Both \code{NULL} and the numeric scalar \code{0L} can be used to specify an missing index argument. \cr
For example, given a matrix \code{x}, \code{ss_x(x, n(0, 1:10))} is equivalent to \code{x[ , 1:10]}. \cr
\cr
\cr
}

\section{Interior Indices and Subscripts}{


One can operate on flat/interior indices (often simply referred to as "indices")
using the \code{ii_}/ \code{ii2_} methods; \cr
These primarily use the \link[=squarebrackets_indx_args]{i} argument. \cr
\cr
One can operate on subscripts (= dimensional indices)
using the \code{ss_}/ \code{ss2_} methods; \cr
These primarily use the the \link[=squarebrackets_indx_args]{s, d} argument pair. \cr
(Given, for example, a 3-dimensional array,
the subscript \verb{[1:10, 2:5, 3:9]},
refers to rows 1 to 10, columns 2 to 5, and layers 3 to 9.) \cr
\cr
The \link[=squarebrackets_indx_args]{s, d} argument pair
works consistently for any dimensional object
supported by 'squarebrackets',
and does not require a-priori knowledge on the number of dimensions the object has. \cr
This is particularly useful for arrays, which can have any number of dimensions. \cr
\cr
Arrays and matrices (matrices are simply arrays with 2 dimensions)
support both flat/interior indices (using the \code{ii_}/ \code{ii2_} methods)
and subscripts (using the \code{ss_}/ \code{ss2_} methods). \cr
In the flat/interior indices, also called linear indices,
specify the indices of an array as-if it is vector,
thus ignoring dimensions. \cr
\cr
For the relationship between flat/interior indices and subscripts for arrays,
see the \link{sub2ind} help page. \cr
\cr
\cr
}

\section{Inverting}{

Inverting indices means to specify all elements \bold{except} the given indices. \cr
Consider for example the atomic vector \code{month.abb} (abbreviate month names). \cr
Given this vector, indices \code{1:5} gives \verb{c("Jan" "Feb" "Mar" "Apr", "May")}. \cr
Inverting those same indices will give \verb{c("Jun" "Jul" "Aug" "Sep" "Oct" "Nov" "Dec")}. \cr
\cr
In base 'R', inverting an index is done in different ways. \cr
(negative numbers for numeric indexing, negation for logical indexing,
manually un-matching for character vectors). \cr
\cr
'squarebrackets' provides a (somewhat) consistent syntax to invert indices: \cr
\itemize{
\item The methods that end with \verb{_x} perform extraction; \cr
to invert extraction,
i.e. return the object \bold{without} the specified subset,
use the methods that end with \verb{_wo}. \cr
\item In the modification methods (\verb{_mod_}/\verb{_set_}) one can set the argument
\link[=squarebrackets_indx_args]{inv}\code{ = TRUE} to invert indices. \cr \cr
}

\bold{EXAMPLES}

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
x <- month.abb
print(x)
#>  [1] "Jan" "Feb" "Mar" "Apr" "May" "Jun" "Jul" "Aug" "Sep" "Oct" "Nov" "Dec"


ii_x(x, 1:5) # extract first 5 elements
#> [1] "Jan" "Feb" "Mar" "Apr" "May"

ii_wo(x, 1:5) # return WITHOUT first 5 elements
#> [1] "Jun" "Jul" "Aug" "Sep" "Oct" "Nov" "Dec"


ii_mod(x, 1:5, rp = "XXX") # copy, replace first 5 elements, return result
#>  [1] "XXX" "XXX" "XXX" "XXX" "XXX" "Jun" "Jul" "Aug" "Sep" "Oct" "Nov" "Dec"

ii_mod(x, 1:5, inv = T, rp = "XXX") # same, but for all except first 5 elements
#>  [1] "Jan" "Feb" "Mar" "Apr" "May" "XXX" "XXX" "XXX" "XXX" "XXX" "XXX" "XXX"
}\if{html}{\out{</div>}}

\bold{ABOUT ORDERING} \cr
The order in which the user gives indices when inverting indices generally does not matter. \cr
The order of the indices as they appear in the original object \code{x} is maintained,
just like in base 'R'. \cr
\cr
\cr
}

\section{Out-of-Bounds Integers, Non-Existing Names, and NAs}{

\itemize{
\item Integer indices that are out of bounds (including \code{NaN} and \code{NA_integer_}) always give an error.
\item Character indices that specify non-existing names
is considered a form of zero-length indexing. \cr
Specifying \code{NA} names returns an error. \cr
\item Logical indices are translated internally to integers using \link[base]{which},
and so \code{NA}s are ignored. \cr \cr
}
}

\section{Index-less Sub-set Operations}{

Until now this help page focussed on performing sub-set operations with an indexing vector. \cr
\cr
Performing sub-set operations on a long vector using a index vector
(which may itself also be a long vector)
is not very memory-efficient. \cr
'squarebrackets' therefore introduces index-less sub-set operations,
through the \link{slice}\code{_} and \link{slicev}\code{_} methods. \cr
These methods are much more memory and computationally efficient than index-based sub-set methods
(and so also a bit better for the environment!). \cr
\cr
The \link{slice}\code{_} methods perform sequence based sub-set operations. \cr
\cr
The \link{slicev}\code{_} methods
(notice the "v" at the end)
perform value-based sub-set operations. \cr
Though this method is intentionally kept relatively simple,
it is still involved enough to warrant its own help page; \cr
for the details on value-based index-less sub-set operations,
please see \link{squarebrackets_slicev}. \cr
\cr
\cr
}

\section{Regarding Performance}{

Integer vectors created through the \code{:} operator are "compact ALTREP" integer vectors,
and provide the fastest way to specify indices. \cr
Indexing through names (i.e. character vectors) is the slowest. \cr
Complex vectors of imaginary numbers are somewhat in the middle
in terms of speed. \cr
\cr
Index-less sub-set operations are usually faster and more memory efficient
than any index-based sub-set operation. \cr
So if performance is important, use index-less sub-set operations,
or use compact ALTREP integer indices. \cr
\cr
\cr
}

\section{Indexing in Recursive Subsets}{

Until now this help page focussed on indexing for regular (or "shallow") subsets. \cr
This section will discuss indexing in recursive subsets. \cr
\cr
One of the differences between atomic and recursive objects,
is that recursive objects support recursive subsets, while atomic objects do not. \cr
\cr
Bear in mind that every element in a recursive object is a reference to another object. \cr
Consider the following list \code{x}:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
x <- list(
   A = 1:10,
   B = letters,
   C = list(A = 11:20, B = month.abb)
)

}\if{html}{\out{</div>}}

Regular subsets, AKA surface-level subset operations (\code{[}, \verb{[<-} in base 'R'),
operate on the recursive object itself. \cr
I.e. \link{ii2_x}\verb{(x, 1)}, or equivalently \code{x[1]},
returns the \bold{list} \code{list(A = 1:10)}:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
ii2_x(x, 1) # equivalent to x[1]; returns list(A = 1:10)
#> $A
#>  [1]  1  2  3  4  5  6  7  8  9 10
}\if{html}{\out{</div>}}

Recursive subset operations (\code{[[}, \verb{[[<-}, and \code{$} in base 'R'), on the other hand,
operate on an object a subset of the recursive object references to. \cr
I.e. \link{lst_rec}\verb{(x, 1)}, or equivalently \code{x[[1]]},
returns the \bold{integer vector} \code{1:10}:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
lst_rec(x, 1) # equivalent to x[[1]]; returns 1:10
#>  [1]  1  2  3  4  5  6  7  8  9 10
}\if{html}{\out{</div>}}

Recursive objects can refer to other recursive objects,
which can themselves refer to recursive objects, and so on. \cr
Recursive subsets can go however deep you want. \cr
So, for example,
to extract the character vector \code{month.abb} from the aforementioned list \code{x},
one would need to do: \cr
\link{lst_rec}\verb{(x, c("C","B"))}, (in base R: \code{x$C$B}):

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
lst_rec(x, c("C","B")) # equivalent to x$C$B
#>  [1] "Jan" "Feb" "Mar" "Apr" "May" "Jun" "Jul" "Aug" "Sep" "Oct" "Nov" "Dec"

# or:

lst_rec(x, c(3, 2)) # equivalent to x[[3]][[2]]
#>  [1] "Jan" "Feb" "Mar" "Apr" "May" "Jun" "Jul" "Aug" "Sep" "Oct" "Nov" "Dec"
}\if{html}{\out{</div>}}

\bold{LIMITATIONS} \cr
Indexing in recursive subsets is significantly more limited than in regular
(or "shallow") subsets:
\itemize{
\item Recursive subset operations
using \link{lst_rec}/\link{lst_recin}
only support positive integer vectors and character vectors.
\item Imaginary numbers (using complex vectors) and logical vectors are not supported.
\item Since a recursive subset operation only operates on a single element,
specifying the index with a character vector only selects the first matching element
(just like base 'R'), not all matches.
\item Inverting indices is also \bold{not} available for recursive indexing.
\item Unlike regular sub-setting, out-of-bounds specification for indices is acceptable,
as it can be used to add new values to lists. \cr \cr
}
}

\section{Non-Standard Evaluation}{

'squarebrackets' is designed primarily for programming,
and seeks to be fully programmatically friendly. \cr
As part of this endeavour,
'squarebrackets' never uses Non-Standard Evaluation. \cr
All input for all methods and functions in 'squarebrackets'
are objects that can be stored in a variable. \cr
Like atomic vectors, lists, formulas, etc. \cr
\cr
}

