% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aaa2_squarebrackets_mutable_classes.R
\name{aaa2_squarebrackets_mutable_classes}
\alias{aaa2_squarebrackets_mutable_classes}
\alias{squarebrackets_mutable_classes}
\title{Supported Mutable S3 classes, With Auto-Coercion Rules}
\description{
The \code{sb_} generic methods support the following Mutable S3 classes: \cr
\itemize{
\item \link{mutable_atomic} (this vector class supports any dimension, thus also matrices and arrays);
\item \link[data.table]{data.table} (and classes that inherit from \code{data.table}, like \code{tidytable} and \code{sf-data.table});
\item \bold{Views of Lists}: Though lists themselves are treated as immutable,
lists can contain mutable objects,
and so modification by reference of mutable views of lists \bold{is} support by the 'squarebrackets'. \cr \cr
}

The mutable version of the \code{list} class
would be, for example,
the various \link[collections]{collections} classes from the 'collections' package,
and the \link[fastmap]{fastmap} class from the 'fastmap' package;
both of these use their own sub-setting method which is \bold{not} based on square brackets operators,
and thus not covered by this package. \cr
Environments are also not covered by this package. \cr \cr
}
\section{Auto-Coercion Rules}{

\bold{Coercion Semantics} \cr
The mutable classes support "copy-on-modify" semantics like the immutable classes,
but - unlike the immutable classes - they also support "pass-by-reference" semantics. \cr
The \link{sb_mod} method
modify subsets of an object through a \bold{deep copy}. \cr
The \link{sb_set} method and \link{dt_setcoe} function
modify subsets of an object \bold{by reference}. \cr
These 2 copy semantics - "pass by reference" or "modify copy" -
have slightly different auto-coercion rules. \cr
These are explained in this section. \cr
Note that the \link{sb_before} and \link{sb_after} methods
usually allow coercion for all classes.
\cr
\cr
\bold{mutable_atomic} \cr
\ifelse{html}{\figure{coercion_through_copy-YES-darkgreen.svg}{options: alt='[coercion_through_copy: YES]'}}{\link[=squarebrackets_mutable_classes]{coercion_through_copy: YES}} \cr
\ifelse{html}{\figure{coercion_by_reference-NO-red.svg}{options: alt='[coercion_by_reference: NO]'}}{\link[=squarebrackets_mutable_classes]{coercion_by_reference: NO}} \cr
Mutable atomic objects are automatically coerced to fit the modified subset values,
when modifying through copy, just like regular atomic classes. \cr
For example, replacing one or multiple values in an integer vector
(type \code{int})
with a decimal number
(type \code{dbl})
will coerce the entire vector to type \code{dbl}. \cr
\cr
Replacing or transforming subsets of mutable atomic objects \bold{by reference}
does NOT support coercion.
Thus, for example, the following code,

\if{html}{\out{<div class="sourceCode r">}}\preformatted{x <- 1:16
sb_set(x, i = 1:6, rp = 8.5)
x
}\if{html}{\out{</div>}}

gives \verb{c(rep(8, 6) 7:16)} instead of \code{c(rep(8.5, 6), 7:16)},
because \code{x} is of type \code{integer}, so \code{rp} is interpreted as type \code{integer} also. \cr
\cr
\cr
\bold{data.table, when replacing/transforming whole columns} \cr
\ifelse{html}{\figure{coercion_through_copy-YES-darkgreen.svg}{options: alt='[coercion_through_copy: YES]'}}{\link[=squarebrackets_mutable_classes]{coercion_through_copy: YES}} \cr
\ifelse{html}{\figure{coercion_by_reference-YES-darkgreen.svg}{options: alt='[coercion_by_reference: YES]'}}{\link[=squarebrackets_mutable_classes]{coercion_by_reference: YES}} \cr
A data.table is actually a list made mutable,
where each column is itself a list.
As such, replacing/transforming whole columns,
so \code{row = NULL} and \code{filter = NULL},
allows completely changing the type of the column. \cr
Note that coercion of columns needs arguments
\code{row = NULL} and \code{filter = NULL}
in the \link{sb_mod} and \link{sb_set} methods;
NO auto-coercion will take place when specifying something like \code{row = 1:nrow(x)}
(see next section). \cr
\cr
\cr
\bold{data.table, when partially replacing/transforming columns} \cr
\ifelse{html}{\figure{coercion_through_copy-NO-red.svg}{options: alt='[coercion_through_copy: NO]'}}{\link[=squarebrackets_mutable_classes]{coercion_through_copy: NO}} \cr
\ifelse{html}{\figure{coercion_by_reference-NO-red.svg}{options: alt='[coercion_by_reference: NO]'}}{\link[=squarebrackets_mutable_classes]{coercion_by_reference: NO}} \cr
If rows are specified in the \link{sb_mod} and \link{sb_set} methods,
and thus not whole columns but parts of columns are replaced or transformed,
NO auto-coercion takes place. \cr
I.e.: replacing/transforming a value in an integer (\code{int}) column to become \code{1.5},
will NOT coerce the column to the decimal type (\code{dbl});
instead, the replacement value \code{1.5} is coerced to integer \code{1}. \cr
The \code{coe} argument in the \link{sb_mod} method
allows the user to enforce coercion,
even if subsets of columns are replaced/transformed instead of whole columns. \cr
Specifically, the \code{coe} arguments allows the user to specify a coercive function
to be applied on the entirety of every column specified in \code{col} or \code{vars};
columns outside this subset are not affected. \cr
This coercion function is, of course,
applied before replacement (\code{rp}) or transformation (\code{tf()}). \cr
\cr
\cr
\bold{Views of Lists} \cr
\ifelse{html}{\figure{coercion_through_copy-depends-lightblue.svg}{options: alt='[coercion_through_copy: depends]'}}{\link[=squarebrackets_mutable_classes]{coercion_through_copy: depends}} \cr
\ifelse{html}{\figure{coercion_by_reference-depends-lightblue.svg}{options: alt='[coercion_by_reference: depends]'}}{\link[=squarebrackets_mutable_classes]{coercion_by_reference: depends}} \cr
Regular lists themselves are not treated as mutable objects by 'squarebrackets'. \cr
However, lists are not actually really objects,
merely a (potentially hierarchical) structure of pointers. \cr
Thus, even if a list itself is not treated as mutable,
subsets of a list which are themselves mutable classes, are mutable. \cr
For example,
if you have a list of \code{data.table} objects,
the data.tables themselves are mutable. \cr
Therefore, the following will work: \cr

\if{html}{\out{<div class="sourceCode r">}}\preformatted{x <- list(
 a = data.table(cola = 1:10, colb = letters[1:10]),
 b = data.table(cola = 11:20, colb = letters[11:20])
)
mypointer <- x$a
sb_set(mypointer, col = "cola", tf = \\(x)x^2)

}\if{html}{\out{</div>}}

Notice in the above code that \code{mypointer} is not a copy of \code{x$a},
since they have the same address. \cr
Thus changing \code{mypointer} also changes \code{x$a}. \cr
In other words: \code{mypointer} is what could be called a "view" of \code{x$a}. \cr
Notice also that \code{sb_set(x$a, ...)} will not work,
since \code{sb_set()} requires \bold{actual variables},
similar to in-place functions in the style of \code{`myfun()<-`}. \cr
\cr
The auto-coercion rules of Views of Lists,
depends entirely on the object itself. \cr
Thus if the list subset is a data.table,
mutable matrix, coercion rules of data.tables apply. \cr
And if the list subset is a data.table,
coercion rules of mutable matrices apply.,
etc. \cr \cr
}

\examples{

# Coercion examples - mutable_atomic ====

x <- as.mutable_atomic(1:16)
sb_set(x, i = 1:6, rp = 8.5) # 8.5 coerced to 8, because `x` is of type `integer`
print(x)

#############################################################################

# Coercion examples - data.table - whole columns ====

# sb_mod():
obj <- data.table::data.table(
  a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])
)
str(obj) # notice that columns "a" and "c" are INTEGER (`int`)
sb_mod(
  obj, vars = is.numeric,
  tf = sqrt # SAFE: row=NULL & filter = NULL, so coercion performed
)

# sb_set():
sb_set(
  obj, vars = is.numeric,
  tf = sqrt # SAFE: row=NULL & filter = NULL, so coercion performed
)
str(obj)

#############################################################################


# Coercion examples - data.table - partial columns ====

# sb_mod():
obj <- data.table::data.table(
  a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])
)
str(obj) # notice that columns "a" and "c" are INTEGER (`int`)

sb_mod(
  obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,
  tf = sqrt
  # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost
) 
sb_mod(
  obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,
  coe = as.double, tf = sqrt # SAFE: coercion performed
)

# sb_set():
obj <- data.table::data.table(
  a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])
)
str(obj) # notice that columns "a" and "c" are INTEGER (`int`)
sb_set(
  obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,
  tf = sqrt
  # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost
)
print(obj)

obj <- data.table::data.table(
  a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])
)
str(obj)
obj <- sb_coe(obj, vars = is.numeric, v = as.numeric)
str(obj)
sb_set(obj,
  filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,
  tf = sqrt # SAFE: coercion performed by sb_coe(); so no warnings
) 
print(obj)

#############################################################################

# View of List ====

x <- list(
 a = data.table::data.table(cola = 1:10, colb = letters[1:10]),
 b = data.table::data.table(cola = 11:20, colb = letters[11:20])
)
print(x)
mypointer <- x$a
address(mypointer) == address(x$a) # they are the same
sb_set(mypointer, col = "cola", tf = \(x)x^2)
print(x) # notice x has been changed


}
