% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aaa00_squarebrackets_help.R
\name{aaa00_squarebrackets_help}
\alias{aaa00_squarebrackets_help}
\alias{squarebrackets-package}
\alias{squarebrackets}
\alias{squarebrackets_help}
\title{squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming}
\description{
squarebrackets: \cr
Subset Methods as Alternatives to the Square Brackets Operators for Programming. \cr
\cr
'squarebrackets' provides subset methods
(supporting both atomic and recursive S3 classes)
that may be more convenient alternatives to the \code{[} and \verb{[<-} operators,
whilst maintaining similar performance. \cr
Some nice properties of these methods include, but are not limited to, the following.
\enumerate{
\item The \code{[} and \verb{[<-} operators use different rule-sets for different data.frame-like types
(data.frames, data.tables, tibbles, tidytables, etc.). \cr
The 'squarebrackets' methods use the same rule-sets for the different data.frame-like types.
\item Performing dimensional subset operations on an array using \code{[} and \verb{[<-},
requires a-priori knowledge on the number of dimensions the array has. \cr
The 'squarebrackets' methods work on any arbitrary dimensions without requiring such prior knowledge.
\item When selecting names with the \code{[} and \verb{[<-} operators,
only the first occurrence of the names are selected in case of duplicate names. \cr
The 'squarebrackets' methods always perform on all names in case of duplicates,
not just the first.
\item The \code{[[} and \verb{[[<-} operators
allow operating on a recursive subset of a nested list. \cr
But these only operate on a single recursive subset,
and are not vectorized for multiple recursive subsets of a nested list at once. \cr
'squarebrackets' provides a way to reshape a nested list
into a recursive matrix,
thereby allowing vectorized operations on recursive subsets of such a nested list.
\item The \verb{[<-} operator only supports copy-on-modify semantics for most classes. \cr
The 'squarebrackets' methods provides explicit pass-by-reference and pass-by-value semantics,
whilst still respecting things like binding-locks and mutability rules.
\item 'squarebrackets' supports index-less sub-set operations,
which is more memory efficient
(and better for the environment)
for \verb{long vectors} than sub-set operations using the \code{[} and \verb{[<-} operators. \cr \cr
}
}
\section{Goal}{


Among programming languages,
'R' has perhaps one of the most
flexible and comprehensive sub-setting functionality,
provided by the square brackets operators (\code{[}, \verb{[<-}). \cr
But in some situations the square brackets operators
are occasionally less than optimally convenient \cr
\cr
The Goal of the 'squarebrackets' package
is not to replace the square-brackets operators,
but to provide \bold{alternative} sub-setting methods and functions,
to be used in situations where the square bracket operators are inconvenient. \cr
\cr
\cr
}

\section{Supported Structures}{

'squarebrackets' only supports the most common S3 classes,
and only those that primarily use square brackets for sub-setting
(hence the name of the package). \cr
\cr
'squarebrackets' supports the following structures:
\itemize{
\item basic \code{atomic} classes \cr
(atomic vectors, matrices, and arrays).
\item \link{mutable_atomic} classes \cr
(\link{mutable_atomic} vectors, matrices, and arrays).
\item \link{factor}. \cr
\item basic list classes \cr
(recursive vectors, matrices, and arrays). \cr
\item \link[base]{data.frame} \cr
(including the classes \code{tibble}, \code{sf-data.frame} and \code{sf-tibble}).
\item \link[data.table]{data.table} \cr
(including the classes \code{tidytable}, \code{sf-data.table}, and \code{sf-tidytable}). \cr \cr
}

See \link{squarebrackets_supported_structures} for more details. \cr \cr
}

\section{Sub-set Operation Methods}{


The main focus of this package is on its generic methods. \cr
\cr
Generic methods for atomic objects
start with \code{sb_}. \cr
Generic methods for recursive objects (list, data.frame, etc.)
start with \code{sb2_}. \cr
There is also the somewhat separate \link{idx} method,
which works on both recursive and non-recursive objects. \cr
And finally there are the \code{slice_} methods,
which (currently) only work on (mutable) atomic vectors. \cr
\cr

\ifelse{html}{\figure{access_subsets-darkgreen.svg}{options: alt='[ACCESS SUBSETS]'}}{\link[=squarebrackets_help]{ACCESS SUBSETS}} \cr

Methods to access subsets (i.e. extract selection, or extract all except selection):
\itemize{
\item \link{sb_x}, \link{sb2_x}: extract, exchange, or duplicate subsets.
\item \link{sb_wo},  \link{sb2_wo}: return an object without the specified subset.
\item \link{sb2_rec}: access recursive subsets of lists.
\item \link{slice_x}: index-less and efficient,
sequence-based extraction of a subset from a long vector.
\item \link{slice_wo}: index-less and efficient,
sequence-based returning a long vector without the specified subset.
\item \link{slicev_x}: index-less and efficient,
value-based extraction of a subset from a long vector. \cr \cr
}

\ifelse{html}{\figure{modify_subsets-red.svg}{options: alt='[MODIFY SUBSETS]'}}{\link[=squarebrackets_help]{MODIFY SUBSETS}} \cr

Methods to modify subsets:
\itemize{
\item \link{idx}: translate given indices/subscripts,
for the purpose of copy-on-modify substitution.
\item \link{sb2_recin}: replace, transform, remove, or add recursive subsets to a list,
through R's default Copy-On-Modify semantics.
\item \link{sb_mod}, \link{sb2_mod}: return the object with modified
(transformed or replaced) subsets.
\item Methods to \link[=sb_setRename]{rename a mutable object} using
\link[=squarebrackets_PassByReference]{pass-by-reference semantics}.
\item \link{sb_set}, \link{sb2_set}: modify (transform or replace)
subsets of a \link[=squarebrackets_supported_structures]{mutable object}
using \link[=squarebrackets_PassByReference]{pass-by-reference semantics}.
\item \link{slice_set}: index-less and efficient,
sequence-based modification of a (long) vector subset using
\link[=squarebrackets_PassByReference]{pass-by-reference semantics}.
\item \link{slicev_set}: index-less and efficient,
value-based modification of a (long) vector subset using
\link[=squarebrackets_PassByReference]{pass-by-reference semantics}. \cr \cr
}

\ifelse{html}{\figure{extend_beyond-purple.svg}{options: alt='[EXTEND BEYOND]'}}{\link[=squarebrackets_help]{EXTEND BEYOND}} \cr

Methods to extend or re-arrange an object beyond its current size:
\itemize{
\item \link{sb_x}, \link{sb2_x}: extract, exchange, or duplicate subsets.
\item \link{sb2_recin}: replace, transform, remove, or add recursive subsets to a list,
through R's default Copy-On-Modify semantics.
}

See \link{squarebrackets_method_dispatch} for more information on how 'squarebrackets'
uses its S3 Method dispatch. \cr \cr
}

\section{Functions}{


\ifelse{html}{\figure{specialized_functions-darkred.svg}{options: alt='[SPECIALIZED FUNCTIONS]'}}{\link[=squarebrackets_help]{SPECIALIZED FUNCTIONS}} \cr
Additional specialized sub-setting functions are provided:
\itemize{
\item \link{lst_untree}: unnest tree-like nested list into a recursive matrix,
to speed-up vectorized sub-setting on recursive subsets of the list.
\item The \link[=dt_setcoe]{dt_}-functions
to programmatically perform \code{data.table}-specific \code{[}-operations,
with the security measures provided by the 'squarebrackets' package.
\item \link{setapply}: apply functions over mutable matrix margins
using \link[=squarebrackets_PassByReference]{pass-by-reference semantics}. \cr \cr
}

\ifelse{html}{\figure{helper_functions-lightblue.svg}{options: alt='[HELPER FUNCTIONS]'}}{\link[=squarebrackets_help]{HELPER FUNCTIONS}} \cr
A couple of convenience functions, and helper functions for creating ranges, sequences, and indices
(often needed in sub-setting)
are provided:
\itemize{
\item \link{currentBindings}: list or lock all currently existing bindings
that share the share the same address as the input variable.
\item \link{n}: Nested version of \link[base]{c},
and short-hand for \link[base]{list}.
\item \link{ndim}: Get the number of dimensions of an object.
\item \link{sub2coord}, \link{coord2ind}: Convert subscripts
(array indices) to coordinates,
coordinates to flat indices,
and vice-versa.
\item \link{match_all}: Find all matches, of one vector in another,
taking into account the order and any duplicate values of both vectors.
\item Computing indices: \cr
\link{idx_r} to compute an integer index range. \cr
\link{idx_by} to compute grouped indices. \cr
\link[=idx_ord_v]{idx_ord_}-functions to compute ordered indices. \cr \cr
}
}

\section{Overview Help Pages}{


Besides the website,
'squarebrackets' comes with several help pages
that can be accessed from within 'R'. \cr

MAIN DOCUMENTATION:
\itemize{
\item \link{squarebrackets_supported_structures}: \cr
Lists the structures that are supported by 'squarebrackets',
and explains some related terminology.
\item \link{squarebrackets_indx_fundamentals}: \cr
Explains the essential fundamentals of the indexing forms in 'squarebrackets'.
\item \link{squarebrackets_indx_args}: \cr
Explains the common indexing arguments used in the main S3 methods.
\item \link{squarebrackets_modify}: \cr
Explains the essentials of modification in 'squarebrackets'
\item \link{squarebrackets_options}: \cr
Lists and explains the options the user can specify in 'squarebrackets'.
\item \link{squarebrackets_method_dispatch}: \cr
Gives details regarding the S3 method dispatch in 'squarebrackets'. \cr \cr
}

ADDITIONAL DOCUMENTATION:
\itemize{
\item \link{squarebrackets_PassByReference}: \cr
Explains Pass-by-Reference semantics, and its important consequences. \cr
If you are not planning on using the pass-by-reference functionality
in 'squarebrackets',
you do not need to read this help page.
\item \link{squarebrackets_coercion}: \cr
Explains the difference in coercion rules between
modification through Pass-by-Reference semantics and
modification through copy (i.e. pass-by-value)
for the supported mutable structures. \cr
If you are not planning on using the pass-by-reference functionality
in 'squarebrackets',
you do not need to read this help page.
\item \link{squarebrackets_slicev}: \cr
Explains the arguments for the \link{slicev} set of methods. \cr
If you are not planning to use the \link{slicev} methods,
you do not need to read this help page. \cr \cr
}
}

\section{Properties Details}{

The alternative sub-setting methods and functions provided by 'squarebrackets'
have the following properties:
\itemize{
\item \bold{Programmatically friendly}:
\itemize{
\item Unlike base \code{[},
it's not required to know the number of dimensions of an array a-priori,
to perform subset-operations on an array.
\item Missing arguments can be filled with \code{NULL},
instead of using dark magic like \code{base::quote(expr =    )}.
\item No Non-standard evaluation.
\item Functions are pipe-friendly.
\item No (silent) vector recycling.
\item Extracting and removing subsets uses the same syntax.
}
\item \bold{Class consistent}:
\itemize{
\item sub-setting of multi-dimensional objects by specifying dimensions
(i.e. rows, columns, ...)
use \code{drop = FALSE}. \cr
So matrix in, matrix out.
\item The methods deliver the same results for
data.frames, data.tables, tibbles, and tidytables. \cr
No longer does one have to re-learn the different brackets-based sub-setting rules
for different types of data.frame-like objects. \cr
Powered by the subclass agnostic 'C'-code from 'collapse' and 'data.table'.
}
\item \bold{Explicit copy semantics}:
\itemize{
\item Sub-set operations that change its memory allocations,
always return a modified (partial) copy of the object. \cr
\item For sub-set operations that just change values in-place
(similar to the \verb{[<-} and \verb{[[<-} methods)
the user can choose a method that modifies the object by \bold{reference},
or choose a method that returns a \bold{(partial) copy}.
}
\item \bold{Careful handling of names}:
\itemize{
\item Sub-setting an object by index names returns ALL matches with the given names,
not just the first.
\item Data.frame-like objects (see supported classes below)
are forced to have unique column names.
\item Sub-setting arrays using \code{x[indx1, indx2, etc.]} will drop \code{names(x)}. \cr
The methods from 'squarebrackets' will not drop \code{names(x)}.
}
\item \bold{Concise function and argument names}.
\item \bold{Performance & Energy aware}: \cr
Despite the many checks performed, the functions are kept reasonably speedy,
through the use of the 'Rcpp', 'collapse', and 'data.table' R-packages. \cr
The functions were also made to be as memory efficient as reasonably possible,
to lower the carbon footprint of this package. \cr \cr
}
}

\references{
The badges shown in the documentation of this R-package were made using the services of: \url{https://shields.io/}
}
\author{
\strong{Author, Maintainer}: Tony Wilkes \email{tony_a_wilkes@outlook.com} (\href{https://orcid.org/0000-0001-9498-8379}{ORCID})
}
