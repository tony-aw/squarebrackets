% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generic_bind.R
\name{bind}
\alias{bind}
\alias{bind_mat}
\alias{bind2_mat}
\alias{bind_array}
\alias{bind2_array}
\alias{bind2_dt}
\title{Dimensional Binding of Objects}
\usage{
bind_mat(arg.list, along, deparse.level = 1)

bind2_mat(arg.list, along, deparse.level = 1)

bind_array(
  arg.list,
  along,
  name_along = TRUE,
  comnames_from = 1L,
  name_flat = FALSE
)

bind2_array(
  arg.list,
  along,
  name_along = TRUE,
  comnames_from = 1L,
  name_flat = FALSE
)

bind2_dt(arg.list, along)
}
\arguments{
\item{arg.list}{a list of only the appropriate objects. \cr
Do not mix recursive and atomic objects in the same list,
as that may result in unexpected results. \cr}

\item{along}{a single integer,
indicating the dimension along which to bind the dimensions. \cr
I.e. use \code{along = 1} for row-binding, \code{along = 2} for column-binding, etc. \cr
For arrays, additional flexibility is available:
\itemize{
\item Specifying \code{along = 0} will bind the arrays on a new dimension before the first,
making \code{along} the new first dimension.
\item Specifying \code{along = n+1}, with \code{n} being the last available dimension,
will create an additional dimension (\code{n+1}) and bind the arrays along that new dimension.
}}

\item{deparse.level}{see \link[base]{cbind} and \link[base]{rbind}.}

\item{name_along}{Boolean, for \code{bind_array()} and \code{bind2_array()}. \cr
Indicates if dimension \code{along} should be named. \cr}

\item{comnames_from}{integer scalar or \code{NULL}, for \code{bind_array()} and \code{bind2_array()}. \cr
Indicates which object in \code{arg.list} should be used for naming the shared dimension. \cr
If \code{NULL}, no communal names will be given. \cr
For example: \cr
When binding columns of atomic matrices,
\code{comnames_from = 1} results in \code{bind_array()} using \code{rownames(arg.list[[1]])} for the row names of the output.}

\item{name_flat}{Boolean, for \code{bind_array()} and \code{bind2_array()}. \cr
Indicates if flat indices should be named. \cr
Note that setting this to \code{TRUE} will reduce performance considerably. \cr
\ifelse{html}{\figure{for_performance-set_to_FALSE-red.svg}{options: alt='[for performance: set to FALSE]'}}{\link[=squarebrackets_help]{for performance: set to FALSE}}}
}
\value{
The new object.
}
\description{
The \code{bind_} and \code{bind2_} implementations provide dimensional binding functionalities. \cr
\code{bind_} is for atomic objects, and \code{bind2_} for recursive objects. \cr
When possible, the \code{bind_}/\code{bind2_} functions return \link[=squarebrackets_supported_structures]{mutable classes}. \cr
\cr
The following implementations are available:
\itemize{
\item \code{bind_mat()} binds dimensionless atomic vectors and atomic matrices row- or column-wise. \cr
Returns a \link{mutable_atomic} matrix. \cr
\item \code{bind2_mat()} binds dimensionless recursive vectors and recursive matrices row- or column-wise. \cr
Returns a recursive matrix (immutable). \cr
\item \code{bind_array()} binds atomic arrays and matrices. \cr
Returns a \link{mutable_atomic} array. \cr
\item \code{bind2_array()} binds recursive arrays and matrices. \cr
Returns a recursive array (immutable).
\item \code{bind2_dt()} binds data.tables and other data.frame-like objects. \cr
Returns a \code{data.table}. \cr
Faster than \code{do.call(cbind, ...)} or \code{do.call(rbind, ...)} for regular \code{data.frame} objects. \cr
}

Note that the naming convention of the binding implementations here is
"bind_"/"bind2_" followed by the \bold{resulting class} (abbreviated). \cr
I.e. \code{bind_mat} \bold{returns} a matrix, but can bind both matrices and vectors. \cr
And \code{bind_array} \bold{returns} an array, but can bind both arrays and matrices. \cr
And \code{bind2_dt} \bold{returns} a data.table, but can bind not only data.tables,
but also most other data.frame-like objects. \cr \cr
}
\details{
\code{bind_array()} and \code{bind2_array()} are modified versions of the fantastic
\code{abind::}\link[abind]{abind} function
by Tony Plare and Richard Heiberger (see reference below). \cr
\code{bind_array()} has slightly better performance than \code{abind::}\link[abind]{abind},
and has more streamlined naming options. \cr
\code{bind2_array()} also has the streamlined naming options,
and additionally differs from \code{abind::}\link[abind]{abind}
in that it can handle recursive arrays properly
(the original \code{abind::}\link[abind]{abind} function would unlist everything to atomic arrays). \cr
\cr
\code{bind_mat()} and \code{bind2_mat()} are modified versions of \link[base]{rbind}/\link[base]{cbind}. \cr
The primary differences is that \code{bind_mat()/bin2_mat()}
give an error when fractional recycling is attempted
(like binding  \code{1:3} with \code{1:10}). \cr \cr
}
\examples{

# atomic arrays ====
x <- matrix(1:12,3,4)
dimnames(x) <- n(letters[1:3], LETTERS[1:4])
names(x) <- month.abb
print(x)
y <- x+100
arg.list <- list(x = x, y = y)
bind_array(arg.list, along=0) # binds on new dimension before first
bind_array(arg.list, along=1) # binds on first dimension
bind_array(arg.list, along=2)
bind_array(arg.list, along=3) # bind on new dimension after last


################################################################################


# recursive arrays ====
x <- matrix(as.list(1:12),3,4)
dimnames(x) <- n(letters[1:3], LETTERS[1:4])
names(x) <- month.abb
print(x)
y <- lapply(x, \(x) + 100)
dim(y) <- dim(x)
arg.list <- list(x = x, y=y)
bind2_array(arg.list, along=0) # binds on new dimension before first
bind2_array(arg.list, along=1) # binds on first dimension
bind2_array(arg.list, along=2)
bind2_array(arg.list, along=3) # bind on new dimension after last

}
\references{
Plate T, Heiberger R (2016). \emph{abind: Combine Multidimensional Arrays}. R package version 1.4-5, \url{https://CRAN.R-project.org/package=abind}.
}
