% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bind.R
\name{bind}
\alias{bind}
\alias{bind_mat}
\alias{bind_array}
\alias{bind_dt}
\title{Dimensional Binding of Objects}
\usage{
bind_mat(arg.list, along, name_deparse = TRUE, comnames_from = 1L)

bind_array(
  arg.list,
  along,
  name_along = TRUE,
  comnames_from = 1L,
  name_flat = FALSE
)

bind_dt(arg.list, along)
}
\arguments{
\item{arg.list}{a list of only the appropriate objects. \cr
If \code{arg.list} is named,
its names will be used for the names of dimension \code{along} of the output,
as far as possible.}

\item{along}{a single integer,
indicating the dimension along which to bind the dimensions. \cr
I.e. use \code{along = 1} for row-binding, \code{along = 2} for column-binding, etc. \cr
For arrays, additional flexibility is available:
\itemize{
\item Specifying \code{along = 0} will bind the arrays on a new dimension before the first,
making \code{along} the new first dimension.
\item Specifying \code{along = n+1}, with \code{n} being the last available dimension,
will create an additional dimension (\code{n+1}) and bind the arrays along that new dimension.
}}

\item{name_deparse}{Boolean, for \code{bind_mat()}. \cr
Indicates if dimension \code{along} should be named. \cr
Uses the naming method from \link[base]{rbind}/\link[base]{cbind} itself.}

\item{comnames_from}{integer scalar or \code{NULL}, for \code{bind_array()}. \cr
Indicates which object in \code{arg.list} should be used for naming the shared dimension. \cr
If \code{NULL}, no communal names will be given. \cr
For example: \cr
When binding columns of matrices, the matrices will share the same rownames. \cr
Using \code{comnames_from = 10} will then result in \code{bind_array()} using
\code{rownames(arg.list[[10]])} for the rownames of the output.}

\item{name_along}{Boolean, for \code{bind_array()}. \cr
Indicates if dimension \code{along} should be named.}

\item{name_flat}{Boolean, for \code{bind_array()}. \cr
Indicates if flat indices should be named. \cr
Note that setting this to \code{TRUE} will reduce performance considerably. \cr
\ifelse{html}{\figure{for_performance-set_to_FALSE-red.svg}{options: alt='[for performance: set to FALSE]'}}{\link[=squarebrackets_help]{for performance: set to FALSE}}}
}
\value{
The bound object.
}
\description{
The \code{bind_}implementations provide dimensional binding functionalities. \cr
When possible, the \code{bind_} functions return \link[=squarebrackets_supported_structures]{mutable classes}. \cr
\cr
The following implementations are available:
\itemize{
\item \code{bind_mat()} binds dimensionless (atomic/recursive) vectors and (atomic/recursive) matrices row- or column-wise. \cr
If the result is atomic, returns a \link{mutable_atomic} matrix; otherwise returns a recursive matrix. \cr
\item \code{bind_array()} binds (atomic/recursive) arrays and (atomic/recursive) matrices. \cr
If the result is atomic, returns a \link{mutable_atomic} array; otherwise returns a recursive array. \cr
\item \code{bind_dt()} binds data.tables and other data.frame-like objects. \cr
Returns a \code{data.table}. \cr
Faster than \code{do.call(cbind, ...)} or \code{do.call(rbind, ...)} for regular \code{data.frame} objects. \cr
}

Note that the naming convention of the binding implementations here is
"bind_" followed by the \bold{resulting class} (abbreviated). \cr
I.e. \code{bind_mat} \bold{returns} a matrix, but can bind both matrices and vectors. \cr
And \code{bind_array} \bold{returns} an array, but can bind both arrays and matrices. \cr
And \code{bind_dt} \bold{returns} a data.table, but can bind not only data.tables,
but also most other data.frame-like objects. \cr \cr
}
\details{
\code{bind_array()} is a modified version of the fantastic
\code{abind::}\link[abind]{abind} function
by Tony Plare & Richard Heiberger (2016),
in the following ways:
\itemize{
\item \code{bind_array()} primarily differs from \code{abind::}\link[abind]{abind}
in that it can handle recursive arrays properly \cr
(the original \code{abind::}\link[abind]{abind} function would unlist everything to atomic arrays,
ruining the structure).
\item unlike \code{abind::}\link[abind]{abind},
\code{bind_array()} only binds (atomic/recursive) arrays and matrices. \cr
\code{bind_array()}does not attempt to convert things to arrays when they are not arrays,
but will give an error instead. \cr
This saves computation time and prevents unexpected results.
\item if \code{bind_array()} results in an atomic array, it will be a \link{mutable_atomic} array.
\item \code{bind_array()} has more streamlined naming options. \cr \cr
}

\code{bind_mat()} is a modified version of \link[base]{rbind}/\link[base]{cbind}. \cr
The primary differences is that \code{bind_mat()} gives an error when fractional recycling is attempted
(like binding  \code{1:3} with \code{1:10}). \cr \cr
}
\examples{

# bind_array ====

# here, atomic and recursive matrices are mixed,
# resulting in a recursive matrix

# creating the arrays
x <- c(
  lapply(1:3, \(x)sample(c(TRUE, FALSE, NA))),
  lapply(1:3, \(x)sample(1:10)),
  lapply(1:3, \(x)rnorm(10)),
  lapply(1:3, \(x)sample(letters))
)
x <- matrix(x, 4, 3, byrow = TRUE)
dimnames(x) <- n(letters[1:4], LETTERS[1:3])
print(x)

y <- matrix(1:12, 4, 3)
print(y)

# binding the arrays
arg.list <- list(x = x, y = y)
bind_array(arg.list, along = 0L) # binds on new dimension before first
bind_array(arg.list, along = 1L) # binds on first dimension
bind_array(arg.list, along = 2L)
bind_array(arg.list, along = 3L) # bind on new dimension after last



################################################################################

# bind_mat ====

# here, atomic and recursive matrices are mixed,
# resulting in a recursive matrix

x <- c(
  lapply(1:3, \(x)sample(c(TRUE, FALSE, NA))),
  lapply(1:3, \(x)sample(1:10)),
  lapply(1:3, \(x)rnorm(10)),
  lapply(1:3, \(x)sample(letters))
)
x <- matrix(x, 4, 3, byrow = TRUE)
dimnames(x) <- n(letters[1:4], LETTERS[1:3])
print(x)

y <- matrix(1:12, 4, 3)
print(y)

bind_mat(n(x = x, y = y), 2L)



################################################################################

# bind_dt ====


x <- data.frame(a = 1:12, b = month.abb) # data.frame
y <- data.table::data.table(a = 1:12, b = month.abb) # data.table

bind_dt(n(x = x, y = y), 2L) # column bind

bind_dt(n(x = x, y = y), 1L) # row bind

}
\references{
Plate T, Heiberger R (2016). \emph{abind: Combine Multidimensional Arrays}. R package version 1.4-5, \url{https://CRAN.R-project.org/package=abind}.
}
