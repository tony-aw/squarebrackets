% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aaa1_squarebrackets_immutable_classes.R
\name{aaa1_squarebrackets_immutable_classes}
\alias{aaa1_squarebrackets_immutable_classes}
\alias{squarebrackets_immutable_classes}
\title{Supported Immutable S3 Classes, With Auto-Coercion Rules}
\description{
The \code{sb_} generic methods support the following immutable S3 classes: \cr
\itemize{
\item \code{atomic} classes \cr
(atomic vectors, matrices, and arrays);
\item \link[base]{factor};
\item \link[base]{list} - including dimensional lists \cr
(note that lists are merely pointers to other objects,
and these other objects may be of a different class and may even be mutable);
\item \link[base]{data.frame} \cr
(including the classes \code{tibble}, \code{sf-data.frame} and \code{sf-tibble}) \cr \cr
}

Note that "immutable" does not mean you cannot modify it. \cr
It simply means that modification leads to a copy being made. \cr \cr
}
\section{Auto-Coercion Rules}{


\bold{Atomic} \cr
\ifelse{html}{\figure{coercion_through_copy-YES-darkgreen.svg}{options: alt='[coercion_through_copy: YES]'}}{\link[=squarebrackets_immutable_classes]{coercion_through_copy: YES}} \cr
Atomic objects are automatically coerced to fit the modified subset values,
when modifying through copy. \cr
For example, replacing one or multiple values in an integer vector
(type \code{int})
with a decimal number
(type \code{dbl})
will coerce the entire vector to type \code{dbl}. \cr
\cr
\cr
\bold{Factor} \cr
\ifelse{html}{\figure{coercion_through_copy-NO-red.svg}{options: alt='[coercion_through_copy: NO]'}}{\link[=squarebrackets_immutable_classes]{coercion_through_copy: NO}} \cr
Factors only accept values that are part of their levels,
and thus do not support coercion on modification.
There is no mechanism for changing factors by reference at all. \cr
Replacing a value with a new value not part of its levels,
will result in the replacement value being \code{NA}. \cr
\cr
\cr
\bold{List} \cr
\ifelse{html}{\figure{coercion_through_copy-depends-lightblue.svg}{options: alt='[coercion_through_copy: depends]'}}{\link[=squarebrackets_immutable_classes]{coercion_through_copy: depends}} \cr
Lists themselves allow complete change of their elements,
since lists are merely pointers. \cr
For example, the following code performs full coercion:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{x <- list(factor(letters), factor(letters))
sb_mod(x, 1, rp = list(1))
}\if{html}{\out{</div>}}

However, a recursive subset of a list which itself is not a list,
follows the coercion rules of whatever class the recursive subset is. \cr
For example the following code:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{x <- list(1:10, 1:10)
sb_rec(x, 1, rp = "a") # coerces to character
}\if{html}{\out{</div>}}

transforms recursive subsets according to the - in this case -
atomic auto-coercion rules. \cr
\cr
\cr
\bold{Data.frames when replacing/transforming whole columns} \cr
\ifelse{html}{\figure{coercion_through_copy-YES-darkgreen.svg}{options: alt='[coercion_through_copy: YES]'}}{\link[=squarebrackets_immutable_classes]{coercion_through_copy: YES}} \cr
A data.frame is actually a list, where each column is itself a list.
As such, replacing/transforming whole columns,
so \code{row = NULL} and \code{filter = NULL},
allows completely changing the type of the column. \cr
Note that coercion of columns needs arguments
\code{row = NULL} and \code{filter = NULL}
in the \link{sb_mod} and \link{sb_set} methods;
no auto-coercion will take place when specifying something like \code{row = 1:nrow(x)}
(see next section). \cr
\cr
\cr
\bold{Data.frames, when partially replacing/transforming columns} \cr
\ifelse{html}{\figure{coercion_through_copy-NO-red.svg}{options: alt='[coercion_through_copy: NO]'}}{\link[=squarebrackets_immutable_classes]{coercion_through_copy: NO}} \cr
If rows are specified in the \link{sb_mod} and \link{sb_set} methods,
and thus not whole columns but parts of columns are replaced or transformed,
no auto-coercion takes place. \cr
I.e.: replacing/transforming a value in an integer (\code{int}) column to become \code{1.5},
will not coerce the column to the decimal type (\code{dbl});
instead, the replacement value \code{1.5} is coerced to integer \code{1}. \cr
The \code{coe} argument in the \link{sb_mod} method
allows the user to enforce coercion,
even if subsets of columns are replaced/transformed instead of whole columns. \cr
Specifically, the \code{coe} arguments allows the user to specify a coercive function
to be applied on the entirety of every column specified in \code{col} or \code{vars};
columns outside this subset are not affected. \cr
This coercion function is, of course,
applied before replacement (\code{rp}) or transformation (\code{tf()}). \cr \cr
}

\examples{

# Coercion examples - lists ====
x <- list(factor(letters), factor(letters))
print(x)
sb2_mod(x, 1, rp = list(1)) # first element fully changed.

x <- list(1:10, 1:10)
print(x)
sb2_reccom(x, 1, rp = "a") # coerces first element to character
print(x)


#############################################################################


# Coercion examples - data.frame-like - whole columns ====

obj <- data.frame(
  a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])
)
str(obj) # notice that columns "a" and "c" are INTEGER (`int`)
sb2_mod(
  obj, vars = is.numeric,
  tf = sqrt # SAFE: row=NULL & filter = NULL, so coercion performed
)

#############################################################################


# Coercion examples - data.frame-like - partial columns ====

# sb_mod():
obj <- data.frame(
  a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])
)
str(obj) # notice that columns "a" and "c" are INTEGER (`int`)

sb2_mod(
  obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,
  tf = sqrt # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost
)
sb2_mod(
  obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,
  coe = as.double, tf = sqrt # SAFE: coercion performed
)



}
