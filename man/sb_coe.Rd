% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generic_coe.R
\name{sb_coe}
\alias{sb_coe}
\alias{sb_coe.default}
\alias{sb_coe.factor}
\alias{sb_coe.list}
\alias{sb_coe.data.frame}
\title{Method to Coercively Transform (Recursive Subsets of) an Object}
\usage{
sb_coe(x, ...)

\method{sb_coe}{default}(x, v, ...)

\method{sb_coe}{factor}(x, v, ...)

\method{sb_coe}{list}(x, i, v, ...)

\method{sb_coe}{data.frame}(x, col = NULL, vars = NULL, v, ...)
}
\arguments{
\item{x}{see \link{squarebrackets_immutable_classes} and \link{squarebrackets_mutable_classes}.}

\item{...}{further arguments passed to or from other methods.}

\item{v}{the coercive transformation function to use.}

\item{i, col, vars}{See \link{squarebrackets_indx_args}. \cr
An empty index selection returns the original object unchanged. \cr}
}
\value{
A copy of the coercively transformed object.
}
\description{
This is an S3 Method to completely transform
(a recursive subsets of)
an object with explicit coercion. \cr
\cr
Given some coercing function \code{v()},
the following can be stated about this method. \cr

(1) For atomic objects (vectors, matrices, arrays), this method is equivalent to:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{x[] <- v(x)
}\if{html}{\out{</div>}}

(2) For factors, this method is equivalent to:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{x <- v(x)
}\if{html}{\out{</div>}}

(3) For lists,
with one or multiple elements specified by argument \code{i},
this method is equivalent to:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{\\(x, i) \{ x[i] <- lapply(x[i], v); return(x) \}
}\if{html}{\out{</div>}}

(4) And for data.frame-like objects,
with one or multiple columns specified by argument \code{col},
this method is equivalent to:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{collapse::ftransformv(x, col, v)

}\if{html}{\out{</div>}}

Note that when \code{x} is a \code{data.table},
one can coercively transform columns by reference
(which is more memory efficient),
using \link{dt_setcoe}. \cr \cr
}
\details{
When replacing values by reference,
the (recursive subset of the) object is never coerced, as that requires making a deep copy;
instead, the replacement value is coerced. \cr
\cr
For example: \cr
Using \code{sb_set()} to replacing/transform one or more values of an integer type
(\code{int})
\link{mutable_atomic} object / \link[data.table]{data.table} column,
to become \code{1.5}, will NOT coerce the object or column
to a decimal type (\code{dbl});
instead, the replacement \code{1.5} is coerced to the integer \code{1}. \cr
\cr
For this reason, the \code{sb_coe()} method can be used to coercively transform an object
before replacing or transforming values by reference. \cr
See also the Examples section below.
}
\examples{

obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]))
str(obj) # notice that columns "a" and "c" are INTEGER (`int`)
sb_set(
  obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,
  tf = sqrt # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost
)
print(obj)
obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]))
obj <- sb_coe(obj, vars = is.numeric, v = as.numeric)
str(obj)
sb_set(obj,
  filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,
  tf = sqrt # SAFE: coercion performed; so no warnings
) 
print(obj)

}
