% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generic_coe.R
\name{sb_coe}
\alias{sb_coe}
\alias{sb_coe.default}
\alias{sb_coe.factor}
\alias{sb2_coe}
\alias{sb2_coe.default}
\alias{sb2_coe.array}
\alias{sb2_coe.data.frame}
\title{Method to Coercively Transform (Recursive Subsets of) an Object}
\usage{
sb_coe(x, ...)

\method{sb_coe}{default}(x, v, ...)

\method{sb_coe}{factor}(x, v, ...)

sb2_coe(x, ...)

\method{sb2_coe}{default}(x, i, v, ..., .lapply = lapply)

\method{sb2_coe}{array}(x, idx = NULL, dims = NULL, i = NULL, v, ..., .lapply = lapply)

\method{sb2_coe}{data.frame}(x, col = NULL, vars = NULL, v, ...)
}
\arguments{
\item{x}{see \link{squarebrackets_immutable_classes} and \link{squarebrackets_mutable_classes}.}

\item{...}{further arguments passed to or from other methods.}

\item{v}{the coercive transformation function to use.}

\item{i, col, vars, idx, dims}{See \link{squarebrackets_indx_args}. \cr
An empty index selection returns the original object unchanged. \cr}

\item{.lapply}{\code{sb2_coe()} by default uses \link[base]{lapply}
for lists and \link[collapse]{dapply} data.frame-like objects
to compute \code{tf()} on every list element or data.frame column. \cr
The user may supply a custom \code{lapply()/dapply()}-like function
in this argument to use instead. \cr
For example, the perform parallel transformation,
the user may supply \verb{future.apply::}\link[future.apply]{future_lapply}. \cr
The supplied function must use the exact same argument convention as
\link[base]{lapply},
otherwise errors or unexpected behaviour may occur.}
}
\value{
A copy of the coercively transformed object.
}
\description{
This is an S3 Method to completely transform
(a recursive subsets of)
an object with explicit coercion. \cr
\cr
Given some coercing function \code{v()},
the following can be stated about this method. \cr

(1) For atomic objects (vectors, matrices, arrays),
this method is \bold{almost} equivalent to:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{x[] <- v(x)
}\if{html}{\out{</div>}}

(2) For factors, this method is equivalent to:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{x <- v(x)
}\if{html}{\out{</div>}}

(3) For lists,
with one or multiple elements specified by argument \code{i},
this method is equivalent to:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{\\(x, i) \{ x[i] <- lapply(x[i], v); return(x) \}
}\if{html}{\out{</div>}}

(4) And for data.frame-like objects,
with one or multiple columns specified by argument \code{col},
this method is equivalent to:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{collapse::ftransformv(x, col, v)

}\if{html}{\out{</div>}}

Note that when \code{x} is a \code{data.table},
one can coercively transform columns by reference
(which is more memory efficient),
using \link{dt_setcoe}. \cr \cr
}
\examples{

obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]))
str(obj) # notice that columns "a" and "c" are INTEGER (`int`)
sb2_set(
  obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,
  tf = sqrt # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost
)
print(obj)
obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]))
obj <- sb2_coe(obj, vars = is.numeric, v = as.numeric)
str(obj)
sb2_set(obj,
  filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,
  tf = sqrt # SAFE: coercion performed; so no warnings
) 
print(obj)

}
