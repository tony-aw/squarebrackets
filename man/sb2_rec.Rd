% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generic_rec.R
\name{sb2_rec}
\alias{sb2_rec}
\alias{sb2_rec.default}
\alias{sb2_recin}
\alias{sb2_recin.default}
\title{Access, Replace, Transform, Delete, or Extend Recursive Subsets}
\usage{
sb2_rec(x, ...)

\method{sb2_rec}{default}(x, rec, ...)

sb2_recin(x, ...)

\method{sb2_recin}{default}(x, rec, ..., rp, tf)
}
\arguments{
\item{x}{a list, or list-like object.}

\item{...}{see \link{squarebrackets_method_dispatch}.}

\item{rec}{a strictly positive integer vector or character vector, of length \code{p},
such that \code{sb2_rec(x, rec)} is equivalent to \verb{x[[ rec[1] ]]...[[ rec[p] ]]},
providing all but the final indexing results in a list. \cr
When on a certain subset level of a nested list,
multiple subsets with the same name exist,
only the first one will be selected when performing recursive indexing by name,
since recursive indexing can only select a single element.}

\item{rp}{optional, and allows for multiple functionalities:
\itemize{
\item In the simplest case, performs \code{x[[rec]] <- rp},
using R's default semantics. \cr
Since this is a replacement of a recursive subset,
\code{rp} does not necessarily have to be a list itself; \cr
\code{rp} can be any type of object.
\item Specifying \code{rp = NULL} will \bold{delete} (recursive) subset \code{sb(x, rec)}. \cr
To specify actual \code{NULL} instead of deleting a subset, use \code{rp = list(NULL)}.
\item When \code{rec} is an integer, and specifies an out-of-bounds subset,
\code{sb2_recin()} will add value \code{rp} to the list. \cr
Any empty positions in between will be filled with \code{NA}.
\item When \code{rec} is character, and specifies a non-existing name,
\code{sb2_recin()} will add value \code{rp} to the list as a new element at the end.
}}

\item{tf}{an optional function. If specified, performs \code{x[[rec]] <- tf(x[[rec]])},
using R's default Copy-On-Modify semantics. \cr
Does not support extending a list like argument \code{rp}.}
}
\value{
For \code{sb2_rec()}: \cr
Returns the recursive subset. \cr
\cr
For \code{sb2_recin(..., rp = rp)}: \cr
Returns VOID,
but replaces, adds, or deletes the specified recursive subset,
using R's default Copy-On-Modify semantics. \cr
\cr
For \code{sb2_recin(..., tf = tf)}: \cr
Returns VOID,
but transforms the specified recursive subset,
using R's default Copy-On-Modify semantics. \cr \cr
}
\description{
The \code{sb2_rec()} and \code{sb2_recin()} methods
are essentially convenient wrappers around \code{[[} and \verb{[[<-},
respectively. \cr
Unlike \code{[[} and \verb{[[<-}, these are actually S3 methods,
so package authors can create additional method dispatches. \cr
\cr
\code{sb2_rec()} will access recursive subsets of lists. \cr
\cr
\code{sb2_recin()} can do the following things: \cr
\itemize{
\item replace or transform recursive subsets of a list,
using R's default Copy-On-Modify semantics,
by specifying the \code{rp} or \code{tf} argument, respectively.
\item delete a recursive subset of a list,
using R's default Copy-On-Modify semantics,
by specifying argument \code{rp = NULL}.
\item extending a list with additional recursive elements,
using R's default Copy-On-Modify semantics. \cr
This is done by specifying an out-of-bounds index in argument \code{rec},
and entering the new values in argument \code{rp}. \cr
Note that adding surface level elements of a dimensional list
will delete the dimension attributes of that list. \cr \cr
}
}
\details{
Since recursive objects are references to other objects,
extending a list or deleting an element of a list does not copy the entire list,
in contrast to atomic vectors. \cr \cr
}
\examples{


lst <- list(
  A = list(
    A = list(A = "AAA", B = "AAB"),
    A = list(A  = "AA2A", B = "AA2B"),
    B = list(A = "ABA", B = "ABB")
  ),
  B = list(
    A = list(A = "BAA", B = "BAB"),
    B = list(A = "BBA", B = "BBB")
  )
)

#############################################################################

# access recursive subsets ====

sb2_rec(lst, c(1,2,2)) # this gives "AA2B"
sb2_rec(lst, c("A", "B", "B")) # this gives "ABB"
sb2_rec(lst, c(2,2,1)) # this gives "BBA"
sb2_rec(lst, c("B", "B", "A")) # this gives "BBA"


#############################################################################

# replace recursive subset with R's default in-place semantics ====

# replace "AAB" using R's default in-place semantics:
sb2_recin(
  lst, c("A", "A", "B"),
  rp = "THIS IS REPLACED WITH IN-PLACE SEMANTICS"
)
print(lst)



#############################################################################

# replace shallow subsets with R's default in-place semantics ====

for(i in c("A", "B")) sb2_recin(lst, i, rp = "AND THEN THERE WERE NONE")

print(lst)


#############################################################################

# Modify View of List By Reference ====

x <- list(
 a = data.table::data.table(cola = 1:10, colb = letters[1:10]),
 b = data.table::data.table(cola = 11:20, colb = letters[11:20])
)
print(x)
myref <- sb2_rec(x, "a")
address(myref) == address(x$a) # they are the same
sb2_set(myref, col = "cola", tf = \(x)x^2)
print(x) # notice x has been changed


}
