% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generic_mod.R
\name{sb_mod}
\alias{sb_mod}
\alias{sb_mod.default}
\alias{sb_mod.matrix}
\alias{sb_mod.array}
\alias{sb_mod.factor}
\alias{sb_mod.list}
\alias{sb_mod.data.frame}
\title{Method to Return a Copy of an Object With Modified Subsets}
\usage{
sb_mod(x, ...)

\method{sb_mod}{default}(x, i, ..., rp, tf, chkdup = getOption("sb.chkdup", FALSE))

\method{sb_mod}{matrix}(
  x,
  row = NULL,
  col = NULL,
  i = NULL,
  ...,
  rp,
  tf,
  chkdup = getOption("sb.chkdup", FALSE)
)

\method{sb_mod}{array}(
  x,
  idx = NULL,
  dims = NULL,
  rcl = NULL,
  i = NULL,
  ...,
  rp,
  tf,
  chkdup = getOption("sb.chkdup", FALSE)
)

\method{sb_mod}{factor}(
  x,
  i = NULL,
  lvl = NULL,
  ...,
  rp,
  chkdup = getOption("sb.chkdup", FALSE)
)

\method{sb_mod}{list}(
  x,
  i,
  ...,
  rp,
  tf,
  chkdup = getOption("sb.chkdup", FALSE),
  .lapply = lapply
)

\method{sb_mod}{data.frame}(
  x,
  row = NULL,
  col = NULL,
  filter = NULL,
  vars = NULL,
  coe = FALSE,
  ...,
  rp,
  tf,
  chkdup = getOption("sb.chkdup", FALSE),
  .lapply = lapply
)
}
\arguments{
\item{x}{see \link{squarebrackets_immutable_classes} and \link{squarebrackets_mutable_classes}.}

\item{...}{further arguments passed to or from other methods.}

\item{i, lvl, row, col, idx, dims, rcl, filter, vars}{See \link{squarebrackets_indx_args}. \cr
An empty index selection returns the original object unchanged. \cr}

\item{rp}{an object of somewhat the same type as the selected subset of \code{x},
and the same same length as the selected subset of \code{x} or a length of 1.}

\item{tf}{the transformation function.}

\item{chkdup}{see \link{squarebrackets_duplicates}. \cr
\ifelse{html}{\figure{for_performance-set_to_FALSE-red.svg}{options: alt='[for performance: set to FALSE]'}}{\link[=squarebrackets_help]{for performance: set to FALSE}} \cr}

\item{.lapply}{\code{sb_mod()} by default uses \link[base]{lapply}
for lists and \link[collapse]{dapply} data.frame-like objects
to compute \code{tf()} on every list element or data.frame column. \cr
The user may supply a custom \code{lapply()/dapply()}-like function
in this argument to use instead. \cr
For example, the perform parallel transformation,
the user may supply \verb{future.apply::}\link[future.apply]{future_lapply}. \cr
The supplied function must use the exact same argument convention as
\link[base]{lapply},
otherwise errors or unexpected behaviour may occur.}

\item{coe}{Either \code{FALSE} (default), \code{TRUE}, or a function. \cr
The argument \code{coe} is ignored
if both the \code{row} and \code{filter} arguments are set to \code{NULL}. \cr
See Details section for more info. \cr
\ifelse{html}{\figure{for_performance-set_to_FALSE-red.svg}{options: alt='[for performance: set to FALSE]'}}{\link[=squarebrackets_help]{for performance: set to FALSE}} \cr}
}
\value{
A copy of the object with replaced/transformed values. \cr \cr
}
\description{
This is an S3 Method to return a copy of an object with modified subsets.
}
\details{
\bold{Transform or Replace} \cr
Specifying argument \code{tf} will transform the subset. \cr
Specifying \code{rp} will replace the subset. \cr
One cannot specify both \code{tf} and \code{rp}. It's either one set or the other. \cr
Note that the \code{tf} argument is not available for factors: this is intentional. \cr
\cr
\bold{Argument \code{coe}} \cr
For data.frame-like objects,
\code{sb_mod()} can only auto-coerce whole columns, not subsets of columns. \cr
So it does not automatically coerce column types
when \code{row} or \code{filter} is also specified. \cr
The \code{coe} arguments provides 2 ways to circumvent this:
\enumerate{
\item The user can supply a coercion function to argument \code{coe}. \cr
The function is applied on the entirety of every column specified in \code{col} or \code{vars};
columns outside this subset are not affected. \cr
This coercion function is, of course,
applied before replacement (\code{rp}) or transformation (\code{tf()}).
\item The user can set \code{coe = TRUE}. \cr
In this case,
the whole columns specified in \code{col} or \code{vars} are extracted and copied to a list. \cr
Subsets of each list element,
corresponding to the selected rows,
are modified with \code{rp} or \code{tf()},
using R's regular auto-coercion rules. \cr
The modified list is then returned to the data.frame-like object,
replacing the original columns.
}

Note that coercion required additional memory. \cr
The larger the data.frame-like object, the larger the memory. \cr
The default, \code{coe = FALSE}, uses the least amount of memory. \cr \cr
}
\examples{

# atomic objects ====

obj <- matrix(1:16, ncol = 4)
colnames(obj) <- c("a", "b", "c", "a")
print(obj)
rp <- -1:-9
sb_mod(obj, 1:3, 1:3, rp = rp)
# above is equivalent to  obj[1:3, 1:3] <- -1:-9; obj
sb_mod(obj, i = \(x)x<=5, rp = -1:-5)
# above is equivalent to  obj[obj <= 5] <- -1:-5; obj
sb_mod(obj, col = "a", rp = -1:-8)
# above is equivalent to  obj[, which(colnames(obj) \%in\% "a")] <- -1:-8; obj
sb_mod(obj, 1:3, 1:3, tf = \(x) -x)
# above is equivalent to  obj[1:3, 1:3] <- (-1 * obj[1:3, 1:3]); obj
sb_mod(obj, i = \(x)x<=5, tf = \(x) -x)
# above is equivalent to  obj[obj <= 5] <- (-1 * obj[obj <= 5]); obj

obj <- matrix(1:16, ncol = 4)
colnames(obj) <- c("a", "b", "c", "a")
print(obj)
sb_mod(obj, 1:3, 1:3, tf = \(x) -x)
# above is equivalent to  obj[1:3, 1:3] <- -1 * obj[1:3, 1:3]
sb_mod(obj, i = \(x)x<=5, tf = \(x) -x)
# above is equivalent to  obj[obj <= 5] <- -1:-5; obj
sb_mod(obj, col = "a", tf = \(x) -x)
# above is equivalent to  obj[, which(colnames(obj) \%in\% "a")] <- -1:-8; obj

obj <- array(1:64, c(4,4,3))
print(obj)
sb_mod(obj, list(1:3, 1:2), c(1,3), rp = -1:-24)
# above is equivalent to obj[1:3, , 1:2] <- -1:-24
sb_mod(obj, i = \(x)x<=5, rp = -1:-5)
# above is equivalent to obj[obj <= 5] <- -1:-5

#############################################################################


# lists ====

obj <- list(a = 1:10, b = letters[1:11], c = 11:20)
print(obj)
sb_mod(obj, "a", rp = list(1L))
# above is equivalent to  obj[["a"]] <- 1L; obj
sb_mod(obj, is.numeric, rp = list(-1:-10, -11:-20))
# above is equivalent to  obj[which(sapply(obj, is.numeric))] <- list(-1:-10, -11:-20); obj

#############################################################################


# data.frame-like objects  - whole columns ====

obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]))
str(obj) # notice that columns "a" and "c" are INTEGER (`int`)
sb_mod(
  obj, vars = is.numeric,
  tf = sqrt # SAFE: row=NULL & filter = NULL, so coercion performed
)

#############################################################################

# data.frame-like objects  - partial columns ====

obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]))
str(obj) # notice that columns "a" and "c" are INTEGER (`int`)

sb_mod(
  obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,
  tf = sqrt # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost
) 
sb_mod(
  obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,
  coe = as.double, tf = sqrt # SAFE: coercion performed
) 
sb_mod(
  obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,
  coe = TRUE, tf = sqrt # SAFE: coercion performed
) 




}
