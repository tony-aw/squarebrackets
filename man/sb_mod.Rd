% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generic_mod.R
\name{sb_mod}
\alias{sb_mod}
\alias{sb_mod.default}
\alias{sb_mod.array}
\alias{sb2_mod}
\alias{sb2_mod.default}
\alias{sb2_mod.array}
\alias{sb2_mod.data.frame}
\title{Method to Return a Copy of an Object With Modified Subsets}
\usage{
sb_mod(x, ...)

\method{sb_mod}{default}(
  x,
  i = NULL,
  inv = FALSE,
  ...,
  rp,
  tf,
  chkdup = getOption("squarebrackets.chkdup", FALSE)
)

\method{sb_mod}{array}(
  x,
  s = NULL,
  d = 1:ndims(x),
  i = NULL,
  inv = FALSE,
  ...,
  rp,
  tf,
  chkdup = getOption("squarebrackets.chkdup", FALSE)
)

sb2_mod(x, ...)

\method{sb2_mod}{default}(
  x,
  i = NULL,
  inv = FALSE,
  ...,
  rp,
  tf,
  chkdup = getOption("squarebrackets.chkdup", FALSE),
  .lapply = lapply
)

\method{sb2_mod}{array}(
  x,
  s = NULL,
  d = 1:ndims(x),
  i = NULL,
  inv = FALSE,
  ...,
  rp,
  tf,
  chkdup = getOption("squarebrackets.chkdup", FALSE),
  .lapply = lapply
)

\method{sb2_mod}{data.frame}(
  x,
  row = NULL,
  col = NULL,
  filter = NULL,
  vars = NULL,
  inv = FALSE,
  ...,
  rp,
  tf,
  chkdup = getOption("squarebrackets.chkdup", FALSE),
  .lapply = lapply
)
}
\arguments{
\item{x}{see \link{squarebrackets_supported_structures}.}

\item{...}{see \link{squarebrackets_method_dispatch}.}

\item{i, row, col, s, d, filter, vars, inv}{See \link{squarebrackets_indx_args}. \cr
An empty index selection returns the original object unchanged. \cr}

\item{rp, tf, .lapply}{see \link{squarebrackets_modify}.}

\item{chkdup}{see \link{squarebrackets_options}. \cr
\ifelse{html}{\figure{for_performance-set_to_FALSE-red.svg}{options: alt='[for performance: set to FALSE]'}}{\link[=squarebrackets_help]{for performance: set to FALSE}}}
}
\value{
A copy of the object with replaced/transformed values. \cr \cr
}
\description{
This is an S3 Method to return a copy of an object with modified subsets. \cr
Use \code{sb_mod(x, ...)} if \code{x} is an atomic object; this returns a full copy. \cr
Use \code{sb2_mod(x, ...)} if \code{x} is a recursive object
(i.e. list or data.frame-like);
this returns a partial copy. \cr
\cr
For modifying subsets using R's default copy-on-modification semantics, see \link{idx}. \cr \cr
}
\details{
\bold{Transform or Replace} \cr
Specifying argument \code{tf} will transform the subset. \cr
Specifying \code{rp} will replace the subset. \cr
One cannot specify both \code{tf} and \code{rp}. It's either one set or the other. \cr
\cr
}
\examples{

# atomic objects ====

obj <- matrix(1:16, ncol = 4)
colnames(obj) <- c("a", "b", "c", "a")
print(obj)
rp <- -1:-9
sb_mod(obj, n(1:3), 1:ndims(obj), rp = rp)
# above is equivalent to  obj[1:3, 1:3] <- -1:-9; obj
sb_mod(obj, i = \(x)x<=5, rp = -1:-5)
# above is equivalent to  obj[obj <= 5] <- -1:-5; obj
sb_mod(obj, n("a"), 2L, rp = -1:-8)
# above is equivalent to  obj[, which(colnames(obj) \%in\% "a")] <- -1:-8; obj
sb_mod(obj, n(1:3), 1:ndims(obj), tf = \(x) -x)
# above is equivalent to  obj[1:3, 1:3] <- (-1 * obj[1:3, 1:3]); obj
sb_mod(obj, i = \(x)x <= 5, tf = \(x) -x)
# above is equivalent to  obj[obj <= 5] <- (-1 * obj[obj <= 5]); obj

obj <- array(1:64, c(4,4,3))
print(obj)
sb_mod(obj, n(1:3, 1:2), c(1,3), rp = -1:-24)
# above is equivalent to obj[1:3, , 1:2] <- -1:-24
sb_mod(obj, i = \(x)x <= 5, rp = -1:-5)
# above is equivalent to obj[obj <= 5] <- -1:-5

#############################################################################


# lists ====

obj <- list(a = 1:10, b = letters[1:11], c = 11:20)
print(obj)
sb2_mod(obj, "a", rp = list(1L))
# above is equivalent to  obj[["a"]] <- 1L; obj
sb2_mod(obj, is.numeric, rp = list(-1:-10, -11:-20))
# above is equivalent to  obj[which(sapply(obj, is.numeric))] <- list(-1:-10, -11:-20); obj

obj <- rbind(
  lapply(1:4, \(x)sample(c(TRUE, FALSE, NA))),
  lapply(1:4, \(x)sample(1:10)),
  lapply(1:4, \(x)rnorm(10)),
  lapply(1:4, \(x)sample(letters))
)
colnames(obj) <- c("a", "b", "c", "a")
print(obj)
sb2_mod(obj, n(1:3), 1:ndims(obj),rp = n(-1))
# above is equivalent to obj[1:3, 1:3] <- list(-1)
sb2_mod(obj, i = is.numeric, rp = n(-1))
# above is equivalent to obj[sapply(obj, is.numeric)] <- list(-1)
sb2_mod(obj, n("a"), 2L, rp = n(-1))
# above is equivalent to
# obj[, lapply(c("a", "a"), \(i) which(colnames(obj) == i)) |> unlist()] <- list(-1)


obj <- array(as.list(1:64), c(4,4,3))
print(obj)
sb2_mod(obj, n(1:3, 1:2), c(1,3), rp = as.list(-1:-24))
# above is equivalent to obj[1:3, , 1:2] <- as.list(-1:-24)
sb2_mod(obj, i = \(x) x <= 5, rp = as.list(-1:-5))
# above is equivalent to obj[sapply(onj, \(x) x <= 5)] <- as.list(-1:-5)


#############################################################################

# data.frame-like objects  - whole columns ====

obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]))
str(obj) # notice that columns "a" and "c" are INTEGER (`int`)
sb2_mod(
  obj, vars = is.numeric,
  tf = sqrt
)

#############################################################################

# data.frame-like objects  - partial columns ====

obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]))
str(obj) # notice that columns "a" and "c" are INTEGER (`int`)

sb2_mod(
  obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,
  tf = sqrt
) 
sb2_mod(
  obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,
  tf = sqrt
) 
sb2_mod(
  obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,
  tf = sqrt
) 




}
