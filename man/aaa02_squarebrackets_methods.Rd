% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aaa02_squarebrackets_methods.R
\name{aaa02_squarebrackets_methods}
\alias{aaa02_squarebrackets_methods}
\alias{squarebrackets_methods}
\title{Methods}
\description{
The main methods of 'squarebrackets' use the naming convention \code{A_B}: \cr
\code{A} tells you on what kind of object and what kind of indices the method operates on; \cr
\code{B} tells you \bold{what operation} is performed. \cr
\cr
For the \code{A} part, the following is available:
\itemize{
\item \code{i_}: operates on subsets of \bold{atomic} objects by (flat/linear) indices.
\item \code{i2_}: operates on subsets of \bold{recursive} objects by (flat/linear) indices.
\item \code{ss_}: operates on subsets of \bold{atomic} objects by (dimensional) subscripts.
\item \code{ss2_}: operates on subsets of \bold{recursive} objects by (dimensional) subscripts.
\item \code{slice_}: uses \bold{index-less}, \bold{sequence-based}, and efficient operations on \code{mutatomic} objects.
\item \code{slicev_}: uses \bold{index-less}, \bold{value-based} and efficient operations on \code{mutatomic} objects. \cr \cr
}

For the \code{B} part, the following is available:
\itemize{
\item \verb{_x}: extract, exchange, or duplicate (if applicable) subsets.
\item \verb{_wo}: returns the original object \bold{without} the provided subsets.
\item \verb{_mod}: modify subsets and return copy.
\item \verb{_set}: modify subsets using \link[=squarebrackets_PassByReference]{pass-by-reference semantics}.
\item \verb{_rec}: access recursive subsets of lists - ONLY available with the \code{i2_} prefix.
\item \verb{_recin}: replace, transform, delete, or extend recursive subsets of lists - ONLY available with the \code{i2_} prefix. \cr \cr
}

There is also the somewhat separate \link{idx} method,
which works on both recursive and non-recursive objects. \cr

Thus, for example,
the \link{i_x} method extracts/exchanges/duplicates subsets of atomic objects by flat/linear indices. \cr \cr
}
\section{Illustration}{


To illustrate, let's take the methods used for extracting subsets
(\eqn{\ast}\verb{_x}): \cr
When \code{y} is atomic, the following holds (roughly speaking):
\itemize{
\item \code{i_x(y, i)} corresponds to \code{y[i]}
\item \code{ss_x(y, n(i, k), c(1, 3))} corresponds to \code{y[i, , k]} \cr \cr
}

When \code{y} is a list (i.e. recursive), the following holds (roughly speaking):
\itemize{
\item \code{i2_x(y, i)} corresponds to \code{y[i]} or \code{y[[i]]} (depending on the arguments given in \code{i2_x()})
\item \code{ss2_x(y, n(i, k), c(1, 3))} corresponds to \code{y[i, , k]} or \code{y[[i, , k]]} (depending on the arguments given in \code{ss2_x()}) \cr \cr
}
}

\section{Finding the Appropriate Help Pages}{


Now that it is clear what the naming convention is of the main methods,
one can easily find out information about a particular method by usign the \verb{?} operator. \cr
So to find out about modifying recursive objects by reference using dimensional indices,
type in: \cr
\code{?ss2_set} \cr
\cr
Note that some combinations of \code{A} and \code{B} are not available. \cr
For example, as the \verb{_rec} \verb{_recin} suffices are only applicable for recursive objects using linear indices,
only \code{i2_rec} and \code{i2_recin} exist; \cr
combinations like \code{i_rec}, \code{ss_recin}, etc. don't exist. \cr
Another example: there is no \verb{_mod} suffix available for the \code{slice_} and \code{slicev_} methods. \cr \cr
}

