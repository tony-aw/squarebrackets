% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cp_seq.R
\name{cp_seq}
\alias{cp_seq}
\title{Construct Parameters for a Sequence Based on Margins}
\usage{
cp_seq(x, m = 0L, from = NULL, to = NULL, by = 1L)
}
\arguments{
\item{x}{the object for which to compute margin-based sequence parameters.}

\item{m}{integer or complex, giving the margin(s). \cr
For non-dimensional objects or for flat indices, specify \code{m = 0L}.}

\item{from}{integer or complex, of the same length as \code{m} or of length 1,
specifying the from point.}

\item{to}{integer or complex, of the same length as \code{m} or of length 1,
specifying the \bold{maximally allowed} end value.}

\item{by}{integer, of the same length as \code{m} or of length 1,
specifying the step size. \cr}
}
\value{
A list of the following elements: \cr
\cr
\bold{\verb{$start}}: \cr
The actual starting point of the sequence. \cr
This is simply \code{from} translated to regular numeric. \cr
\cr
\bold{\verb{$end}}: \cr
The \bold{actual} ending point of the sequence. \cr
This is \bold{not} the same as \code{to}, not even when translated to regular numeric. \cr
For example, the following code:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{seq(from = 1L, to = 10L, by = 2L)
#> [1] 1 3 5 7 9
}\if{html}{\out{</div>}}

specifies \code{to = 10L}. \cr
But the sequence doesn't actually end at \code{10}; it ends at \code{9}. \cr
Therefore, \code{cp_seq(x, m, 1, 10, 2)} will return \code{end = 9}, not \code{end = 10}. \cr
This allows the user to easily predict where an sequence given in
\link{idx_r}/\link{slice} will actually end. \cr
\cr
\bold{\verb{$by}}: \cr
This will give \code{by}, but with it's sign adjusted, if needed. \cr
\cr
\bold{\verb{$length.out}}: \cr
The actual vector lengths the sequences would be,
given the translated parameters. \cr \cr
}
\description{
\code{cp_seq()} returns a list of parameters to construct a sequence based on the margins of an object. \cr
It is internally used by the \link{idx_r} function and \link{slice} method. \cr \cr
}
\section{Arguments Details}{

\bold{Multiple dimensions at once} \cr
The \code{cp_seq} function can construct the sequence parameters needed for multiple dimensions at once,
by specifying a vector for \code{m}. \cr
The lengths of the other arguments are then recycled if needed. \cr
\cr
\bold{Using only \code{by}} \cr
If \verb{from, to} are not specified,
using \code{by} will construct the following sequence: \cr
If \code{by} is positive, \code{seq.int(1L, n, by)}. \cr
If \code{by} is negative, \code{seq.int(n, 1L, by)}. \cr
Where \code{n} is the maximum index
(i.e. \code{length(x)} or \code{dim(x)[m]}, depending on the situation). \cr
\cr
\bold{Using \verb{from, to, by}} \cr
If \verb{from, to, by} are all specified,
\code{by} is stored as \code{abs(by)},
and the sign  of \code{by} is automatically adjusted to ensure a sensible sequence is created. \cr
\cr
\cr
}

\examples{

x <- data.frame(
  a = 1:10, b = letters[1:10], c = factor(letters[1:10]), d = -1:-10
)
print(x)
ind1 <- idx_r(x, 1, 2, 2* -1i) # rows 2:(nrow(x)-1)
sb2_x(x, ind1) # extract the row range

x <- array(1:125, c(5,5,5))
dims <- 1:3
sub <- idx_r(x, dims, 2, 2* -1i) # 2:(n-1) for every dimension
sb_x(x, sub, dims) # same as x[ 2:4, 2:4, 2:4, drop = FALSE]

x <- letters
x[idx_r(x, 0, 2, 2* -1i)]

}
