% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aaa08_squarebrackets_slicev.R
\name{aaa08_squarebrackets_slicev}
\alias{aaa08_squarebrackets_slicev}
\alias{squarebrackets_slicev}
\title{On Index-Less Value-Based Sub-Set Operations}
\description{
This help page explains the details on the arguments used in the
\link{slicev}\code{_} methods and the \link{countv} function. \cr
\cr
}
\section{The Basic Idea}{


The basic idea is as follows. \cr
Let \code{x} and \code{y} be 2 atomic vectors of the same length
(but they don't have to be of the same type). \cr
Let \code{v} be some atomic scalar of the same type as \code{y}. \cr
Given the result \code{r} of the condition \code{y == v},
the basic idea is to perform the following sub-set operations: \cr

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
slicev_x(x, y = y, v = v)            # ==> x[y == v]
slicev_set(x, y = y, v = v, rp = rp) # ==> x[y == v] <- rp
slicev_set(x, y = y, v = v, tf = tf) # ==> x[y == v] <- tf(x[y == v]) 
countv(y,v = v)                      # ==> sum(y == v)

}\if{html}{\out{</div>}}

The above is with the default argument specification \code{r = TRUE}. \cr
Of course one can invert the relationship by specifying argument \code{r = FALSE},
to get something like the following:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
slicev_x(x, y = y, v = v, r = FALSE)             # ==> x[y != v]                  
slicev_set(x, y = y, v = v, r = FALSE, rp = rp)  # ==> x[y != v] <- rp
slicev_set(x, y = y, v = v, r = FALSE, tf = tf)  # ==> x[y != v] <- tf(x[y != v])
countv(y, v = v, r = FALSE)                  # ==> sum(y != v)

}\if{html}{\out{</div>}}

And \code{y} is allowed to be the same vector as \code{x}, of course. \cr
\cr
This basic idea, however, can become more complicated,
depending on the atomic type of \code{y}, which is discussed in the next section. \cr
\cr
\cr
}

\section{Details per Atomic Type}{

\bold{Logical, Raw, Complex} \cr
For \code{y} of type \code{logical}, \code{raw}, and \code{complex},
\link{slicev} works exactly as explained in the previous section. \cr
\code{y} and \code{v} must be of the same atomic type. \cr
\cr
\cr

\bold{Numeric} \cr
For \code{y} of type \code{integer} or \code{double} (collectively referred to as "numeric"),
the basic idea laid-out before still holds: \cr
one can use atomic vector \code{y} and atomic scalar \code{v} to perform sub-set operations like \cr
\code{x[y == v]}. \cr
\cr
But one may be more interested in a range of numbers, rather than one specific number
(especially considering things like measurement error, and machine precision,
and greater-than/larger-than relationships). \cr
So for numeric \code{y}, one can also supply \code{v} of length \bold{2}. \cr
When \code{length(v) == 2L}, \code{slicev_}/ \code{countv} will check whether \code{y} is inside
(or outside if \code{r = FALSE}) the bounded range given by \code{v}. \cr
I.e. :

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
y >= v[1] & y <= v[2]  # if r = TRUE
y < v[1] | y > v[2]    # if r = FALSE

}\if{html}{\out{</div>}}

Note that \code{y} and \code{v} must both be numeric here,
but they don't have to be the same type. \cr
I.e. one can have \code{y} of type \code{integer} and \code{v} of type \code{double},
without problems. \cr
\cr
\cr

\bold{Character} \cr
For \code{y} of type \code{character},
the basic idea is still to do something like \code{x[y == v]}. \cr
\cr
When searching for string \code{v} for sub-setting purposes,
one may want to take into consideration things like different spelling,
spacing, or even encodings of the same string. \cr
Implementing every form of fuzzy matching or encoding matching is computationally intensive,
and also quite beyond the scope of this package. \cr
Instead, the user may supply a character vector \code{v} of arbitrary length,
containing all the variations
(in terms of spelling, spacing, encoding, or whatever)
of all the strings to look for. \cr
\cr
So if a vector is given for \code{v} (instead of a single string),
the following check is performed:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
y \%in\% v   # if r = TRUE
!y \%in\% v  # if r = FALSE

}\if{html}{\out{</div>}}
}

\section{Factors}{


Technically, a factor has the type of \code{integer},
but it has special behaviour to the extend that it is treated differently in 'R'. \cr
It is similarly treated by the \code{slicev_}/ \code{countv_} methods and functions. \cr
\cr
When \code{y} is a factor, \code{v} can be given as:
\itemize{
\item a single string (matching one of the levels of \code{y});
\item a single integer (matching one of the unique values of \code{unclass(y)});
\item a factor of length 1, with the same levels and level-ordering as \code{y}. \cr
}

Note that factors with \code{NA} levels are not supported,
and passing such a factor to \code{y} will result in an error. \cr \cr
}

\section{Smaller Than, Greater Than}{

For numeric \code{y}, one can specify a range for \code{v}, as explained earlier. \cr
But note one can also specify something like \code{v = c(-Inf, 4)},
which essentially corresponds to the condition \code{y <= 4}. \cr
Thus, when \code{v} specifies a range, "greater-than" and "smaller-than" comparisons are also possible. \cr
\cr
\cr
}

\section{Handling NAs and NaN}{

We also have to handle the \code{NA}s and \code{NaN}s. \cr
The \code{na} argument can be used to specify what to do when
a \code{y} is \code{NA}. \cr
\cr
When \code{na = FALSE}, all \code{NA} values of \code{y} are always ignored. \cr
So these are not extracted (\link{slicev_x}),
replaced (\link{slicev_set}),
or counted (\link{countv}). \cr
\cr
When \code{na = TRUE}, \code{NA} values of \code{y} are always included. \cr
So these will be included in the extractions (\link{slicev_x}),
replacements (\link{slicev_set}),
and counts (\link{countv}). \cr
\cr
One can also specify \code{na = NA},
which will ignore \code{v} completely,
and explicitly look for \code{NA}s/\code{NaN}s in \code{y} instead - like so:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
slicev_x(x, y = y, na = NA)                        # ==> x[is.na(y)]                     
slicev_x(x, y = y, na = NA, r = FALSE)             # ==> x[!is.na(y)]
slicev_set(x, y = y, na = NA, rp = rp)             # ==> x[is.na(y)] <- rp                 
slicev_set(x, y = y, na = NA, r = FALSE, rp = rp)  # ==> x[!is.na(y)] <- rp               
slicev_set(x, y = y, na = NA, tf = tf)             # ==> x[is.na(y)] <- tf(x[is.na(y)])    
slicev_set(x, y = y, na = NA, r = FALSE, tf = tf)  # ==> x[!is.na(y)] <- tf(x[!is.na(y)]) 
countv(y, na = NA)                                 # ==> sum(is.na(y))                    
countv(y, na = NA, r = FALSE)                      # ==> sum(!is.na(y))                    

}\if{html}{\out{</div>}}

Handling \code{NA}s works the same for all atomic types. \cr
For \code{y} of type \code{complex},
a value \code{y[i]} is considered \code{NA}
if \code{Re(y[i])} is \code{NA}/\code{NaN} and/or \code{Im(y[i])} is \code{NA}/\code{NaN}. \cr
\cr
Argument \code{v} is never allowed to contain \code{NA}/\code{NaN}. \cr
\cr
\cr
}

\section{From, To}{

Like the \code{slice} methods,
one can specify the range within to perform the sub-set operations,
using the \verb{from, to} arguments. \cr
For example,
if you wish to extract all values of \code{x} for which holds that \code{y != v},
but \bold{only} want the extractions between index 10 and 100,
one can specify the following: \cr
\verb{slicev_x(x, y = y, v = v, r = FALSE, from = 10, to = 100}. \cr
\cr
Just like \code{slice},
the \verb{from,to} argument can also be used for reverse the order of the result,
by specifying a higher value for \code{from} than for \code{to}. \cr
The step-size in the \code{slicev}/\code{countv} functions is always \code{1L} (or  \code{-1L} if \code{from > to}). \cr
\cr
Also like \code{slice}, \verb{from, to} can be imaginary numbers also, as explained in \link{cp_seq}. \cr
\cr
\cr
}

\section{Inverting}{

\code{countv()} and \code{slicev_set()} do not have an "invert" argument,
and likewise there is no \code{slicev_wo()} function. \cr
One can only invert the sub-set condition, by specifying \code{r = FALSE}. \cr
But \code{r = FALSE} only inverts the condition; it does not invert the range specified by \verb{from, to}. \cr
\cr
\cr
}

\section{Ellipsis}{

The ellipsis (\code{...}) is intentionally placed right after the first argument
(\code{x} in \code{slicev_} and \code{y} in \code{countv})
to force the user to explicitly name all arguments,
as doing so will avoid a lot of unnecessary confusion. \cr \cr
}

\examples{

# basic idea ====
nms <- c(letters, LETTERS, month.abb, month.name) |> rep_len(1e6)
x <- mutatomic(1:1e6, names = nms)
head(x)

# memory efficient form of sum(x <= 10):
countv(x, v = c(-Inf, 10))

# extract all elements of x with the name "a":
slicev_x(x, y = names(x), v = "a") |> head()

# find all x smaller than or equal to 5, and replace with `-1000`:
slicev_set(x, y = x, v = c(-Inf, 5), rp = -1000L)
head(x, n = 10)


################################################################################
# Numeric range ====
#
x <- mutatomic(1:1e6)
head(x)
slicev_x(x, v= c(-Inf, 5)) # x[x <= 5]


################################################################################
# Character ====
#
x <- stringi::stri_rand_shuffle(rep("hello", 1e5))
head(x)
slicev_x(x, v = "hello") |> head() # find "hello"

# find 2 possible misspellings of "hello":
slicev_x(x, v = c("holle", "helol")) |> head()




}
