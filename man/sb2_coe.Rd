% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generic_coe.R
\name{sb2_coe}
\alias{sb2_coe}
\alias{sb2_coe.default}
\alias{sb2_coe.array}
\alias{sb2_coe.data.frame}
\title{Method to Coercively Transform Subsets of Recursive Objects}
\usage{
sb2_coe(x, ...)

\method{sb2_coe}{default}(x, i, inv = FALSE, ..., v, .lapply = lapply)

\method{sb2_coe}{array}(
  x,
  idx = NULL,
  dims = NULL,
  i = NULL,
  inv = FALSE,
  ...,
  v,
  .lapply = lapply
)

\method{sb2_coe}{data.frame}(x, col = NULL, vars = NULL, inv = FALSE, ..., v)
}
\arguments{
\item{x}{a recursive object (list-like or data.frame-like).}

\item{...}{further arguments passed to or from other methods.}

\item{i, col, vars, idx, dims, inv}{See \link{squarebrackets_indx_args}. \cr
An empty index selection returns the original object unchanged. \cr}

\item{v}{the coercive transformation function to use.}

\item{.lapply}{the generic methods use \link[base]{lapply}
for list- and data.frame-like objects
to compute \code{tf()} on every list element or dataset column. \cr
The user may supply a custom \code{lapply()}-like function
in this argument to use instead. \cr
For example, the perform parallel transformation,
the user may supply \verb{future.apply::}\link[future.apply]{future_lapply}. \cr
The supplied function must use the exact same argument convention as
\link[base]{lapply},
otherwise errors or unexpected behaviour may occur.}
}
\value{
A copy of the coercively transformed object.
}
\description{
This is an S3 Method to completely transform subsets of
recursive objects with explicit coercion. \cr
\cr
Note that when \code{x} is a \code{data.table},
one can coercively transform columns by reference
(which is more memory efficient),
using \link{dt_setcoe}. \cr \cr
}
\examples{

obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]))
str(obj) # notice that columns "a" and "c" are INTEGER (`int`)
sb2_set(
  obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,
  tf = sqrt # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost
)
print(obj)
obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]))
obj <- sb2_coe(obj, vars = is.numeric, v = as.numeric)
str(obj)
sb2_set(obj,
  filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,
  tf = sqrt # SAFE: coercion performed; so no warnings
) 
print(obj)

}
