% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generic_set.R
\name{sb_set}
\alias{sb_set}
\alias{sb_set.default}
\alias{sb_set.matrix}
\alias{sb_set.array}
\alias{sb2_set}
\alias{sb2_set.default}
\alias{sb2_set.data.table}
\title{Method to Modify Subsets of a Mutable Object By Reference}
\usage{
sb_set(x, ...)

\method{sb_set}{default}(
  x,
  i = NULL,
  inv = FALSE,
  ...,
  rp,
  tf,
  chkdup = getOption("squarebrackets.chkdup", FALSE)
)

\method{sb_set}{matrix}(
  x,
  row = NULL,
  col = NULL,
  i = NULL,
  inv = FALSE,
  ...,
  rp,
  tf,
  chkdup = getOption("squarebrackets.chkdup", FALSE)
)

\method{sb_set}{array}(
  x,
  sub = NULL,
  dims = NULL,
  i = NULL,
  inv = FALSE,
  ...,
  rp,
  tf,
  chkdup = getOption("squarebrackets.chkdup", FALSE)
)

sb2_set(x, ...)

\method{sb2_set}{default}(x, ...)

\method{sb2_set}{data.table}(
  x,
  row = NULL,
  col = NULL,
  filter = NULL,
  vars = NULL,
  inv = FALSE,
  ...,
  rp,
  tf,
  chkdup = getOption("squarebrackets.chkdup", FALSE),
  .lapply = lapply
)
}
\arguments{
\item{x}{a \bold{variable} belonging to one of the
\link[=squarebrackets_mutable_classes]{supported mutable classes}. \cr}

\item{...}{see \link{squarebrackets_method_dispatch}.}

\item{i, row, col, sub, dims, filter, vars, inv}{See \link{squarebrackets_indx_args}. \cr
An empty index selection leaves the original object unchanged. \cr}

\item{rp}{an object of somewhat the same type as the selected subset of \code{x},
and the same same length as the selected subset of \code{x} or a length of 1. \cr
To remove recursive subsets of recursive objects, see either \link{sb2_rec} or \link{sb2_rm}.}

\item{tf}{the transformation function.}

\item{chkdup}{see \link{squarebrackets_options}. \cr
\ifelse{html}{\figure{for_performance-set_to_FALSE-red.svg}{options: alt='[for performance: set to FALSE]'}}{\link[=squarebrackets_help]{for performance: set to FALSE}} \cr}

\item{.lapply}{the generic methods use \link[base]{lapply}
for list- and data.frame-like objects
to compute \code{tf()} on every list element or dataset column. \cr
The user may supply a custom \code{lapply()}-like function
in this argument to use instead. \cr
For example, the perform parallel transformation,
the user may supply \verb{future.apply::}\link[future.apply]{future_lapply}. \cr
The supplied function must use the exact same argument convention as
\link[base]{lapply},
otherwise errors or unexpected behaviour may occur.}
}
\value{
Returns: VOID. This method modifies the object by reference. \cr
Do not use assignments like \code{x <- sb_set(x, ...)}. \cr
Since this function returns void, you'll just get \code{NULL}. \cr \cr
}
\description{
This is an S3 Method to replace or transform a subset of a
\link[=squarebrackets_mutable_classes]{supported mutable object}
using
\link[=squarebrackets_PassByReference]{pass-by-reference semantics} \cr
Use \code{sb_set(x, ...)} if \code{x} is an atomic object (i.e. \link{mutable_atomic}). \cr
Use \code{sb2_set(x, ...)} if \code{x} is a recursive object (i.e. \link{data.table}). \cr \cr
}
\details{
\bold{Transform or Replace} \cr
Specifying argument \code{tf} will transform the subset.
Specifying \code{rp} will replace the subset.
One cannot specify both \code{tf} and \code{rp}. It's either one set or the other. \cr
\cr
}
\examples{


# mutable_atomic objects ====

gen_mat <- function() {
  obj <- as.mutable_atomic(matrix(1:16, ncol = 4))
  colnames(obj) <- c("a", "b", "c", "a")
  return(obj)
}

obj <- obj2 <- gen_mat()
obj
sb_set(obj, 1:3, 1:3, rp = -1:-9)
obj2
obj <- obj2 <- gen_mat()
obj
sb_set(obj, i = \(x)x<=5, rp = -1:-5)
obj2
obj <- obj2 <- gen_mat()
obj
sb_set(obj, col = "a", rp = cbind(-1:-4, -5:-8))
obj2

obj <- obj2 <- gen_mat()
obj
sb_set(obj, 1:3, 1:3, tf = \(x) -x)
obj2
obj <- obj2 <- gen_mat()
obj
sb_set(obj, i = \(x)x<=5, tf = \(x) -x)
obj2
obj <- obj2 <- gen_mat()
obj
sb_set(obj, col = "a", tf = \(x) -x)
obj2


gen_array <- function() {
  as.mutable_atomic(array(1:64, c(4,4,3)))
}
obj <- gen_array()
obj
sb_set(obj, list(1:3, 1:2, c(1, 3)), 1:3, rp = -1:-12)
obj
obj <- gen_array()
obj
sb_set(obj, i = \(x)x<=5, rp = -1:-5)
obj


#############################################################################

# data.table ====

obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]))
str(obj) # notice that columns "a" and "c" are INTEGER (`int`)
sb2_set(
  obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,
  tf = sqrt # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost
)
print(obj)

obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]))
dt_setcoe(obj, vars = is.numeric, v = as.numeric)
str(obj)
sb2_set(obj,
  filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,
  tf = sqrt # SAFE: coercion performed by dt_setcoe(); so no warnings
) 
print(obj)

obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]))
str(obj) # notice that columns "a" and "c" are INTEGER (`int`)
sb2_set(
  obj, vars = is.numeric,
  tf = sqrt # SAFE: row=NULL & filter = NULL, so coercion performed
)
str(obj)

}
