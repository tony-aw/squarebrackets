% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aaa03_squarebrackets_indx_args.R
\name{aaa03_squarebrackets_indx_args}
\alias{aaa03_squarebrackets_indx_args}
\alias{squarebrackets_indx_args}
\title{Index Arguments in the Generic Sub-setting Methods}
\description{
There are several types of arguments that can be used
in the generic methods of 'squarebrackets' to specify the indices to perform operations on:
\itemize{
\item \code{i}: to specify flat (i.e. dimensionless) indices.
\item \verb{sub, dims}: to specify indices of arbitrary dimensions in arrays
(including matrices, which inherit from arrays).
\item \verb{margin, slice}: to specify indices of one particular dimension.
\item \verb{row, col}: to specify rows and/or columns in specifically in data.frame-like objects.
\item \verb{filter, vars}: to specify rows and/or columns specifically in data.frame-like objects. \cr \cr
}

Thus there are essentially 3 APIs: one for vectors, one for arrays and matrices,
and one for data.frame-like objects. \cr
\cr
For the fundamentals of indexing in 'squarebrackets', see \link{squarebrackets_indx_fundamentals}. \cr
In this help page \code{x} refers to the object on which subset operations are performed. \cr
\cr
\cr
}
\section{Argument i}{

\ifelse{html}{\figure{class-atomic_vector-blue.svg}{options: alt='[class: atomic vector]'}}{\link[=squarebrackets_indx_args]{class: atomic vector}} \cr
\ifelse{html}{\figure{class-derived_atomic_vector-blue.svg}{options: alt='[class: derived atomic vector]'}}{\link[=squarebrackets_indx_args]{class: derived atomic vector}} \cr
\ifelse{html}{\figure{class-recursive_vector-blue.svg}{options: alt='[class: recursive vector]'}}{\link[=squarebrackets_indx_args]{class: recursive vector}} \cr

Any of the following can be specified for argument \code{i}:
\itemize{
\item \code{NULL}, corresponds to missing argument.
\item a vector of length 0,
in which case no indices are selected for the operation
(i.e. empty selection).
\item a numeric vector of \bold{strictly positive whole numbers} with indices.
\item a \bold{complex} vector, as explained in \link{squarebrackets_indx_fundamentals}.
\item a \bold{logical vector},
of the same length as \code{x},
giving the indices to select for the operation.
\item a \bold{character} vector of index names. \cr
If an object has multiple indices with the given name,
ALL the corresponding indices will be selected for the operation.
\item a \bold{function} that takes as input \code{x},
and returns a logical vector,
giving the element indices to select for the operation. \cr
For atomic objects, \code{i} is interpreted as \code{i(x)}. \cr
For recursive objects, \code{i} is interpreted as \code{lapply(x, i)}. \cr
\cr
}

Using the \code{i} arguments corresponds to doing something like the following:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{ sb_x(x, i = i) # ==> x[i]   # if `x` is atomic
 sb2_x(x, i = i) # ==> x[i]  # if `x` is recursive
 
}\if{html}{\out{</div>}}

If \code{i} is a function, it corresponds to the following:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{ sb_x(x, i = i) # ==> x[i(x)] # if `x` is atomic
 sb2_x(x, i = i) # ==> x[lapply(x, i)] # if `x` is recursive
 
}\if{html}{\out{</div>}}
}

\section{Argument Pair sub, dims}{

\ifelse{html}{\figure{class-atomic_matrix-blue.svg}{options: alt='[class: atomic matrix]'}}{\link[=squarebrackets_indx_args]{class: atomic matrix}} \cr
\ifelse{html}{\figure{class-recursive_matrix-blue.svg}{options: alt='[class: recursive matrix]'}}{\link[=squarebrackets_indx_args]{class: recursive matrix}} \cr
\ifelse{html}{\figure{class-atomic_array-blue.svg}{options: alt='[class: atomic array]'}}{\link[=squarebrackets_indx_args]{class: atomic array}} \cr
\ifelse{html}{\figure{class-recursive_array-blue.svg}{options: alt='[class: recursive array]'}}{\link[=squarebrackets_indx_args]{class: recursive array}} \cr
The \verb{sub, dims} argument pair is inspired by the
\code{abind::}\link[abind]{asub} function from the 'abind' package
(see reference below). \cr
\code{dims} must be an integer vector,
giving the dimensions for which to specify the
\link[=squarebrackets_indx_fundamentals]{subscripts}.
(i.e. \code{dims} specifies the "non-missing" margins). \cr \cr

\code{sub} must be either of the following:
\itemize{
\item a list of length \code{length(dims)}.
\item a list of length 1; \cr
in this case \code{sub} will be recycled to \code{length(dims)}.
\item an atomic vector; \cr
this is functionally equivalent to specifying \code{sub} as a list of length 1. \cr \cr
}

Each element of \code{sub} when \code{sub} is a list,
or \code{sub} itself when \code{sub} is an atomic vector,
can be any of the following:
\itemize{
\item a vector of length 0,
in which case no indices are selected for the operation (i.e. empty selection).
\item a numeric vector of \bold{strictly positive whole numbers} with indices of the specified dimension to select for the operation.
\item a \bold{complex} vector, as explained in \link{squarebrackets_indx_fundamentals}.
\item a \bold{logical} vector of the same length as the corresponding dimension size,
giving the indices of the specified dimension to select for the operation.
\item a \bold{character} vector giving the \code{dimnames} to select. \cr
If a dimension has multiple indices with the given name,
ALL the corresponding indices will be selected for the operation. \cr \cr
}

Note also the following:
\itemize{
\item As stated, \code{dims} specifies which index margins are non-missing. \cr
If \code{dims} is of length \code{0},
it is taken as "all index margins are missing".
\item The default value for \code{dims} is \code{1:}\link{ndims}\code{(x)}. \cr \cr
}

To keep the syntax short,
the user can use the \link{n} function instead of \code{list()} to specify \code{sub}. \cr
\cr
Here are some examples for clarity,
using an array \code{x} of 3 dimensions:
\itemize{
\item \code{sb_x(x, n(1:10, 1:5), c(1, 3))} \cr
extracts the first 10 rows, all columns, and the first 5 layers,
of array \code{x}. \cr
The equivalence in base 'R' is: \cr
\code{x[1:10, , 1:5, drop = FALSE]}.
\item \code{sb_x(x, n(1:10), c(1, 3))}, or equivalently \code{sb_x(x, 1:10, c(1, 3))}, \cr
extracts the first 10 rows, all columns, and the first 10 layers,
of array \code{x}. \cr
The equivalence in base 'R' is: \cr
\code{x[1:10, , 1:10, drop = FALSE]}.
\item \code{sb_x(x, n(1:10))}, or equivalently \code{sb_x(x, 1:10)}, \cr
extracts the first 10 rows, columns, and layers of array \code{x}. \cr
The equivalence in base 'R' is: \cr
\code{x[1:10, 1:10, 1:10, drop = FALSE]}. \cr \cr
}

I.e.:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
sb_x(x, n(1:10, 1:5), c(1, 3)) # ==> x[1:10, , 1:5, drop = FALSE]

sb_x(x, n(1:10), c(1, 3))      # ==> x[1:10, , 1:10, drop = FALSE]
sb2_x(x, 1:10, c(1, 3))        # ==> x[1:10, , 1:10, drop = FALSE]

sb2_x(x, n(1:10))              # ==> x[1:10, 1:10, 1:10, drop = FALSE]
sb_x(x, 1:10)                  # ==> x[1:10, 1:10, 1:10, drop = FALSE]
}\if{html}{\out{</div>}}

Note that specifying a list of length 1 for \code{sub}
(like \code{sub = n(1:10)})
is equivalent to specifying an atomic vector for \code{sub}
(like \code{sub = 1:10}). \cr
\cr
For a brief explanation of the relationship between flat indices (\code{i}),
and dimensional subscripts (\code{sub}, \code{dims}),
see \link{squarebrackets_indx_fundamentals}. \cr \cr
}

\section{Argument Pair margin, slice}{

\ifelse{html}{\figure{class-atomic_matrix-blue.svg}{options: alt='[class: atomic matrix]'}}{\link[=squarebrackets_indx_args]{class: atomic matrix}} \cr
\ifelse{html}{\figure{class-recursive_matrix-blue.svg}{options: alt='[class: recursive matrix]'}}{\link[=squarebrackets_indx_args]{class: recursive matrix}} \cr
\ifelse{html}{\figure{class-atomic_array-blue.svg}{options: alt='[class: atomic array]'}}{\link[=squarebrackets_indx_args]{class: atomic array}} \cr
\ifelse{html}{\figure{class-recursive_array-blue.svg}{options: alt='[class: recursive array]'}}{\link[=squarebrackets_indx_args]{class: recursive array}} \cr
\ifelse{html}{\figure{class-data.frame-like-blue.svg}{options: alt='[class: data.frame-like]'}}{\link[=squarebrackets_indx_args]{class: data.frame-like}} \cr

Relevant only for the \link{idx} method. \cr
The \code{margin} argument specifies the dimension on which argument \code{slice} is used. \cr
I.e. when \code{margin = 1}, \code{slice} selects rows; \cr
when \code{margin = 2}, \code{slice} selects columns; \cr
etc. \cr
\cr
The \code{slice} argument can be any of the following:
\itemize{
\item a numeric vector of \bold{strictly positive whole numbers} with dimension indices to select for the operation.
\item a \bold{complex} vector, as explained in \link{squarebrackets_indx_fundamentals}.
\item a \bold{logical} vector of the same length as the corresponding dimension size,
giving the dimension indices to select for the operation.
\item a \bold{character} vector of index names. \cr
If a dimension has multiple indices with the given name,
ALL the corresponding indices will be selected for the operation. \cr
}

One could also give a vector of length \code{0} for \code{slice}; \cr
Argument \code{slice} is only used in the \link{idx} method ,
and the result of \link{idx} are meant to be used inside the regular \code{[} and \verb{[<-} operators. \cr
Thus the effect of a zero-length index specification depends on the rule-set of
\verb{[.class(x)} and \verb{[<-.class(x)}. \cr \cr
}

\section{Arguments row, col}{

\ifelse{html}{\figure{class-data.frame-like-blue.svg}{options: alt='[class: data.frame-like]'}}{\link[=squarebrackets_indx_args]{class: data.frame-like}} \cr

Any of the following can be specified for the arguments \code{row} / \code{col}:
\itemize{
\item \code{NULL} (default), corresponds to a missing argument.
\item a vector of length 0,
in which case no indices are selected for the operation (i.e. empty selection).
\item a numeric vector of \bold{strictly positive whole numbers} with indices of the specified dimension to select for the operation.
\item a \bold{complex} vector, as explained in \link{squarebrackets_indx_fundamentals}.
\item a \bold{logical} vector of the same length as the corresponding dimension size,
giving the indices of the specified dimension to select for the operation.
\item a \bold{character} vector giving the \code{dimnames} to select. \cr
If a dimension has multiple indices with the given name,
ALL the corresponding indices will be selected for the operation. \cr
}

Using the \verb{row, col} arguments corresponds to doing something like the following:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{ sb2_x(x, row, col) # ==> x[row, col, drop = FALSE]
 
}\if{html}{\out{</div>}}
}

\section{Arguments filter, vars}{

\ifelse{html}{\figure{class-data.frame-like-blue.svg}{options: alt='[class: data.frame-like]'}}{\link[=squarebrackets_indx_args]{class: data.frame-like}} \cr

\code{filter} must be a one-sided formula
with a single logical expression using the column names of the data.frame,
giving the condition which observation/row indices should be selected for the operation. \cr
For example,
to perform an operation on the rows for which column \code{height > 2} and for which column \code{sex != "female"},
specify the following formula:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{~ (height > 2) & (sex != "female")
}\if{html}{\out{</div>}}

If the formula is linked to an environment,
any variables not found in the data set will be searched from the environment. \cr
\cr
\code{vars} must be a function that returns a logical vector,
giving the column indices to select for the operation. \cr
For example, to select all numeric columns, specify \code{vars = is.numeric}. \cr
\cr
}

\section{Argument inv}{

\ifelse{html}{\figure{all_classes-blue.svg}{options: alt='[all classes]'}}{\link[=squarebrackets_indx_args]{all classes}} \cr

Relevant for the \link{sb_mod}/\link{sb2_mod}, \link{sb_set}/\link{sb2_set},
and \link{idx} methods. \cr
By default, \code{inv = FALSE}, which translates the indices like normally. \cr
When \code{inv = TRUE}, the inverse of the indices is taken. \cr
Consider, for example, an atomic matrix \code{x}; \cr
using \code{sb_mod(x, 1:2, 2L, tf = tf)}
corresponds to something like the following:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
x[, 1:2] <- tf(x[, 1:2])
x

}\if{html}{\out{</div>}}

and using \code{sb_mod(x, col = 1:2, inv = TRUE, tf = tf)}
corresponds to something like the following:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
x[, -1:-2] <- tf(x[, -1:-2])
x

}\if{html}{\out{</div>}}

\bold{NOTE} \cr
The order in which the user gives indices when \code{inv = TRUE} generally does not matter. \cr
The order of the indices as they appear in the original object \code{x} is maintained,
just like in base 'R'. \cr
Therefore, when replacing multiple values where the order of the replacement matters,
it is better to keep \code{inv = FALSE}, which is the default. \cr
For replacement with a single value or with a transformation function,
\code{inv = TRUE} can be used without considering the ordering. \cr \cr
}

\section{All NULL indices}{

\code{NULL} in the indexing arguments corresponds to a missing argument. \cr
Thus, for \bold{both} \link{sb_x} and \link{sb_rm},
using \code{NULL} for all indexing arguments corresponds to something like the following:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
x[]

}\if{html}{\out{</div>}}

Similarly, for \link{sb_mod} and \link{sb_set},
using \code{NULL} corresponds to something like the following:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
x[] <- rp # for replacement
x[] <- tf(x) # for transformation

}\if{html}{\out{</div>}}

The above is true \bold{even if} \code{inv = TRUE} and/or \code{red = TRUE}. \cr \cr
}

\section{Out-of-Bounds Integers, Non-Existing Names, and NAs}{

\itemize{
\item Integer indices that are out of bounds (including \code{NaN} and \code{NA_integer_}) always give an error.
\item Specifying non-existing names (including \code{NA_character_}) as indices
is considered a form of zero-length indexing.
\item Logical indices are translated internally to integers using \link[base]{which},
and so \code{NA}s are ignored. \cr \cr
}
}

\section{Disallowed Combinations of Index Arguments}{


One cannot specify \code{i} and  the other indexing arguments simultaneously;
it's either \code{i}, or the other arguments. \cr
\cr
One cannot specify \code{row} and \code{filter} simultaneously;
it's either one or the other. \cr
One cannot specify \code{col} and \code{vars} simultaneously;
it's either one or the other. \cr
One cannot specify the \verb{sub, dims} pair and \verb{slice, margin} pair simultaneously;
it's either one pair or the other pair. \cr
In the above cases it holds that if one set is specified, the other is set is ignored. \cr
\cr
}

\section{Drop}{

Sub-setting with the generic methods from the 'squarebrackets' R-package using dimensional arguments
(\verb{row, col, lyr, sub, dims, filter, vars})
always use \code{drop = FALSE}. \cr
To drop potentially redundant (i.e. single level) dimensions,
use the \link[base]{drop} function, like so:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{ sb_x(x, row = row, col = col) |> drop() # ==> x[row, col, drop = TRUE]
 
}\if{html}{\out{</div>}}
}

\references{
Plate T, Heiberger R (2016). \emph{abind: Combine Multidimensional Arrays}. R package version 1.4-5, \url{https://CRAN.R-project.org/package=abind}.
}
