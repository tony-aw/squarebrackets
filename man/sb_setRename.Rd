% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generic_setRename.R
\name{sb_setRename}
\alias{sb_setRename}
\alias{sb_setRename.default}
\alias{sb_setRename.array}
\alias{sb2_setRename}
\alias{sb2_setRename.data.table}
\title{Method to Change the Names of a Mutable Object By Reference}
\usage{
sb_setRename(x, ...)

\method{sb_setRename}{default}(x, newnames, ...)

\method{sb_setRename}{array}(x, newnames, newdimnames, ...)

sb2_setRename(x, ...)

\method{sb2_setRename}{data.table}(x, old, new, skip_absent = FALSE, ...)
}
\arguments{
\item{x}{a \bold{variable} belonging to one of the
\link[=squarebrackets_mutable_classes]{supported mutable classes}. \cr}

\item{...}{further arguments passed to or from other methods. \cr \cr}

\item{newnames}{atomic character vector giving the new names. \cr
Specifying \code{NULL} will remove the names.}

\item{newdimnames}{a list of the same length as \code{dim(x)}. \cr
The first element of the list corresponds to the first dimension,
the second element to the second dimension, and so on. \cr
The components of the list can be either \code{NULL},
or a character vector with the same length as the corresponding dimension. \cr
Instead of a list,
simply \code{NULL} can be specified,
which will remove the \code{dimnames} completely.}

\item{old}{the old column names}

\item{new}{the new column names, in the same order as \code{old}}

\item{skip_absent}{Skip items in old that are missing
(i.e. absent) in \code{names(x)}. \cr
Default \code{FALSE} halts with error if any are missing.}
}
\value{
Returns: VOID. This method modifies the object by reference. \cr
Do not use assignment like \code{names(x) <- sb_setRename(x, ...)}. \cr
Since this function returns void, you'll just get \code{NULL}. \cr \cr
}
\description{
This is an S3 Method to rename a
\link[=squarebrackets_mutable_classes]{supported mutable object}
using
\link[=squarebrackets_PassByReference]{pass-by-reference}
semantics. \cr
\cr
This method takes extra care
not to modify any objects that happen to share the same address as
the (dim)names of \code{x}. \cr
I.e. the following code:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{x <- mutable_atomic(1:26)
names(x) <- base::letters
y <- x
sb_setRename(x, newnames = rev(names(x)))

}\if{html}{\out{</div>}}

will not modify \code{base::letters}, even though \code{names(x)} shared the same address. \cr
Thus, \code{sb_setRename()} can be used safely without fearing such accidents. \cr
\cr
Use \code{sb_setRename(x, ...)} if \code{x} is a non-recursive object
(i.e. \link{mutable_atomic}). \cr
Use \code{sb2_setRename(x, ...)} if \code{x} is a recursive object
(i.e. \link{data.table}). \cr \cr
}
\examples{
 
# mutable atomic vector ====
x <- y <- mutable_atomic(1:10, names = letters[1:10])
sb_setRename(x, rev(letters[1:10]))
print(x)

################################################################################


# mutable atomic matrix ====
x <- mutable_atomic(
  1:20, dim = c(5, 4), dimnames = n(letters[1:5], letters[1:4])
)
print(x)
sb_setRename(
  x,
  newdimnames = lapply(dimnames(x), rev)
)
print(x)


x <- mutable_atomic(
   1:20, letters[1:20], dim = c(5, 4), dimnames = n(letters[1:5], letters[1:4])
)
print(x)
sb_setRename(
  x, newnames = rev(names(x)),
  newdimnames = lapply(dimnames(x), rev)
)
print(x)


################################################################################



# data.table ====

x <- data.table::data.table(
  a = 1:20,
  b = letters[1:20]
)
print(x)
sb2_setRename(x, old = names(x), new = rev(names(x)))
print(x)

}
