% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generic_setRename.R
\name{sb_setRename}
\alias{sb_setRename}
\alias{sb_setFlatnames}
\alias{sb_setDimnames}
\alias{sb2_setVarnames}
\title{Change the Names of a Mutable Object By Reference}
\usage{
sb_setFlatnames(x, i = NULL, newnames, ...)

sb_setDimnames(x, m, newdimnames, ...)

sb2_setVarnames(x, old, new, skip_absent = FALSE, ...)
}
\arguments{
\item{x}{a \bold{variable} belonging to one of the
\link[=squarebrackets_mutable_classes]{supported mutable classes}. \cr}

\item{i}{logical, numeric, character, or imaginary indices, indicating which flatnames should be changed. \cr
If \code{i = NULL}, the names will be completely replaced.}

\item{newnames}{Atomic character vector giving the new names. \cr
Specifying \code{NULL} will remove the names. \cr}

\item{...}{see \link{squarebrackets_method_dispatch}. \cr \cr}

\item{m}{integer vector giving the margin(s) for which to change the names
(\code{m = 1L} for rows, \code{m = 2L} for columns, etc.).}

\item{newdimnames}{a list of the same length as \code{m}. \cr
The first element of the list corresponds to margin \code{m[1]},
the second element to \code{m[2]},
and so on. \cr
The components of the list can be either \code{NULL},
or a character vector with the same length as the corresponding dimension. \cr
Instead of a list,
simply \code{NULL} can be specified,
which will remove the \code{dimnames} completely.}

\item{old}{the old column names}

\item{new}{the new column names, in the same order as \code{old}}

\item{skip_absent}{Skip items in old that are missing
(i.e. absent) in \code{names(x)}. \cr
Default \code{FALSE} halts with error if any are missing.}
}
\value{
Returns: VOID. This method modifies the object by reference. \cr
Do not use assignment like \code{names(x) <- sb_setRename(x, ...)}. \cr
Since this function returns void, you'll just get \code{NULL}. \cr \cr
}
\description{
Functions to rename a
\link[=squarebrackets_mutable_classes]{supported mutable object}
using
\link[=squarebrackets_PassByReference]{pass-by-reference}
semantics:
\itemize{
\item \code{sb_setFlatnames()} renames the (flat) names of a \code{mutable_atomic} object.
\item \code{sb_setDimnames()} renames the dimension names of a \code{mutable_atomic} object.
\item \code{sb2_setVarnames()} renames the variable names of a \code{data.table} object. \cr \cr
}
}
\details{
These methods take extra care
not to modify any objects that happen to share the same address as
the (dim)names of \code{x}. \cr
I.e. the following code:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{x <- mutable_atomic(1:26)
names(x) <- base::letters
y <- x
sb_setFlatname(x, newnames = rev(names(x)))

}\if{html}{\out{</div>}}

will not modify \code{base::letters}, even though \code{names(x)} shared the same address. \cr
Thus, these functions can be used safely without fearing such accidents. \cr
\cr
}
\examples{
 
# mutable atomic vector ====
x <- y <- mutable_atomic(1:10, names = letters[1:10])
print(x)
sb_setFlatnames(x, newnames = rev(letters[1:10]))
print(y)

x <- y <- mutable_atomic(1:10, names = letters[1:10])
print(x)
sb_setFlatnames(x, 1L, "XXX")
print(y)

################################################################################


# mutable atomic matrix ====
x <- mutable_atomic(
  1:20, dim = c(5, 4), dimnames = n(letters[1:5], letters[1:4])
)
print(x)
sb_setDimnames(
  x,
  1:2,
  lapply(dimnames(x), rev)
)
print(x)



################################################################################



# data.table ====

x <- data.table::data.table(
  a = 1:20,
  b = letters[1:20]
)
print(x)
sb2_setVarnames(x, old = names(x), new = rev(names(x)))
print(x)

}
