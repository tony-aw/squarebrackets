% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lst.R
\name{lst}
\alias{lst}
\alias{lst_nlists}
\alias{lst_untree}
\title{Unnest Tree-like List to Recursive 2d Array or Flattened Recursive Vector}
\usage{
lst_nlists(x)

lst_untree(x, margin, use.names = FALSE)
}
\arguments{
\item{x}{a tree-like nested list.}

\item{margin}{a single integer, indicating how the result should be arranged:
\itemize{
\item \code{margin = 0} produces a simple flattened recursive vector (i.e. list) without dimensions.
\item \code{margin = 1} produces a 2D recursive array (i.e. a matrix of lists), \cr
with \code{length(x)} rows and \code{n} columns, \cr
where \code{n = sapply(x, }\link{lst_nlists}\code{) |> max()}. \cr
Empty elements will be filled with \code{list(NULL)}.
\item \code{margin = 2} produces a 2D recursive array (i.e. a matrix of lists), \cr
with \code{length(x)} columns and \code{n} rows, \cr
where \code{n = sapply(x, }\link{lst_nlists}\code{) |> max()}. \cr
Empty elements will be filled with \code{list(NULL)}.
}}

\item{use.names}{Boolean,
indicating if the elements returned from \code{lst_untree()} should be named. \cr
Names of nested elements, such as \code{x[[c("A", "B", "C")]]},
will become \code{"A.B.C"},
as that is the behaviour of the \link[base]{rapply} function
(which \code{lst_untree()} calls internally). \cr
It is therefore advised not to use dots (\code{"."}) in your list names,
and use underscores (\code{"_"}) instead,
before calling \code{lst_untree()}. \cr
See the \code{rrapply::}\link[rrapply]{rrapply} function
for renaming
(and other forms of transforming)
recursive subsets of lists. \cr \cr}
}
\value{
For \code{lst_untree()}: \cr
A non-nested (dimensional) list. \cr
Note that if \code{margin = 1} or \code{margin = 2}, \code{lst_untree()} returns a recursive matrix
(i.e. a recursive array with 2 dimensions),
\bold{not} a data.frame. \cr
(One advantage of a recursive matrix over a data.frame,
is that a recursive matrix can have separate column names and regular names,
whereas the names of a data.frame are necessarily equal to the column names). \cr
\cr
For \code{lst_nlists()}: \cr
A single integer,
giving the total number of recursive list-elements in the given list. \cr \cr
}
\description{
\code{[[}, \verb{[[<-}, \link{sb2_rec}, and \link{sb2_recin},
can performing recursive subset operation on a nested list. \cr
Such recursive subset operations only operate on a single element. \cr
Performing recursive subset operations on multiple elements is not vectorized,
and requires a (potentially slow) loop. \cr
\cr
The \code{lst_untree()} function takes a nested tree-like list,
and turns it into a 2d recursive array (i.e. a list-matrix),
allowing vectorized subset operations to be performed on the list. \cr
\code{lst_untree()} can also simply flatten the list, making it a non-nested list. \cr
See the Examples section to understand how the list will be arranged and named. \cr
\cr
The \code{lst_nlists()} counts the total number of recursive list-elements inside a list. \cr \cr
}
\examples{

# show-casing how the list-elements are arranged and named ====

x <- list(
  A = list(
    A = list(A = "AAA", B = "AAB"),
    A = list(A  = "AA2A", B = "AA2B"),
    B = list(A = "ABA", B = "ABB"),
    C = letters
  ),
  Y = list(
    Z = list(Z = "YZZ", Y = "YZY"),
    Y = list(Z = "YYZ", Y = "YYY"),
    X = "YX"
  )
)


# un-tree column-wise:
sapply(x, lst_nlists) |> max() # number of rows `y` will have
y <- lst_untree(x, margin = 2, use.names = TRUE)
dim(y)
print(y)
sb2_x(y, 1:3, 1:2) # vectorized selection of multiple recursive elements


# un-tree row-wise:
sapply(x, lst_nlists) |> max() # number of columns `y` will have
y <- lst_untree(x, margin = 1, use.names = TRUE)
dim(y)
print(y)
sb2_x(y,1:2, 1:3)  # vectorized selection of multiple recursive elements


# simple flattened list:
y <- lst_untree(x, margin = 0, use.names = TRUE)
print(y)
y[["Y.Z.Y"]]
x[[c("Y", "Z", "Y")]] # equivalent in the original list


################################################################################

# showcasing that only list-elements are recursively flattened ====
# i.e. atomic vectors in recursive subsets remain atomic

x <- lapply(1:10, \(x)list(sample(letters), sample(1:10)))

sapply(x, lst_nlists) |> max()
y <- lst_untree(x, margin = 1)
dim(y)
print(y)

lst_untree(x, margin = 1)


################################################################################

# showcasing vectorized sub-setting ====
x <- lapply(1:10, \(x) list(
  list(sample(letters[1:10]), sample(LETTERS[1:10])),
  list(sample(month.abb), sample(month.name)),
  list(sample(1:10), rnorm(10))
))
y <- lst_untree(x, 1)

# getting the first recursive elements in the second level/depth in base R:
for(i in seq_along(x)) {
  x[[c(i, c(1,1))]]
}

# the same, but vectorized using the untree'd list:
y[seq_len(nrow(y)), 1]

}
