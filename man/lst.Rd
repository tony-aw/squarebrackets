% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lst.R
\name{lst}
\alias{lst}
\alias{lst_nlists}
\alias{lst_untree}
\title{Unnest Tree-like List into a Recursive Matrix or Flattened Recursive Vector}
\usage{
lst_nlists(x)

lst_untree(x, margin, use.names = TRUE)
}
\arguments{
\item{x}{a tree-like nested list.}

\item{margin}{a single integer, indicating how the result should be arranged:
\itemize{
\item \code{margin = 0} produces a simple flattened recursive vector (i.e. list) without dimensions.
\item \code{margin = 1} produces a recursive matrix (i.e. a matrix of list-elements), \cr
with \code{length(x)} rows and \code{n} columns, \cr
where \code{n = sapply(x, }\link{lst_nlists}\code{) |> max()}. \cr
Empty elements will be filled with \code{list(NULL)}.
\item \code{margin = 2} produces a recursive matrix (i.e. a matrix of list-elements), \cr
with \code{length(x)} columns and \code{n} rows, \cr
where \code{n = sapply(x, }\link{lst_nlists}\code{) |> max()}. \cr
Empty elements will be filled with \code{list(NULL)}.
}}

\item{use.names}{Boolean, indicating if the result should be named. \cr
See section "use.names" for more information.}
}
\value{
For \code{lst_untree()}: \cr
A non-nested (dimensional) list. \cr
Note that if \code{margin = 1} or \code{margin = 2}, \code{lst_untree()} returns a recursive matrix
(i.e. a recursive array with 2 dimensions),
\bold{not} a data.frame. \cr
To turn a nested list into a data.frame instead, one option would be to use: \cr
\link[rrapply]{rrapply}\code{(x, how = "melt")} \cr
\cr
For \code{lst_nlists()}: \cr
A single integer,
giving the total number of recursive list-elements in the given list. \cr \cr
}
\description{
\code{[[}, \verb{[[<-}, \link{sb2_rec}, and \link{sb2_recin},
can performing recursive subset operation on a nested list. \cr
Such recursive subset operations only operate on a single element. \cr
Performing recursive subset operations on multiple elements is not vectorized,
and requires a (potentially slow) loop. \cr
\cr
The \code{lst_untree()} function takes a nested tree-like list,
and turns it into a recursive matrix (a matrix of list-elements),
allowing vectorized subset operations to be performed on the nested list. \cr
\code{lst_untree()} can also simply flatten the list, making it a non-nested list. \cr
See the Examples section to understand how the list will be arranged and named. \cr
\cr
The \code{lst_nlists()} counts the total number of recursive list-elements inside a list. \cr \cr
}
\section{use.names}{

\bold{\code{margin = 0} and \code{use.names = TRUE}} \cr
If \code{margin = 0} and \code{use.names = TRUE},
every element in the flattened list will be named. \cr
Names of nested elements, such as \code{x[["A"]][["B"]][["C"]]},
will become \code{"A.B.C"},
as that is the behaviour of the \link[base]{rapply} function
(which \code{lst_untree()} calls internally). \cr
It is therefore advised not to use dots (\code{"."}) in your list names,
and use underscores (\code{"_"}) instead,
before calling \code{lst_untree()}. \cr
See the \code{rrapply::}\link[rrapply]{rrapply} function
for renaming
(and other forms of transforming)
recursive subsets of lists. \cr
\cr
\bold{\code{margin = 1} and \code{use.names = TRUE}} \cr
If \code{margin == 1} and \code{use.names = TRUE},
the rows of resulting recursive matrix will be equal to \code{names(x)},
but recursive names will not be assigned. \cr
\cr
\bold{\code{margin = 2} and \code{use.names = TRUE}} \cr
If \code{margin == 2} and \code{use.names = TRUE},
the columns of resulting recursive matrix will be equal to \code{names(x)},
but recursive names will not be assigned. \cr
\cr
\bold{\code{use.names = FALSE}} \cr
If \code{use.names = FALSE}, the result will not have any names assigned at all. \cr
\cr
}

\examples{

# show-casing how the list-elements are arranged and named ====

x <- list(
  A = list(
    A = list(A = "AAA", B = "AAB"),
    A = list(A  = "AA2A", B = "AA2B"),
    B = list(A = "ABA", B = "ABB"),
    C = letters
  ),
  Y = list(
    Z = list(Z = "YZZ", Y = "YZY"),
    Y = list(Z = "YYZ", Y = "YYY"),
    X = "YX"
  )
)


# un-tree column-wise:
sapply(x, lst_nlists) |> max() # number of rows `y` will have
y <- lst_untree(x, margin = 2L, use.names = TRUE)
dim(y)
print(y)
sb2_x(y, n(1:3, 1:2), 1:ndims(y)) # vectorized selection of multiple recursive elements


# un-tree row-wise:
sapply(x, lst_nlists) |> max() # number of columns `y` will have
y <- lst_untree(x, margin = 1L, use.names = TRUE)
dim(y)
print(y)
sb2_x(y, n(1:2, 1:3), 1:ndims(y))  # vectorized selection of multiple recursive elements


# simple flattened list:
y <- lst_untree(x, margin = 0, use.names = TRUE)
print(y)
y[["Y.Z.Y"]]
x[[c("Y", "Z", "Y")]] # equivalent in the original list


################################################################################

# showcasing that only list-elements are recursively flattened ====
# i.e. atomic vectors in recursive subsets remain atomic

x <- lapply(1:10, \(x)list(sample(letters), sample(1:10)))

sapply(x, lst_nlists) |> max()
y <- lst_untree(x, margin = 1)
dim(y)
print(y)

lst_untree(x, margin = 1)


################################################################################

# showcasing vectorized sub-setting ====
x <- lapply(1:10, \(x) list(
  list(sample(letters[1:10]), sample(LETTERS[1:10])),
  list(sample(month.abb), sample(month.name)),
  list(sample(1:10), rnorm(10))
))
y <- lst_untree(x, 1)

# getting the first recursive elements in the second level/depth in base R:
for(i in seq_along(x)) {
  x[[c(i, c(1L, 1L))]] |> print() # for-loop, slow
}

# the same, but vectorized using the untree'd list:
sb2_x(y, n(1:nrow(y), 1L), 1:ndims(y)) |> drop() |> print() # vectorized, fast

}
