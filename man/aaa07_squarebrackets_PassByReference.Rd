% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aaa07_squarebrackets_PassByReference.R
\name{aaa07_squarebrackets_PassByReference}
\alias{aaa07_squarebrackets_PassByReference}
\alias{squarebrackets_PassByReference}
\title{Regarding Modification By Reference}
\description{
This help page describes how modification using "pass-by-reference" semantics
is handled by the 'squarebrackets' package. \cr
This help page does not explain all the basics of pass-by-reference semantics,
as this is treated as prior knowledge. \cr
All functions/methods in the 'squarebrackets' package
with the word "set" in the name
use pass-by-reference semantics. \cr \cr
}
\section{Advantages and Disadvantages}{

The main advantage of pass-by-reference is that much less memory is required to modify objects,
and modification is also generally faster. \cr
But it does have several disadvantages. \cr
\cr
First, the coercion rules are slightly different: see \link{squarebrackets_coercion}. \cr
\cr
Second, if 2 or more variables refer to exactly the same object,
changing one variable also changes the other ones. \cr
I.e. the following code,

\if{html}{\out{<div class="sourceCode r">}}\preformatted{x <- y <- mutable_atomic(1:16)
sb_set(x, i = 1:6, rp = 8)
}\if{html}{\out{</div>}}

modifies not just \code{x}, but also \code{y}. \cr
This is true even if one of the variables is locked
(see \link[base]{bindingIsLocked}). \cr
I.e. the following code,

\if{html}{\out{<div class="sourceCode r">}}\preformatted{x <- mutable_atomic(1:16)
y <- x
lockBinding("y", environment())
sb_set(x, i = 1:6, rp = 8)
}\if{html}{\out{</div>}}

modifies both \code{x} and \code{y} without error,
even though \code{y} is a locked constant. \cr
\cr
}

\section{Mutable vs Immutable Classes}{

With the exception of environments,
most of base R's S3 classes are treated as immutable: \cr
Modifying an object in 'R' will make a copy of the object,
something called 'copy-on-modify' semantics. \cr
\cr
A prominent mutable S3 class is the \code{data.table} class,
which is a mutable data.frame class, and supported by 'squarebrackets'. \cr
Similarly, 'squarebrackets' adds a class for mutable atomic objects: \cr
\link{mutable_atomic}. \cr \cr
}

\section{Material vs Immaterial objects}{

Most objects in 'R' are material objects: \cr
the values an object contains are actually stored in memory. \cr
For example, given \code{x <- rnorm(1e6)}, \code{x} is a material object: \cr
1 million values (decimal numbers, in this case) are actually stored in memory. \cr
\cr
In contrast, \link[=makeActiveBinding]{ActiveBindings} are immaterial: \cr
They are objects that,
when accessed,
call a function to generate values on the fly,
rather than actually storing values. \cr
\cr
Since immaterial objects do not actually store the values in memory,
the values obviously also cannot be changed in memory. \cr
Therefore, Pass-by-Reference semantics don't work on immaterial objects. \cr
\cr
}

\section{ALTREP}{

The \link{mutable_atomic} constructors
(i.e. \link{mutable_atomic}, \link{as.mutable_atomic}, etc.)
will automatically materialize ALTREP objects,
to ensure consistent behaviour for 'pass-by-reference' semantics. \cr
\cr
A \code{data.table} can have ALTREP columns. \cr
A \code{data.tables} will coerce the column to a materialized column when it is modified, even by reference. \cr
\cr
}

\section{Mutability Rules With Respect To Recursive Objects}{

Lists are difficult objects in that they do not contain elements,
they simply point to  other objects,
that one can access via a list. \cr
When a recursive object is of a mutable class,
all its subsets are treated as mutable,
as long as they are part of the object. \cr
On the other hand,
When a recursive object is of an immutable class,
its recursive subsets retain their original mutability. \cr
\cr
\bold{Example 1: Mutable data.tables} \cr
A \code{data.table} is a mutable class. \cr
So all columns of the \code{data.table} are treated as mutable; \cr
There is no requirement to, for instance,
first change all columns into the class of \link{mutable_atomic}
to modify these columns by reference. \cr
\cr
\bold{Example 2: Immutable lists} \cr
A regular \code{list} is an immutable class. \cr
So the list itself is immutable,
but the recursive subsets of the list retain their mutability. \cr
If you have a list of \code{data.table} objects, for example,
the data.tables themselves remain mutable. \cr
Therefore, the following pass-by-reference modification will work without issue: \cr

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
x <- list(
 a = data.table::data.table(cola = 1:10, colb = letters[1:10]),
 b = data.table::data.table(cola = 11:20, colb = letters[11:20])
)
myref <- x$a
sb2_set(myref, vars = "cola", tf = \\(x)x^2)
}\if{html}{\out{</div>}}

Notice in the above code that \code{myref} has the same address as \code{x$a},
and is therefore not a copy of \code{x$a}. \cr
Thus changing \code{myref} also changes \code{x$a}. \cr
In other words: \code{myref} is what could be called a "\bold{View}" of \code{x$a}. \cr \cr
}

\section{Input Variable}{

Methods/functions that perform in-place modification by reference
only works on objects that actually exist as an actual variable,
similar to functions in the style of \code{some_function(x, ...) <- value}. \cr
Thus things like any of the following, \cr
\code{sb_set(1:10, ...)}, \code{sb2_set(x$a, ...)}, or \code{sb_set(base::letters)}, \cr
will not work. \cr \cr
}

\section{Lock Binding}{

Mutable classes are,
as the name suggests,
meant to be mutable. \cr
Locking the binding of a mutable object is \bold{mostly} fruitless
(but not completely;
see the \link{currentBindings} function). \cr
To ensure an object cannot be modified by any of the methods/functions from 'squarebrackets',
2 things must be true: \cr
\itemize{
\item the object must be an immutable class.
\item the binding must be \bold{locked} (see \link[base]{lockBinding}). \cr \cr
}
}

\section{Protection}{


Due to the properties described above in this help page,
'squarebrackets' protects the user from do something like the following:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
# letters = base::letters
sb_set(letters, i = 1, rp = "XXX")

}\if{html}{\out{</div>}}

'squarebrackets' will give an error when running the code above, because:
\enumerate{
\item most addresses in \code{baseenv()} are protected;
\item immutable objects are disallowed
(you'll have to create a mutable object,
which will create a copy of the original,
thus keeping the original object safe from modification by reference);
\item locked bindings are disallowed.
}
}

\examples{




# the following code demonstrates how locked bindings,
# such as `base::letters`,
# are being safe-guarded

x <- list(a = base::letters)
myref <- x$a # view of a list
address(myref) == address(base::letters) # TRUE: point to the same memory
bindingIsLocked("letters", baseenv()) # base::letters is locked ...
bindingIsLocked("myref", environment()) # ... but this pointer is not!

if(requireNamespace("tinytest")) {
  tinytest::expect_error(
    sb_set(myref, i = 1, rp = "XXX") # this still gives an error though ...
  )
}

is.mutable_atomic(myref) # ... because it's not of class `mutable_atomic`


x <- list(
  a = as.mutable_atomic(base::letters) # `as.mutable_atomic()` makes a copy
)
myref <- x$a # view of a list
address(myref) == address(base::letters) # FALSE: it's a copy
sb_set(
  myref, i = 1, rp = "XXX"  # modifies x, does NOT modify `base::letters`
)
print(x) # x is modified
base::letters # but this still the same


}
