% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aaa04_squarebrackets_indx_args.R
\name{aaa04_squarebrackets_indx_args}
\alias{aaa04_squarebrackets_indx_args}
\alias{squarebrackets_indx_args}
\title{Index Arguments in the Generic Sub-setting Methods}
\description{
There are several types of arguments that can be used
in the generic methods of 'squarebrackets' to specify the indices to perform operations on:
\itemize{
\item \code{i}: to specify interior (i.e. dimensionless) indices.
\item \verb{s, d}: to specify subscripts of arbitrary dimensions
in any dimensional object supported by 'squarebrackets'
(i.e. arrays and data.frame-like objects).
\item \verb{margin, slice}: to specify indices of one particular dimension
(for arrays and data.frame-like objects). \cr
Currently only used in the \link{idx} method. \cr
\item tabular indices (\code{row}, \code{col}, \verb{obs, vars}):
to specify rows and columns in tabular objects (matrices and data.frames). \cr \cr
}

For the fundamentals of indexing in 'squarebrackets',
see \link{squarebrackets_indx_fundamentals}. \cr
In this help page \code{x} refers to the object on which subset operations are performed. \cr
\cr
\cr
}
\section{Argument i}{

\ifelse{html}{\figure{class-atomic_vector-blue.svg}{options: alt='[class: atomic vector]'}}{\link[=squarebrackets_indx_args]{class: atomic vector}} \cr
\ifelse{html}{\figure{class-derived_atomic_vector-blue.svg}{options: alt='[class: derived atomic vector]'}}{\link[=squarebrackets_indx_args]{class: derived atomic vector}} \cr
\ifelse{html}{\figure{class-recursive_vector-blue.svg}{options: alt='[class: recursive vector]'}}{\link[=squarebrackets_indx_args]{class: recursive vector}} \cr
\ifelse{html}{\figure{class-atomic_array-blue.svg}{options: alt='[class: atomic array]'}}{\link[=squarebrackets_indx_args]{class: atomic array}} \cr
\ifelse{html}{\figure{class-recursive_array-blue.svg}{options: alt='[class: recursive array]'}}{\link[=squarebrackets_indx_args]{class: recursive array}} \cr

Any of the following can be specified for argument \code{i}:
\itemize{
\item \code{NULL} or \code{0L}, corresponds to missing argument.
\item a vector of length 0,
in which case no indices are selected for the operation
(i.e. empty selection).
\item a numeric vector of \bold{strictly positive whole numbers} giving indices.
\item a \bold{complex} vector, as explained in \link{squarebrackets_indx_fundamentals}.
\item a \bold{logical vector},
of the same length as \code{x},
giving the indices to select for the operation.
\item a \bold{character} vector of index names. \cr
If an object has multiple indices with the given name,
ALL the corresponding indices will be selected for the operation.
\item a \bold{function} that takes as input \code{x},
and returns a logical vector,
giving the element indices to select for the operation. \cr
For atomic objects, \code{i} is interpreted as \code{i(x)}. \cr
For recursive objects, \code{i} is interpreted as \code{lapply(x, i)}. \cr
\cr
}

Using the \code{i} arguments corresponds to doing something like the following:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{ ii_x(x, i = i) # ==> x[i]   # if `x` is atomic
 ii_x(x, i = i) # ==> x[i]  # if `x` is recursive
 
}\if{html}{\out{</div>}}

If \code{i} is a function, it corresponds to the following:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{ ii_x(x, i = i) # ==> x[i(x)] # if `x` is atomic
 ii_x(x, i = i) # ==> x[lapply(x, i)] # if `x` is recursive
 
}\if{html}{\out{</div>}}
}

\section{Argument Pair s, d}{

\ifelse{html}{\figure{class-atomic_array-blue.svg}{options: alt='[class: atomic array]'}}{\link[=squarebrackets_indx_args]{class: atomic array}} \cr
\ifelse{html}{\figure{class-recursive_array-blue.svg}{options: alt='[class: recursive array]'}}{\link[=squarebrackets_indx_args]{class: recursive array}} \cr
The \verb{s, d} argument pair, inspired by the
\code{abind::}\link[abind]{asub} function from the 'abind' package,
is the primary indexing argument for sub-set operations on dimensional objects. \cr
\cr
The \code{s} argument specifies the
\bold{subscripts}
(i.e. dimensional indices). \cr
The \code{d} argument gives the dimensions for which the
\code{s} holds
(i.e. \code{d} specifies the "non-missing" margins). \cr
\cr
The \code{d} argument must be an integer vector. \cr
\cr
\code{s} must be an atomic vector, a list of length 1, or a list of the same length as \code{d}. \cr
If \code{s} is a list of length 1,
it is internally recycled to become the same length as \code{d}. \cr
If \code{s} is an atomic vector,
it is internally treated as \code{list(s)},
and (as with the previous case) recycled to become the same length as \code{d}. \cr
\cr
Each element of \code{s} when \code{s} is a list, or \code{s} as a whole when \code{s} is atomic,
can be any of the following:
\itemize{
\item \code{NULL} or \code{0L}, which corresponds to a missing index argument.
\item a vector of length 0,
in which case no indices are selected for the operation (i.e. empty selection).
\item a numeric vector of \bold{strictly positive whole numbers}
with indices of the specified dimension to select for the operation.
\item a \bold{complex} vector, as explained in \link{squarebrackets_indx_fundamentals}.
\item a \bold{logical} vector of the same length as the corresponding dimension size,
giving the indices of the specified dimension to select for the operation.
\item a \bold{character} vector giving the \code{dimnames} to select. \cr
If a dimension has multiple indices with the given name,
ALL the corresponding indices will be selected for the operation. \cr \cr
}

Note the following:
\itemize{
\item As stated, \code{d} specifies which index margins are non-missing. \cr
If \code{d} is of length \code{0},
it is taken as "all index margins are missing".
\item The default value for \code{d} is \code{1:}\link{ndim}\code{(x)}. \cr
}

To keep the syntax short,
the user can use the \link{n} function instead of \code{list()} to specify \code{s}. \cr
\cr
\bold{EXAMPLES} \cr
Here are some examples for clarity,
using an atomic array \code{x} of 3 dimensions:
\itemize{
\item \code{ss_x(x, n(1:10, 1:5), c(1, 3))},
extracts the first 10 rows, all columns, and the first 5 layers,
of array \code{x}. \cr
\code{ss_x(x, n(1:10, 0L, 1:5))} is the same.
\item \code{ss_x(x, n(1:10), 2)} \cr
extracts the first 10 columns of array \code{x}.
\item \code{ss_x(x, 1:10)}, \cr
extracts the first 10 rows, columns, and layers of array \code{x}.
\item \code{ss_x(x, 1:10, c(1, 3))}, \cr
extracts the first 10 rows, all columns, and the first 10 layers,
of array \code{x}. \cr
}

I.e.:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
ss_x(x, n(1:10, 1:5), c(1, 3)) # ==> x[1:10, , 1:5, drop = FALSE]

ss_x(x, n(1:10, 0L, 1:5))      # ==> x[1:10, , 1:5, drop = FALSE]

ss_x(x, 1:10, 2)               # ==> x[ , 1:10, , drop = FALSE]

ss_x(x, 1:10)                  # ==> x[1:10, 1:10, 1:10, drop = FALSE]

ss_x(x, 1:10, c(1, 3))         # ==> x[1:10, , 1:10, drop = FALSE]

}\if{html}{\out{</div>}}

For a brief explanation on the relationship between flat indices (\code{i})
and subscripts (\code{s}, \code{d}) in arrays,
see \link{ss2ii}. \cr \cr
}

\section{Argument Pair margin, slice}{

\ifelse{html}{\figure{class-atomic_array-blue.svg}{options: alt='[class: atomic array]'}}{\link[=squarebrackets_indx_args]{class: atomic array}} \cr
\ifelse{html}{\figure{class-recursive_array-blue.svg}{options: alt='[class: recursive array]'}}{\link[=squarebrackets_indx_args]{class: recursive array}} \cr
\ifelse{html}{\figure{class-data.frame-like-blue.svg}{options: alt='[class: data.frame-like]'}}{\link[=squarebrackets_indx_args]{class: data.frame-like}} \cr

Relevant only for the \link{idx} method. \cr
The \code{margin} argument specifies the dimension on which argument \code{slice} is used. \cr
I.e. when \code{margin = 1}, \code{slice} selects rows; \cr
when \code{margin = 2}, \code{slice} selects columns; \cr
etc. \cr
\cr
The \code{slice} argument can be any of the following:
\itemize{
\item \code{NULL} or \code{0L}, which corresponds to a missing index argument.
\item a numeric vector of \bold{strictly positive whole numbers}
with dimension indices to select for the operation.
\item a \bold{complex} vector, as explained in \link{squarebrackets_indx_fundamentals}.
\item a \bold{logical} vector of the same length as the corresponding dimension size,
giving the dimension indices to select for the operation.
\item a \bold{character} vector of index names. \cr
If a dimension has multiple indices with the given name,
ALL the corresponding indices will be selected for the operation. \cr
}

One could also give a vector of length \code{0} for \code{slice}; \cr
Argument \code{slice} is only used in the \link{idx} method ,
and the result of \link{idx} are meant to be used inside the regular \code{[} and \verb{[<-} operators. \cr
Thus the effect of a zero-length index specification depends on the rule-set of
\verb{[.class(x)} and \verb{[<-.class(x)}. \cr \cr
}

\section{Arguments row, col}{

\ifelse{html}{\figure{class-atomic_matrix-blue.svg}{options: alt='[class: atomic matrix]'}}{\link[=squarebrackets_indx_args]{class: atomic matrix}} \cr
\ifelse{html}{\figure{class-recursive_matrix-blue.svg}{options: alt='[class: recursive matrix]'}}{\link[=squarebrackets_indx_args]{class: recursive matrix}} \cr

Specifies rows and columns in a matrix.
The argument \code{row} and \code{col} can each be any of the following:
\itemize{
\item \code{NULL} or \code{0L}, which corresponds to a missing index argument.
\item a vector of length 0,
in which case no indices are selected for the operation (i.e. empty selection).
\item a numeric vector of \bold{strictly positive whole numbers}
with dimension indices to select for the operation.
\item a \bold{complex} vector, as explained in \link{squarebrackets_indx_fundamentals}.
\item a \bold{logical} vector of the same length as the corresponding dimension size,
giving the dimension indices to select for the operation.
\item a \bold{character} vector of index names. \cr
If a dimension has multiple indices with the given name,
ALL the corresponding indices will be selected for the operation. \cr \cr
}
}

\section{Arguments obs, vars}{

\ifelse{html}{\figure{class-data.frame-like-blue.svg}{options: alt='[class: data.frame-like]'}}{\link[=squarebrackets_indx_args]{class: data.frame-like}} \cr
The \code{obs} argument specifies indices for observations (i.e. rows)
in data.frame-like objects. \cr
The \code{vars} argument specifies indices for variables (i.e. columns)
in data.frame-like objects. \cr
The \code{obs} and  \code{vars} arguments are inspired by the \code{subset} and \code{select}
arguments, respectively, of base R's \link[base]{subset}\code{.data.frame} method.
However, the \code{obs} and  \code{vars} arguments do \bold{not} use
non-standard evaluation,
as to keep 'squarebrackets' fully programmatically friendly. \cr
\cr
\bold{The \code{obs} Argument} \cr
The \code{obs} argument can be any of the following:
\itemize{
\item \code{NULL} or \code{0L}, which corresponds to a missing index argument.
\item a vector of length 0,
in which case no indices are selected for the operation (i.e. empty selection).
\item a numeric vector of \bold{strictly positive whole numbers}
with row indices to select for the operation.
\item a \bold{complex} vector, as explained in \link{squarebrackets_indx_fundamentals}.
\item a \bold{logical} vector of the same length as the number of rows,
giving the row indices to select for the operation. \cr
\item a \bold{one-sided formula},
with a single logical expression using the column names of the data.frame,
giving the condition which observation/row indices should be selected for the operation. \cr
}

So to perform an operation on the observations for which holds that \code{height > 2} and \code{sex != "female"},
specify the following formula:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{obs = ~ (height > 2) & (sex != "female")
}\if{html}{\out{</div>}}

If the formula is linked to an environment,
any variables not found in the data set will be searched from the environment. \cr
\cr

\bold{The \code{vars} Argument} \cr
The \code{vars} argument can be any of the following
\itemize{
\item \code{NULL} (default) or \code{0L}, corresponds to a missing argument.
\item a vector of length 0,
in which case no indices are selected for the operation (i.e. empty selection).
\item a numeric vector of \bold{strictly positive whole numbers}
with column indices to select for the operation.
\item a \bold{complex} vector, as explained in \link{squarebrackets_indx_fundamentals}.
\item a \bold{logical} vector of the same length as the number of columns,
giving the column indices to select for the operation.
\item a \bold{character} vector giving the \code{colnames} to select. \cr
Note that 'squarebrackets' assumes data.frame-like objects have unique column names.
\item a \bold{function} that returns a logical vector,
giving the column indices to select for the operation. \cr
For example, to select all numeric variables,
specify \code{vars = is.numeric}.
\item a \bold{two-sided formula}, where each side consists of a single term,
giving a range of names to select. \cr
For example,
to select all variables between and including the variables "height" and "weight",
specify the following: \cr
\code{vars =  heigth ~ weight}. \cr \cr
}

\bold{EXAMPLE} \cr

So using the \verb{obs, vars} arguments corresponds to doing something like the following:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{ sbt_x(x, obs, vars) # ==> subset(x, ...obs..., ...vars...)
 
}\if{html}{\out{</div>}}
}

\section{Argument inv}{

\ifelse{html}{\figure{all_classes-blue.svg}{options: alt='[all classes]'}}{\link[=squarebrackets_indx_args]{all classes}} \cr

Relevant for the \verb{_mod},\verb{_set},
and \link{idx} methods. \cr
By default, \code{inv = FALSE}, which translates the indices like normally. \cr
When \code{inv = TRUE}, the inverse of the indices is taken. \cr
Consider, for example, an atomic matrix \code{x}; \cr
using \code{ss_mod(x, 1:2, 2L, tf = tf)}
corresponds to something like the following:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
x[, 1:2] <- tf(x[, 1:2])
x

}\if{html}{\out{</div>}}

and using \code{ss_mod(x, vars = 1:2, inv = TRUE, tf = tf)}
corresponds to something like the following:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
x[, -1:-2] <- tf(x[, -1:-2])
x

}\if{html}{\out{</div>}}

\bold{NOTE} \cr
The order in which the user gives indices when \code{inv = TRUE} generally does not matter. \cr
The order of the indices as they appear in the original object \code{x} is maintained,
just like in base 'R'. \cr
Therefore, when replacing multiple values where the order of the replacement matters,
it is better to keep \code{inv = FALSE}, which is the default. \cr
For replacement with a single value or with a transformation function,
\code{inv = TRUE} can be used without considering the ordering. \cr \cr
}

\section{All Missing Indices}{

\code{NULL} and \code{0L} in the indexing arguments correspond to a missing argument. \cr
For \verb{s, d}, specifying \code{d} of length 0 also corresponds to all subscripts being missing. \cr
Thus, for \bold{both} the \verb{_x} and \verb{_wo} methods,
using missing indexing arguments for all indexing arguments corresponds to something like the following:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
x[]

}\if{html}{\out{</div>}}

Similarly, for the \verb{_mod} and \verb{_set} methods,
using missing or \code{NULL} indexing arguments corresponds to something like the following:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
x[] <- rp # for replacement
x[] <- tf(x) # for transformation

}\if{html}{\out{</div>}}

The above is true \bold{even if} \code{inv = TRUE}. \cr \cr
}

\section{Drop}{

Sub-setting with the generic methods from the 'squarebrackets' R-package using dimensional arguments
(\verb{s, d, row, col obs, vars})
always use \code{drop = FALSE}. \cr
To drop potentially redundant (i.e. single level) dimensions,
use the \link[base]{drop} function, like so:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{ ss_x(x, s, d) |> drop() # ==> x[..., drop = TRUE]
 
}\if{html}{\out{</div>}}
}

\references{
Plate T, Heiberger R (2016). \emph{abind: Combine Multidimensional Arrays}.
R package version 1.4-5, \url{https://CRAN.R-project.org/package=abind}.
}
