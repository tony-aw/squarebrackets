% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aaa04_squarebrackets_indx_args.R
\name{aaa04_squarebrackets_indx_args}
\alias{aaa04_squarebrackets_indx_args}
\alias{squarebrackets_indx_args}
\title{Index Arguments in the Generic Sub-setting Methods}
\description{
There are several types of arguments that can be used
in the generic methods of 'squarebrackets' to specify the indices to perform operations on:
\itemize{
\item \verb{i, use}: to specify interior (i.e. dimensionless) indices.
\item \verb{s, use}: to specify subscripts of arbitrary dimensions
in arrays.
\item \verb{row, col, use}:
to specify rows and columns in tabular objects (matrices and data.frames). \cr
\item \verb{slice, use}: to specify indices of one particular dimension
(for arrays and data.frame-like objects). \cr
Currently only used in the \verb{_icom} methods. \cr \cr
}

For the fundamentals of indexing in 'squarebrackets',
see \link{squarebrackets_indx_fundamentals}. \cr
In this help page \code{x} refers to the object on which subset operations are performed. \cr
\cr
\cr
}
\section{Argument Pair \verb{i, use}}{

\ifelse{html}{\figure{class-atomic_vector-blue.svg}{options: alt='[class: atomic vector]'}}{\link[=squarebrackets_indx_args]{class: atomic vector}} \cr
\ifelse{html}{\figure{class-derived_atomic_vector-blue.svg}{options: alt='[class: derived atomic vector]'}}{\link[=squarebrackets_indx_args]{class: derived atomic vector}} \cr
\ifelse{html}{\figure{class-recursive_vector-blue.svg}{options: alt='[class: recursive vector]'}}{\link[=squarebrackets_indx_args]{class: recursive vector}} \cr
\ifelse{html}{\figure{class-atomic_array-blue.svg}{options: alt='[class: atomic array]'}}{\link[=squarebrackets_indx_args]{class: atomic array}} \cr
\ifelse{html}{\figure{class-recursive_array-blue.svg}{options: alt='[class: recursive array]'}}{\link[=squarebrackets_indx_args]{class: recursive array}} \cr

\code{i} specifies the interior (or flat) indices. \cr
\code{use} can be \code{1} or \code{-1}: \cr
\code{1} means the specified indices in \code{i} are to be used for the sub-set operation. \cr
\code{-1L} means \strong{all} indices \strong{except} the indices in \code{i} are to be used for the sub-set operation. \cr \cr

Any of the following can be specified for argument \code{i}:
\itemize{
\item \code{NULL} or \code{0L}, corresponds to missing argument.
\item a vector of length 0,
in which case no indices are selected for the operation
(i.e. empty selection).
\item a numeric vector of \bold{strictly positive whole numbers} giving indices.
\item a \bold{logical vector},
of the same length as \code{x},
giving the indices to select for the operation.
\item a \bold{character} vector of index names. \cr
If an object has multiple indices with the given name,
ALL the corresponding indices will be selected for the operation.
\item a \bold{function} that takes as input \code{x},
and returns a logical vector,
giving the element indices to select for the operation. \cr
For atomic objects, \code{i} is interpreted as \code{i(x)}. \cr
For recursive objects, \code{i} is interpreted as \code{lapply(x, i)}.
\item a formula; see \link{keywords}. \cr \cr
}

Using the \code{i} arguments corresponds to doing something like the following:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{ ii_x(x, i = i) # ==> x[i]   # if `x` is atomic
 ii_x(x, i = i) # ==> x[i]  # if `x` is recursive
 
}\if{html}{\out{</div>}}

If \code{i} is a function, it corresponds to the following:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{ ii_x(x, i = i) # ==> x[i(x)] # if `x` is atomic
 ii_x(x, i = i) # ==> x[lapply(x, i)] # if `x` is recursive
 
}\if{html}{\out{</div>}}
}

\section{Argument Pair \verb{s, use}}{

\ifelse{html}{\figure{class-atomic_array-blue.svg}{options: alt='[class: atomic array]'}}{\link[=squarebrackets_indx_args]{class: atomic array}} \cr
\ifelse{html}{\figure{class-recursive_array-blue.svg}{options: alt='[class: recursive array]'}}{\link[=squarebrackets_indx_args]{class: recursive array}} \cr
The \verb{s, use} argument pair, inspired by the
\code{abind::}\link[abind]{asub} function from the 'abind' package,
is the primary indexing argument for sub-set operations on dimensional objects. \cr
\cr
The \code{s} argument specifies the
\bold{subscripts}
(i.e. dimensional indices). \cr
The \strong{absolute value} of \code{use} argument gives the dimensions for which the
\code{s} holds (i.e. \code{use} specifies the "non-missing" margins),
and the sign (+ or -) of \code{use} specifies if the indices are to be selected or excluded,
similar to the \code{use} argument used in combination with \code{i} (see previous section). \cr
\cr
Specifically, the \code{use} argument can be any of the following:
\itemize{
\item a vector of length \code{0}, which will be interpreted as "all subscripts are missing".
\item an integer vector;
\item the real scalar \code{Inf}, which will be interpreted as \code{1:dim(x)};
\item the real scalar \code{-Inf}, which will be interpreted as \code{-1:-ndim(x)}. \cr
}

\code{use} is not allowed to have any duplicate values,
nor is it allowed to include zero (\code{0})\code{.} \cr
The default value for \code{use} is \bold{lazy evaluated} \code{1:}\link{ndim}\code{(x)}. \cr

\code{s} must be an atomic vector, a list of length 1, or a list of the same length as \code{use}. \cr
If \code{s} is a list of length 1,
it is internally recycled to become the same length as \code{use}. \cr
If \code{s} is an atomic vector,
it is internally treated as \code{list(s)},
and (as with the previous case) recycled to become the same length as \code{use}. \cr
\cr
Each element of \code{s} when \code{s} is a list, or \code{s} as a whole when \code{s} is atomic,
can be any of the following:
\itemize{
\item \code{NULL} or \code{0L}, which corresponds to a missing index argument.
\item a vector of length 0,
in which case no indices are selected for the operation (i.e. empty selection).
\item A formula, with optional keywords, giving an expression to evaluate. \cr
See \link{keywords}. \cr
\item a numeric vector of \bold{strictly positive whole numbers}
with indices of the specified dimension to select for the operation.
\item a \bold{logical} vector of the same length as the corresponding dimension size,
giving the indices of the specified dimension to select for the operation.
\item a \bold{character} vector giving the \code{dimnames} to select. \cr
If a dimension has multiple indices with the given name,
ALL the corresponding indices will be selected for the operation.
\item a formula; see \link{keywords}. \cr \cr
}

To keep the syntax short,
the user can use the \link{n} function instead of \code{list()} to specify \code{s}. \cr
\cr
\bold{EXAMPLES} \cr
Here are some examples for clarity,
using an atomic array \code{x} of 3 dimensions:
\itemize{
\item \code{ss_x(x, n(1:10, 1:5), c(1, -3))},
extracts the first 10 rows, extracts all columns, and \strong{removes} the first 5 layers,
of array \code{x}. \cr
\code{ss_x(x, n(1:10, 0L, 1:5))} is the same.
\item \code{ss_x(x, n(1:10), 2)} \cr
extracts the first 10 columns of array \code{x}.
\item \code{ss_x(x, 1:10)}, \cr
extracts the first 10 rows, columns, and layers of array \code{x}.
\item \code{ss_x(x, 1:10, c(1, 3))}, \cr
extracts the first 10 rows, all columns, and the first 10 layers,
of array \code{x}. \cr
}

I.e.:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
ss_x(x, n(1:10, 1:5), c(1, -3)) # ==> x[1:10, , -1:-5, drop = FALSE]

ss_x(x, n(1:10, 0L, 1:5))      # ==> x[1:10, , 1:5, drop = FALSE]

ss_x(x, 1:10, 2)               # ==> x[ , 1:10, , drop = FALSE]

ss_x(x, 1:10)                  # ==> x[1:10, 1:10, 1:10, drop = FALSE]

ss_x(x, 1:10, c(1, 3))         # ==> x[1:10, , 1:10, drop = FALSE]

}\if{html}{\out{</div>}}

For a brief explanation on the relationship between flat indices (\code{i})
and subscripts (\code{s}, \code{use}) in arrays,
see \link{ss2ii}. \cr
\cr
}

\section{Arguments set \verb{row, col, use}}{

\ifelse{html}{\figure{class-atomic_matrix-blue.svg}{options: alt='[class: atomic matrix]'}}{\link[=squarebrackets_indx_args]{class: atomic matrix}} \cr
\ifelse{html}{\figure{class-recursive_matrix-blue.svg}{options: alt='[class: recursive matrix]'}}{\link[=squarebrackets_indx_args]{class: recursive matrix}} \cr

Specifies rows and columns in a matrix.
The argument \code{row} and \code{col} can each be any of the following:
\itemize{
\item \code{NULL} or \code{0L}, which corresponds to a missing index argument.
\item a vector of length 0,
in which case no indices are selected for the operation (i.e. empty selection).
\item a numeric vector of \bold{strictly positive whole numbers}
with dimension indices to select for the operation.
\item a \bold{logical} vector of the same length as the corresponding dimension size,
giving the dimension indices to select for the operation.
\item a \bold{character} vector of index names. \cr
If a dimension has multiple indices with the given name,
ALL the corresponding indices will be selected for the operation.
\item a formula; see \link{keywords}. \cr
}

For data.frames, \code{col} can also be a function. \cr
\cr
\code{use} is set to \code{1:2} by default. \cr
If \code{use} is \code{c(-1, 2)} or \code{-1}, the row indices will be inverted
(i.e. select all rows \strong{except} those specified in \code{row}). \cr
If \code{use} is \code{c(1, -2)} or \code{-2}, the column indices will be inverted
(i.e. select all columns \strong{except} those specified in \code{col}). \cr
If \code{use} is \code{-1:-2}, both the row- and column- indices will be inverted. \cr
The order of \code{use} is irrelevant; i.e. \code{c(-1, 2)} is the same as \code{c(2, -1)}. \cr
\cr
}

\section{Argument Pair \verb{slice, use}}{

\ifelse{html}{\figure{class-atomic_array-blue.svg}{options: alt='[class: atomic array]'}}{\link[=squarebrackets_indx_args]{class: atomic array}} \cr
\ifelse{html}{\figure{class-recursive_array-blue.svg}{options: alt='[class: recursive array]'}}{\link[=squarebrackets_indx_args]{class: recursive array}} \cr
\ifelse{html}{\figure{class-data.frame-like-blue.svg}{options: alt='[class: data.frame-like]'}}{\link[=squarebrackets_indx_args]{class: data.frame-like}} \cr

Relevant only for the \verb{_icom} methods. \cr
The absolute value of \code{use} specifies the dimension on which argument \code{slice} is used. \cr
The sign of \code{use}, just like in the previous argument sets, specifies whether to invert the indices or not. \cr
I.e. if \code{use = 1} , \code{slice} specifies which rows to select; \cr
if \code{use = -2}, \code{slice} specifies which columns to \strong{not} select; \cr
etc. \cr
\cr
The \code{slice} argument can be any of the following:
\itemize{
\item \code{NULL} or \code{0L}, which corresponds to a missing index argument.
\item a numeric vector of \bold{strictly positive whole numbers}
with dimension indices to select for the operation.
\item a \bold{logical} vector of the same length as the corresponding dimension size,
giving the dimension indices to select for the operation.
\item a \bold{character} vector of index names. \cr
If a dimension has multiple indices with the given name,
ALL the corresponding indices will be selected for the operation. \cr
\item a formula; see \link{keywords}.
}

One could also give a vector of length \code{0} for \code{slice}; \cr
Argument \code{slice} is only used in the \verb{_icom} methods,
and the results are meant to be used inside the regular \code{[} and \verb{[<-} operators. \cr
Thus the effect of a zero-length index specification depends on the rule-set of
\verb{[.class(x)} and \verb{[<-.class(x)}. \cr \cr
}

\section{All Missing Indices}{

\code{NULL} and \code{0L} in the indexing arguments correspond to a missing argument. \cr
For \verb{s, use}, specifying \code{use} of length 0 also corresponds to all subscripts being missing. \cr
Thus, for the \verb{_x} methods,
using missing indexing arguments for all indexing arguments corresponds to something like the following:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
x[]

}\if{html}{\out{</div>}}

Similarly, for the \verb{_mod} and \verb{_set} methods,
using missing or \code{NULL} indexing arguments corresponds to something like the following:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
x[] <- rp # for replacement
x[] <- tf(x) # for transformation

}\if{html}{\out{</div>}}

The above is true \bold{even if} \code{sign(use) < 0}. \cr \cr
}

\section{Drop}{

Sub-setting with the generic methods from the 'squarebrackets' R-package using dimensional arguments
(\verb{s, row, col, use})
always use \code{drop = FALSE}. \cr
To drop potentially redundant (i.e. single level) dimensions,
use the \link[base]{drop} function, like so:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{ ss_x(x, s, use) |> drop() # ==> x[..., drop = TRUE]
 
}\if{html}{\out{</div>}}
}

\references{
Plate T, Heiberger R (2016). \emph{abind: Combine Multidimensional Arrays}.
R package version 1.4-5, \url{https://CRAN.R-project.org/package=abind}.
}
