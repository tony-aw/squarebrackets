% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/idx1.R
\name{idx1}
\alias{idx1}
\alias{idx1.default}
\alias{idx1.matrix}
\alias{idx1.array}
\title{Compute Flat Integer Indices (for Copy-On-Modify Substitution)}
\usage{
idx1(x, ...)

\method{idx1}{default}(
  x,
  i,
  inv = FALSE,
  ...,
  chkdup = getOption("squarebrackets.chkdup", FALSE)
)

\method{idx1}{matrix}(
  x,
  row = NULL,
  col = NULL,
  i = NULL,
  inv = FALSE,
  ...,
  chkdup = getOption("squarebrackets.chkdup", FALSE)
)

\method{idx1}{array}(
  x,
  idx = NULL,
  dims = NULL,
  rcl = NULL,
  i = NULL,
  inv = FALSE,
  ...,
  chkdup = getOption("squarebrackets.chkdup", FALSE)
)
}
\arguments{
\item{x}{vector, matrix, or array; both atomic and recursive objects are supported.}

\item{...}{further arguments passed to or from other methods.}

\item{i, row, col, idx, dims, rcl, inv}{See \link{squarebrackets_indx_args}. \cr
Duplicates are not allowed.}

\item{chkdup}{see \link{squarebrackets_duplicates}. \cr
\ifelse{html}{\figure{for_performance-set_to_FALSE-red.svg}{options: alt='[for performance: set to FALSE]'}}{\link[=squarebrackets_help]{for performance: set to FALSE}} \cr}
}
\value{
A vector of flat/linear integer indices.
}
\description{
The \code{idx1()} method
translates the given indices/subscripts to flat/linear integer indices. \cr
\cr
This function can be used inside the regular square brackets operators
(without commas; as stated, these are linear indices). \cr
For example like so:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
x[idx1(x, ...)] <- value
# OR
my_indices <- idx1(x, ...)
x[my_indices] <- value

}\if{html}{\out{</div>}}

thus allowing the user to benefit from the convenient index translations from 'squarebrackets',
whilst still using R's default copy-on-modification semantics
(instead of the deep copy semantics and
\link[=squarebrackets_PassByReference]{pass-by-reference semantics}
provided by 'squarebrackets'). \cr
\cr
\code{idx1()} supports any \code{x} that is a vector, matrix, or array,
regardless if \code{x} is atomic or recursive. \cr
\cr
For data.frames, see \code{collapse::}\link[collapse]{fsubset}. \cr \cr
}
\examples{

# atomic ====

x <- 1:10
x[idx1(x, \(x)x>5)] <- -5
print(x)

x <- matrix(1:20, ncol = 4)
colnames(x) <- letters[1:4]
x[idx1(x, 1:2, c("a", "b"))] <- -5
print(x)

x <- array(1:27, dim = c(3,3,3))
x[idx1(x, n(1:2, 1:2), c(1,3))] <- -10
print(x)

x <- array(1:27, dim = c(3,3,3))
x[idx1(x, rcl = n(1:2, 1:2, NULL))] <- -10
print(x)


################################################################################


# recursive ====

x <- as.list(1:10)
x[idx1(x, \(x)x>5)] <- -5
print(x)

x <- matrix(as.list(1:20), ncol = 4)
colnames(x) <- letters[1:4]
x[idx1(x, 1:2, c("a", "b"))] <- -5
print(x)

x <- array(as.list(1:27), dim = c(3,3,3))
x[idx1(x, n(1:2, 1:2), c(1,3))] <- -10
print(x)


}
