% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/idx1.R
\name{idx1_dim}
\alias{idx1_dim}
\alias{idx1}
\alias{idx1.default}
\alias{idx1.matrix}
\alias{idx1.array}
\title{Compute Flat Integer Indices (for Copy-On-Modify Substitution)}
\usage{
idx1_dim(
  x,
  slice,
  margin,
  inv = FALSE,
  chkdup = getOption("squarebrackets.chkdup", FALSE)
)

idx1(x, ...)

\method{idx1}{default}(
  x,
  i,
  inv = FALSE,
  ...,
  chkdup = getOption("squarebrackets.chkdup", FALSE)
)

\method{idx1}{matrix}(
  x,
  row = NULL,
  col = NULL,
  i = NULL,
  inv = FALSE,
  ...,
  chkdup = getOption("squarebrackets.chkdup", FALSE)
)

\method{idx1}{array}(
  x,
  idx = NULL,
  dims = NULL,
  rcl = NULL,
  i = NULL,
  inv = FALSE,
  ...,
  chkdup = getOption("squarebrackets.chkdup", FALSE)
)
}
\arguments{
\item{x}{vector, matrix, or array; both atomic and recursive objects are supported.}

\item{slice}{works the same as arguments \code{row} and \code{col}.}

\item{margin}{a single integer, specifying the dimension for \code{slice}.}

\item{chkdup}{see \link{squarebrackets_duplicates}. \cr
\ifelse{html}{\figure{for_performance-set_to_FALSE-red.svg}{options: alt='[for performance: set to FALSE]'}}{\link[=squarebrackets_help]{for performance: set to FALSE}} \cr}

\item{...}{further arguments passed to or from other methods.}

\item{i, row, col, idx, dims, rcl, inv}{See \link{squarebrackets_indx_args}. \cr
Duplicates are not allowed.}
}
\value{
A vector of flat/linear integer indices.
}
\description{
The \code{idx1()} method
translates the given indices/subscripts to flat/linear integer indices. \cr
\cr
This function can be used inside the regular square brackets operators
(without commas; as stated, these are linear indices). \cr
For example like so:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
my_indices <- idx1(x, ...)
x[my_indices] <- value

}\if{html}{\out{</div>}}

thus allowing the user to benefit from the convenient index translations from 'squarebrackets',
whilst still using R's default copy-on-modification semantics
(instead of the deep copy semantics and
\link[=squarebrackets_PassByReference]{pass-by-reference semantics}
provided by 'squarebrackets'). \cr
\cr
\code{idx1()} supports any \code{x} that is a vector, matrix, or array,
regardless if \code{x} is atomic or recursive. \cr
\cr
\code{idx1_dim()} translates indices for a specific dimension
(handy for data.frames). \cr
Use it for example like so:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
rows <- idx1_dim(x, 1:10, 1)
cols <- idx1_dim(x, c("b", "a"), 2)
x[rows, cols] <- value

}\if{html}{\out{</div>}}
}
\examples{

# atomic ====

x <- 1:10
x[idx1(x, \(x)x>5)] <- -5
print(x)

x <- matrix(1:20, ncol = 4)
colnames(x) <- letters[1:4]
x[idx1(x, 1:2, c("a", "b"))] <- -5
print(x)

x <- array(1:27, dim = c(3,3,3))
x[idx1(x, n(1:2, 1:2), c(1,3))] <- -10
print(x)

x <- array(1:27, dim = c(3,3,3))
x[idx1(x, rcl = n(1:2, 1:2, NULL))] <- -10
print(x)


################################################################################


# recursive ====

x <- as.list(1:10)
x[idx1(x, \(x)x>5)] <- -5
print(x)

x <- matrix(as.list(1:20), ncol = 4)
colnames(x) <- letters[1:4]
x[idx1(x, 1:2, c("a", "b"))] <- -5
print(x)

x <- array(as.list(1:27), dim = c(3,3,3))
x[idx1(x, n(1:2, 1:2), c(1,3))] <- -10
print(x)


x <- data.frame(
  a = sample(c(TRUE, FALSE, NA), 10, TRUE),
  b = 1:10,
  c = rnorm(10),
  d = letters[1:10],
  e = factor(letters[11:20])
)
rows <- idx1_dim(x, 1:5, 1, inv = TRUE)
cols <- idx1_dim(x, c("b", "a"), 2)
x[rows, cols] <- NA
print(x)
}
