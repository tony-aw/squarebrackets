% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generic_idx.R
\name{idx}
\alias{idx}
\alias{idx.default}
\alias{idx.array}
\alias{idx.data.frame}
\title{Convert/Translate Indices (for Copy-On-Modify Substitution)}
\usage{
idx(x, ...)

\method{idx}{default}(x, i, inv = FALSE, ..., chkdup = getOption("squarebrackets.chkdup", FALSE))

\method{idx}{array}(
  x,
  idx = NULL,
  dims = NULL,
  slice = NULL,
  margin = NULL,
  i = NULL,
  inv = FALSE,
  ...,
  chkdup = getOption("squarebrackets.chkdup", FALSE)
)

\method{idx}{data.frame}(
  x,
  slice,
  margin,
  inv = FALSE,
  ...,
  chkdup = getOption("squarebrackets.chkdup", FALSE)
)
}
\arguments{
\item{x}{vector, matrix, array, or data.frame; both atomic and recursive objects are supported.}

\item{...}{further arguments passed to or from other methods.}

\item{i, idx, dims, inv}{See \link{squarebrackets_indx_args}. \cr
Duplicates are not allowed.}

\item{chkdup}{see \link{squarebrackets_duplicates}. \cr
\ifelse{html}{\figure{for_performance-set_to_FALSE-red.svg}{options: alt='[for performance: set to FALSE]'}}{\link[=squarebrackets_help]{for performance: set to FALSE}} \cr}

\item{slice}{see arguments \code{row} and \code{col} in \link{squarebrackets_indx_args}.}

\item{margin}{a single integer, specifying the dimension for \code{slice}.}
}
\value{
A vector of strictly positive integer indices.
}
\description{
The \code{idx()} method converts indices. \cr
The type of output depends on the type of input index arguments given:
\itemize{
\item \code{idx(x, i = i, ...)}
converts linear indices to a strictly positive integer vector of linear indices.
\item \code{idx(x, idx = idx, dims = dims, ...)}
converts dimensional indices to a strictly positive integer vector of linear indices.
\item \code{idx(x, slice = slice, margin = margin, ...)}
converts indices of one dimension to a strictly positive integer vector of
indices for that specific dimension.
}

Vectors (both atomic and recursive) only have index argument \code{i}. \cr
Data.frame-like objects only have the \verb{slice, margin} index argument pair. \cr
Arrays (both atomic and recursive) have the \verb{idx, dims} index argument pair,
as well as the arguments \code{i} and \verb{slice, margin}. \cr
\cr
The result of the \code{idx()} method
can be used inside the regular square-brackets operators. \cr
For example like so:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{x <- array(...)
my_indices <- idx(x, idx, dims)
x[my_indices] <- value

y <- data.frame(...)
rows <- idx(y, 1:10, 1, inv = TRUE)
cols <- idx(y, c("a", "b"), 2)
y[rows, cols] <- value
}\if{html}{\out{</div>}}

thus allowing the user to benefit from the convenient index translations from 'squarebrackets',
whilst still using R's default copy-on-modification semantics
(instead of the deep copy semantics and
\link[=squarebrackets_PassByReference]{pass-by-reference semantics}
provided by 'squarebrackets'). \cr
}
\examples{

# atomic ====

x <- 1:10
x[idx(x, \(x)x>5)] <- -5
print(x)

x <- array(1:27, dim = c(3,3,3))
x[idx(x, n(1:2, 1:2), c(1,3))] <- -10
print(x)


################################################################################


# recursive ====

x <- as.list(1:10)
x[idx(x, \(x)x>5)] <- -5
print(x)

x <- array(as.list(1:27), dim = c(3,3,3))
x[idx(x, n(1:2, 1:2), c(1,3))] <- -10
print(x)


x <- data.frame(
  a = sample(c(TRUE, FALSE, NA), 10, TRUE),
  b = 1:10,
  c = rnorm(10),
  d = letters[1:10],
  e = factor(letters[11:20])
)
rows <- idx(x, 1:5, 1, inv = TRUE)
cols <- idx(x, c("b", "a"), 2)
x[rows, cols] <- NA
print(x)
}
