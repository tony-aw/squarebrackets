% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dt.R
\name{dt}
\alias{dt}
\alias{dt_aggregate}
\alias{dt_setcoe}
\alias{dt_setrm}
\alias{dt_setadd}
\alias{dt_setreorder}
\title{Functional Forms of data.table Operations}
\usage{
dt_aggregate(x, SDcols = NULL, f, by, order_by = FALSE)

dt_setcoe(
  x,
  vars = NULL,
  inv = FALSE,
  v,
  chkdup = getOption("squarebrackets.chkdup", FALSE)
)

dt_setrm(
  x,
  vars = NULL,
  inv = FALSE,
  chkdup = getOption("squarebrackets.chkdup", FALSE)
)

dt_setadd(x, new)

dt_setreorder(x, roworder = NULL, varorder = NULL)
}
\arguments{
\item{x}{a \code{data.table} or \code{tidytable}.}

\item{SDcols}{atomic vector,
giving the columns to which the aggregation function \code{f()} is to be applied on.}

\item{f}{the aggregation function}

\item{by}{atomic vector,
giving the grouping columns.}

\item{order_by}{Boolean,
indicating if the aggregated result should be ordered by the columns specified in \code{by}.}

\item{vars, inv}{see \link{squarebrackets_indx_args}. \cr
Duplicates are not allowed.}

\item{v}{the coercive transformation function}

\item{chkdup}{see \link{squarebrackets_options}. \cr
\ifelse{html}{\figure{for_performance-set_to_FALSE-red.svg}{options: alt='[for performance: set to FALSE]'}}{\link[=squarebrackets_help]{for performance: set to FALSE}} \cr}

\item{new}{a data.frame-like object. \cr
It must have column names that do not already exist in \code{x}.}

\item{roworder}{a integer vector of the same length as \code{nrow(x)},
giving the order in which the rows are to be re-order.
Internally,
this numeric vector will be turned into an order using \link[base]{order},
thus ensuring it is a strict permutation of \code{1:nrow(x)}.}

\item{varorder}{integer or character vector of the same length as \code{ncol(x)},
giving the new column order. \cr
See \code{data.table::}\link[data.table]{setcolorder}.}
}
\value{
For \code{dt_aggregate()}: \cr
The aggregated \code{data.table} object. \cr
\cr
For the rest of the functions: \cr
Returns: VOID. These functions modify the object by reference. \cr
Do not use assignments like \code{x <- dt_setcoe(x, ...)}. \cr
Since these functions return void, you'll just get \code{NULL}. \cr \cr
}
\description{
Functional forms of special data.table operations. \cr
These functions do not use Non-Standard Evaluation. \cr
These functions also benefit from the security measures that
'squarebrackets' implements for
the \link[=squarebrackets_PassByReference]{pass-by-reference semantics}. \cr
\itemize{
\item \code{dt_aggregate()}
aggregates a data.table or tidytable, and returns the aggregated copy.
\item \code{dt_setcoe()}
coercively transforms columns of a data.table or tidytable
using \link[=squarebrackets_PassByReference]{pass-by-reference semantics}.
\item \code{dt_setrm()}
removes columns of a data.table or tidytable
using \link[=squarebrackets_PassByReference]{pass-by-reference semantics}.
\item \code{dt_setadd(x, new)}
adds the columns from data.table/tidytable \code{new} to data.table/tidytable \code{x},
thereby modifying \code{x}
using \link[=squarebrackets_PassByReference]{pass-by-reference semantics}.
\item \code{dt_setreorder()}
reorders the rows and/or variables of a \code{data.table}
using \link[=squarebrackets_PassByReference]{pass-by-reference semantics}. \cr \cr
}
}
\details{
\code{dt_setreorder(x, roworder = roworder)}
internally creates a new column to reorder the data.table by,
and then removes the new column. \cr
The column name is randomized,
and extra care is given to ensure it does not overwrite any existing columns. \cr \cr
}
\examples{
# dt_aggregate on sf-data.table ====

if(requireNamespace("sf")) {
  x <- sf::st_read(system.file("shape/nc.shp", package = "sf"))
  x <- data.table::as.data.table(x)
  
  x$region <- ifelse(x$CNTY_ID <= 2000, 'high', 'low')
  d.aggr <- dt_aggregate(
    x, SDcols = "geometry", f= sf::st_union, by = "region"
  )
  
  head(d.aggr)
}



#############################################################################


# dt_setcoe ====

obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]))
str(obj) # notice that columns "a" and "c" are INTEGER (`int`)
ss2_set(
  obj, obs = ~ (a >= 2) & (c <= 17), vars = is.numeric,
  tf = sqrt # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost
)
str(obj)
obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]))
dt_setcoe(obj, vars = is.numeric, v = as.numeric) # integers are now numeric
str(obj)
ss2_set(obj,
  obs = ~ (a >= 2) & (c <= 17), vars = is.numeric,
  tf = sqrt # SAFE: coercion performed; so no warnings
) 
str(obj)


#############################################################################


# dt_setrm ====

obj <- data.table::data.table(
  a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])
)
str(obj)
dt_setrm(obj, vars = 1)
str(obj)

obj <- data.table::data.table(
  a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])
)
str(obj)
dt_setrm(obj, vars = is.numeric)
str(obj)


#############################################################################


# dt_setadd ====

obj <- data.table::data.table(
  a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])
)
new <- data.table::data.table(
  e = sample(c(TRUE, FALSE), 10, TRUE),
  f = sample(c(TRUE, FALSE), 10, TRUE)
)
dt_setadd(obj, new)
print(obj)



#############################################################################


# dt_setreorder====

n <- 1e4
obj <- data.table::data.table(
  a = 1L:n, b = n:1L, c = as.double(1:n), d = as.double(n:1)
)
dt_setreorder(obj, roworder = n:1)
head(obj)
dt_setreorder(obj, varorder = ncol(obj):1)
head(obj)

}
