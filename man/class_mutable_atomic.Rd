% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/class_mutable_atomic.R
\name{class_mutable_atomic}
\alias{class_mutable_atomic}
\alias{mutable_atomic}
\alias{as.mutable_atomic}
\alias{as.mutable_atomic.default}
\alias{is.mutable_atomic}
\alias{couldb.mutable_atomic}
\alias{typecast.mutable_atomic}
\alias{c.mutable_atomic}
\alias{[.mutable_atomic}
\alias{[<-.mutable_atomic}
\alias{format.mutable_atomic}
\alias{print.mutable_atomic}
\title{Mutable Atomic Classes}
\usage{
mutable_atomic(data, names = NULL, dim = NULL, dimnames = NULL)

as.mutable_atomic(x, ...)

\method{as.mutable_atomic}{default}(x, ...)

is.mutable_atomic(x)

couldb.mutable_atomic(x)

typecast.mutable_atomic(x, type = typeof(x), dims = dim(x))

\method{c}{mutable_atomic}(..., use.names = TRUE)

\method{[}{mutable_atomic}(x, ...)

\method{[}{mutable_atomic}(x, ...) <- value

\method{format}{mutable_atomic}(x, ...)

\method{print}{mutable_atomic}(x, ...)
}
\arguments{
\item{data}{atomic vector giving data to fill the \code{mutable_atomic} object.}

\item{names, dim, dimnames}{see \link[stats]{setNames} and \link[base]{array}.}

\item{x}{an atomic object.}

\item{...}{method dependent arguments.}

\item{type}{a string giving the type; see \link[base]{typeof}.}

\item{dims}{integer vector, giving the new dimensions.}

\item{use.names}{Boolean, indicating if \link[base]{names} should be preserved.}

\item{value}{see \link[base]{Extract}.}
}
\value{
For \code{mutable_atomic()}, \code{as.mutable_atomic()}, \code{typecast.mutable_atomic()}: \cr
Returns a \code{mutable_atomic} object. \cr
\cr
For \code{is.mutable_atomic()}: \cr
Returns \code{TRUE} if the object is \code{mutable_atomic},
and returns \code{FALSE} otherwise. \cr
\cr
For \code{couldb.mutable_atomic()}: \cr
Returns \code{TRUE} if the object is one of the following types: \cr
\link{logical}, \link{integer}, \link{double}, \link{character}, \link{complex}, \link{raw}. \cr
\code{bit64::}\link[bit64]{integer64} type is also supported,
since it is internally defined as \link{double}. \cr
Returns \code{FALSE} otherwise. \cr \cr
}
\description{
The \code{mutable_atomic} class is a mutable version of atomic classes. \cr
It works exactly the same in all aspects as regular atomic classes,
with only one real difference: \cr
The 'squarebrackets' methods and functions that perform modification by reference
(basically all methods and functions with "set" in the name)
accept \code{mutable_atomic},
but do not accept regular \code{atomic}. \cr
See \link{squarebrackets_PassByReference} for details. \cr
\cr
Like \code{data.table}, \verb{[<-} performs R's default copy-on-modification semantics. \cr
For modification  by reference, use \link{sb_set}. \cr
\cr
Exposed functions (beside the S3 methods):
\itemize{
\item \code{mutable_atomic()}: create a \code{mutable_atomic} object from given data.
\item \code{couldb.mutable_atomic()}: checks if an object could become \code{mutable_atomic}. \cr
An objects can become \code{mutable_atomic} if it is one of the following types: \cr
\link{logical}, \link{integer}, \link{double}, \link{character}, \link{complex}, \link{raw}. \cr
\code{bit64::}\link[bit64]{integer64} type is also supported,
since it is internally defined as \link{double}. \cr
\item \code{typecast.mutable_atomic()} type-casts and possibly reshapes a (mutable) atomic object,
and returns a \code{mutable_atomic} object. \cr
Does not preserve dimension names if dimensions are changed. \cr \cr
}
}
\section{Warning}{

Always use
the exported functions given by 'squarebrackets'
to create a \code{mutable_atomic} object,
as they make necessary checks. \cr
Circumventing these checks may break things! \cr
\cr
}

\examples{

x <- mutable_atomic(
  1:20, dim = c(5, 4), dimnames = list(letters[1:5], letters[1:4])
)
x
typecast.mutable_atomic(x, "character")

x <- matrix(1:10, ncol = 2)
x <- as.mutable_atomic(x)
is.mutable_atomic(x)
print(x)
x[, 1]
x[] <- as.double(x)
print(x)
is.mutable_atomic(x)
}
