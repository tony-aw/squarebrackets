% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/class_mutable_atomic.R
\name{class_mutable_atomic}
\alias{class_mutable_atomic}
\alias{mutable_atomic}
\alias{as.mutable_atomic}
\alias{is.mutable_atomic}
\alias{couldb.mutable_atomic}
\alias{[.mutable_atomic}
\alias{[<-.mutable_atomic}
\alias{format.mutable_atomic}
\alias{print.mutable_atomic}
\title{Mutable Atomic Classes}
\usage{
mutable_atomic(data, names = NULL, dim = NULL, dimnames = NULL)

as.mutable_atomic(x, ...)

is.mutable_atomic(x)

couldb.mutable_atomic(x)

\method{[}{mutable_atomic}(x, ...)

\method{[}{mutable_atomic}(x, ...) <- value

\method{format}{mutable_atomic}(x, ...)

\method{print}{mutable_atomic}(x, ...)
}
\arguments{
\item{data}{atomic vector giving data to fill the \code{mutable_atomic} object.}

\item{names, dim, dimnames}{see \link[stats]{setNames} and \link[base]{array}.}

\item{x}{an atomic object.}

\item{...}{method dependent arguments.}

\item{value}{see \link[base]{Extract}.}
}
\value{
For \code{mutable_atomic()}: \cr
Returns a \code{mutable_atomic} object. \cr
\cr
For \code{as.mutable_atomic()}: \cr
Converts an atomic object (vector, matrix, array)
to the same object, but with additional class \code{"mutable_atomic"},
and the additional attribute \code{"typeof"}. \cr
\cr
For \code{is.mutable_atomic()}: \cr
Returns \code{TRUE} if the object is atomic, has
the class \code{"mutable_atomic"},
has the correctly set attribute \code{"typeof"},
\bold{and} has an address that does not overlap with the addresses of base objects. \cr
\code{is.mutable_atomic()} returns \code{FALSE} otherwise. \cr
\cr
For \code{couldb.mutable_atomic()}: \cr
Returns \code{TRUE} if the object is one of the following types: \cr
\link{logical}, \link{integer}, \link{double}, \link{character}, \link{complex}, \link{raw}. \cr
\code{bit64::}\link[bit64]{integer64} type is also supported,
since it is internally defined as \link{double}. \cr
Returns \code{FALSE} otherwise. \cr \cr
}
\description{
The \code{mutable_atomic} class is a mutable version of atomic classes. \cr
It works exactly the same in all aspects as regular atomic classes,
with only one real difference: \cr
The 'squarebrackets' methods and functions that perform modification by reference
(basically all methods and functions with "set" in the name)
accept \code{mutable_atomic},
but do not accept regular \code{atomic}. \cr
See \link{squarebrackets_PassByReference} for details. \cr
\cr
Like \code{data.table}, \verb{[<-} performs R's default copy-on-modification semantics. \cr
For modification  by reference, use \link{sb_set}. \cr
\cr
Exposed functions (beside the S3 methods):
\itemize{
\item \code{mutable_atomic()}: create a \code{mutable_atomic} object.
\item \code{is.mutable_atomic()}: checks if an object is atomic.
\item \code{as.mutable_atomic()}: converts a regular atomic object to \code{mutable_atomic}.
\item \code{couldb.mutable_atomic()}: checks if an object could be \code{mutable_atomic}. \cr
An objects can become \code{mutable_atomic} if it is one of the following types: \cr
\link{logical}, \link{integer}, \link{double}, \link{character}, \link{complex}, \link{raw}. \cr
\code{bit64::}\link[bit64]{integer64} type is also supported,
since it is internally defined as \link{double}. \cr \cr
}
}
\section{Warning}{


Always use \code{mutable_atomic()} or \code{as.mutable_atomic()} to create a mutable object,
as they make necessary checks. \cr
Circumventing these checks may break things. \cr \cr
}

\examples{

x <- mutable_atomic(
  1:20, dim = c(5, 4), dimnames = list(letters[1:5], letters[1:4])
)
x

x <- matrix(1:10, ncol = 2)
x <- as.mutable_atomic(x)
is.mutable_atomic(x)
print(x)
x[, 1]
x[] <- as.double(x) # notifies the user a copy is being made
print(x) # "typeof" attribute adjusted accordingly, and class still present
}
