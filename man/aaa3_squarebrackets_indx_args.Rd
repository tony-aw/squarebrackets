% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aaa3_squarebrackets_indx_args.R
\name{aaa3_squarebrackets_indx_args}
\alias{aaa3_squarebrackets_indx_args}
\alias{squarebrackets_indx_args}
\title{Index Arguments in the Generic Sub-setting Methods}
\description{
There are 6 types of arguments that can be used
in the generic methods of 'squarebrackets' to specify the indices to perform operations on:
\itemize{
\item \code{i}: to specify flat (i.e. dimensionless) indices.
\item \verb{row, col}: to specify rows and/or columns in tabular objects.
\item \verb{sub, dims}: to specify indices of arbitrary dimensions in arrays.
\item \code{lvl}: specify levels, for factors only.
\item \verb{filter, vars}: to specify rows and/or columns specifically in data.frame-like objects.
\item \verb{margin, slice}: to specify indices of one particular dimension. \cr \cr
}

In this help page \code{x} refers to the object on which subset operations are performed. \cr
\cr
\cr
}
\section{Fundamentals}{


Base 'R' supports indexing through \code{logical}, \code{integer}, and \code{character} vectors. \cr
'squarebrackets' suppports these also (albeit with some improvements),
but also supports some additional methods of indexing. \cr
\cr
\cr
\bold{Integers} \cr
Integers are the most basic form on index selection. \cr
All forms of indexing in 'squarebrackets' are internally translated to integer indexing first,
ensuring consistency. \cr
Indexing through integers in 'squarebrackets' works the same as in base 'R',
except that negative values are not allowed. \cr
\cr
\cr
\bold{Logical} \cr
Selecting indices with a logical vector in 'squarebrackets' works the same as in base 'R',
except that recycling is not allowed. \cr
Thus the logical vector must be of the correct length
(i.e. \code{length(x)} or \code{dim(x)[L]}, depending on the situation). \cr
\cr
\cr
\bold{Characters} \cr
When selecting indices using a character vector,
base 'R' only selects the first matches in the names. \cr
'squarebrackets', however, selects ALL matches. \cr
Character indices are internally translated to integer indices using
\link{match_all}. \cr
\cr
\cr
\bold{Complex Numbers} \cr
Unlike base 'R',
squarebrackets' includes support for indexing through \code{complex} vectors. \cr
Indexing with complex numbers is a generalization of indexing with regular integers. \cr
\cr
It works as follows: \cr
A complex vector is essentially structured as \code{Real + Imaginary}. \cr
The Real part must be \bold{strictly positive integers}. \cr
The Imaginary part must be \bold{constant}.
\itemize{
\item If \code{Imaginary} is positive or zero, it works the same as integer values.
\item If \code{Imaginary} is negative, indexing counts backwards,
where the integer indices are computed as \code{n - Real + 1L}.
}

Where \code{n} is the maximum possible integer
(i.e. \code{length(x)}, or \code{dim(x)[L]}, depending on the situation). \cr
\cr
See the results of the following code as an example:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
x <- 1:30 # vector of 30 elements

sb_x(x, 1:10 + 1i) # extract first 10 elements
#>  [1]  1  2  3  4  5  6  7  8  9 10

sb_x(x, 1:10 - 1i) # extract last 10 elements
#>  [1] 30 29 28 27 26 25 24 23 22 21

sb_x(x, 10:1 - 1i) # last 10 elements, in tail()-like order
#>  [1] 21 22 23 24 25 26 27 28 29 30
}\if{html}{\out{</div>}}

Thus complex vectors allow the user to choose between counting from the beginning,
like regular integers,
or counting from the end. \cr
\cr
\cr
What follows are detailed descriptions of the common arguments
in 'squarebrackets' used to select indices. \cr
\cr
}

\section{Argument i}{

\ifelse{html}{\figure{class-atomic_vector-blue.svg}{options: alt='[class: atomic vector]'}}{\link[=squarebrackets_indx_args]{class: atomic vector}} \cr
\ifelse{html}{\figure{class-factor-blue.svg}{options: alt='[class: factor]'}}{\link[=squarebrackets_indx_args]{class: factor}} \cr
\ifelse{html}{\figure{class-recursive_vector-blue.svg}{options: alt='[class: recursive vector]'}}{\link[=squarebrackets_indx_args]{class: recursive vector}} \cr

Any of the following can be specified for argument \code{i}:
\itemize{
\item \code{NULL}, corresponds to missing argument.
\item a vector of length 0,
in which case no indices are selected for the operation
(i.e. empty selection).
\item a \bold{strictly positive integer} vector with indices.
\item a \bold{complex} vector, as explained at the start of this help page.
\item a \bold{logical vector},
of the same length as \code{x},
giving the indices to select for the operation.
\item a \bold{character} vector of index names. \cr
If an object has multiple indices with the given name,
ALL the corresponding indices will be selected for the operation.
\item a \bold{function} that takes as input \code{x},
and returns a logical vector,
giving the element indices to select for the operation. \cr
For atomic objects, \code{i} is interpreted as \code{i(x)}. \cr
For recursive objects, \code{i} is interpreted as \code{lapply(x, i)}. \cr
\cr
}

Using the \code{i} arguments corresponds to doing something like the following:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{ sb_x(x, i = i) # ==> x[i]
 
}\if{html}{\out{</div>}}
}

\section{Arguments row, col}{

\ifelse{html}{\figure{class-atomic_matrix-blue.svg}{options: alt='[class: atomic matrix]'}}{\link[=squarebrackets_indx_args]{class: atomic matrix}} \cr
\ifelse{html}{\figure{class-data.frame-like-blue.svg}{options: alt='[class: data.frame-like]'}}{\link[=squarebrackets_indx_args]{class: data.frame-like}} \cr

Any of the following can be specified for the arguments \code{row} / \code{col}:
\itemize{
\item \code{NULL} (default), corresponds to a missing argument.
\item a vector of length 0,
in which case no indices are selected for the operation (i.e. empty selection).
\item a \bold{strictly positive integer} vector with dimension indices to select for the operation.
\item a \bold{complex} vector, as explained at the start of this help page.
\item a \bold{logical} vector of the same length as the corresponding dimension size,
giving the indices of this dimension to select for the operation.
\item a \bold{character} vector of index names. \cr
If a dimension has multiple indices with the given name,
ALL the corresponding indices will be selected for the operation.
}

NOTE: The arguments \code{row} and \code{col} will be ignored if \code{i} is specified.

Using the \verb{row, col} arguments corresponds to doing something like the following:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{ sb_x(x, row = row, col = col) # ==> x[row, col, drop = FALSE]
 
}\if{html}{\out{</div>}}
}

\section{Argument Pair sub, dims}{

\ifelse{html}{\figure{class-atomic_array-blue.svg}{options: alt='[class: atomic array]'}}{\link[=squarebrackets_indx_args]{class: atomic array}} \cr
\ifelse{html}{\figure{class-recursive_array-blue.svg}{options: alt='[class: recursive array]'}}{\link[=squarebrackets_indx_args]{class: recursive array}} \cr
The \verb{sub, dims} argument pair is inspired by the
\code{abind::}\link[abind]{asub} function from the 'abind' package (see reference below). \cr
\code{dims} must be an integer vector of the same length as \code{sub},
giving the dimensions over which to select indices
(i.e. \code{dims} specifies the "non-missing" index margins). \cr
\code{sub} must be a list of subscripts, of the same length as \code{dims}.
Each element of \code{sub} can be any of the following:
\itemize{
\item a vector of length 0,
in which case no indices are selected for the operation (i.e. empty selection).
\item a \bold{strictly positive integer} vector with dimension indices to select for the operation.
\item a \bold{complex} vector, as explained at the start of this help page.
\item a \bold{logical} vector of the same length as the corresponding dimension size,
giving the indices of this dimension to select for the operation.
\item a \bold{character} vector of index names. \cr
If a dimension has multiple indices with the given name,
ALL the corresponding indices will be selected for the operation. \cr
}

Note also the following:
\itemize{
\item If \code{dims} is a single integer,
one can specify \code{sub} as an atomic vector of any of the above specified types,
instead of as a list of length \code{1}.
\item As stated, \code{dims} specifies which index margins are non-missing. \cr
If \code{dims} - and thus also \code{sub} - is of length \code{0},
it is taken as "all index margins are missing". \cr
}

To keep the syntax short,
the user can use the \link{n} function instead of \code{list()} to specify \code{sub}. \cr
\cr
Using the \verb{sub, dims} arguments,
corresponds to doing something like the following,
here using an example of extracting subsets from a 4-dimensional array:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{sb_x(x, n(1:10, 1:5), c(1, 3)) # ==> x[1:10, , 1:5, , drop = FALSE]

}\if{html}{\out{</div>}}

For a brief explanation of the relationship between flat indices (\code{i}),
and dimensional subscripts (\code{sub}, \code{dims}),
see the \code{Details} section in \link{sub2ind}. \cr \cr
}

\section{Argument lvl}{

\ifelse{html}{\figure{class-factor-blue.svg}{options: alt='[class: factor]'}}{\link[=squarebrackets_indx_args]{class: factor}} \cr

For this argument, the names of the levels of \code{x} can be given,
selecting the corresponding indices for the operation. \cr
\cr
}

\section{Arguments filter, vars}{

\ifelse{html}{\figure{class-data.frame-like-blue.svg}{options: alt='[class: data.frame-like]'}}{\link[=squarebrackets_indx_args]{class: data.frame-like}} \cr

\code{filter} must be a one-sided formula
with a single logical expression using the column names of the data.frame,
giving the condition which observation/row indices should be selected for the operation. \cr
For example,
to perform an operation on the rows for which column \code{height > 2} and for which column \code{sex != "female"},
specify the following formula:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{~ (height > 2) & (sex != "female")
}\if{html}{\out{</div>}}

If the formula is linked to an environment,
any variables not found in the data set will be searched from the environment. \cr
\cr
\code{vars} must be a function that returns a logical vector,
giving the column indices to select for the operation. \cr
For example, to select all numeric columns, specify \code{vars = is.numeric}. \cr
\cr
}

\section{Argument Pair margin, slice}{

\ifelse{html}{\figure{class-atomic_array-blue.svg}{options: alt='[class: atomic array]'}}{\link[=squarebrackets_indx_args]{class: atomic array}} \cr
\ifelse{html}{\figure{class-recursive_array-blue.svg}{options: alt='[class: recursive array]'}}{\link[=squarebrackets_indx_args]{class: recursive array}} \cr
\ifelse{html}{\figure{class-data.frame-like-blue.svg}{options: alt='[class: data.frame-like]'}}{\link[=squarebrackets_indx_args]{class: data.frame-like}} \cr

Relevant only for the \link{idx} method. \cr
The \code{margin} argument specifies the dimension on which argument \code{slice} is used. \cr
I.e. when \code{margin = 1}, \code{slice} selects rows; \cr
when \code{margin = 2}, \code{slice} selects columns; \cr
etc. \cr
\cr
The \code{slice} argument can be any of the following:
\itemize{
\item a \bold{strictly positive integer} vector with dimension indices to select for the operation.
\item a \bold{complex} vector, as explained at the start of this help page.
\item a \bold{logical} vector of the same length as the corresponding dimension size,
giving the dimension indices to select for the operation.
\item a \bold{character} vector of index names. \cr
If a dimension has multiple indices with the given name,
ALL the corresponding indices will be selected for the operation. \cr
}

One could also give a vector of length \code{0} for \code{slice}; \cr
Argument \code{slice} is only used in method \code{sub},
and the result of \code{sub} are meant to be used inside the regular \code{[} and \verb{[<-} operators. \cr
Thus the result of a zero-length index specification depends on the rule-set of
\verb{[.class(x)} and \verb{[<-.class(x)}. \cr \cr
}

\section{Argument inv}{

\ifelse{html}{\figure{all_classes-blue.svg}{options: alt='[all classes]'}}{\link[=squarebrackets_indx_args]{all classes}} \cr

Relevant for the \link{sb_mod}/\link{sb2_mod}, \link{sb_set}/\link{sb2_set},
and \link{idx} methods. \cr
By default, \code{inv = FALSE}, which translates the indices like normally. \cr
When \code{inv = TRUE}, the inverse of the indices is taken. \cr
Consider, for example, an atomic matrix \code{x}; \cr
using \code{sb_mod(x, col = 1:2, tf = tf)}
corresponds to something like the following:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
x[, 1:2] <- tf(x[, 1:2])
x

}\if{html}{\out{</div>}}

and using \code{sb_mod(x, col = 1:2, inv = TRUE, tf = tf)}
corresponds to something like the following:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
x[, -1:-2] <- tf(x[, -1:-2])
x

}\if{html}{\out{</div>}}

\bold{NOTE} \cr
The order in which the user gives indices when \code{inv = TRUE} generally does not matter. \cr
The order of the indices as they appear in the original object \code{x} is maintained,
just like in base 'R'. \cr
Therefore, when replacing multiple values where the order of the replacement matters,
it is better to keep \code{inv = FALSE}, which is the default. \cr
For replacement with a single value or with a transformation function,
\code{inv = TRUE} can be used without considering the ordering. \cr \cr
}

\section{All NULL indices}{

\code{NULL} in the indexing arguments corresponds to a missing argument. \cr
Thus, for \bold{both} \link{sb_x} and \link{sb_rm},
using \code{NULL} for all indexing arguments corresponds to something like the following:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
x[]

}\if{html}{\out{</div>}}

Similarly, for \link{sb_mod} and \link{sb_set},
using \code{NULL} corresponds to something like the following:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
x[] <- rp # for replacement
x[] <- tf(x) # for transformation

}\if{html}{\out{</div>}}

The above is true \bold{even if} \code{inv = TRUE}: \cr
\code{NULL} corresponds to a missing index arguments,
and missing arguments cannot be inversed. \cr \cr
}

\section{Out-of-Bounds Integers, Non-Existing Names/Levels, and NAs}{

\itemize{
\item Integer indices that are out of bounds (including \code{NaN} and \code{NA_integer_}) always give an error.
\item Specifying non-existing names/levels (including \code{NA_character_}) as indices
is considered a form of zero-length indexing.
\item Logical indices are translated internally to integers using \link[base]{which},
and so \code{NA}s are ignored. \cr \cr
}
}

\section{Disallowed Combinations of Index Arguments}{


One cannot specify \code{i} and  the other indexing arguments simultaneously;
it's either \code{i}, or the other arguments. \cr
The arguments are  evaluated in the following order:
\enumerate{
\item Argument \code{i}
\item Argument \code{lvl} (for factors)
\item The rest of the indexing arguments.
}

One cannot specify \code{row} and \code{filter} simultaneously;
it's either one or the other. \cr
One cannot specify \code{col} and \code{vars} simultaneously;
it's either one or the other. \cr
One cannot specify the \verb{sub, dims} pair and \verb{slice, margin} pair simultaneously;
it's either one pair or the other pair. \cr
In the above cases it holds that if one set is specified, the other is set is ignored. \cr
\cr
}

\section{Drop}{

Sub-setting with the generic methods from the 'squarebrackets' R-package using dimensional arguments
(\verb{row, col, lyr, sub, dims, filter, vars})
always use \code{drop = FALSE}. \cr
To drop potentially redundant (i.e. single level) dimensions,
use the \link[base]{drop} function, like so:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{ sb_x(x, row = row, col = col) |> drop() # ==> x[row, col, drop = TRUE]
 
}\if{html}{\out{</div>}}
}

\section{Regarding Performance}{

Integer indices and logical indices are the fastest. \cr
Indexing through names or levels (i.e. character vectors) is the slowest. \cr
Thus if performance is important, use integer or logical indices. \cr \cr
}

\references{
Plate T, Heiberger R (2016). \emph{abind: Combine Multidimensional Arrays}. R package version 1.4-5, \url{https://CRAN.R-project.org/package=abind}.
}
