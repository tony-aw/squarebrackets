% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aaa06_squarebrackets_method_dispatch.R
\name{aaa06_squarebrackets_method_dispatch}
\alias{aaa06_squarebrackets_method_dispatch}
\alias{squarebrackets_method_dispatch}
\title{Method Dispatch of 'squarebrackets'}
\description{
This help page gives some additional details regarding the S3 method dispatch
used in 'squarebrackets'. \cr \cr
}
\section{Atomic vs Recursive}{

Atomic and recursive objects are quite different from each other in some ways:
\itemize{
\item \strong{homo- or heterogeneous}: an atomic object can only have values of one data type. \cr
recursive objects can hold values of any combination of data types. \cr
\item \strong{nesting}: Recursive objects can be nested, while atomic objects cannot be nested.
\item \strong{copy and coercion effect}: One can coerce or copy a subset of a recursive object,
without copying the rest of the object. \cr
For atomic objects, however, a coercion or copy operation coerces or copies the entire vector
(ignoring attributes). \cr
\item \strong{vectorization}: most vectorized operations generally work on atomic objects,
whereas recursive objects often require loops or apply-like functions. \cr
\item \strong{recursive subsets}: Recursive objects distinguish between "regular" subset operations
(in base R using \code{[}, \verb{[<-}),
and recursive subset operations (in base R using \code{[[}, \verb{[[<-}). \cr
See for example the \link{sb2_rec} method,
or the \code{red = TRUE} argument in the \link{sb2_x} and \link{sb2_wo} methods. \cr
For atomic objects, these 2 have no meaningful difference
(safe for perhaps some minor attribute handling). \cr
\item \strong{views}: For recursive objects,
one can create a \link[=squarebrackets_coercion]{view} of a recursive subset. \cr
Subset views do not exist for atomic objects. \cr \cr
}

The main S3 methods
that perform subset operation on an object,
come in the atomic (\code{sb_}) and recursive (\code{sb2_}) form. \cr
The \link{idx} method operates on the indices of an object,
but does not operate on the object itself,
and so has no distinction between the atomic and recursive form. \cr
\cr
The split between the atomic and recursive forms of the method dispatches
is done for several reasons:
\itemize{
\item There are too many nuances to keep track of for the user between atomic and recursive objects. \cr
By splitting the methods into atomic and recursive objects,
the user only has to choose \code{sb_} or \code{sb2_}, and 'squarebrackets' can handle most of the rest for the user.
\item By giving atomic and recursive separate methods,
it becomes syntactically clear what the consequences are for a subset-operation: \cr
will the entire object be coerced or copied?
will a transformation function go through \code{lapply}?
is an operation only affecting shallow subsets?
etc.
\item Some S3 classes, like the \code{array} and \code{matrix} classes,
are available in both atomic and recursive forms. \cr
But the S3 method dispatch does not distinguish between atomic and recursive objects,
despite the aforementioned differences between the 2. \cr
So 'squarebrackets' uses a separate method dispatch for the atomic and recursive form.
\item Package authors can create separate sub-set operation methods for
atomic and recursive objects using 'squarebrackets'. \cr \cr
}
}

\section{Manual Dispatch}{

The 'squarebrackets' package intentionally exports each function in its S3 method dispatch system. \cr
This is handy for programming purposes. \cr
For example: one can explicitly alias a specific dispatch of a method,
if one so desires. \cr
For example like so: \cr

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
array_x <- function(x, ...) \{

   if(is.atomic(x)) \{
     sb_x.array(x, ...)
   \}
   else if(is.recursive(x)) \{
     sb2_x.array(x, ...)
   \}
   
\}

}\if{html}{\out{</div>}}

Under certain circumstances, this might help your code to be more clear. \cr
\cr
}

\section{Ellipsis}{

Due to how the S3 method dispatch system works in 'R',
all generic methods have the ellipsis argument (\code{...}). \cr
For the user's safety,
'squarebrackets' does check that the user doesn't accidentally
add arguments that make no sense for that method
(like specifying the \code{inv} argument when calling \link{sb_x}). \cr
\cr
\cr
}

