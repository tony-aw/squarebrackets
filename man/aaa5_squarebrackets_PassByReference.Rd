% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aaa5_squarebrackets_PassByReference.R
\name{aaa5_squarebrackets_PassByReference}
\alias{aaa5_squarebrackets_PassByReference}
\alias{squarebrackets_PassByReference}
\title{Regarding Modification By Reference}
\description{
This help page describes how modification using "pass-by-reference" semantics
is handled by the 'squarebrackets' package. \cr
This help page does not explain all the basics of pass-by-reference semantics,
as this is treated as prior knowledge. \cr
All functions/methods in the 'squarebrackets' package
with the word "set" in the name
use pass-by-reference semantics. \cr \cr
}
\section{Advantages and Disadvantages}{

The main advantage of pass-by-reference is that much less memory is required to modify objects. \cr
But at least 2 things should be taken into consideration
when modifying an object by reference. \cr
\cr
First, the coercion rules are slightly different: see \link{squarebrackets_mutable_classes}. \cr
\cr
Second, if 2 or more variables refer to exactly the same object,
changing one variable also changes the other ones. \cr
I.e. the following code,

\if{html}{\out{<div class="sourceCode r">}}\preformatted{x <- y <- mutable_atomic(1:16)
sb_set(x, i = 1:6, rp = 8)
}\if{html}{\out{</div>}}

modifies not just \code{x}, but also \code{y}. \cr
This is true even if one of the variables is locked
(see \link[base]{bindingIsLocked}). \cr
I.e. the following code,

\if{html}{\out{<div class="sourceCode r">}}\preformatted{x <- mutable_atomic(1:16)
y <- x
lockBinding("y", environment())
sb_set(x, i = 1:6, rp = 8)
}\if{html}{\out{</div>}}

modifies both \code{x} and \code{y} without error,
even though \code{y} is a locked constant. \cr \cr
}

\section{Mutable vs Immutable types}{

With the exception of environments,
most of base R's data types are treated as immutable: \cr
Modifying an object in 'R' will make a copy of the object,
something called 'copy-on-modify' semantics. \cr
However, almost any of base R's datatypes can be modified by reference,
through R's own 'C' API, or through 'C++' code (like via 'Rcpp'),
thus treating these objects as mutable,
even though they are not "supposed" to be mutable. \cr
Modifying a base 'R' object by reference can be problematic. \cr
Since 'R', and also most R-packages, treat these objects as immutable,
modifying them as-if they are mutable may produce undesired results. \cr
\cr
To prevent the issue described above,
'squarebrackets' only supports pass-by-reference semantics
on objects that are actually supposed to be mutable. \cr
In relation to this restriction,
'squarebrackets' adds a new class of objects,
\link[=class_mutable_atomic]{mutable_atomic},
which are simply atomic objects
that have the permission to be modified by reference. \cr \cr
}

\section{Mutability rules with respect to recursive objects}{

Lists are difficult objects in that they do not contain elements,
they simply point to  other objects,
that one can access via a list. \cr
When a recursive object is of a mutable class,
all its subsets are treated as mutable,
as long as they are part of the object. \cr
On the other hand,
When a recursive object is of an immutable class,
than its recursive subsets retain their original mutability. \cr
\cr
For example: \cr
\itemize{
\item A \code{data.table} is a mutable class. \cr
So all columns of the \code{data.table} are treated as mutable; \cr
There is no requirement, for example,
to first change all columns into the class of \link{mutable_atomic}
to modify them by reference. \cr
\item A regular \code{list} is an immutable class. \cr
The contents of the list therefore retain their mutability. \cr
So if a mutable object,
such as a \link{mutable_atomic} object or a \code{data.table},
is a subset of a list,
the view of that list subset can be modified by reference,
even though the list as a whole is immutable. \cr \cr
}
}

\section{Views of Lists}{

Regular lists themselves are not treated as mutable objects by 'squarebrackets'. \cr
However, lists are not actually really objects,
merely a (potentially hierarchical) structure of pointers. \cr
Thus, even if a list itself is not treated as mutable,
subsets of a list which are themselves mutable classes, are mutable. \cr
For example,
if you have a list of \code{data.table} objects,
the data.tables themselves are mutable. \cr
Therefore, the following will work: \cr

\if{html}{\out{<div class="sourceCode r">}}\preformatted{x <- list(
 a = data.table(cola = 1:10, colb = letters[1:10]),
 b = data.table(cola = 11:20, colb = letters[11:20])
)
mypointer <- x$a
sb_set(mypointer, col = "cola", tf = \\(x)x^2)

}\if{html}{\out{</div>}}

Notice in the above code that \code{mypointer} is not a copy of \code{x$a},
since they have the same address. \cr
Thus changing \code{mypointer} also changes \code{x$a}. \cr
In other words: \code{mypointer} is what could be called a "view" of \code{x$a}. \cr \cr
}

\section{Input Variable}{

Methods/functions that perform in-place modification by reference
can be thought of as similar to functions in the style of \code{some_function(x, ...) <- value},
in the sense that the variable must actually exist as an actual variable. \cr
Thus things like any of the following, \cr
\code{sb_set(1:10, ...)}, \code{sb2_set(x$a, ...)}, or \code{sb_set(base::letters)}, \cr
will not work. \cr \cr
}

\section{Lock Binding}{

\link[=squarebrackets_mutable_classes]{Mutable classes} are,
as the name suggests,
meant to be mutable. \cr
Locking the binding of a mutable object is \bold{mostly} fruitless
(but not completely;
see the \link{currentBindings} function). \cr
To prevent modification of an object's binding, 2 things must be true: \cr
\itemize{
\item the object must be an \link[=squarebrackets_immutable_classes]{immutable class}.
\item the binding must be \bold{locked} (see \link[base]{lockBinding}).
}

Some packages that provide pass-by-reference semantics
tend to ignore the lock of an object's binding. \cr
Use the 'squarebrackets'  methods and (of course) core/base 'R' methods,
in case the user fears the binding locks will not be respected. \cr \cr
}

\section{Protected Addresses}{

To prevent an accidental pass-by-reference modification of objects in the base environment,
all addresses of all exported objects in the base environment
(\link[base]{baseenv})
are stored in
the option \code{squarebrackets.protected} whenever 'squarebrackets' is \bold{loaded},
either directly or indirectly. \cr
Needless to say, the user should never touch this option. \cr \cr
}

\section{Protection}{


Due to the properties described above in this help page,
something like the following will not work:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
letters <- base::letters
sb_set(letters, i = 1, rp = "XXX")

}\if{html}{\out{</div>}}

The above won't work because:
\enumerate{
\item addresses in \code{baseenv()} are protected;
\item immutable objects are disallowed
(you'll have to create a mutable object,
which will create a copy of the original,
thus keeping the original object safe from modification by reference);
\item locked bindings are disallowed.
}

Despite the checks made by this package,
the user should never actively try to modify
a \bold{locked} or \bold{protected} object by reference,
as that would defeat the purpose of locking an object. \cr \cr
}

\examples{




# the following code demonstrates how locked bindings,
# such as `base::letters`,
# are being safe-guarded

x <- list(a = base::letters)
mypointer <- x$a # view of a list
address(mypointer) == address(base::letters) # TRUE: point to the same memory
bindingIsLocked("letters", baseenv()) # base::letters is locked ...
bindingIsLocked("mypointer", environment()) # ... but this pointer is not!

if(requireNamespace("tinytest")) {
  tinytest::expect_error(
    sb_set(mypointer, i = 1, rp = "XXX") # this still gives an error though ...
  )
}

is.mutable_atomic(mypointer) # ... because it's not of class `mutable_atomic`


x <- list(
  a = as.mutable_atomic(base::letters) # `as.mutable_atomic()` makes a copy
)
mypointer <- x$a # view of a list
address(mypointer) == address(base::letters) # FALSE: it's a copy
sb_set(
  mypointer, i = 1, rp = "XXX"  # modifies x, does NOT modify `base::letters`
)
print(x) # x is modified
base::letters # but this still the same

# Word of warning:
# the safe-guard in 'squarebrackets' is good, but definitely not perfect.
# Do not actively try to break things; you might actually succeed.


}
