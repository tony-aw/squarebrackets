% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aaa0_squarebrackets_help.R
\name{aaa0_squarebrackets_help}
\alias{aaa0_squarebrackets_help}
\alias{squarebrackets-package}
\alias{squarebrackets}
\alias{squarebrackets_help}
\title{squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming}
\description{
squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming \cr \cr
}
\section{Goal & Properties}{


Among programming languages,
'R' has perhaps one of the most
flexible and comprehensive sub-setting functionality,
provided by the square brackets operators (\code{[}, \verb{[<-}). \cr
But in some situations the square brackets operators
are occasionally less than optimally convenient \cr
(see \link{squarebrackets_inconveniences}). \cr
\cr
The Goal of the 'squarebrackets' package
is not to replace the square-brackets operators,
but to provide \bold{alternative} sub-setting methods and functions,
to be used in situations where the square bracket operators are inconvenient. \cr
\cr
These alternative sub-setting methods and functions have the following properties:
\itemize{
\item \bold{Programmatically friendly}:
\itemize{
\item Unlike base \code{[},
it's not required to know the number of dimensions of an array a-priori,
to perform subset-operations on an array.
\item Missing arguments can be filled with \code{NULL},
instead of using dark magic like \code{base::quote(expr =    )}.
\item No Non-standard evaluation.
\item Functions are pipe-friendly.
\item No (silent) vector recycling.
\item Extracting and removing subsets uses the same syntax.
}
\item \bold{Class consistent}:
\itemize{
\item sub-setting of multi-dimensional objects by specifying dimensions
(i.e. rows, columns, ...)
use \code{drop = FALSE}. \cr
So matrix in, matrix out.
\item The methods deliver the same results for
data.frames, data.tables, tibbles, and tidytables. \cr
No longer does one have to re-learn the different brackets-based sub-setting rules
for different types of data.frame-like objects. \cr
Powered by the subclass agnostic 'C'-code from 'collapse' and 'data.table'.
}
\item \bold{Explicit copy semantics}:
\itemize{
\item Sub-set operations that change its memory allocations,
always return a modified (partial) copy of the object. \cr
\item For sub-set operations that just change values in-place
(similar to the \verb{[<-} and \verb{[[<-} methods)
the user can choose a method that modifies the object by \bold{reference},
or choose a method that returns a \bold{(partial) copy}.
}
\item \bold{Careful handling of names}:
\itemize{
\item Sub-setting an object by index names returns ALL matches with the given names,
not just the first.
\item Data.frame-like objects (see supported classes below)
are forced to have unique column names.
\item Sub-setting arrays using \code{x[indx1, indx2, etc.]} will drop \code{names(x)}. \cr
The methods from 'squarebrackets' will not drop \code{names(x)}.
}
\item \bold{Concise function and argument names}.
\item \bold{Performance aware}: \cr
Despite the many checks performed, the functions are kept reasonably speedy,
through the use of the 'Rcpp', 'collapse', and 'data.table' R-packages. \cr \cr
}
}

\section{Supported Classes}{

'squarebrackets' only supports the most common S3 classes,
and only those that primarily use square brackets for sub-setting
(hence the name of the package). \cr
\cr
Supported immutable classes: \cr
\code{atomic}, \code{list}, \code{data.frame}
(including \code{tibble}, \code{sf-data.frame}, and \code{sf-tibble}). \cr
\cr
Supported  mutable classes: \cr
\link{mutable_atomic}, \code{data.table}
(including \code{tidytable}, \code{sf-data.table}, and \code{sf-tidytable}). \cr
\cr
Key-value storages,
such as environments,
and the various classes of the 'collections' package,
are not supported. \cr \cr
}

\section{Methods}{


The main focus of this package is on its generic methods
and dimensional binding implementations. \cr
\cr
Generic methods for atomic objects
start with \code{sb_}. \cr
Generic methods for recursive objects (list, data.frame, etc.)
start with \code{sb2_}. \cr
The binding implementations for atomic dimensional objects (atomic arrays)
start with \code{bind_}. \cr
The binding implementations for recursive dimensional objects (recursive arrays, data.frames)
start with \code{bind2_}. \cr
There is also the somewhat separate \link{idx} method,
which works on both recursive and non-recursive objects. \cr
And finally there are the \code{slice_} methods, which (currently) only work on atomic vectors. \cr \cr

\ifelse{html}{\figure{accessor_methods-darkgreen.svg}{options: alt='[ACCESSOR METHODS]'}}{\link[=squarebrackets_help]{ACCESSOR METHODS}} \cr

Methods to access subsets (i.e. extract selection, or extract all except selection):
\itemize{
\item \link{sb_x}, \link{sb2_x}: extract, exchange, or duplicate subsets.
\item \link{sb_rm},  \link{sb2_rm}: un-select/remove subsets.
\item \link{sb2_rec}: access recursive subsets of lists.
\item \link{slice_x}, \link{slice_rm}: efficiently extract or un-select/remove subset from a (long) vector. \cr \cr
}

\ifelse{html}{\figure{modification_methods-red.svg}{options: alt='[MODIFICATION METHODS]'}}{\link[=squarebrackets_help]{MODIFICATION METHODS}} \cr

Methods to modify subsets:
\itemize{
\item \link{idx}: translate given indices/subscripts,
for the purpose of copy-on-modify substitution.
\item \link{sb2_recin}: replace, transform, remove, or add recursive subsets to a list,
through R's default Copy-On-Modify semantics.
\item \link{sb_mod}, \link{sb2_mod}: return a \bold{(partial) copy}
of an object with modified
(transformed or replaced) subsets.
\item \link{sb_set}, \link{sb2_set}: modify (transform or replace)
subsets of a \link[=squarebrackets_supported_structures]{mutable object}
using \link[=squarebrackets_PassByReference]{pass-by-reference semantics}.
\item \link{slice_set}: efficiently modify a (long) vector subset using
\link[=squarebrackets_PassByReference]{pass-by-reference semantics}. \cr \cr
}

\ifelse{html}{\figure{extending_methods-purple.svg}{options: alt='[EXTENDING METHODS]'}}{\link[=squarebrackets_help]{EXTENDING METHODS}} \cr

Methods to extend or re-arrange an object beyond its current size:
\itemize{
\item \link[=bind]{bind_}, \link[=bind]{bind2_}:  implementations for binding dimensional objects.
\item \link{sb_x}, \link{sb2_x}: extract, exchange, or duplicate subsets.
\item \link{sb2_recin}: replace, transform, remove, or add recursive subsets to a list,
through R's default Copy-On-Modify semantics.
}

So for example,
use \code{sb_rm()} to remove subsets from atomic arrays,
and use \code{sb2_rm()} to remove subsets from recursive arrays. \cr
See \link{squarebrackets_method_dispatch} for more information on how 'squarebrackets'
uses its S3 Method dispatch. \cr \cr
}

\section{Functions}{


\ifelse{html}{\figure{specialized_functions-darkred.svg}{options: alt='[SPECIALIZED FUNCTIONS]'}}{\link[=squarebrackets_help]{SPECIALIZED FUNCTIONS}} \cr
Additional specialized sub-setting functions are provided:
\itemize{
\item \link{lst_untree}: unnest tree-like nested list into a recursive array,
to speed-up vectorized sub-setting on recursive subsets of the list.
\item The \link[=dt_setcoe]{dt_}-functions
to programmatically perform \code{data.table}-specific \code{[}-operations,
with the security measures provided by the 'squarebrackets' package.
\item \link{setapply}: apply functions over mutable matrix margins
using \link[=squarebrackets_PassByReference]{pass-by-reference semantics}.
\item \link{ma_setv}: Find & Replace values in \link{mutable_atomic} objects
using \link[=squarebrackets_PassByReference]{pass-by-reference semantics}. \cr
This is considerably faster and more memory efficient than using \link{sb_set} for this. \cr \cr
}

\ifelse{html}{\figure{helper_functions-lightblue.svg}{options: alt='[HELPER FUNCTIONS]'}}{\link[=squarebrackets_help]{HELPER FUNCTIONS}} \cr
A couple of convenience functions, and helper functions for creating ranges, sequences, and indices
(often needed in sub-setting)
are provided:
\itemize{
\item \link{currentBindings}: list or lock all currently existing bindings
that share the share the same address as the input variable.
\item \link{n}: Nested version of \link[base]{c},
and short-hand for \link[base]{list}.
\item \link{ndims}: Get the number of dimensions of an object.
\item \link{sub2coord}, \link{coord2ind}: Convert subscripts
(array indices) to coordinates,
coordinates to flat indices,
and vice-versa.
\item \link{match_all}: Find all matches, of one vector in another,
taking into account the order and any duplicate values of both vectors.
\item Computing indices: \cr
\link{idx_r} to compute an integer index range. \cr
\link{idx_by} to compute grouped indices. \cr
\link[=idx_ord_v]{idx_ord_}-functions to compute ordered indices. \cr \cr
}

\ifelse{html}{\figure{developer_functions-pink.svg}{options: alt='[DEVELOPER FUNCTIONS]'}}{\link[=squarebrackets_help]{DEVELOPER FUNCTIONS}} \cr

And finally some developer functions for constructing indices. \cr
These are also used internally by 'squarebrackets',
and package authors can use these to create additional sb_/sb2_ S3 methods,
or even entirely new subset-related functions.
\itemize{
\item \link[=tci_bool]{tci_} functions, for type-casting indices.
\item \link[=ci_flat]{ci_} functions, for constructing indices.
\item \link{indx_x} and \link{indx_rm}, for testing methods.
}
}

\references{
The badges shown in the documentation of this R-package were made using the services of: \url{https://shields.io/}
}
\author{
\strong{Maintainer}: Tony Wilkes \email{tony_a_wilkes@outlook.com} (\href{https://orcid.org/0000-0001-9498-8379}{ORCID})
}
