% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ci.R
\name{developer_ci}
\alias{developer_ci}
\alias{ci_ii}
\alias{ci_margin}
\alias{ci_ss}
\title{Construct Indices}
\usage{
ci_ii(
  x,
  i = NULL,
  use = 1L,
  chkdup = FALSE,
  uniquely_named = FALSE,
  .abortcall = sys.call()
)

ci_margin(
  x,
  slice = NULL,
  margin,
  use = 1L,
  chkdup = FALSE,
  uniquely_named = FALSE,
  .abortcall = sys.call()
)

ci_ss(
  x,
  s = NULL,
  use = 1:ndim(x),
  chkdup = FALSE,
  uniquely_named = FALSE,
  .abortcall = sys.call()
)
}
\arguments{
\item{x}{the object for which the indices are meant.}

\item{i, s, use, slice, margin}{See \link{squarebrackets_indx_args}. \cr}

\item{chkdup}{see \link{squarebrackets_options}. \cr
\ifelse{html}{\figure{for_performance-set_to_FALSE-red.svg}{options: alt='[for performance: set to FALSE]'}}{\link[=squarebrackets_help]{for performance: set to FALSE}} \cr}

\item{uniquely_named}{Boolean,
indicating if the user knows a-priori that the relevant names of \code{x} are unique. \cr
If set to \code{TRUE}, speed may increase. \cr
But specifying \code{TRUE} when the relevant names are not unique will result in incorrect output.}

\item{.abortcall}{environment where the error message is passed to.}
}
\value{
An integer vector of constructed indices.
}
\description{
These functions construct indices. \cr
\itemize{
\item \code{ci_ii()} constructs an integer vector flat/interior indices.
\item \code{ci_margin()} constructs an integer vector of indices for one particular dimension margin.
\item \code{ci_ss()} constructs a list of integer subscripts.
\item \code{ci_df()} is the same as \code{ci_margin()},
except it is specifically designed for data.frame-like objects. \cr
It is a separate function,
because things like \code{dimnames(x)[1]} and \code{rownames(x)}
do not always return the same output for certain data.frame-like objects.
\item \code{ci_obs()} and \code{ci_vars()} construct row and column indices,
respectively,
for data.frame-like objects. \cr
}
}
\examples{

x <- matrix(1:25, 5, 5)
colnames(x) <- c("a", "a", "b", "c", "d")
print(x)

bool <- sample(c(TRUE, FALSE), 5, TRUE)
int <- 1:4
chr <- c("a", "a")
tci_bool(bool, nrow(x))
tci_int(int, ncol(x), -1)
tci_chr(chr, colnames(x))

ci_ii(x, 1:10)
ci_margin(x, 1:4, 2)
ci_ss(x, n(~ .bi(-1:-5), 1:4), 1:2)

}
