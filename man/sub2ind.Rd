% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sub2ind.R
\name{sub2ind}
\alias{sub2ind}
\alias{sub2coord}
\alias{coord2sub}
\alias{coord2ind}
\alias{ind2coord}
\title{Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa}
\usage{
sub2coord(sub, x.dim)

coord2sub(coord)

coord2ind(coord, x.dim, checks = TRUE)

ind2coord(ind, x.dim)

sub2ind(sub, x.dim, checks = TRUE)
}
\arguments{
\item{sub}{a list of integer subscripts. \cr
The first element of the list corresponds to the first dimension (rows),
the second element to the second dimensions (columns),
etc. \cr
The length of \code{sub} must be equal to the length of \code{x.dim}. \cr
One cannot give an empty subscript;
instead fill in something like \code{seq_len(dim(x)[margin])}. \cr
NOTE: The \code{coord2sub()} function does not support duplicate subscripts.}

\item{x.dim}{an integer vector giving the dimensions of the array in question. I.e. \code{dim(x)}.}

\item{coord}{an integer matrix, giving the coordinate indices (subscripts) to convert. \cr
Each row is an index, and each column is the dimension. \cr
The first columns corresponds to the first dimension,
the second column to the second dimensions,
etc. \cr
The number of columns of \code{coord} must be equal to the length of \code{x.dim}. \cr}

\item{checks}{logical, indicating if arguments checks should be performed. \cr
Defaults to \code{TRUE}. Can be set to \code{FALSE} for minor speed improvements, but not recommended.}

\item{ind}{an integer vector, giving the flat position indices to convert.}
}
\value{
For \code{sub2coord()} and \code{ind2coord()}: \cr
Returns an integer matrix of coordinates
(with properties as described in argument \code{coord}). \cr
\cr
For \code{coord2ind()}: \cr
Returns an integer vector of flat indices
(with properties as described in argument \code{ind}). \cr
\cr
For \code{coord2sub()}: \cr
Returns a list of integer subscripts
(with properties as described in argument \code{sub}) \cr
\cr
}
\description{
These functions convert a list of integer subscripts to an integer matrix of coordinates,
an integer matrix of coordinates to an integer vector of flat indices,
and vice-versa. \cr
Inspired by the \code{sub2ind} function from 'MatLab'. \cr

\code{sub2coord()} converts a list of integer subscripts to an integer matrix of coordinates. \cr
\code{coord2ind()} converts an integer matrix of coordinates to an integer vector of flat indices. \cr
\code{ind2coord()} converts an integer vector of flat indices to an integer matrix of coordinates. \cr
\code{coord2sub()} converts an integer matrix of coordinates to a list of integer subscripts. \cr
\code{sub2ind()} is a faster and more memory efficient version of
\code{coord2ind(sub2coord(sub, x.dims), x.dims)} (especially for up to 5 dimensions). \cr
\cr
Note that the \code{coord2sub()} function performs a very simple (one might even say naive) conversion. \cr
\cr
All of these functions are written to be memory-efficient. \cr
The \code{coord2ind()} is thus the opposite of \link{arrayInd},
and \code{ind2coord} is merely a convenient wrapper around \link{arrayInd}. \cr
\cr
Note that the equivalent to the \code{sub2ind} function from 'MatLab'
is actually the \code{coord2ind()} function here. \cr
}
\details{
The S3 classes in 'R' use the standard Linear Algebraic convention,
as in academic fields like Mathematics and Statistics,
in the following sense: \cr
\itemize{
\item vectors are \bold{column} vectors (i.e. vertically aligned vectors);
\item index counting starts at \code{1};
\item rows are the first dimension/subscript, columns are the second dimension/subscript, etc.
}

Thus, the orientation of flat indices in, for example, a 4 by 4 matrix, is as follows:

\if{html}{\out{<div class="sourceCode">}}\preformatted{     [,1] [,2] [,3] [,4]
[1,]    1    5    9   13
[2,]    2    6   10   14
[3,]    3    7   11   15
[4,]    4    8   12   16
}\if{html}{\out{</div>}}

The subscript \verb{[1,2]} refers to the first row and the second column.
In a 4 by 4 matrix, subscript \verb{[1,2]} corresponds to flat index \code{5}. \cr
The functions described here thus follow also this convention. \cr
\cr
}
\section{Warning}{

These functions do not support duplicate indices. \cr
For efficiency, they do not check for duplicate indices either. \cr
}

\examples{

x.dim <- c(10, 10, 3)
x.len <- prod(x.dim)
x <- array(1:x.len, x.dim)
sub <- list(c(4, 3), c(3, 2), c(2, 3))
coord <- sub2coord(sub, x.dim)
print(coord)
ind <- coord2ind(coord, x.dim)
print(ind)
all(x[ind] == c(x[c(4, 3), c(3, 2), c(2, 3)])) # TRUE
coord2 <- ind2coord(ind, x.dim)
print(coord)
all(coord == coord2) # TRUE
sub2 <- coord2sub(coord2)
sapply(1:3, \(i) sub2[[i]] == sub[[i]]) |> all() # TRUE

}
