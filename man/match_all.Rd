% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/match_all.R
\name{match_all}
\alias{match_all}
\title{Match All, Order-Sensitive and Duplicates-Sensitive}
\usage{
match_all(needles, haystack, unlist = TRUE)
}
\arguments{
\item{needles, haystack}{vectors}

\item{unlist}{Boolean,
indicating if the result should be a single integer vector (\code{TRUE}, default),
or a list (length = \code{length(needles)}) of integer vectors (\code{FALSE}). \cr}
}
\value{
An integer vector, or list of integer vector. \cr
If a list, each element of the list corresponds to each value of \code{needles}. \cr
When \code{needles} and/or \code{haystack} is/are empty or fully \code{NA},
\code{match_all()} returns an empty integer vector (if \code{unlist = TRUE}),
or an empty list (if \code{unlist = FALSE}). \cr
}
\description{
Find all indices of vector \code{haystack} that are equal to vector \code{needles},
taking into account the order of both vectors, and their duplicate values. \cr
\cr
It is essentially a much more efficient version of:

\if{html}{\out{<div class="sourceCode">}}\preformatted{lapply(needles, \\(i) which(haystack == i))

}\if{html}{\out{</div>}}

Like \verb{lapply(needles, \\(i) which(haystack == i))}, \code{NA}s are ignored. \cr
\cr
Core of the code is based on a suggestion by Sebastian Kranz
(author of the 'collapse' package). \cr
\cr
}
\examples{
n <- 200
haystack <- sample(letters, n, TRUE)
needles <- sample(letters, n/2, TRUE)
indices1 <- match_all(needles, haystack)
head(indices1)

 
}
