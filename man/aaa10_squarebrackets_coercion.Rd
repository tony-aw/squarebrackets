% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aaa10_squarebrackets_coercion.R
\name{aaa10_squarebrackets_coercion}
\alias{aaa10_squarebrackets_coercion}
\alias{squarebrackets_coercion}
\title{Auto-Coercion Rules for Mutable Objects}
\description{
This help page describes the auto-coercion rules of the mutable classes,
as they are handled by the 'squarebrackets' package. \cr
This useful information for users who wish to intend to employ
\link[=squarebrackets_PassByReference]{Pass-by-Reference semantics}
as provided by 'squarebrackets'. \cr
\cr
\cr
}
\section{mutatomic}{

\ifelse{html}{\figure{coercion_through_copy-YES-darkgreen.svg}{options: alt='[coercion_through_copy: YES]'}}{\link[=squarebrackets_coercion]{coercion_through_copy: YES}} \cr
\ifelse{html}{\figure{coercion_by_reference-NO-red.svg}{options: alt='[coercion_by_reference: NO]'}}{\link[=squarebrackets_coercion]{coercion_by_reference: NO}} \cr
Mutable atomic objects are automatically coerced to fit the modified subset values,
when modifying through copy, just like regular atomic classes. \cr
For example, replacing one or multiple values in an integer vector
(type \code{int})
with a decimal number
(type \code{dbl})
will coerce the entire vector to type \code{dbl}. \cr
\cr
Replacing or transforming subsets of mutable atomic objects \bold{by reference}
does not support coercion.
Thus, for example, the following code,

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
x <- mutatomic(1:16)
fi_set(x, i = 1:6, rp = 8.5)
#> coercing replacement to integer
print(x)
#>  [1]  8  8  8  8  8  8  7  8  9 10 11 12 13 14 15 16
#> mutatomic 
#> typeof:  integer
}\if{html}{\out{</div>}}

gives \verb{c(rep(8, 6) 7:16)} instead of \code{c(rep(8.5, 6), 7:16)},
because \code{x} is of type \code{integer}, so \code{rp} is interpreted as type \code{integer} also. \cr
\cr
\cr
}

\section{data.table, when replacing/transforming whole columns}{

\ifelse{html}{\figure{coercion_through_copy-YES-darkgreen.svg}{options: alt='[coercion_through_copy: YES]'}}{\link[=squarebrackets_coercion]{coercion_through_copy: YES}} \cr
\ifelse{html}{\figure{coercion_by_reference-YES-darkgreen.svg}{options: alt='[coercion_by_reference: YES]'}}{\link[=squarebrackets_coercion]{coercion_by_reference: YES}} \cr
A data.table is actually a list made mutable,
where each column is itself a list.
As such, replacing/transforming whole columns using \code{data.table::set()},
without specifying rows (not even \code{i = 1:nrow(x)}),
allows completely changing the type of the column. \cr
\cr
\cr
}

\section{data.table, when partially replacing/transforming columns}{

\ifelse{html}{\figure{coercion_through_copy-YES-darkgreen.svg}{options: alt='[coercion_through_copy: YES]'}}{\link[=squarebrackets_coercion]{coercion_through_copy: YES}} \cr
\ifelse{html}{\figure{coercion_by_reference-NO-red.svg}{options: alt='[coercion_by_reference: NO]'}}{\link[=squarebrackets_coercion]{coercion_by_reference: NO}} \cr
If rows are specified in the \code{data.table::set()} function
(and functions that internally use \code{data.table::set()}),
and thus not all values of columns but parts(i.e. rows) of columns are replaced,
no auto-coercion takes place. \cr
I.e.: replacing/transforming a value in an integer (\code{int}) column to become \code{1.5},
will not coerce the column to the decimal type (\code{dbl});
instead, the replacement value \code{1.5} is coerced to integer \code{1}. \cr
\cr
Using R's native copy-on-modify semantics
(for example by changing a \code{data.table} into a \code{data.frame})
allows for coercion even when partially replacing/transforming columns. \cr
\cr
\cr
}

\section{Views of Lists}{

Regular lists are treated as immutable by 'squarebrackets'. \cr
But remember that a list is a
(potentially hierarchical)
structure of references to other objects. \cr
Thus, even if a list itself is not treated as mutable,
subsets of a list which are themselves mutable classes, are mutable. \cr
For example,
if you have a list of \code{data.table} objects,
the data.tables themselves are mutable. \cr
Therefore, the following will work: \cr

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
x <- list(
 a = mutatomic(letters[1:10]),
 b = mutatomic(letters[11:20])
)
myref <- x$a
fi_set(myref, 1, rp = "xxx")

}\if{html}{\out{</div>}}

Notice in the above code that \code{myref} is not a copy of \code{x$a},
since they have the same address. \cr
Thus changing \code{myref} also changes \code{x$a}. \cr
In other words: \code{myref} is what could be called a "view" of \code{x$a}. \cr
Notice also that \link{fi_set}\verb{(x$a, ...)} will not work. \cr
This is because \link{stopifnot_ma_safe2mutate} will give an error
if \code{x} is not an \bold{actual variable},
similar to in-place functions in the style of \code{`myfun()<-`}. \cr
\cr
The auto-coercion rules of Views of Lists,
depends entirely on the object itself. \cr
Thus if the View is a data.table,
coercion rules of data.tables apply. \cr
And if the View is a \link{mutatomic} object,
coercion rules of \link{mutatomic} objects apply,
etc. \cr \cr
}

\examples{

# Coercion examples - mutatomic ====

x <- as.mutatomic(1:16)
fi_set(x, i = 1:6, rp = 8.5) # 8.5 coerced to 8, because `x` is of type `integer`
print(x)

#############################################################################

# Coercion examples - data.table - whole columns ====

# ss2_mod():
obj <- data.table::data.table(
  a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])
)
str(obj) # notice that columns "a" and "c" are INTEGER (`int`)
ss2_mod(
  obj, vars = is.numeric,
  tf = sqrt # SAFE: row=NULL & obs = NULL, so coercion performed
)

# ss2_set():
ss2_set(
  obj, vars = is.numeric,
  tf = sqrt # SAFE: row=NULL & obs = NULL, so coercion performed
)
str(obj)

#############################################################################


# Coercion examples - data.table - partial columns ====

# ss2_mod():
obj <- data.table::data.table(
  a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])
)
str(obj) # notice that columns "a" and "c" are INTEGER (`int`)

ss2_mod(
  obj, obs = ~ (a >= 2) & (c <= 17), vars = is.numeric,
  tf = sqrt # SAFE: coercion performed
)

# ss2_set():
obj <- data.table::data.table(
  a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])
)
str(obj) # notice that columns "a" and "c" are INTEGER (`int`)
ss2_set(
  obj, obs = ~ (a >= 2) & (c <= 17), vars = is.numeric,
  tf = sqrt
  # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost
)
print(obj)

obj <- data.table::data.table(
  a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])
)
str(obj)
dt_setcoe(obj, vars = is.numeric, v = as.numeric)
str(obj)
ss2_set(obj,
  obs = ~ (a >= 2) & (c <= 17), vars = is.numeric,
  tf = sqrt # SAFE: coercion performed by dt_setcoe(); so no warnings
) 
print(obj)


#############################################################################

# View of List ====

x <- list(
 a = data.table::data.table(cola = 1:10, colb = letters[1:10]),
 b = data.table::data.table(cola = 11:20, colb = letters[11:20])
)
print(x)
myref <- x$a
address(myref) == address(x$a) # they are the same
ss2_set(myref, vars = "cola", tf = \(x)x^2)
print(x) # notice x has been changed


}
