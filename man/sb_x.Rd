% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generic_x.R
\name{sb_x}
\alias{sb_x}
\alias{sb_x.default}
\alias{sb_x.matrix}
\alias{sb_x.array}
\alias{sb_x.factor}
\alias{sb2_x}
\alias{sb2_x.default}
\alias{sb2_x.array}
\alias{sb2_x.data.frame}
\title{Method to Extract, Exchange, or Duplicate Subsets of an Object}
\usage{
sb_x(x, ...)

\method{sb_x}{default}(x, i, ..., rat = getOption("squarebrackets.rat", FALSE))

\method{sb_x}{matrix}(
  x,
  row = NULL,
  col = NULL,
  i = NULL,
  ...,
  rat = getOption("squarebrackets.rat", FALSE)
)

\method{sb_x}{array}(
  x,
  idx = NULL,
  dims = NULL,
  rcl = NULL,
  i = NULL,
  ...,
  rat = getOption("squarebrackets.rat", FALSE)
)

\method{sb_x}{factor}(
  x,
  i = NULL,
  lvl = NULL,
  drop = FALSE,
  ...,
  rat = getOption("squarebrackets.rat", FALSE)
)

sb2_x(x, ...)

\method{sb2_x}{default}(x, i, drop = FALSE, ..., rat = getOption("squarebrackets.rat", FALSE))

\method{sb2_x}{array}(
  x,
  idx = NULL,
  dims = NULL,
  i = NULL,
  drop = FALSE,
  ...,
  rat = getOption("squarebrackets.rat", FALSE)
)

\method{sb2_x}{data.frame}(x, row = NULL, col = NULL, filter = NULL, vars = NULL, ...)
}
\arguments{
\item{x}{see \link{squarebrackets_immutable_classes} and \link{squarebrackets_mutable_classes}.}

\item{...}{further arguments passed to or from other methods.}

\item{i, lvl, row, col, idx, dims, rcl, filter, vars}{See \link{squarebrackets_indx_args}. \cr
Duplicates are allowed, resulting in duplicated indices. \cr
An empty index selection results in an empty object of length 0. \cr}

\item{rat}{Boolean, indicating if attributes should be returned with the sub-setted object.
See Details section for more info. \cr
\ifelse{html}{\figure{for_performance-set_to_FALSE-red.svg}{options: alt='[for performance: set to FALSE]'}}{\link[=squarebrackets_help]{for performance: set to FALSE}} \cr}

\item{drop}{Boolean.
\itemize{
\item For factors: If \code{drop = TRUE}, unused levels are dropped, if \code{drop = FALSE} they are not dropped.
\item For lists: if \code{drop = TRUE},
and sub-setting is done using argument \code{i},
selecting a single element will give the simplified result,
like using \verb{[[]]}.
If \code{drop = FALSE}, a list is always returned regardless of the number of elements.
}}
}
\value{
Returns a copy of the sub-setted object.
}
\description{
This is an S3 Method to extract, exchange,
or duplicate (i.e. repeat x times) subsets of an object. \cr
Use \code{sb_x(x, ...)} if \code{x} is a non-recursive object (i.e. atomic or factor). \cr
Use \code{sb2_x(x, ...)} if \code{x} is a recursive object (i.e. list or data.frame-like). \cr \cr
}
\details{
\bold{One the \code{rat} argument} \cr
Most \code{[} - methods strip most (but not all) attributes. \cr
If \code{rat = FALSE}, this default behaviour is preserved,
for compatibility with special classes. This is the fastest option. \cr
If \code{rat = TRUE},
attributes from \code{x} missing after sub-setting are re-assigned to \code{x}.
Already existing attributes after sub-setting will not be overwritten. \cr
There is no \code{rat} argument for data.frame-like object:
their attributes will always be preserved. \cr
NOTE: In the following situations, the \code{rat} argument will be ignored,
as the attributes necessarily have to be dropped:
\itemize{
\item when \code{x} is a list, AND \code{drop = TRUE},
AND a single element is selected,
AND sub-setting is done through the \code{i} argument.
\item when \code{x} is an atomic matrix or array,
and sub-setting is done through the \code{i} argument. \cr \cr
}
}
\examples{


# atomic objects ====

obj <- matrix(1:16, ncol = 4)
colnames(obj) <- c("a", "b", "c", "a")
print(obj)
sb_x(obj, 1:3, 1:3)
# above is equivalent to obj[1:3, 1:3, drop = FALSE]
sb_x(obj, i = \(x)x>5)
# above is equivalent to obj[obj > 5]
sb_x(obj, col = c("a", "a"))
# above is equivalent to obj[, lapply(c("a", "a"), \(i) which(colnames(obj) == i)) |> unlist()]

obj <- array(1:64, c(4,4,3))
print(obj)
sb_x(obj, n(1:3, 1:2), c(1,3))
sb_x(obj, rcl = n(1:3, NULL, 1:2))
# above 2 lines are equivalent to obj[1:3, , 1:2, drop = FALSE]
sb_x(obj, i = \(x)x>5)
# above is equivalent to obj[obj > 5]

#############################################################################



# factors ====

obj <- factor(rep(letters[1:5], 2))
sb_x(obj, lvl = c("a", "a"))
# above is equivalent to obj[lapply(c("a", "a"), \(i) which(obj == i)) |> unlist()]

#############################################################################


# lists ====

obj <- list(a = 1:10, b = letters[1:11], c = 11:20)
print(obj)
sb2_x(obj, 1) # obj[1]
sb2_x(obj, 1, drop = TRUE) # obj[[1]]
sb2_x(obj, 1:2) # obj[1:2]
sb2_x(obj, is.numeric) # obj[sapply(obj, is.numeric)]
# for recursive indexing, see sb2_rec()

################################################################################


# recursive arrays / dimensional lists ====
obj <- c(as.list(1:10), as.list(letters[1:10])) |> array(dim = c(5, 4)) |> t()
print(obj)
sb2_x(obj, list(1:3), 1)
# above is equivalent to obj[1:3, ]


#############################################################################

# data.frame-like objects ====

obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]))
print(obj)
sb2_x(obj, 1:3, 1:3) # obj[1:3, 1:3, drop = FALSE]
sb2_x(obj, filter = ~ (a > 5) & (c < 19), vars = is.numeric)


}
