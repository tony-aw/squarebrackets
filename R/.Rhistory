#' x[,1]
#' x[] <- as.double(x) # notifies the user a copy is being made
#' print(x) # "typeof" attribute adjusted accordingly, and class still present
#'
#'
#'
#' @name class_mutable_atomic
NULL
#' @rdname class_mutable_atomic
#' @export
mutable_atomic <- function(data, names = NULL, dim = NULL, dimnames = NULL) {
if(!is.atomic(data)) {
stop("non-atomic data given")
}
x <- structure(
data, class = "mutable_atomic", typeof = typeof(data),
names = names, dim = dim, dimnames = dimnames
)
return(x)
}
#' @rdname class_mutable_atomic
#' @export
as.mutable_atomic <- function(x, ...) {
if(!is.atomic(x)) {
stop("not atomic")
}
if(is.mutable_atomic(x)) {
return(x)
}
y <- x
attr(y, "typeof") <- typeof(x)
class(y) <- c("mutable_atomic", class(y))
return(y)
}
#' @rdname class_mutable_atomic
#' @export
is.mutable_atomic <- function(x) {
if(!is.atomic(x)) return(FALSE)
check1 <- !data.table::`%chin%`(.rcpp_address(x), getOption("squarebrackets.protected"))
check2 <- inherits(x, "mutable_atomic") && isTRUE(attr(x, "typeof") == typeof(x))
return(check1 && check2)
}
#' @rdname class_mutable_atomic
#' @export
`[.mutable_atomic` <- function(x, ...) {
y <- NextMethod("[")
attr(y, "typeof") <- typeof(x)
class(y) <- c("mutable_atomic", oldClass(x))
y
}
#' @rdname class_mutable_atomic
#' @export
`[<-.mutable_atomic` <- function(x, ..., value) {
message("copying on modification; for modification by reference, use `sb_set()`")
oc <- oldClass(x)
class(x) <- NULL
x[...] <- value
attr(x, "typeof") <- typeof(x)
class(x) <- oc
x
}
#' @rdname class_mutable_atomic
#' @export
format.mutable_atomic <- function(x, ...) {
class(x) <- setdiff(class(x), "mutable_atomic")
format(x, ...)
}
#' @rdname class_mutable_atomic
#' @export
print.mutable_atomic <- function(x, ...) {
class(x) <- setdiff(class(x), "mutable_atomic")
print(x, ...)
cat("mutable_atomic \n")
cat(paste("typeof: ", typeof(x), "\n"))
}
#' @keywords internal
#' @noRd
.protected_addresses <- function() {
tempfun <- function(x) {
if(!is.function(x)) {
return(.rcpp_address(x))
}
}
lst <- eapply(baseenv(), tempfun, all.names = FALSE)
lst <- lst[sapply(lst, \(x)!is.null(x))]
return(unlist(lst))
}
x <- mutable_atomic(1:20, dim = c(5,4), dimnames = list(letters[1:5], letters[1:4]))
x
#' Mutable Atomic Classes
#'
#' @description
#' The `mutable_atomic` class is a mutable version of atomic classes. \cr
#' It works exactly the same in all aspects as regular atomic classes,
#' with only one real difference: \cr
#' `sb_set()` accepts `mutable_atomic`, but does not accept regular `atomic`. \cr
#' This separate class, although a shallow difference, is done on purpose: \cr
#' If regular atomic classes would be allowed as input for `sb_set()`,
#' dangerous modifications
#' (like `sb_set(base::letters, i = 1, rp = "XXX"`)
#' could be possible. \cr
#' \cr
#' Like `data.table`, `[<-` performs R's default copy-on-modification semantics. \cr
#' For modification  by reference, use `sb_set()`. \cr
#' \cr
#' The `is.mutable_atomic()` function checks if an object is atomic.
#'
#'
#' @param x an atomic object.
#' @param value see \link[base]{Extract}.
#' @param ... method dependent arguments.
#'
#' @section Warning:
#'
#' Always use `mutable_atomic()` or `as.mutable_atomic` to create a mutable object. \cr
#' Do NOT attempt to manually create a mutable atomic object by tweaking attributes: \cr
#' `mutable_atomic()` and `as.mutable_atomic` make some necessary checks so that other functions,
#' such as `sb_set()`,
#' don't have to spend computation time to perform these checks also. \cr
#' Circumventing these checks may break things. \cr \cr
#'
#'
#' @returns
#' `as.mutable_atomic` converts an atomic object (vector, matrix, array)
#' to the same object, but with additional class `"mutable_atomic"`,
#' and the additional attribute `"typeof"`. \cr
#' \cr
#' `is.mutable_atomic` returns `TRUE` if the object is atomic, has
#' the class `"mutable_atomic"`, \bold{and} has the correctly set attribute `"typeof"`; \cr
#' `is.mutable_atomic` returns `FALSE` otherwise.
#'
#'
#' @examples
#'
#' x <- mutable_atomic(1:20, dim = c(5,4), dimnames = list(letters[1:5], letters[1:4]))
#' x
#'
#' x <- matrix(1:10, ncol = 2)
#' x <- as.mutable_atomic(x)
#' is.mutable_atomic(x)
#' print(x)
#' x[,1]
#' x[] <- as.double(x) # notifies the user a copy is being made
#' print(x) # "typeof" attribute adjusted accordingly, and class still present
#'
#'
#'
#' @name class_mutable_atomic
NULL
#' @rdname class_mutable_atomic
#' @export
mutable_atomic <- function(data, names = NULL, dim = NULL, dimnames = NULL) {
if(!is.atomic(data)) {
stop("non-atomic data given")
}
x <- structure(
data, class = "mutable_atomic", typeof = typeof(data),
names = names, dim = dim, dimnames = dimnames
)
return(x)
}
#' @rdname class_mutable_atomic
#' @export
as.mutable_atomic <- function(x, ...) {
if(!is.atomic(x)) {
stop("not atomic")
}
if(is.mutable_atomic(x)) {
return(x)
}
y <- x
attr(y, "typeof") <- typeof(x)
class(y) <- c("mutable_atomic", class(y))
return(y)
}
#' @rdname class_mutable_atomic
#' @export
is.mutable_atomic <- function(x) {
if(!is.atomic(x)) return(FALSE)
check1 <- !data.table::`%chin%`(.rcpp_address(x), getOption("squarebrackets.protected"))
check2 <- inherits(x, "mutable_atomic") && isTRUE(attr(x, "typeof") == typeof(x))
return(check1 && check2)
}
#' @rdname class_mutable_atomic
#' @export
`[.mutable_atomic` <- function(x, ...) {
y <- NextMethod("[")
attr(y, "typeof") <- typeof(x)
class(y) <- c("mutable_atomic", oldClass(x))
y
}
#' @rdname class_mutable_atomic
#' @export
`[<-.mutable_atomic` <- function(x, ..., value) {
message("copying on modification; for modification by reference, use `sb_set()`")
oc <- oldClass(x)
class(x) <- NULL
x[...] <- value
attr(x, "typeof") <- typeof(x)
class(x) <- oc
x
}
#' @rdname class_mutable_atomic
#' @export
format.mutable_atomic <- function(x, ...) {
class(x) <- setdiff(class(x), "mutable_atomic")
format(x, ...)
}
#' @rdname class_mutable_atomic
#' @export
print.mutable_atomic <- function(x, ...) {
class(x) <- setdiff(class(x), "mutable_atomic")
attr(x, "typeof") <- NULL
print(x, ...)
cat("mutable_atomic \n")
cat(paste("typeof: ", typeof(x), "\n"))
}
#' @keywords internal
#' @noRd
.protected_addresses <- function() {
tempfun <- function(x) {
if(!is.function(x)) {
return(.rcpp_address(x))
}
}
lst <- eapply(baseenv(), tempfun, all.names = FALSE)
lst <- lst[sapply(lst, \(x)!is.null(x))]
return(unlist(lst))
}
x <- mutable_atomic(1:20, dim = c(5,4), dimnames = list(letters[1:5], letters[1:4]))
x
factor(letters)
?typeof
View(x)
x
class(x)
x
is.matrix(x)
View(as.matrix(x))
class(x)
dim(x)
#' @rdname class_mutable_atomic
#' @export
mutable_atomic <- function(data, names = NULL, dim = NULL, dimnames = NULL) {
if(!is.atomic(data)) {
stop("non-atomic data given")
}
if(length(dim) == 2) {
x <- structure(
data, class = c("mutable_atomic", "matrix", "array"), typeof = typeof(data),
names = names, dim = dim, dimnames = dimnames
)
return(x)
}
if(length(dim) > 2) {
x <- structure(
data, class = c("mutable_atomic", "array"), typeof = typeof(data),
names = names, dim = dim, dimnames = dimnames
)
return(x)
}
x <- structure(
data, class = c("mutable_atomic", class(data)), typeof = typeof(data),
names = names, dim = dim, dimnames = dimnames
)
return(x)
}
x <- mutable_atomic(1:20, dim = c(5,4), dimnames = list(letters[1:5], letters[1:4]))
x
View(x)
class(x)
is.matrix(x)
matrix(as.Date(1:10), ncol = 2)
as.Date(1:10)
x <- matrix(as.Date(1:10), ncol = 2)
View(x)
is.POSIXct(x)
is.Date
x <- mutable_atomic(1:20, dim = c(5,4), dimnames = list(letters[1:4], letters[1:4]))
x <- mutable_atomic(1:20, dim = c(5,4), dimnames = list(letters[1:5], letters[1:4]))
x
View(x)
structure
NULL > 2
library(fastmap)
?fastmap
m <- fastmap()
# Set some key-value pairs
m$set("x", 100)
m$set("letters", c("a", "b", "c"))
m$mset(numbers = c(10, 20, 30), nothing = NULL)
m
m$as_list()
m2 <- m
library(squarebrackets)
address(m)
address(m2)
m$set("y", 200)
m2$as_list()
m$as_list()
library(collections)
?collections::dict
d <- d2 <- dict(list(apple = 5, orange = 10))
d2$as_list()
d$as_list()
d$set("banana", 3)
d$get("apple")
d$as_list()  # unordered
d$pop("orange")
d$as_list()  # "orange" is removed
d$set("orange", 3)$set("pear", 7)  # chain method
d$as_list()
d2$as_list()
?squarebrackets::sb_x
?collapse::ss
dt_set_aslist <- function(x, row, col, filter, vars, method = 1, rp) {
if(method == 1) {
for(i in collapse::seq_col(x)) {
temp <- x[[ col[i] ]]
temp[row] <- rp[i]
data.table::set(x, j = col[i], value = temp)
}
}
if(method == 2) {
temp <- collapse::ss(x, j = col, check = FALSE)
temp[row, col] <- rp
data.table::set(x, j = col[i], value = temp)
}
}
x <- data.table::data.table(
a = letters,
b = 1:26
)
x <- data.table::data.table(
a = sample(c(TRUE, FALSE, NA), 26, TRUE),
b = 1:26,
c = c(rnorm(25), NaN),
d = letters,
e = factor(letters)
f = as.complex(1:26)
x <- data.table::data.table(
a = sample(c(TRUE, FALSE, NA), 26, TRUE),
b = 1:26,
c = c(rnorm(25), NaN),
d = letters,
e = factor(letters),
f = as.complex(1:26)
)
dt_set_aslist <- function(x, row, col, filter, vars, method = 1, rp) {
if(method == 1) {
for(i in collapse::seq_col(x)) {
temp <- x[[ col[i] ]]
temp[row] <- rp[[i]]
data.table::set(x, j = col[i], value = temp)
}
}
if(method == 2) {
temp <- collapse::ss(x, j = col, check = FALSE)
temp[row, col] <- rp
data.table::set(x, j = col[i], value = temp)
}
}
dt_set_aslist(x, 1:2, 2:3, method = 2, rp = list(c("a", "b"), c(-10, -20)))
rlang::global_entrace()
dt_set_aslist(x, 1:2, 2:3, method = 2, rp = list(c("a", "b"), c(-10, -20)))
rlang::last_trace()
dt_set_aslist <- function(x, row, col, filter, vars, method = 1, rp) {
if(method == 1) {
for(i in collapse::seq_col(x)) {
temp <- x[[ col[i] ]]
temp[row] <- rp[[i]]
data.table::set(x, j = col[i], value = temp)
}
}
if(method == 2) {
temp <- collapse::ss(x, j = col, check = FALSE)
temp[row, col] <- rp
data.table::set(x, j = col, value = temp)
}
}
x <- data.table::data.table(
a = sample(c(TRUE, FALSE, NA), 26, TRUE),
b = 1:26,
c = c(rnorm(25), NaN),
d = letters,
e = factor(letters),
f = as.complex(1:26)
)
dt_set_aslist(x, 1:2, 2:3, method = 2, rp = list(c("a", "b"), c(-10, -20)))
col = 2:3
temp <- collapse::ss(x, j = col, check = FALSE)
rp = list(c("a", "b"), c(-10, -20))
temp <- collapse::ss(x, j = col, check = FALSE)
temp[row, col] <- rp
row = 1:2
temp <- collapse::ss(x, j = col, check = FALSE)
temp[row, col] <- rp
rp
temp[row, col]
temp <- collapse::qDF(collapse::ss(x, j = col, check = FALSE))
temp[row, col] <- rp
data.table::set(x, j = col, value = temp)
col
temp <- collapse::qDF(collapse::ss(x, j = col, check = FALSE))
temp[row, col] <- rp
col
row
rp
temp <- collapse::qDF(collapse::ss(x, j = col, check = FALSE))
temp[row, col] <- collapse::qDF(rp)
View(temp)
temp <- collapse::qDF(collapse::ss(x, j = col, check = FALSE))
temp[row,] <- collapse::qDF(rp)
data.table::set(x, j = col, value = temp)
dt_set_aslist <- function(x, row, col, filter, vars, method = 1, rp) {
if(method == 1) {
for(i in collapse::seq_col(x)) {
temp <- x[[ col[i] ]]
temp[row] <- rp[[i]]
data.table::set(x, j = col[i], value = temp)
}
}
if(method == 2) {
temp <- collapse::qDF(collapse::ss(x, j = col, check = FALSE))
temp[row,] <- collapse::qDF(rp)
data.table::set(x, j = col, value = temp)
}
}
x <- data.table::data.table(
a = sample(c(TRUE, FALSE, NA), 26, TRUE),
b = 1:26,
c = c(rnorm(25), NaN),
d = letters,
e = factor(letters),
f = as.complex(1:26)
)
dt_set_aslist(x, 1:2, 2:3, method = 2, rp = list(c("a", "b"), c(-10, -20)))
x
dt_set_aslist(x, 1:2, 2:3, method = 1, rp = list(c("a", "b"), c(-10, -20)))
rlang::last_trace()
dt_set_aslist <- function(x, row, col, filter, vars, method = 1, rp) {
if(method == 1) {
for(i in seq_along(col)) {
temp <- x[[ col[i] ]]
temp[row] <- rp[[i]]
data.table::set(x, j = col[i], value = temp)
}
}
if(method == 2) {
temp <- collapse::qDF(collapse::ss(x, j = col, check = FALSE))
temp[row,] <- collapse::qDF(rp)
data.table::set(x, j = col, value = temp)
}
}
x <- data.table::data.table(
a = sample(c(TRUE, FALSE, NA), 26, TRUE),
b = 1:26,
c = c(rnorm(25), NaN),
d = letters,
e = factor(letters),
f = as.complex(1:26)
)
dt_set_aslist(x, 1:2, 2:3, method = 1, rp = list(c("a", "b"), c(-10, -20)))
x
?fastmap::is.key_missing()
fastmap::is.key_missing
?fastmap::fastmap
?collections::`collections-package`
x <- 1:10
x[] <- as.logical(x)
x
x[] <- as.logical(x)
z
x
x[] <- sample(c(TRUE, FALSE, NA), length(x), TRUE)
x
x[] <- as.logical(x)
x
typeof(x)
?structure
x <- matrix(1:10, ncol = 2)
colnames(x) <- c("a", "b")
x
as.logical(x)
names(x) <- letters[1:10]
x
as.logical(x)
?attributes
attr(x, "test") <- "test"
x
x[] <- as.logical(x)
x
tinycodet::as_bool
x
x[] <- collapse::unattrib(x)
x
x[] <- collapse::unattrib(x)
collapse::unattrib(x)
install.packages("listArray")
listArray::listArray(1:10)
x <- listArray::listArray(1:10)
View(x)
is.array(x)
View(x)
?`[`
x <- as.list(1:20)
dim(x) <- c(5, 4)
x
x[,1]
x[,1, drop = FALSE]
library(squarebrackets)
?squarebrackets::aaa3_squarebrackets_indx_args
