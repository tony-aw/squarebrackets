return(invisible(NULL))
}
if(!missing(tf)) {
rp <- tf(slice_rm(x, start, end, by))
}
.rcpp_slice_setinv(x, rp, start - 1L, end - 1L, abs(by), len_mod)
return(invisible(NULL))
}
x
slice_rm(x, 25, 1)
slice_rm(x, 1, 25)
slice_rm(x, 1, 24)
slice_rm(x, 24,1)
slice_set(x, 1, 2, rp = "XXX")
x
x = letters
inv = FALSE
#' Efficient Sequence-based Subset Methods on (Long) Vectors
#'
#' @description
#' The `slice_` - methods are similar to the `sb_` - methods,
#' except they don't require an indexing vector,
#' and are designed for speed and memory efficiency. \cr \cr
#'
#' @param x an atomic object. \cr
#' For `slice_set` it must be a \link{mutable_atomic} \bold{variable}.
#' @param from,to,by see \link{cp_seq}.
#' @param rp,tf see \link{squarebrackets_modify}.
#' @param names Boolean, indicating if flat names should be preserved. \cr
#' Note that, since `slice` operates on flat indices only, `dimnames` are always dropped.
#' @param mostattr Boolean, indicating if `mostattributes` should be preserved. \cr
#'
#'
#' @returns
#' Similar to the `sb_` methods.
#'
#' @example inst/examples/slice.R
#
#' @rdname slice
#' @export
slice_x <- function(
x, from = NULL, to = NULL, by = 1L,
names = TRUE, mostattr = TRUE
) {
myslice <- cp_seq(x, 0L, from, to, by)
start <- myslice$start
end <- myslice$end
by <- myslice$by
len <- myslice$length
if(len == 0L) {
return(vector(typeof(x), length = 0L))
}
if(by > 0) {
out <- .rcpp_slice_x(x, start - 1L, end - 1L, abs(by), len)
}
else if(by < 0) {
out <- .rcpp_slice_xrev(x, start - 1L, end - 1L, abs(by), len)
}
if(!is.null(names(x)) && names) {
nms <- slice_x(names(x), from, to, by, names = FALSE, mostattr = FALSE)
data.table::setattr(out, "names", nms)
}
if(mostattr) {
mostattributes(out) <- attributes(x)
}
return(out)
}
#' @rdname slice
#' @export
slice_rm <- function(
x, from = NULL, to = NULL, by = 1L,
names = TRUE, mostattr = TRUE
) {
myslice <- cp_seq(x, 0L, from, to, by)
by <- myslice$by
len_rm <- myslice$length.out
len_x <- length(x) - myslice$length.out
if(len_rm == 0L) {
return(x)
}
if(len_rm == length(x)) {
return(vector(typeof(x), length = 0L))
}
if(myslice$start > myslice$end) {
start <- myslice$end
end <- myslice$start
}
else {
start <- myslice$start
end <- myslice$end
}
out <- .rcpp_slice_rm(x, start - 1L, end - 1L, abs(by), len_x)
if(!is.null(names(x)) && names) {
nms <- slice_rm(names(x), from, to, by, names = FALSE, mostattr = FALSE)
data.table::setattr(out, "names", nms)
}
if(mostattr) {
mostattributes(out) <- attributes(x)
}
return(out)
}
#' @rdname slice
#' @export
slice_set <- function(x, from = NULL, to = NULL, by = 1L, inv = FALSE, rp, tf) {
.internal_check_rptf(rp, tf, sys.call())
myslice <- cp_seq(x, 0L, from, to, by)
start <- myslice$start
end <- myslice$end
by <- myslice$by
len <- myslice$length
# call correct internal function
if(!inv && start <= end) {
.slice_set(x, start, end, by, len, rp, tf)
return(invisible(NULL))
}
else if(!inv && start > end) {
.slice_setrev(x, start, end, by, len, rp, tf)
return(invisible(NULL))
}
else if(inv) {
.slice_setinv(x, start, end, by, len, rp, tf)
return(invisible(NULL))
}
else {
stop("improper input given")
}
}
#' @keywords internal
#' @noRd
.slice_set <- function(x, start, end, by, len, rp, tf) {
if(!missing(tf)) {
rp <- tf(slice_x(x, start, end, by))
}
if(len == 0) {
return(invisible(NULL))
}
.rcpp_slice_set(x, rp, start - 1L, end - 1L, abs(by), len)
return(invisible(NULL))
}
#' @keywords internal
#' @noRd
.slice_setrev <- function(x, start, end, by, len, rp, tf) {
if(len == 0) {
return(invisible(NULL))
}
if(!missing(tf)) {
rp <- tf(slice_x(x, start, end, by))
}
.rcpp_slice_setrev(x, rp, start - 1L, end - 1L, abs(by), len)
return(invisible(NULL))
}
#' @keywords internal
#' @noRd
.slice_setinv <- function(x, start, end, by, len, rp, tf) {
if(start > end ) {
oldstart <- start
oldend <- end
start <- oldend
end <- oldstart
}
myslice <- cp_seq(x, 0L, from, to, by)
by <- abs(myslice$by)
len_rm <- myslice$length.out
len_mod <- length(x) - myslice$length.out
if(len_mod == 0) {
return(invisible(NULL))
}
if(!missing(tf)) {
rp <- tf(slice_rm(x, start, end, by))
}
.rcpp_slice_setinv(x, rp, start - 1L, end - 1L, abs(by), len_mod)
return(invisible(NULL))
}
x
x = letters
x
x = mutable_atomic(1:10)
x
slice_set(x, 1, 10, rp = -1)
x
slice_set(x, 1, 10, rp = -1)
x = mutable_atomic(1:10)
slice_set(x, 1, 5, rp = -1)
x
x = mutable_atomic(1:10)
slice_set(x, 1, 5, rp = -1, inv = TRUE)
#' Efficient Sequence-based Subset Methods on (Long) Vectors
#'
#' @description
#' The `slice_` - methods are similar to the `sb_` - methods,
#' except they don't require an indexing vector,
#' and are designed for speed and memory efficiency. \cr \cr
#'
#' @param x an atomic object. \cr
#' For `slice_set` it must be a \link{mutable_atomic} \bold{variable}.
#' @param from,to,by see \link{cp_seq}.
#' @param rp,tf see \link{squarebrackets_modify}.
#' @param names Boolean, indicating if flat names should be preserved. \cr
#' Note that, since `slice` operates on flat indices only, `dimnames` are always dropped.
#' @param mostattr Boolean, indicating if `mostattributes` should be preserved. \cr
#'
#'
#' @returns
#' Similar to the `sb_` methods.
#'
#' @example inst/examples/slice.R
#
#' @rdname slice
#' @export
slice_x <- function(
x, from = NULL, to = NULL, by = 1L,
names = TRUE, mostattr = TRUE
) {
myslice <- cp_seq(x, 0L, from, to, by)
start <- myslice$start
end <- myslice$end
by <- myslice$by
len <- myslice$length
if(len == 0L) {
return(vector(typeof(x), length = 0L))
}
if(by > 0) {
out <- .rcpp_slice_x(x, start - 1L, end - 1L, abs(by), len)
}
else if(by < 0) {
out <- .rcpp_slice_xrev(x, start - 1L, end - 1L, abs(by), len)
}
if(!is.null(names(x)) && names) {
nms <- slice_x(names(x), from, to, by, names = FALSE, mostattr = FALSE)
data.table::setattr(out, "names", nms)
}
if(mostattr) {
mostattributes(out) <- attributes(x)
}
return(out)
}
#' @rdname slice
#' @export
slice_rm <- function(
x, from = NULL, to = NULL, by = 1L,
names = TRUE, mostattr = TRUE
) {
myslice <- cp_seq(x, 0L, from, to, by)
by <- myslice$by
len_rm <- myslice$length.out
len_x <- length(x) - myslice$length.out
if(len_rm == 0L) {
return(x)
}
if(len_rm == length(x)) {
return(vector(typeof(x), length = 0L))
}
if(myslice$start > myslice$end) {
start <- myslice$end
end <- myslice$start
}
else {
start <- myslice$start
end <- myslice$end
}
out <- .rcpp_slice_rm(x, start - 1L, end - 1L, abs(by), len_x)
if(!is.null(names(x)) && names) {
nms <- slice_rm(names(x), from, to, by, names = FALSE, mostattr = FALSE)
data.table::setattr(out, "names", nms)
}
if(mostattr) {
mostattributes(out) <- attributes(x)
}
return(out)
}
#' @rdname slice
#' @export
slice_set <- function(x, from = NULL, to = NULL, by = 1L, inv = FALSE, rp, tf) {
.internal_check_rptf(rp, tf, sys.call())
myslice <- cp_seq(x, 0L, from, to, by)
start <- myslice$start
end <- myslice$end
by <- myslice$by
len <- myslice$length
# call correct internal function
if(!inv && start <= end) {
.slice_set(x, start, end, by, len, rp, tf)
return(invisible(NULL))
}
else if(!inv && start > end) {
.slice_setrev(x, start, end, by, len, rp, tf)
return(invisible(NULL))
}
else if(inv) {
.slice_setinv(x, start, end, by, len, rp, tf)
return(invisible(NULL))
}
else {
stop("improper input given")
}
}
#' @keywords internal
#' @noRd
.slice_set <- function(x, start, end, by, len, rp, tf) {
if(!missing(tf)) {
rp <- tf(slice_x(x, start, end, by))
}
if(len == 0) {
return(invisible(NULL))
}
.rcpp_slice_set(x, rp, start - 1L, end - 1L, abs(by), len)
return(invisible(NULL))
}
#' @keywords internal
#' @noRd
.slice_setrev <- function(x, start, end, by, len, rp, tf) {
if(len == 0) {
return(invisible(NULL))
}
if(!missing(tf)) {
rp <- tf(slice_x(x, start, end, by))
}
.rcpp_slice_setrev(x, rp, start - 1L, end - 1L, abs(by), len)
return(invisible(NULL))
}
#' @keywords internal
#' @noRd
.slice_setinv <- function(x, start, end, by, len, rp, tf) {
if(start > end ) {
oldstart <- start
oldend <- end
start <- oldend
end <- oldstart
}
len_rm <- len
len_mod <- length(x) - len
if(len_mod == 0) {
return(invisible(NULL))
}
if(!missing(tf)) {
rp <- tf(slice_rm(x, start, end, by))
}
.rcpp_slice_setinv(x, rp, start - 1L, end - 1L, abs(by), len_mod)
return(invisible(NULL))
}
x
slice_set(x, 1, 5, rp = -1, inv = TRUE)
x
#' Efficient Sequence-based Subset Methods on (Long) Vectors
#'
#' @description
#' The `slice_` - methods are similar to the `sb_` - methods,
#' except they don't require an indexing vector,
#' and are designed for speed and memory efficiency. \cr \cr
#'
#' @param x an atomic object. \cr
#' For `slice_set` it must be a \link{mutable_atomic} \bold{variable}.
#' @param from,to,by see \link{cp_seq}.
#' @param rp,tf see \link{squarebrackets_modify}.
#' @param names Boolean, indicating if flat names should be preserved. \cr
#' Note that, since `slice` operates on flat indices only, `dimnames` are always dropped.
#' @param mostattr Boolean, indicating if `mostattributes` should be preserved. \cr
#'
#'
#' @returns
#' Similar to the `sb_` methods.
#'
#' @example inst/examples/slice.R
#
#' @rdname slice
#' @export
slice_x <- function(
x, from = NULL, to = NULL, by = 1L,
names = TRUE, mostattr = TRUE
) {
myslice <- cp_seq(x, 0L, from, to, by)
start <- myslice$start
end <- myslice$end
by <- myslice$by
len <- myslice$length
if(len == 0L) {
return(vector(typeof(x), length = 0L))
}
if(by > 0) {
out <- .rcpp_slice_x(x, start - 1L, end - 1L, abs(by), len)
}
else if(by < 0) {
out <- .rcpp_slice_xrev(x, start - 1L, end - 1L, abs(by), len)
}
if(!is.null(names(x)) && names) {
nms <- slice_x(names(x), from, to, by, names = FALSE, mostattr = FALSE)
data.table::setattr(out, "names", nms)
}
if(mostattr) {
mostattributes(out) <- attributes(x)
}
return(out)
}
#' @rdname slice
#' @export
slice_rm <- function(
x, from = NULL, to = NULL, by = 1L,
names = TRUE, mostattr = TRUE
) {
myslice <- cp_seq(x, 0L, from, to, by)
by <- myslice$by
len_rm <- myslice$length.out
len_x <- length(x) - myslice$length.out
if(len_rm == 0L) {
return(x)
}
if(len_rm == length(x)) {
return(vector(typeof(x), length = 0L))
}
if(myslice$start > myslice$end) {
start <- myslice$end
end <- myslice$start
}
else {
start <- myslice$start
end <- myslice$end
}
out <- .rcpp_slice_rm(x, start - 1L, end - 1L, abs(by), len_x)
if(!is.null(names(x)) && names) {
nms <- slice_rm(names(x), from, to, by, names = FALSE, mostattr = FALSE)
data.table::setattr(out, "names", nms)
}
if(mostattr) {
mostattributes(out) <- attributes(x)
}
return(out)
}
#' @rdname slice
#' @export
slice_set <- function(x, from = NULL, to = NULL, by = 1L, inv = FALSE, rp, tf) {
if(!is.mutable_atomic(x)){
stop("`x` is not a (supported) mutable object")
}
.internal_check_rptf(rp, tf, sys.call())
.check_bindingIsLocked(substitute(x), parent.frame(n = 1), abortcall = sys.call())
myslice <- cp_seq(x, 0L, from, to, by)
start <- myslice$start
end <- myslice$end
by <- myslice$by
len <- myslice$length
# call correct internal function
if(!inv && start <= end) {
.slice_set(x, start, end, by, len, rp, tf)
return(invisible(NULL))
}
else if(!inv && start > end) {
.slice_setrev(x, start, end, by, len, rp, tf)
return(invisible(NULL))
}
else if(inv) {
.slice_setinv(x, start, end, by, len, rp, tf)
return(invisible(NULL))
}
else {
stop("improper input given")
}
}
#' @keywords internal
#' @noRd
.slice_set <- function(x, start, end, by, len, rp, tf) {
if(!missing(tf)) {
rp <- tf(slice_x(x, start, end, by))
}
if(len == 0) {
return(invisible(NULL))
}
.rcpp_slice_set(x, rp, start - 1L, end - 1L, abs(by), len)
return(invisible(NULL))
}
#' @keywords internal
#' @noRd
.slice_setrev <- function(x, start, end, by, len, rp, tf) {
if(len == 0) {
return(invisible(NULL))
}
if(!missing(tf)) {
rp <- tf(slice_x(x, start, end, by))
}
.rcpp_slice_setrev(x, rp, start - 1L, end - 1L, abs(by), len)
return(invisible(NULL))
}
#' @keywords internal
#' @noRd
.slice_setinv <- function(x, start, end, by, len, rp, tf) {
if(start > end ) {
oldstart <- start
oldend <- end
start <- oldend
end <- oldstart
}
len_rm <- len
len_mod <- length(x) - len
if(len_mod == 0) {
return(invisible(NULL))
}
if(!missing(tf)) {
rp <- tf(slice_rm(x, start, end, by))
}
.rcpp_slice_setinv(x, rp, start - 1L, end - 1L, abs(by), len_mod)
return(invisible(NULL))
}
x
x = mutable_atomic(1:10)
slice_set(x, -1i, 5, rp = -1)
z
x
x = mutable_atomic(1:10)
slice_set(x, -1i, 5, rp = -1, inv = TRUE)
x
slice_rm(x, -1i, 5)
x <- mutable_atomic(1:10)
slice_rm(x, -1i, 5)
