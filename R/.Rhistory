#'
#'
#' @name class_mutable_atomic
NULL
#' @rdname class_mutable_atomic
#' @export
mutable_atomic <- function(data, names = NULL, dim = NULL, dimnames = NULL) {
if(!is.atomic(data)) {
stop("non-atomic data given")
}
x <- structure(
data, class = "mutable_atomic", typeof = typeof(data),
names = names, dim = dim, dimnames = dimnames
)
return(x)
}
#' @rdname class_mutable_atomic
#' @export
as.mutable_atomic <- function(x, ...) {
if(!is.atomic(x)) {
stop("not atomic")
}
if(is.mutable_atomic(x)) {
return(x)
}
y <- x
attr(y, "typeof") <- typeof(x)
class(y) <- c("mutable_atomic", class(y))
return(y)
}
#' @rdname class_mutable_atomic
#' @export
is.mutable_atomic <- function(x) {
if(!is.atomic(x)) return(FALSE)
check1 <- !data.table::`%chin%`(.rcpp_address(x), getOption("squarebrackets.protected"))
check2 <- inherits(x, "mutable_atomic") && isTRUE(attr(x, "typeof") == typeof(x))
return(check1 && check2)
}
#' @rdname class_mutable_atomic
#' @export
`[.mutable_atomic` <- function(x, ...) {
y <- NextMethod("[")
attr(y, "typeof") <- typeof(x)
class(y) <- c("mutable_atomic", oldClass(x))
y
}
#' @rdname class_mutable_atomic
#' @export
`[<-.mutable_atomic` <- function(x, ..., value) {
message("copying on modification; for modification by reference, use `sb_set()`")
oc <- oldClass(x)
class(x) <- NULL
x[...] <- value
attr(x, "typeof") <- typeof(x)
class(x) <- oc
x
}
#' @rdname class_mutable_atomic
#' @export
format.mutable_atomic <- function(x, ...) {
class(x) <- setdiff(class(x), "mutable_atomic")
format(x, ...)
}
#' @rdname class_mutable_atomic
#' @export
print.mutable_atomic <- function(x, ...) {
class(x) <- setdiff(class(x), "mutable_atomic")
attr(x, "typeof") <- NULL
print(x, ...)
cat("mutable_atomic \n")
cat(paste("typeof: ", typeof(x), "\n"))
}
#' @keywords internal
#' @noRd
.protected_addresses <- function() {
tempfun <- function(x) {
if(!is.function(x)) {
return(.rcpp_address(x))
}
}
lst <- eapply(baseenv(), tempfun, all.names = FALSE)
lst <- lst[sapply(lst, \(x)!is.null(x))]
return(unlist(lst))
}
x <- mutable_atomic(1:20, dim = c(5,4), dimnames = list(letters[1:5], letters[1:4]))
x
factor(letters)
?typeof
View(x)
x
class(x)
x
is.matrix(x)
View(as.matrix(x))
class(x)
dim(x)
#' @rdname class_mutable_atomic
#' @export
mutable_atomic <- function(data, names = NULL, dim = NULL, dimnames = NULL) {
if(!is.atomic(data)) {
stop("non-atomic data given")
}
if(length(dim) == 2) {
x <- structure(
data, class = c("mutable_atomic", "matrix", "array"), typeof = typeof(data),
names = names, dim = dim, dimnames = dimnames
)
return(x)
}
if(length(dim) > 2) {
x <- structure(
data, class = c("mutable_atomic", "array"), typeof = typeof(data),
names = names, dim = dim, dimnames = dimnames
)
return(x)
}
x <- structure(
data, class = c("mutable_atomic", class(data)), typeof = typeof(data),
names = names, dim = dim, dimnames = dimnames
)
return(x)
}
x <- mutable_atomic(1:20, dim = c(5,4), dimnames = list(letters[1:5], letters[1:4]))
x
View(x)
class(x)
is.matrix(x)
matrix(as.Date(1:10), ncol = 2)
as.Date(1:10)
x <- matrix(as.Date(1:10), ncol = 2)
View(x)
is.POSIXct(x)
is.Date
x <- mutable_atomic(1:20, dim = c(5,4), dimnames = list(letters[1:4], letters[1:4]))
x <- mutable_atomic(1:20, dim = c(5,4), dimnames = list(letters[1:5], letters[1:4]))
x
View(x)
structure
NULL > 2
library(fastmap)
?fastmap
m <- fastmap()
# Set some key-value pairs
m$set("x", 100)
m$set("letters", c("a", "b", "c"))
m$mset(numbers = c(10, 20, 30), nothing = NULL)
m
m$as_list()
m2 <- m
library(squarebrackets)
address(m)
address(m2)
m$set("y", 200)
m2$as_list()
m$as_list()
library(collections)
?collections::dict
d <- d2 <- dict(list(apple = 5, orange = 10))
d2$as_list()
d$as_list()
d$set("banana", 3)
d$get("apple")
d$as_list()  # unordered
d$pop("orange")
d$as_list()  # "orange" is removed
d$set("orange", 3)$set("pear", 7)  # chain method
d$as_list()
d2$as_list()
?squarebrackets::sb_x
?collapse::ss
dt_set_aslist <- function(x, row, col, filter, vars, method = 1, rp) {
if(method == 1) {
for(i in collapse::seq_col(x)) {
temp <- x[[ col[i] ]]
temp[row] <- rp[i]
data.table::set(x, j = col[i], value = temp)
}
}
if(method == 2) {
temp <- collapse::ss(x, j = col, check = FALSE)
temp[row, col] <- rp
data.table::set(x, j = col[i], value = temp)
}
}
x <- data.table::data.table(
a = letters,
b = 1:26
)
x <- data.table::data.table(
a = sample(c(TRUE, FALSE, NA), 26, TRUE),
b = 1:26,
c = c(rnorm(25), NaN),
d = letters,
e = factor(letters)
f = as.complex(1:26)
x <- data.table::data.table(
a = sample(c(TRUE, FALSE, NA), 26, TRUE),
b = 1:26,
c = c(rnorm(25), NaN),
d = letters,
e = factor(letters),
f = as.complex(1:26)
)
dt_set_aslist <- function(x, row, col, filter, vars, method = 1, rp) {
if(method == 1) {
for(i in collapse::seq_col(x)) {
temp <- x[[ col[i] ]]
temp[row] <- rp[[i]]
data.table::set(x, j = col[i], value = temp)
}
}
if(method == 2) {
temp <- collapse::ss(x, j = col, check = FALSE)
temp[row, col] <- rp
data.table::set(x, j = col[i], value = temp)
}
}
dt_set_aslist(x, 1:2, 2:3, method = 2, rp = list(c("a", "b"), c(-10, -20)))
rlang::global_entrace()
dt_set_aslist(x, 1:2, 2:3, method = 2, rp = list(c("a", "b"), c(-10, -20)))
rlang::last_trace()
dt_set_aslist <- function(x, row, col, filter, vars, method = 1, rp) {
if(method == 1) {
for(i in collapse::seq_col(x)) {
temp <- x[[ col[i] ]]
temp[row] <- rp[[i]]
data.table::set(x, j = col[i], value = temp)
}
}
if(method == 2) {
temp <- collapse::ss(x, j = col, check = FALSE)
temp[row, col] <- rp
data.table::set(x, j = col, value = temp)
}
}
x <- data.table::data.table(
a = sample(c(TRUE, FALSE, NA), 26, TRUE),
b = 1:26,
c = c(rnorm(25), NaN),
d = letters,
e = factor(letters),
f = as.complex(1:26)
)
dt_set_aslist(x, 1:2, 2:3, method = 2, rp = list(c("a", "b"), c(-10, -20)))
col = 2:3
temp <- collapse::ss(x, j = col, check = FALSE)
rp = list(c("a", "b"), c(-10, -20))
temp <- collapse::ss(x, j = col, check = FALSE)
temp[row, col] <- rp
row = 1:2
temp <- collapse::ss(x, j = col, check = FALSE)
temp[row, col] <- rp
rp
temp[row, col]
temp <- collapse::qDF(collapse::ss(x, j = col, check = FALSE))
temp[row, col] <- rp
data.table::set(x, j = col, value = temp)
col
temp <- collapse::qDF(collapse::ss(x, j = col, check = FALSE))
temp[row, col] <- rp
col
row
rp
temp <- collapse::qDF(collapse::ss(x, j = col, check = FALSE))
temp[row, col] <- collapse::qDF(rp)
View(temp)
temp <- collapse::qDF(collapse::ss(x, j = col, check = FALSE))
temp[row,] <- collapse::qDF(rp)
data.table::set(x, j = col, value = temp)
dt_set_aslist <- function(x, row, col, filter, vars, method = 1, rp) {
if(method == 1) {
for(i in collapse::seq_col(x)) {
temp <- x[[ col[i] ]]
temp[row] <- rp[[i]]
data.table::set(x, j = col[i], value = temp)
}
}
if(method == 2) {
temp <- collapse::qDF(collapse::ss(x, j = col, check = FALSE))
temp[row,] <- collapse::qDF(rp)
data.table::set(x, j = col, value = temp)
}
}
x <- data.table::data.table(
a = sample(c(TRUE, FALSE, NA), 26, TRUE),
b = 1:26,
c = c(rnorm(25), NaN),
d = letters,
e = factor(letters),
f = as.complex(1:26)
)
dt_set_aslist(x, 1:2, 2:3, method = 2, rp = list(c("a", "b"), c(-10, -20)))
x
dt_set_aslist(x, 1:2, 2:3, method = 1, rp = list(c("a", "b"), c(-10, -20)))
rlang::last_trace()
dt_set_aslist <- function(x, row, col, filter, vars, method = 1, rp) {
if(method == 1) {
for(i in seq_along(col)) {
temp <- x[[ col[i] ]]
temp[row] <- rp[[i]]
data.table::set(x, j = col[i], value = temp)
}
}
if(method == 2) {
temp <- collapse::qDF(collapse::ss(x, j = col, check = FALSE))
temp[row,] <- collapse::qDF(rp)
data.table::set(x, j = col, value = temp)
}
}
x <- data.table::data.table(
a = sample(c(TRUE, FALSE, NA), 26, TRUE),
b = 1:26,
c = c(rnorm(25), NaN),
d = letters,
e = factor(letters),
f = as.complex(1:26)
)
dt_set_aslist(x, 1:2, 2:3, method = 1, rp = list(c("a", "b"), c(-10, -20)))
x
?fastmap::is.key_missing()
fastmap::is.key_missing
?fastmap::fastmap
?collections::`collections-package`
x <- 1:10
x[] <- as.logical(x)
x
x[] <- as.logical(x)
z
x
x[] <- sample(c(TRUE, FALSE, NA), length(x), TRUE)
x
x[] <- as.logical(x)
x
typeof(x)
?structure
x <- matrix(1:10, ncol = 2)
colnames(x) <- c("a", "b")
x
as.logical(x)
names(x) <- letters[1:10]
x
as.logical(x)
?attributes
attr(x, "test") <- "test"
x
x[] <- as.logical(x)
x
tinycodet::as_bool
x
x[] <- collapse::unattrib(x)
x
x[] <- collapse::unattrib(x)
collapse::unattrib(x)
install.packages("listArray")
listArray::listArray(1:10)
x <- listArray::listArray(1:10)
View(x)
is.array(x)
View(x)
?`[`
x <- as.list(1:20)
dim(x) <- c(5, 4)
x
x[,1]
x[,1, drop = FALSE]
library(squarebrackets)
?squarebrackets::aaa3_squarebrackets_indx_args
Rcpp::cppFunction(
"
NumericVector rcpp_seq_rec(NumericVector inits, int w, int n, Function f) {
NumericVector x(n);
Range idx(0, w - 1);
x[idx] = inits;
for (int i = w; i < n; i++){
Range idx(i - w, i - 1);
x[i] = as<double>(f(x[idx]));
}
return x;
}
"
)
Rcpp::cppFunction(
"
NumericVector rcpp_seq_rec_minus(NumericVector inits, int w, int n, bool rev) {
NumericVector x(n);
Range idx(0, w - 1);
x[idx] = inits;
if(!rev) {
for (int i = w; i < n; i++){
Range idx(i - w, i - 1);
x[i] = x[i-1] - x[i-2];
}
}
if(rev) {
for (int i = w; i < n; i++){
Range idx(i - w, i - 1);
x[i] = x[i-2] - x[i-1];
}
}
return x;
}
"
)
library(squarebrackets)
seq_rec(f = \(x)x[2] - x[1])
Rcpp::cppFunction(
"
NumericVector rcpp_seq_rec_minus(NumericVector inits, int n, bool rev) {
NumericVector x(n);
Range idx(0, 1);
x[idx] = inits;
if(!rev) {
for (int i = 2; i < n; i++){
x[i] = x[i-1] - x[i-2];
}
}
if(rev) {
for (int i = 2; i < n; i++){
x[i] = x[i-2] - x[i-1];
}
}
return x;
}
"
)
seq_rec(f = \(x)x[2] - x[1])
rcpp_seq_rec_minus(c(0,1), 10L, FALSE)
rcpp_seq_rec_minus(c(0,1), 10L, TRUE)
seq_rec(f = \(x)x[1] - x[2])
Rcpp::cppFunction(
"
NumericVector rcpp_seq_rec_pow(NumericVector inits, int n, bool rev) {
NumericVector x(n);
Range idx(0, 1);
x[idx] = inits;
if(!rev) {
for (int i = 2; i < n; i++){
x[i] = pow(x[i-1], x[i-2]);
}
}
if(rev) {
for (int i = 2; i < n; i++){
x[i] = pow(x[i-2], x[i-1]);
}
}
return x;
}
"
)
rcpp_seq_rec_pow(c(0,1), 10L)
rcpp_seq_rec_pow(c(0,1), 10L, FALSE)
rcpp_seq_rec_pow(c(0,1), 10L, FALSE)
squarebrackets::seq_rec(f = \(x)x[2]^x[1])
squarebrackets::seq_rec(f = \(x)x[1]^x[2])
rcpp_seq_rec_pow(c(0,1), 10L, TRUE)
rcpp_seq_rec_pow(c(1,2), 10L, TRUE)
squarebrackets::seq_rec(c(1,2), f = \(x)x[1]^x[2])
rcpp_seq_rec_pow(c(1.5,2.5), 10L, TRUE)
rcpp_seq_rec_pow(c(1.5,2.5), 10L, FALSE)
rcpp_seq_rec_pow(c(1.1,1.3), 10L, FALSE)
squarebrackets::seq_rec(c(1.1,1.3), f = \(x)x[1]^x[2])
squarebrackets::seq_rec(c(1.1,1.3), f = \(x)x[2]^x[1])
Rcpp::cppFunction(
"
NumericVector rcpp_seq_rec_log(NumericVector inits, int n, bool rev) {
NumericVector x(n);
Range idx(0, 1);
x[idx] = inits;
if(!rev) {
for (int i = 2; i < n; i++){
x[i] = log(x[i-2]) / log(x[i-1]); // = log_a(b)
}
}
if(rev) {
for (int i = 2; i < n; i++){
x[i] = log(x[i-1]) / log(x[i-2]); // = log_b(a)
}
}
return x;
}
"
)
?log
squarebrackets::seq_rec(c(1.1,1.3), f = \(x)log(x[2], base = log(x[1])))
squarebrackets::seq_rec(c(1,2), f = \(x)log(x[2], base = log(x[1])))
squarebrackets::seq_rec(c(2,1), f = \(x)log(x[2], base = log(x[1])))
squarebrackets::seq_rec(c(20,10), f = \(x)log(x[2], base = log(x[1])))
squarebrackets::seq_rec(c(200,100), f = \(x)log(x[2], base = log(x[1])))
squarebrackets::seq_rec(c(200,10), f = \(x)log(x[2], base = log(x[1])))
Rcpp::cppFunction(
"
NumericVector rcpp_seq_rec_log(NumericVector inits, int n, bool rev) {
NumericVector x(n);
Range idx(0, 1);
x[idx] = inits;
if(!rev) {
for (int i = 2; i < n; i++){
x[i] = log(x[i-2]) / log(x[i-1]); // = log_a(b)
}
}
if(rev) {
for (int i = 2; i < n; i++){
x[i] = log(x[i-1]) / log(x[i-2]); // = log_b(a)
}
}
return x;
}
"
)
rcpp_seq_rec_log(c(200,10), 10L, FALSE)
squarebrackets::seq_rec(c(200,10), f = \(x)log(x[2], base = log(x[1])))
squarebrackets::seq_rec(c(200,10), f = \(x)log(x[1], base = log(x[2])))
