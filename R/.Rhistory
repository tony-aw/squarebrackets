print(x)
cat(paste("typeof: ", typeof(x)))
format.factor
?format.factor
?data.table::format.ITime
#' Mutable Atomic Classes
#'
#' @description
#' The `mutable_atomic` class is a mutable version of atomic classes. \cr
#' It works exactly the same in all aspects as regular atomic classes,
#' with only one real difference: \cr
#' `sb_set()` accepts `mutable_atomic`, but does not accept regular `atomic`. \cr
#' This separate class, although a shallow difference, is done on purpose: \cr
#' If regular atomic classes would be allowed as input for `sb_set()`,
#' dangerous modifications
#' (like `sb_set(base::letters, i = 1, rp = "XXX"`)
#' could be possible. \cr
#' \cr
#' Like `data.table`, `[<-` performs R's default copy-on-modification semantics. \cr
#' For modification  by reference, use `sb_set()`. \cr
#' \cr
#' The `is.mutable_atomic()` function checks if an object is atomic.
#'
#'
#' @param x an atomic object.
#' @param value see \link[base]{Extract}.
#' @param ... method dependent arguments.
#'
#' @section Warning:
#'
#' Always use `mutable_atomic()` or `as.mutable_atomic` to create a mutable object. \cr
#' Do NOT attempt to manually create a mutable atomic object by tweaking attributes: \cr
#' `mutable_atomic()` and `as.mutable_atomic` make some necessary checks so that other functions,
#' such as `sb_set()`,
#' don't have to spend computation time to perform these checks also. \cr
#' Circumventing these checks may break things. \cr \cr
#'
#'
#' @returns
#' `as.mutable_atomic` converts an atomic object (vector, matrix, array)
#' to the same object, but with additional class `"mutable_atomic"`,
#' and the additional attribute `"typeof"`. \cr
#' \cr
#' `is.mutable_atomic` returns `TRUE` if the object is atomic, has
#' the class `"mutable_atomic"`, \bold{and} has the correctly set attribute `"typeof"`; \cr
#' `is.mutable_atomic` returns `FALSE` otherwise.
#'
#'
#' @examples
#'
#' x <- mutable_atomic(1:20, dim = c(5,4), dimnames = list(letters[1:5], letters[1:4]))
#'
#'
#' x <- matrix(1:10, ncol = 2)
#' x <- as.mutable_atomic(x)
#' is.mutable_atomic(x)
#' print(x)
#' x[,1]
#' x[] <- as.double(x) # notifies the user a copy is being made
#' print(x) # "typeof" attribute adjusted accordingly, and class still present
#'
#'
#'
#' @name class_mutable_atomic
NULL
#' @rdname class_mutable_atomic
#' @export
mutable_atomic <- function(data, names = NULL, dim = NULL, dimnames = NULL) {
if(!is.atomic(data)) {
stop("non-atomic data given")
}
x <- structure(
data, class = "mutable_atomic", typeof = typeof(data),
names = names, dim = dim, dimnames = dimnames
)
return(x)
}
#' @rdname class_mutable_atomic
#' @export
as.mutable_atomic <- function(x, ...) {
if(!is.atomic(x)) {
stop("not atomic")
}
if(is.mutable_atomic(x)) {
return(x)
}
y <- x
attr(y, "typeof") <- typeof(x)
class(y) <- c("mutable_atomic", class(y))
return(y)
}
#' @rdname class_mutable_atomic
#' @export
is.mutable_atomic <- function(x) {
if(!is.atomic(x)) return(FALSE)
check1 <- !data.table::`%chin%`(.rcpp_address(x), getOption("squarebrackets.protected"))
check2 <- inherits(x, "mutable_atomic") && isTRUE(attr(x, "typeof") == typeof(x))
return(check1 && check2)
}
#' @rdname class_mutable_atomic
#' @export
`[.mutable_atomic` <- function(x, ...) {
y <- NextMethod("[")
attr(y, "typeof") <- typeof(x)
class(y) <- c("mutable_atomic", oldClass(x))
y
}
#' @rdname class_mutable_atomic
#' @export
`[<-.mutable_atomic` <- function(x, ..., value) {
message("copying on modification; for modification by reference, use `sb_set()`")
oc <- oldClass(x)
class(x) <- NULL
x[...] <- value
attr(x, "typeof") <- typeof(x)
class(x) <- oc
x
}
#' @rdname class_mutable_atomic
#' @export
format.mutable_atomic <- function(x, ...) {
class(x) <- setdiff(class(x), "mutable_atomic")
format(x, ...)
}
#' @rdname class_mutable_atomic
#' @export
print.mutable_atomic <- function(x, ...) {
class(x) <- setdiff(class(x), "mutable_atomic")
print(x, ...)
cat("mutable_atomic")
cat(paste("typeof: ", typeof(x)))
}
#' @keywords internal
#' @noRd
.protected_addresses <- function() {
tempfun <- function(x) {
if(!is.function(x)) {
return(.rcpp_address(x))
}
}
lst <- eapply(baseenv(), tempfun, all.names = FALSE)
lst <- lst[sapply(lst, \(x)!is.null(x))]
return(unlist(lst))
}
x <- mutable_atomic(1:20, dim = c(5,4), dimnames = list(letters[1:5], letters[1:4]))
x
#' Mutable Atomic Classes
#'
#' @description
#' The `mutable_atomic` class is a mutable version of atomic classes. \cr
#' It works exactly the same in all aspects as regular atomic classes,
#' with only one real difference: \cr
#' `sb_set()` accepts `mutable_atomic`, but does not accept regular `atomic`. \cr
#' This separate class, although a shallow difference, is done on purpose: \cr
#' If regular atomic classes would be allowed as input for `sb_set()`,
#' dangerous modifications
#' (like `sb_set(base::letters, i = 1, rp = "XXX"`)
#' could be possible. \cr
#' \cr
#' Like `data.table`, `[<-` performs R's default copy-on-modification semantics. \cr
#' For modification  by reference, use `sb_set()`. \cr
#' \cr
#' The `is.mutable_atomic()` function checks if an object is atomic.
#'
#'
#' @param x an atomic object.
#' @param value see \link[base]{Extract}.
#' @param ... method dependent arguments.
#'
#' @section Warning:
#'
#' Always use `mutable_atomic()` or `as.mutable_atomic` to create a mutable object. \cr
#' Do NOT attempt to manually create a mutable atomic object by tweaking attributes: \cr
#' `mutable_atomic()` and `as.mutable_atomic` make some necessary checks so that other functions,
#' such as `sb_set()`,
#' don't have to spend computation time to perform these checks also. \cr
#' Circumventing these checks may break things. \cr \cr
#'
#'
#' @returns
#' `as.mutable_atomic` converts an atomic object (vector, matrix, array)
#' to the same object, but with additional class `"mutable_atomic"`,
#' and the additional attribute `"typeof"`. \cr
#' \cr
#' `is.mutable_atomic` returns `TRUE` if the object is atomic, has
#' the class `"mutable_atomic"`, \bold{and} has the correctly set attribute `"typeof"`; \cr
#' `is.mutable_atomic` returns `FALSE` otherwise.
#'
#'
#' @examples
#'
#' x <- mutable_atomic(1:20, dim = c(5,4), dimnames = list(letters[1:5], letters[1:4]))
#' x
#'
#' x <- matrix(1:10, ncol = 2)
#' x <- as.mutable_atomic(x)
#' is.mutable_atomic(x)
#' print(x)
#' x[,1]
#' x[] <- as.double(x) # notifies the user a copy is being made
#' print(x) # "typeof" attribute adjusted accordingly, and class still present
#'
#'
#'
#' @name class_mutable_atomic
NULL
#' @rdname class_mutable_atomic
#' @export
mutable_atomic <- function(data, names = NULL, dim = NULL, dimnames = NULL) {
if(!is.atomic(data)) {
stop("non-atomic data given")
}
x <- structure(
data, class = "mutable_atomic", typeof = typeof(data),
names = names, dim = dim, dimnames = dimnames
)
return(x)
}
#' @rdname class_mutable_atomic
#' @export
as.mutable_atomic <- function(x, ...) {
if(!is.atomic(x)) {
stop("not atomic")
}
if(is.mutable_atomic(x)) {
return(x)
}
y <- x
attr(y, "typeof") <- typeof(x)
class(y) <- c("mutable_atomic", class(y))
return(y)
}
#' @rdname class_mutable_atomic
#' @export
is.mutable_atomic <- function(x) {
if(!is.atomic(x)) return(FALSE)
check1 <- !data.table::`%chin%`(.rcpp_address(x), getOption("squarebrackets.protected"))
check2 <- inherits(x, "mutable_atomic") && isTRUE(attr(x, "typeof") == typeof(x))
return(check1 && check2)
}
#' @rdname class_mutable_atomic
#' @export
`[.mutable_atomic` <- function(x, ...) {
y <- NextMethod("[")
attr(y, "typeof") <- typeof(x)
class(y) <- c("mutable_atomic", oldClass(x))
y
}
#' @rdname class_mutable_atomic
#' @export
`[<-.mutable_atomic` <- function(x, ..., value) {
message("copying on modification; for modification by reference, use `sb_set()`")
oc <- oldClass(x)
class(x) <- NULL
x[...] <- value
attr(x, "typeof") <- typeof(x)
class(x) <- oc
x
}
#' @rdname class_mutable_atomic
#' @export
format.mutable_atomic <- function(x, ...) {
class(x) <- setdiff(class(x), "mutable_atomic")
format(x, ...)
}
#' @rdname class_mutable_atomic
#' @export
print.mutable_atomic <- function(x, ...) {
class(x) <- setdiff(class(x), "mutable_atomic")
print(x, ...)
cat("mutable_atomic \n")
cat(paste("typeof: ", typeof(x), "\n"))
}
#' @keywords internal
#' @noRd
.protected_addresses <- function() {
tempfun <- function(x) {
if(!is.function(x)) {
return(.rcpp_address(x))
}
}
lst <- eapply(baseenv(), tempfun, all.names = FALSE)
lst <- lst[sapply(lst, \(x)!is.null(x))]
return(unlist(lst))
}
x <- mutable_atomic(1:20, dim = c(5,4), dimnames = list(letters[1:5], letters[1:4]))
x
#' Mutable Atomic Classes
#'
#' @description
#' The `mutable_atomic` class is a mutable version of atomic classes. \cr
#' It works exactly the same in all aspects as regular atomic classes,
#' with only one real difference: \cr
#' `sb_set()` accepts `mutable_atomic`, but does not accept regular `atomic`. \cr
#' This separate class, although a shallow difference, is done on purpose: \cr
#' If regular atomic classes would be allowed as input for `sb_set()`,
#' dangerous modifications
#' (like `sb_set(base::letters, i = 1, rp = "XXX"`)
#' could be possible. \cr
#' \cr
#' Like `data.table`, `[<-` performs R's default copy-on-modification semantics. \cr
#' For modification  by reference, use `sb_set()`. \cr
#' \cr
#' The `is.mutable_atomic()` function checks if an object is atomic.
#'
#'
#' @param x an atomic object.
#' @param value see \link[base]{Extract}.
#' @param ... method dependent arguments.
#'
#' @section Warning:
#'
#' Always use `mutable_atomic()` or `as.mutable_atomic` to create a mutable object. \cr
#' Do NOT attempt to manually create a mutable atomic object by tweaking attributes: \cr
#' `mutable_atomic()` and `as.mutable_atomic` make some necessary checks so that other functions,
#' such as `sb_set()`,
#' don't have to spend computation time to perform these checks also. \cr
#' Circumventing these checks may break things. \cr \cr
#'
#'
#' @returns
#' `as.mutable_atomic` converts an atomic object (vector, matrix, array)
#' to the same object, but with additional class `"mutable_atomic"`,
#' and the additional attribute `"typeof"`. \cr
#' \cr
#' `is.mutable_atomic` returns `TRUE` if the object is atomic, has
#' the class `"mutable_atomic"`, \bold{and} has the correctly set attribute `"typeof"`; \cr
#' `is.mutable_atomic` returns `FALSE` otherwise.
#'
#'
#' @examples
#'
#' x <- mutable_atomic(1:20, dim = c(5,4), dimnames = list(letters[1:5], letters[1:4]))
#' x
#'
#' x <- matrix(1:10, ncol = 2)
#' x <- as.mutable_atomic(x)
#' is.mutable_atomic(x)
#' print(x)
#' x[,1]
#' x[] <- as.double(x) # notifies the user a copy is being made
#' print(x) # "typeof" attribute adjusted accordingly, and class still present
#'
#'
#'
#' @name class_mutable_atomic
NULL
#' @rdname class_mutable_atomic
#' @export
mutable_atomic <- function(data, names = NULL, dim = NULL, dimnames = NULL) {
if(!is.atomic(data)) {
stop("non-atomic data given")
}
x <- structure(
data, class = "mutable_atomic", typeof = typeof(data),
names = names, dim = dim, dimnames = dimnames
)
return(x)
}
#' @rdname class_mutable_atomic
#' @export
as.mutable_atomic <- function(x, ...) {
if(!is.atomic(x)) {
stop("not atomic")
}
if(is.mutable_atomic(x)) {
return(x)
}
y <- x
attr(y, "typeof") <- typeof(x)
class(y) <- c("mutable_atomic", class(y))
return(y)
}
#' @rdname class_mutable_atomic
#' @export
is.mutable_atomic <- function(x) {
if(!is.atomic(x)) return(FALSE)
check1 <- !data.table::`%chin%`(.rcpp_address(x), getOption("squarebrackets.protected"))
check2 <- inherits(x, "mutable_atomic") && isTRUE(attr(x, "typeof") == typeof(x))
return(check1 && check2)
}
#' @rdname class_mutable_atomic
#' @export
`[.mutable_atomic` <- function(x, ...) {
y <- NextMethod("[")
attr(y, "typeof") <- typeof(x)
class(y) <- c("mutable_atomic", oldClass(x))
y
}
#' @rdname class_mutable_atomic
#' @export
`[<-.mutable_atomic` <- function(x, ..., value) {
message("copying on modification; for modification by reference, use `sb_set()`")
oc <- oldClass(x)
class(x) <- NULL
x[...] <- value
attr(x, "typeof") <- typeof(x)
class(x) <- oc
x
}
#' @rdname class_mutable_atomic
#' @export
format.mutable_atomic <- function(x, ...) {
class(x) <- setdiff(class(x), "mutable_atomic")
format(x, ...)
}
#' @rdname class_mutable_atomic
#' @export
print.mutable_atomic <- function(x, ...) {
class(x) <- setdiff(class(x), "mutable_atomic")
attr(x, "typeof") <- NULL
print(x, ...)
cat("mutable_atomic \n")
cat(paste("typeof: ", typeof(x), "\n"))
}
#' @keywords internal
#' @noRd
.protected_addresses <- function() {
tempfun <- function(x) {
if(!is.function(x)) {
return(.rcpp_address(x))
}
}
lst <- eapply(baseenv(), tempfun, all.names = FALSE)
lst <- lst[sapply(lst, \(x)!is.null(x))]
return(unlist(lst))
}
x <- mutable_atomic(1:20, dim = c(5,4), dimnames = list(letters[1:5], letters[1:4]))
x
factor(letters)
?typeof
View(x)
x
class(x)
x
is.matrix(x)
View(as.matrix(x))
class(x)
dim(x)
#' @rdname class_mutable_atomic
#' @export
mutable_atomic <- function(data, names = NULL, dim = NULL, dimnames = NULL) {
if(!is.atomic(data)) {
stop("non-atomic data given")
}
if(length(dim) == 2) {
x <- structure(
data, class = c("mutable_atomic", "matrix", "array"), typeof = typeof(data),
names = names, dim = dim, dimnames = dimnames
)
return(x)
}
if(length(dim) > 2) {
x <- structure(
data, class = c("mutable_atomic", "array"), typeof = typeof(data),
names = names, dim = dim, dimnames = dimnames
)
return(x)
}
x <- structure(
data, class = c("mutable_atomic", class(data)), typeof = typeof(data),
names = names, dim = dim, dimnames = dimnames
)
return(x)
}
x <- mutable_atomic(1:20, dim = c(5,4), dimnames = list(letters[1:5], letters[1:4]))
x
View(x)
class(x)
is.matrix(x)
matrix(as.Date(1:10), ncol = 2)
as.Date(1:10)
x <- matrix(as.Date(1:10), ncol = 2)
View(x)
is.POSIXct(x)
is.Date
x <- mutable_atomic(1:20, dim = c(5,4), dimnames = list(letters[1:4], letters[1:4]))
x <- mutable_atomic(1:20, dim = c(5,4), dimnames = list(letters[1:5], letters[1:4]))
x
View(x)
structure
NULL > 2
library(fastmap)
?fastmap
m <- fastmap()
# Set some key-value pairs
m$set("x", 100)
m$set("letters", c("a", "b", "c"))
m$mset(numbers = c(10, 20, 30), nothing = NULL)
m
m$as_list()
m2 <- m
library(squarebrackets)
address(m)
address(m2)
m$set("y", 200)
m2$as_list()
m$as_list()
library(collections)
?collections::dict
d <- d2 <- dict(list(apple = 5, orange = 10))
d2$as_list()
d$as_list()
d$set("banana", 3)
d$get("apple")
d$as_list()  # unordered
d$pop("orange")
d$as_list()  # "orange" is removed
d$set("orange", 3)$set("pear", 7)  # chain method
d$as_list()
d2$as_list()
?squarebrackets::sb_x
