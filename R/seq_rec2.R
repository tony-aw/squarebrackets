#' Generate Recursive Sequence Through Repeated Arithmetic Infix Operations
#'
#' @description
#' This is a recursive sequence generator. \cr
#' The function is essentially a
#' highly generalized version of a Fibonacci sequence generator. \cr
#' \cr
#' Starting with 2 initial values,
#' each next value `i` is generated by either one of 2 formulas:
#' 
#'  1) `x[i] = (s[1] + m[1] * x[i-1]) %inop% (s[2] + m[2] * x[i-2])`
#'  2) `x[i] = (m[1] * (x[i-1] + s[1])) %inop% (m[2] * (x[i-2] + s[2]))`
#' 
#' where `%inop%` is the arithmetic infix operator chosen, \cr
#' and `m` and `s` are each a numeric vector of length 2. \cr
#' The order of `x[i-1]` and `x[i-2]` can also be swapped. \cr \cr
#' 
#' 
#' @param inits a numeric (double or integer) vector of length `2`,
#' giving the initial values. \cr
#' Any numbers are allowed, even negative and/or fractional numbers. \cr
#' Note that numbers given must give valid results when passed to function \code{f()}. \cr
#' @param n a single integer,
#' giving the size of the numeric vector to generate. \cr
#' NOTE: it must hold that `n > 2`.
#' @param inop a single string,
#' giving the arithmetic infix operator to be used. \cr
#' Currently supported: "+", "-", "*", "/". \cr
#' For a fibonacci sequence, `inop = "+"`.
#' @param s,m numeric vectors of length 2 to be used in the formula.
#' @param form either `1` or `2`, indicating which formula to be used
#' (see Description section above).
#' @param rev reverse the order of `x[i-1]` and `x[-2]`. \cr
#' For example, using `form = 1`:
#'  * If `rev = FALSE` (default), it holds: \cr
#'  `x[i] = (s[1] + m[1] * x[i-1]) %inop% (s[2] + m[2] * x[i-2])`.
#'  * If `rev = TRUE`, it holds: \cr
#'  `x[i] = (s[1] + m[1] * x[i-2]) %inop% (s[2] + m[2] * x[i-1])` \cr \cr
#' 
#'
#' @details
#' The default values of the arguments give the first 10 numbers
#' of a regular Fibonacci sequence. \cr
#' See examples for several number series created with this function. \cr
#' This function is written in C++ using \code{Rcpp} for better performance. \cr \cr
#'
#'
#' @returns
#' A sequence of numbers. \cr \cr
#'
#'
#' @note
#' Do not supply `NA`s or `NaN`s to this function, as it cannot handle them. \cr \cr
#' 
#'
#' @example inst/examples/seq_rec2.R
#'

#' @rdname seq_rec2
#' @export
seq_rec2 <- function(
    inits = c(0L, 1L), n = 10L, s = c(0L, 0L), m = c(1L, 1L),
    inop = "+", form = 1L, rev = FALSE
) {
  
  # error handling:
  numchecks <- c(
    is.numeric(inits),
    is.numeric(n),
    is.numeric(s),
    is.numeric(m),
    is.numeric(form)
  )
  if(!all(numchecks)) {
    stop("`inits`, `n`, `s`, `m`, and `form` must all be numeric")
  }
  if(n <= 2) {
    stop("`n` must be greater than 2")
  }
  
  
  # FUNCTION:
  inop <- trimws(as.character(inop))
  
  if(inop == "+") {
    return(.rcpp_seq_rec2_plus(inits, n, s, m, form, rev))
  }
  else if(inop == "-") {
    return(.rcpp_seq_rec2_min(inits, n, s, m, form, rev))
  }
  else if(inop == "*") {
    return(.rcpp_seq_rec2_x(inits, n, s, m, form, rev))
  }
  else if(inop == "/" || inop == ":") {
    return(.rcpp_seq_rec2_div(inits, n, s, m, form, rev))
  }
  else {
    stop("unsupported arithmetic infix operator given")
  }
}

