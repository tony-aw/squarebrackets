[{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Benchmarks - extract, exchange, duplicate","text":"Due many checks conversions performed squarebrackets:: functions, make sub-setting programmatically beginner friendly, functions almost necessarily slower base R’s [-like operators. However, considerable effort made keep speed loss minimum. Generally, speed loss indeed negligible, cases even speed improvement (thanks heavy lifting performed ‘collapse’ package). benchmarks give one idea speed loss. just examples; speed determined great number factors.  ","code":"library(bench) library(ggplot2) library(patchwork)"},{"path":[]},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"matrix","dir":"Articles","previous_headings":"Atomic objects","what":"Matrix","title":"Benchmarks - extract, exchange, duplicate","text":" ","code":"n <- 5e3 x.mat <- matrix(seq_len(n*n), ncol = n) colnames(x.mat) <- sample(c(letters, NA), n, TRUE) sel.rows <- 1:100 sel.cols <- rep(sample(letters[1:13]), 10) bm.sb_x.matrix <- bench::mark(   \"squarebrackets\" = ss_x(x.mat, n(sel.rows, sel.cols)),   \"base R\" = x.mat[sel.rows, lapply(sel.cols, \\(i) which(colnames(x.mat) == i)) |> unlist(), drop = FALSE],   min_iterations = 500 ) bm.sb_x.matrix summary(bm.sb_x.matrix) #> # A tibble: 2 × 6 #>   expression          min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>     <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 squarebrackets   4.96ms   5.27ms      186.    9.71MB    1.12  #> 2 base R           8.13ms   9.83ms      101.    14.6MB    0.818"},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"array-3d","dir":"Articles","previous_headings":"Atomic objects","what":"Array (3D)","title":"Benchmarks - extract, exchange, duplicate","text":" ","code":"x.dims <- c(5000, 2000, 4) x.3d <- array(1:prod(x.dims), x.dims) sel.rows <- 1:900 sel.lyrs <- c(TRUE, FALSE, TRUE, FALSE) bm.sb_x.3d <- bench::mark(   \"squarebrackets\" =  ss_x(x.3d, n(sel.rows, sel.lyrs), c(1,3)),   \"base R + abind\" = abind::asub(x.3d, idx = list(sel.rows, sel.lyrs), dims = c(1,3)),   min_iterations = 500 ) summary(bm.sb_x.3d) #> # A tibble: 2 × 6 #>   expression          min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>     <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 squarebrackets   9.64ms   10.6ms      94.1    13.7MB     7.52 #> 2 base R + abind    9.7ms   10.7ms      92.8    13.7MB     6.56"},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"plot","dir":"Articles","previous_headings":"Atomic objects","what":"Plot","title":"Benchmarks - extract, exchange, duplicate","text":" ","code":"#> Loading required namespace: tidyr"},{"path":[]},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"data-frame","dir":"Articles","previous_headings":"Data.frame-like objects","what":"data.frame","title":"Benchmarks - extract, exchange, duplicate","text":" ","code":"n <- 1e5 chrmat <- matrix(   sample(letters, n*400, replace = TRUE), ncol = 400 ) intmat <- matrix(   seq.int(n*400), ncol = 400 ) x <- cbind(chrmat, intmat) |> as.data.frame() rm(list = c(\"chrmat\", \"intmat\")) colnames(x) <- make.names(colnames(x), unique = TRUE) sel.cols <- rep(sample(names(x), 10), 4) sel.rows <- 1:1000 bm.sb_x.df <- bench::mark(   \"squarebrackets\" = sbt_x(x, sel.rows,  sel.cols),   \"base R\" = x[sel.rows, sel.cols, drop = FALSE],   min_iterations = 500 ) summary(bm.sb_x.df) #> # A tibble: 2 × 6 #>   expression          min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>     <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 squarebrackets   99.8µs    112µs     7360.     318KB     2.34 #> 2 base R          282.5µs    306µs     3097.     377KB     0"},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"data-table","dir":"Articles","previous_headings":"Data.frame-like objects","what":"data.table","title":"Benchmarks - extract, exchange, duplicate","text":" ","code":"x <- data.tableas.data.table(x) tempfun <- function(x, i, j) {   x <- collapse::ss(x, i, j, check = TRUE)   names(x) <- make.names(names(x), unique = TRUE)   return(x) } bm.sb_x.dt <- bench::mark(   \"squarebrackets\" = sbt_x(x, obs = sel.rows, vars = sel.cols),   \"data.table + collapse\" = tempfun(x, sel.rows, sel.cols),   min_iterations = 1e4 ) summary(bm.sb_x.dt) #> # A tibble: 2 × 6 #>   expression                 min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>            <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 squarebrackets           134µs    147µs     6156.     342KB     1.23 #> 2 data.table + collapse    110µs    122µs     7255.     341KB     1.45"},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"plot-1","dir":"Articles","previous_headings":"Data.frame-like objects","what":"plot","title":"Benchmarks - extract, exchange, duplicate","text":" ","code":""},{"path":"https://tony-aw.github.io/squarebrackets/articles/b_benchmarks_tf.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Benchmarks - transform operations","text":"Base R’s [<-, [[<-, $<- methods perform -place modification subsets objects using “copy--modify” semantics. ‘squarebrackets’ R-package provides 2 alternative semantics modification: “pass--reference” *_set methods, “pass--value” *_mod methods. Moreover, base ‘R’ provides direct replacement , ‘squarebrackets’ provides replacement (rp argument) transformation (tf argument) mechanics. Thus, ‘squarebrackets’ base R really directly comparable terms benchmarking. Nonetheless, tried keep comparisons somewhat fair. *_set methods generally several times (2 5 times) faster base R’s -place modification, generally uses half memory. *_mod methods generally fast base R’s -place modification, uses amount memory. benchmarks give one idea speed loss. just examples; speed determined great number factors. keep comparisons classes fair, objects approximately 1e7 elements.  ","code":"library(bench) library(ggplot2) library(patchwork) library(tinycodet) #> Run `?tinycodet::tinycodet` to open the introduction help page of 'tinycodet'. plotfun <- function(title1, bm1, title2, bm2) {    plotdat1 <- bm1 |> tidyr::unnest(cols = c(\"time\", \"gc\", \"mem_alloc\"))   plotdat1$expression <- paste(     plotdat1$expression,     \"\\n (\", as.character(plotdat1$mem_alloc), \")\"   )   p1 <- ggplot(plotdat1, aes_pro(x = ~ time, y = ~ expression, color = ~ gc)) +   ggbeeswarm::geom_quasirandom() + ggtitle(title1)    plotdat2 <- bm2 |> tidyr::unnest(cols = c(\"time\", \"gc\", \"mem_alloc\"))   plotdat2$expression <- paste(     plotdat2$expression,     \"\\n (\", as.character(plotdat2$mem_alloc), \")\"   )   p2 <- ggplot(plotdat2, aes_pro(x = ~ time, y = ~ expression, color = ~ gc)) +   ggbeeswarm::geom_quasirandom() + ggtitle(title2)    combined <- p1 + p2 & theme(legend.position = \"bottom\")   combined + plot_layout(guides = \"collect\") }"},{"path":[]},{"path":"https://tony-aw.github.io/squarebrackets/articles/b_benchmarks_tf.html","id":"matrix","dir":"Articles","previous_headings":"Atomic objects","what":"Matrix","title":"Benchmarks - transform operations","text":" ","code":"n <- 3162 # approx sqrt(1e7) x.mat <- matrix(seq_len(n*n), ncol = n) x.mat2 <- as.mutable_atomic(x.mat) colnames(x.mat) <- sample(c(letters, LETTERS, NA), n, TRUE) sel.rows <- 1:1000 sel.cols <- 1:1000 basefun <- function(x, rows, cols, tf) {   x[rows, cols] <- tf(x[rows, cols])   return(x) } base_plus_idx <- function(x, rows, cols, tf) {   x[idx(x, n(rows, cols), 1:2)] <- tf(x[idx(x, n(rows, cols), 1:2)])   return(x) } tf <- function(x) { return(-1 * x) } bm.sb_tf.matrix <- bench::mark(   \"base [<-\" =  basefun(x.mat, sel.rows, sel.cols, tf = tf),   \"idx + [<-\" = base_plus_idx(x.mat, sel.rows, sel.cols, tf = tf),   \"ss_set\" = ss_set(x.mat2, n(sel.rows, sel.cols), tf = tf),   \"ss_mod\" = ss_mod(x.mat, n(sel.rows, sel.cols), tf = tf),   check = FALSE,   min_iterations = 500 ) bm.sb_tf.matrix summary(bm.sb_tf.matrix) #> # A tibble: 4 × 6 #>   expression      min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 base [<-    24.37ms  26.07ms      37.6    87.7MB     51.1 #> 2 idx + [<-   26.88ms  29.35ms      33.4    95.5MB     32.6 #> 3 ss_set       6.31ms   6.87ms     142.     15.4MB     11.7 #> 4 ss_mod       24.1ms  26.51ms      36.7    87.8MB     30.8"},{"path":"https://tony-aw.github.io/squarebrackets/articles/b_benchmarks_tf.html","id":"array-3d","dir":"Articles","previous_headings":"Atomic objects","what":"Array (3D)","title":"Benchmarks - transform operations","text":" ","code":"x.dims <- c(1900, 1900, 3) # leads to approx 1e7 elements x.3d <- array(1:prod(x.dims), x.dims) x.3d2 <- as.mutable_atomic(x.3d) sel.rows <- 1:900 sel.lyrs <- c(TRUE, FALSE, TRUE) basefun <- function(x, rows, lyrs, tf) {   x[rows, , lyrs] <- tf(x[rows, , lyrs])   return(x) } base_plus_idx <- function(x, rows, lyrs, tf) {   x[idx(x, n(rows, lyrs), c(1, 3))] <- tf(x[idx(x, n(rows, lyrs), c(1, 3))])   return(x) } tf <- function(x) { return(-1 * x) } bm.sb_tf.3d <- bench::mark(   \"base [<-\" = basefun(x.3d, sel.rows, sel.lyrs, tf = tf ),   \"idx + [<-\" = base_plus_idx(x.3d, sel.rows, sel.lyrs, tf = tf),   \"ss_set\" =  ss_set(x.3d2, n(sel.rows, sel.lyrs), c(1,3), tf = tf),   \"ss_mod\" = ss_mod(x.3d, n(sel.rows, sel.lyrs), c(1, 3), tf = tf),   check = FALSE,   min_iterations = 500 ) summary(bm.sb_tf.3d) #> # A tibble: 4 × 6 #>   expression      min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 base [<-     31.2ms   33.3ms      29.7    67.4MB    14.8  #> 2 idx + [<-    31.5ms   34.4ms      28.6    93.5MB    27.5  #> 3 ss_set       20.1ms   21.9ms      45.2    26.1MB     7.36 #> 4 ss_mod       31.3ms   33.9ms      29.3    68.2MB    18.9"},{"path":"https://tony-aw.github.io/squarebrackets/articles/b_benchmarks_tf.html","id":"plot","dir":"Articles","previous_headings":"Atomic objects","what":"Plot","title":"Benchmarks - transform operations","text":" ","code":"#> Warning: The `trans` argument of `continuous_scale()` is deprecated as of ggplot2 3.5.0. #> ℹ Please use the `transform` argument instead. #> This warning is displayed once every 8 hours. #> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was #> generated. #> Orientation inferred to be along y-axis; override with #> `position_quasirandom(orientation = 'x')` #> Orientation inferred to be along y-axis; override with #> `position_quasirandom(orientation = 'x')`"},{"path":"https://tony-aw.github.io/squarebrackets/articles/b_benchmarks_tf.html","id":"data-frame-like","dir":"Articles","previous_headings":"","what":"Data.frame-like","title":"Benchmarks - transform operations","text":"    ","code":"n <- 1e5 ncol <- 200 # times 2 chrmat <- matrix(   sample(letters, n*ncol, replace = TRUE), ncol = ncol ) intmat <- matrix(   seq.int(n*ncol), ncol = ncol ) df <- cbind(chrmat, intmat) |> as.data.frame() colnames(df) <- make.names(colnames(df), unique = TRUE) dt <- data.table::as.data.table(df) rm(list = c(\"chrmat\", \"intmat\"))  sel.rows <- 1:1000 basefun <- function(x, rows, tf) {   x[rows, sapply(x, is.numeric)] <- lapply(x[rows, sapply(x, is.numeric)], tf)   return(x) } gc() bm.sb_tf.df <- bench::mark(   \"base [<-\" = basefun(df, sel.rows, tf = \\(x) -1 * x),   \"sbt_set\" = sbt_set(     dt, obs = sel.rows, vars = is.numeric, tf = \\(x) -1 * x   ),   \"sbt_mod\" = sbt_mod(     df, obs = sel.rows, vars = is.numeric, tf = \\(x) -1 * x   ),   check = FALSE,   min_iterations = 500 ) #> # A tibble: 3 × 6 #>   expression      min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 base [<-      226µs    288µs     3229.    62.3KB        0 #> 2 sbt_set       112µs    149µs     6239.   120.8KB        0 #> 3 sbt_mod       113µs    171µs     5517.    41.3KB        0 #> Orientation inferred to be along y-axis; override with #> `position_quasirandom(orientation = 'x')`"},{"path":"https://tony-aw.github.io/squarebrackets/articles/squarebrackets.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Introduction to squarebrackets","text":"‘squarebrackets’ provides subset methods may convenient alternatives [ [<- operators, whilst maintaining similar performance. goal Vignette present problems sub-setting objects programmatically ‘R’, ‘squarebrackets’ package solves problems. Vignette starts solving sub-setting problems (simple) vectors. moves solving issue sub-setting arrays arbitrary number dimensions. many types data.frames next. end index-less sub-setting long vectors. order follow Vignette, reader needs familiar square-brackets operators ([, [<-, [[, [[<-), dimensional structures base ‘R’ (vectors, arrays, data.frames), familiarity atomic recursive types. vignette provide complete thorough explanation methods, functions, options available ‘squarebrackets’ package. vignette merely gives , reader, glimpse package . don’t worry don’t understand everything immediately. complete explanation available functionality can found package documentation .  ","code":""},{"path":"https://tony-aw.github.io/squarebrackets/articles/squarebrackets.html","id":"vectors-improved-index-specification","dir":"Articles","previous_headings":"","what":"Vectors: Improved Index Specification","title":"Introduction to squarebrackets","text":"‘squarebrackets’ provides set methods work atomic recursive vectors: ii_x extract subsets ii_wo return object without selected subset ii_mod return copy modified subsets ii_set modify object reference. base ‘R’ supports specifying indices sub-set operations logical, integer, character vectors. ‘squarebrackets’ enhances capabilities, adds possibilities. following sub-sections show capabilities; exhaustive list possibilities can found package documentation.  ","code":""},{"path":"https://tony-aw.github.io/squarebrackets/articles/squarebrackets.html","id":"specify-indices-by-names","dir":"Articles","previous_headings":"Vectors: Improved Index Specification","what":"Specify Indices by Names","title":"Introduction to squarebrackets","text":"Base ‘R’ selects first matching names selecting indices character vector. ‘squarebrackets’ selects matching names. example: select indices c(\"\", \"\", \"b\"), whilst ensuring indices names get selected, one needs following base ‘R’: See much easier ‘squarebrackets’!: ’s just shorter way, ‘squarebrackets’ faster, rely lapply() (friends) , uses compiled ‘C’ code.  ","code":"nms <- c(\"a\", sample(letters[1:4], 9, replace = TRUE)) x <- sample(1:10) names(x) <- nms print(x) # `x` has multiple elements with the name \"a\" #>  a  a  d  c  a  b  a  c  c  b  #>  2  3  1  5  7 10  6  4  9  8  x[\"a\"] # only selects only the first index with name \"a\" #> a  #> 2 ii_x(x, \"a\") # selects all indices with the name \"a\" #> a a a a  #> 2 3 7 6  x[c(\"a\", \"a\")] # repeats only the first index with name \"a\" #> a a  #> 2 2 ii_x(x, c(\"a\", \"a\")) # repeats all indices with the name \"a\" #> a a a a a a a a  #> 2 3 7 6 2 3 7 6 x[lapply(c(\"a\", \"a\", \"b\"), \\(i)which(names(x) == i)) |> unlist()] #>  a  a  a  a  a  a  a  a  b  b  #>  2  3  7  6  2  3  7  6 10  8 ii_x(x, c(\"a\", \"a\", \"b\")) #>  a  a  a  a  a  a  a  a  b  b  #>  2  3  7  6  2  3  7  6 10  8"},{"path":"https://tony-aw.github.io/squarebrackets/articles/squarebrackets.html","id":"inverting-index-specification","dir":"Articles","previous_headings":"Vectors: Improved Index Specification","what":"Inverting Index Specification","title":"Introduction to squarebrackets","text":"Inverting indices base ‘R’ done different ways. (negative numbers numeric indexing, negation logical indexing, manually un-matching character vectors). ‘squarebrackets’ provides (somewhat) consistent syntax invert indices: methods whose names end _x (like ii_x() shown ) perform extraction; invert extraction, .e. return object without specified subset, use methods whose names end _wo. modification methods (whose names end _mod _set) one can set argument inv = TRUE invert indices. consequence, removing sub-sets syntax extracting indices. example:  ","code":"x <- sample(1:10) names(x) <- letters[1:10]  x[\"a\"] # extract element \"a\" in base R #> a  #> 9 x[!names(x) %in% \"a\"] # but removing has different syntax #>  b  c  d  e  f  g  h  i  j  #>  5 10  1  7  8  6  2  3  4  ii_x(x, \"a\") # extract element \"a\" with 'squarebrackets' #> a  #> 9 ii_wo(x, \"a\") # remove element \"a\" with 'squarebrackets'; same syntax #>  b  c  d  e  f  g  h  i  j  #>  5 10  1  7  8  6  2  3  4"},{"path":"https://tony-aw.github.io/squarebrackets/articles/squarebrackets.html","id":"not-just-vectors","dir":"Articles","previous_headings":"Vectors: Improved Index Specification","what":"Not Just Vectors","title":"Introduction to squarebrackets","text":"given enhanced indexing just available regular vectors, types supported ‘squarebrackets’.  ","code":""},{"path":[]},{"path":"https://tony-aw.github.io/squarebrackets/articles/squarebrackets.html","id":"introduction-1","dir":"Articles","previous_headings":"Arrays: sub-setting unknown number of dimensions","what":"Introduction","title":"Introduction to squarebrackets","text":"order perform subset operations array x square brackets operator ([, [<-), one needs know many dimensions . example: Using x[, j, k] array 4 dimensions produces error, since number indices empty arguments conform number dimensions. suppose number dimensions array x unknown, example iterating many arrays may different number dimensions. one use [ [<- operators situation? ’s strictly impossible, convoluted. methods provided ‘squarebrackets’ use position-based arguments, work arbitrary dimensions without requiring prior knowledge.  ","code":"# if x has 3 dimensions: x[i, j, k, drop = FALSE] x[i, j, k] <- value  # if x has 4 dimensions: x[i, j, k, l, drop = FALSE] x[i, j, k, l] <- value"},{"path":"https://tony-aw.github.io/squarebrackets/articles/squarebrackets.html","id":"the-s-d-argument-pair","dir":"Articles","previous_headings":"Arrays: sub-setting unknown number of dimensions","what":"The s, d argument pair","title":"Introduction to squarebrackets","text":"‘squarebrackets’ provides set methods work arrays number dimensions: ss_x extract subsets ss_wo return object without selected subset ss_mod return copy modified subsets ss_set modify object reference. methods use s, d argument pair specify indices subset operations. argument form requires prior knowledge number dimensions object . s d must specified follows: s argument must list, specifying subscripts (.e. dimensional indices). d argument must integer vector, specifying dimensions s holds. subscripts dimensions specified d, s can also given atomic vector, list length 1. minimize keystrokes, ‘squarebrackets’ provides n() function, short-hand list(); n() nests multiple objects together, just like c() concatenates multiple objects together. .e. : specify rows 1:10, use s = 1:10, d = 1. specify layers (third dimension) 4:9, use s = 4:9 d = 3. specify rows 1:10 columns 2:5, use s = n(1:10, 2:5) d = 1:2. specify rows columns 1:5, one can use s = 1:5 d = 1:2. d argument default specification 1:ndim(x), ndim(x) = length(dim(x)).  ","code":""},{"path":"https://tony-aw.github.io/squarebrackets/articles/squarebrackets.html","id":"examples","dir":"Articles","previous_headings":"Arrays: sub-setting unknown number of dimensions","what":"Examples","title":"Introduction to squarebrackets","text":"Consider following example - Given set atomic arrays different dimensions, select first 2 indices every available dimension: s d argument used perform sub-setting. Since position-based system, like base ‘R’, works matrices arrays arbitrary dimension.   Another example - select first 3 indices first dimension, first 2 indices last available dimension, select indices dimensions. ‘squarebrackets’ allows user perform easy sub-set operations arrays, even dimensions known -priori, without ridiculously convoluted fiddling .call(), non-standard evaluation, ugly programming tricks. just works.  ","code":"lst <- list(   array(1:25, c(5, 5)), # matrix / 2d array   array(1:48, c(4, 4, 3)), # 3d array   array(1:240, c(4, 3, 4, 3)) # 4d array )  for(i in seq_along(lst)) {   x <- lst[[i]]   ss_x(x, s = 1:2, d = 1:ndim(x))   ss_x(x, 1:2) # the same (by default, d = 1:ndim(x)) } lst <- list(   array(1:25, c(5, 5)), # matrix / 2d array   array(1:48, c(4, 4, 3)), # 3d array   array(1:240, c(4, 3, 4, 3)) #4d array )  for(i in seq_along(lst)) {   x <- lst[[i]]   ss_x(x, n(1:3, 1:2), c(1, ndim(x)))   ss_x(x, s = n(1:3, 1:2), d = c(1, ndim(x))) # the same }"},{"path":"https://tony-aw.github.io/squarebrackets/articles/squarebrackets.html","id":"data-frame-different-types-different-rules","dir":"Articles","previous_headings":"","what":"Data.frame: different types, different rules","title":"Introduction to squarebrackets","text":"several types data.frame-like objects available ‘R’: data.frames, data.tables, tibbles, tidytables; rules regarding sub-set operations. Consider following example, values column “” replaced “XXX”, rows holds column “b” larger 10: Note following: syntax different type data.frame data.frames use copy-modify. ‘dplyr’ + ‘tibble’ almost always uses explicit copy, data.table almost always uses pass--reference. ’s lot non-standard evaluation going . point 1): ‘squarebrackets’ uses exact methods syntax data.frame types. point 2): ‘squarebrackets’ always allows user use explicitly return modified copy (necessary parts copied, unnecessary copies), *_mod methods. mutable classes, data.tables, ‘squarebrackets’ additionally provides *_set methods, pass--reference semantics. point 3): ‘squarebrackets’ never use non-standard evaluation. syntax ‘squarebrackets’ 100% programmatically friendly, input can stored variable later use. ‘squarebrackets’ provides set methods work consistently manner tabular (data.frames matrix) types: sbt_x extract subsets sbt_wo return object without selected subset sbt_mod return copy modified subsets sbt_set modify object reference. let’s operation , now using ‘squarebrackets’; since data.frames tibbles mutable types, demonstration ’ll stick using sbt_mod(): Notice syntax exactly classes. original attributes also preserved using sbt_mod(); .e. nothing forced become tibble, data.table, something else. Input class = output class. data.tables specifically, user can also use sbt_set(), perform pass--reference semantics, considerably faster memory efficient: powered class-agnostic ‘C’ code fantastic ‘collapse’ ‘data.table’ packages.  ","code":"tinycodet::import_as(~ dpr., \"dplyr\", dependencies = \"tibble\")  x <- data.frame(a = month.abb, b = 1:12) y <- dpr.$tibble(a = month.abb, b = 1:12) z <- data.table::data.table(a = month.abb, b = 1:12)  x[with(x, b > 10), \"a\"] <- \"XXX\" # data.frame with base y <- dpr.$mutate(y, a = ifelse(b > 10, \"XXX\", b)) # tibble with tidyverse z[b > 10, a:= \"XXX\"] # data.table with fastverse/tinyverse x <- data.frame(a = month.abb, b = 1:12) y <- tibble::tibble(a = month.abb, b = 1:12) z <- data.table::data.table(a = month.abb, b = 1:12)  sbt_mod(x, ~ b > 10, \"a\", rp = \"XXX\") sbt_mod(y, ~ b > 10, \"a\", rp = \"XXX\") sbt_mod(z, ~ b > 10, \"a\", rp = \"XXX\") z <- data.table::data.table(a = month.abb, b = 1:12) sbt_set(z, ~ b > 10, \"a\", rp = \"XXX\") print(z) #>          a     b #>     <char> <int> #>  1:    Jan     1 #>  2:    Feb     2 #>  3:    Mar     3 #>  4:    Apr     4 #>  5:    May     5 #>  6:    Jun     6 #>  7:    Jul     7 #>  8:    Aug     8 #>  9:    Sep     9 #> 10:    Oct    10 #> 11:    XXX    11 #> 12:    XXX    12"},{"path":[]},{"path":"https://tony-aw.github.io/squarebrackets/articles/squarebrackets.html","id":"sub-set-operations-without-indices","dir":"Articles","previous_headings":"Long Vectors: So much memory usage","what":"Sub-set operations without indices","title":"Introduction to squarebrackets","text":"Long Vectors take quite bit memory. Performing sub-set operation base ‘R’ vector requires indexing vector, - long vector - may also long vector. lot memory usage. can better. ‘squarebrackets’ provides 2 sets methods perform sub-set operations without indexing vector : slice_ - methods: perform sequence-based sub-set operations. example: slicev_ - methods: perform value-based sub-set operations. example: extracting sub-sets pass--reference modification sub-sets, available methods.  ","code":"x <- 1:50 slice_x(x, 1, 10, 2) # equivalent to x[seq(1, 10, 2)] #> [1] 1 3 5 7 9 x <- 1:50 slicev_x(x, v = 1L, r = FALSE) # equivalent to x[x != 1L] #>  [1]  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #> [26] 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50"},{"path":"https://tony-aw.github.io/squarebrackets/articles/squarebrackets.html","id":"sub-set-operations-without-copies","dir":"Articles","previous_headings":"Long Vectors: So much memory usage","what":"Sub-set operations without copies","title":"Introduction to squarebrackets","text":"R’s [<- operator (sometimes) makes copies objects; making copies long vectors, however, enormous waste memory. reduce memory usage, ‘squarebrackets’ provides class mutable atomic objects can modified without making copies, similar ‘data.table’ package works. new class mutable atomic objects called mutatomic, can created ease: can modify vector reference using various methods end _set. example like : can still use regular indices, example using ii_set():  ","code":"x <- mutatomic(seq(1L, 1e6L, 2L)) head(x) #> [1]  1  3  5  7  9 11 #> mutatomic  #> typeof:  integer slice_set(x, 2, 4, rp = -1L) head(x) #> [1]  1 -1 -1 -1  9 11 #> mutatomic  #> typeof:  integer ii_set(x, 1, rp = -1000L) head(x) #> [1] -1000    -1    -1    -1     9    11 #> mutatomic  #> typeof:  integer"},{"path":"https://tony-aw.github.io/squarebrackets/articles/squarebrackets.html","id":"closing-remarks","dir":"Articles","previous_headings":"","what":"Closing Remarks","title":"Introduction to squarebrackets","text":"introductory article piqued interest, kindly invite read rest (admittedly rather extensive) documentation, perhaps try package .    ","code":""},{"path":"https://tony-aw.github.io/squarebrackets/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Tony Wilkes. Author, maintainer, copyright holder. Tony Plate. Contributor.           Author included 'abind' fragments Richard Heiberger. Contributor.           Author included 'abind' fragments Sebastian Krantz. Contributor.           Contributed internal code 'match_all' function","code":""},{"path":"https://tony-aw.github.io/squarebrackets/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Wilkes T (2025). squarebrackets: Subset Methods Alternatives Square Brackets Operators Programming. R package version 0.0.0.9006, https://github.com/tony-aw/squarebrackets/.","code":"@Manual{,   title = {squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming},   author = {Tony Wilkes},   year = {2025},   note = {R package version 0.0.0.9006},   url = {https://github.com/tony-aw/squarebrackets/}, }"},{"path":"https://tony-aw.github.io/squarebrackets/index.html","id":"squarebrackets","dir":"","previous_headings":"","what":"Subset Methods as Alternatives to the Square Brackets Operators for Programming","title":"Subset Methods as Alternatives to the Square Brackets Operators for Programming","text":"squarebrackets: Subset Methods Alternatives Square Brackets Operators Programming","code":""},{"path":"https://tony-aw.github.io/squarebrackets/index.html","id":"description","dir":"","previous_headings":"","what":"Description","title":"Subset Methods as Alternatives to the Square Brackets Operators for Programming","text":"Provides subset methods (supporting atomic recursive S3 classes) may convenient alternatives [ [<- operators, whilst maintaining similar performance. nice properties methods include, limited , following: [ [<- operators use different rule-sets different data.frame-like types (data.frames, data.tables, tibbles, tidytables, etc.). ‘squarebrackets’ methods use rule-sets different data.frame-like types. Performing dimensional subset operations array using [ [<-, requires -priori knowledge number dimensions array . ‘squarebrackets’ methods work arbitrary dimensions without requiring prior knowledge. selecting names [ [<- operators, first occurrence names selected case duplicate names. ‘squarebrackets’ methods always perform names case duplicates, just first. [<- operator supports copy--modify semantics classes. ‘squarebrackets’ methods provides explicit pass--reference pass--value semantics, whilst still respecting things like binding-locks mutability rules. ‘squarebrackets’ supports index-less sub-set operations, memory efficient (better environment) long vectors sub-set operations using [ [<- operators.  ","code":""},{"path":"https://tony-aw.github.io/squarebrackets/index.html","id":"get-started","dir":"","previous_headings":"","what":"Get Started","title":"Subset Methods as Alternatives to the Square Brackets Operators for Programming","text":"get started see Get Started page.  ","code":""},{"path":"https://tony-aw.github.io/squarebrackets/index.html","id":"installing--loading","dir":"","previous_headings":"","what":"Installing & Loading","title":"Subset Methods as Alternatives to the Square Brackets Operators for Programming","text":"One can install ‘squarebrackets’ GitHub like : Special care taken make sure function names clear, function names unlikely conflict core R, recommended R packages, rstudioapi package, major packages fastverse. one can attach package - thus exposing functions namespace - using:    ","code":"remotes::install_github(\"https://github.com/tony-aw/squarebrackets\") library(squarebrackets)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa00_squarebrackets_help.html","id":null,"dir":"Reference","previous_headings":"","what":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa00_squarebrackets_help","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa00_squarebrackets_help","text":"squarebrackets:  Subset Methods Alternatives Square Brackets Operators Programming.  'squarebrackets' provides subset methods (supporting atomic recursive S3 classes) may convenient alternatives [ [<- operators, whilst maintaining similar performance.  nice properties methods include, limited , following. [ [<- operators use different rule-sets different data.frame-like types (data.frames, data.tables, tibbles, tidytables, etc.).  'squarebrackets' methods use rule-sets different data.frame-like types. Performing dimensional subset operations array using [ [<-, requires -priori knowledge number dimensions array .  'squarebrackets' methods work arbitrary dimensions without requiring prior knowledge. selecting names [ [<- operators, first occurrence names selected case duplicate names.  'squarebrackets' methods always perform names case duplicates, just first. [<- operator supports copy--modify semantics classes.  'squarebrackets' methods provides explicit pass--reference pass--value semantics, whilst still respecting things like binding-locks mutability rules. 'squarebrackets' supports index-less sub-set operations, memory efficient (better environment) long vectors sub-set operations using [ [<- operators.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa00_squarebrackets_help.html","id":"goal","dir":"Reference","previous_headings":"","what":"Goal","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa00_squarebrackets_help","text":"Among programming languages, 'R' perhaps one flexible comprehensive sub-setting functionality, provided square brackets operators ([, [<-).  situations square brackets operators occasionally less optimally convenient  Goal 'squarebrackets' package replace square-brackets operators, provide alternative sub-setting methods functions, used situations square bracket operators inconvenient.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa00_squarebrackets_help.html","id":"quick-start-guide","dir":"Reference","previous_headings":"","what":"Quick Start Guide","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa00_squarebrackets_help","text":"Quick Start Guide, see: https://tony-aw.github.io/squarebrackets/articles/squarebrackets.html.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa00_squarebrackets_help.html","id":"overview-help-pages","dir":"Reference","previous_headings":"","what":"Overview Help Pages","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa00_squarebrackets_help","text":"Essentials  essential documentation split following help pages: squarebrackets_methods:  Lists main methods provided 'squarebrackets'. squarebrackets_indx_fundamentals:  Explains essential fundamentals indexing forms 'squarebrackets'. Arguments  methods 'squarebrackets' share lot common arguments.  explanations common arguments given following help pages: squarebrackets_supported_structures:  Lists structures supported 'squarebrackets', explains related terminology. squarebrackets_indx_args:  Explains common indexing arguments used main S3 methods. squarebrackets_modify:  Explains modification-related arguments, essential information regarding modification. squarebrackets_options:  Lists explains options user can specify 'squarebrackets'. squarebrackets_slicev:  Explains special argument structure used slicev_ methods. Pass--Reference  following help pages explain pass--reference semantics provided 'squarebrackets', need read planning use semantics: squarebrackets_PassByReference:  Explains Pass--Reference semantics, important consequences. squarebrackets_coercion:  Explains difference coercion rules modification Pass--Reference semantics modification copy (.e. pass--value).  finally, squarebrackets_method_dispatch help page, gives small additional details regarding S3 method dispatch used 'squarebrackets'.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa00_squarebrackets_help.html","id":"helper-functions","dir":"Reference","previous_headings":"","what":"Helper Functions","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa00_squarebrackets_help","text":"couple convenience functions, helper functions creating ranges, sequences, indices (often needed sub-setting) provided: n: Nested version c, short-hand list. ndim: Get number dimensions object. ss2coord, coord2ii: Convert subscripts (array indices) coordinates, coordinates flat indices, vice-versa. match_all: Find matches, one vector another, taking account order duplicate values vectors. Computing indices: idx_r compute integer index range. idx_by compute grouped indices.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa00_squarebrackets_help.html","id":"properties-details","dir":"Reference","previous_headings":"","what":"Properties Details","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa00_squarebrackets_help","text":"alternative sub-setting methods functions provided 'squarebrackets' following properties: Programmatically friendly: Unlike base [, required know number dimensions array -priori, perform subset-operations array. Missing arguments can filled NULL, instead using dark magic like base::quote(expr =    ). Non-standard evaluation. Functions pipe-friendly. (silent) vector recycling. Extracting removing subsets uses syntax. Class consistent: sub-setting multi-dimensional objects specifying dimensions (.e. rows, columns, ...) use drop = FALSE.  matrix , matrix . methods deliver results data.frames, data.tables, tibbles, tidytables.  longer one re-learn different brackets-based sub-setting rules different types data.frame-like objects.  Powered subclass agnostic 'C'-code 'collapse' 'data.table'. Explicit copy semantics: Sub-set operations change memory allocations, always return modified (partial) copy object. sub-set operations just change values -place (similar [<- [[<- methods) user can choose method modifies object reference, choose method returns (partial) copy. Careful handling names: Sub-setting object index names returns matches given names, just first. Data.frame-like objects (see supported classes ) forced unique column names. Concise function argument names. Performance & Energy aware:  Despite many checks performed, functions kept reasonably speedy, use 'Rcpp', 'collapse', 'data.table' R-packages.  functions also made memory efficient reasonably possible, lower carbon footprint package.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa00_squarebrackets_help.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa00_squarebrackets_help","text":"badges shown documentation R-package made using services : https://shields.io/","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa00_squarebrackets_help.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa00_squarebrackets_help","text":"Author, Maintainer: Tony Wilkes tony_a_wilkes@outlook.com (ORCID)","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa01_squarebrackets_methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods Available in 'squarebrackets' — aaa01_squarebrackets_methods","title":"Methods Available in 'squarebrackets' — aaa01_squarebrackets_methods","text":"help page gives overview methods available 'squarebrackets'.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa01_squarebrackets_methods.html","id":"main-methods","dir":"Reference","previous_headings":"","what":"Main Methods","title":"Methods Available in 'squarebrackets' — aaa01_squarebrackets_methods","text":"main methods 'squarebrackets' use naming convention <indexform>_<operation>: <indexform> tells form indices method uses; <operation> tells operation performed.  <indexform> part, following available: ii_: operates subsets atomic/recursive vectors/arrays interior indices. ss_: operates subsets atomic/recursive arrays dimensionality subscripts. sbt_: operates subsets data.frames atomic/recursive matrices tabular indices. slice_: uses index-less, sequence-based, efficient operations (mutatomic) long vectors. slicev_: uses index-less & value-based efficient operations (mutatomic) long vectors. <operation> part, following available: _x: extract, exchange, duplicate (applicable) subsets. _wo: returns original object without provided subsets. _mod: modify subsets return copy. _set: modify subsets using pass--reference semantics. illustrate, take methods used extracting subsets (_x): y vector array (dimension), ii_x(y, ) corresponds y[]. y 3d array, ss_x(y, n(, k), c(1, 3)) corresponds y[, , k, drop = FALSE]. y matrix data.frame-like object, sbt_x(y, , j) corresponds y[, j, drop = FALSE].","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa01_squarebrackets_methods.html","id":"other-methods","dir":"Reference","previous_headings":"","what":"Other Methods","title":"Methods Available in 'squarebrackets' — aaa01_squarebrackets_methods","text":"Besides main methods, 'squarebrackets' provides additional methods neatly fit methods.  First, lst_ set methods, deal sub-set operations relevant (nested) lists, types supported objects.  Second, idx method, works recursive non-recursive objects, transforms/translates indices used R's default copy--modify semantics.  Finally, sb_ sets methods, cover miscellaneous operations atomic/recursive objects.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa01_squarebrackets_methods.html","id":"finding-the-appropriate-help-pages","dir":"Reference","previous_headings":"","what":"Finding the Appropriate Help Pages","title":"Methods Available in 'squarebrackets' — aaa01_squarebrackets_methods","text":"knowledge naming convention main methods, one can easily find information particular method usign ? operator.  find modifying objects subscripts using Pass--Reference semantics, type : ?ss_set","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa01_squarebrackets_supported_structures.html","id":null,"dir":"Reference","previous_headings":"","what":"Supported Structures — aaa01_squarebrackets_supported_structures","title":"Supported Structures — aaa01_squarebrackets_supported_structures","text":"'squarebrackets' supports common S3 objects, primarily use square brackets sub-set operations (hence name package).  One can generally divide structures supported 'squarebrackets' along 3 key properties: atomic vs recursive:  Types logical, integer, double, complex, character, raw atomic.  Lists data.frames recursive. dimensionality:  Whether object vector, array, data.frame.  Note matrix simply array 2 dimensions. mutability:  Base R's S3 classes (except Environments) generally immutable:  Modifying object create copy (called 'copy--modify').  'squarebrackets also supports data.tables mutatomic objects, mutable:  desired, one can modify without copy using pass--reference semantics. Supported Structures 'squarebrackets' supports following immutable structures: basic atomic classes  (atomic vectors arrays). factor. basic list classes  (recursive vectors arrays). data.frame  (including classes tibble, sf-data.frame sf-tibble). 'squarebrackets' supports following mutable structures: mutatomic  (mutatomic vectors arrays); data.table  (including classes tidytable, sf-data.table, sf-tidytable). methods provided 'squarebrackets', like method, can extended ('R' package authors) support additional classes already supported natively 'squarebrackets'.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa01_squarebrackets_supported_structures.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Supported Structures — aaa01_squarebrackets_supported_structures","text":"Atomic vs Recursive  ii_/ss_ methods provided 'squarebrackets' work atomic (see .atomic) objects.  ii2_/ss2_ methods provided 'squarebrackets' work recursive (see .recursive) objects.  See squarebrackets_methods details. Dimensionality  'squarebrackets' supports dimensionless vector objects (.e. ndim == 0L).  squarebrackets' supports arrays (see .array .matrix); note matrix simply array 2 dimensions.  'squarebrackets' also supports data.frame-like objects (see .data.frame).  Specifically, squarebrackets' supports wide variety data.frame classes: data.frame, data.table, tibble, tidytable;  'squarebrackets' also supports 'sf'-package compatible counter-parts: sf-data.frame, sf-data.table, sf-tibble, sf-tidytable.  Dimensionless vectors dimensional arrays supported atomic recursive forms.  Data.frame-like objects, contrast, exist recursive form (, stated, supported 'squarebrackets').  Recursive vectors, recursive matrices, recursive arrays, collectively referred \"lists\" 'squarebrackets' documentation.  Note dimensionality data.frame-like objects dimensionality (recursive) arrays/matrices.  example:  array/matrix x, holds length(x) == prod(dim(x)).  data.frame x, case length(x) == ncol(x). Mutable vs Immutable  base R's S3 classes (except Environments) generally immutable:  Modifying object create copy (called 'copy--modify').  explicit pass--reference semantics.  S3 objects base 'R' immutable:  Environments pass--reference semantics, supported 'squarebrackets'.  Supported mutable structures: 'squarebrackets' supports mutable data.table class  (thus also tidytable, inherits data.table). 'squarebrackets' supports mutatomic class. mutatomic objects atomic objects, except mutable (hence name). Supported immutable structures:  Atomic recursive vectors/matrices/arrays, data.frames, tibbles.  functions 'squarebrackets' package word \"set\" name perform pass--reference modification, thus work mutable structures.  functions work way mutable immutable structures. Derived Atomic Vector  special class objects Derived Atomic Vector structures:  structures derived atomic objects, behave differently.  example:  Factors, datetime, POSIXct derived atomic vectors.  attributes special methods make behave differently.  'squarebrackets' treats derived atomic classes regular atomic vectors.  highly specialized packages handle objects derived atomic objects.  example, 'anytime' package handle date-time objects.  'squarebrackets  provide explicit support factors. Supported S3 structures  Key-Values storage S3 structures, environments, supported 'squarebrackets'.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa02_squarebrackets_indx_fundamentals.html","id":null,"dir":"Reference","previous_headings":"","what":"Indexing Fundamentals of 'squarebrackets' — aaa02_squarebrackets_indx_fundamentals","title":"Indexing Fundamentals of 'squarebrackets' — aaa02_squarebrackets_indx_fundamentals","text":"help page explains fundamentals regarding 'squarebrackets' treats indexing.  familiarity base R's [ [<- operators required follow help page.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa02_squarebrackets_indx_fundamentals.html","id":"indexing-forms","dir":"Reference","previous_headings":"","what":"Indexing Forms","title":"Indexing Fundamentals of 'squarebrackets' — aaa02_squarebrackets_indx_fundamentals","text":"Consider following representation array indices (case) 4 5 matrix:   numbers 1 20 interior representation, referred documentation \"interior indices\" (abbreviated \"ii\"), also known \"flat indices\".  numbers edges representations, 1 4 rows 1 5 columns, referred documentation \"subscripts\" (abbreviated \"ss\"), also known \"dimensional indices\".  Indexing rows columns, referred tabular indices, commonly used special subset using subscripts, available data.frames matrices.  Thus 'squarebracets' supports 3 forms indexing:  Indexing interior indices, indexing subscripts, tabular indices.  Regarding kind object supports kind indexing form: Matrices, simply 2-dimensional arrays, support 3 given indexing forms. Arrays general can always support interior indices subscripts. Dimensionless vectors (.e. objects dim() returns NULL) support interior indices. Data.frames support tabular indices. Regarding set methods support kind indexing form: One can operate flat/interior indices (often simply referred \"indices\") using ii_ methods;  primarily use argument. One can operate general subscripts (= dimensional indices) using ss_ methods;  primarily use s, d argument pair. One can operate tabular indices using  sbt_ methods;  primarily use obs, vars row, col argument pair. relationship flat/interior indices subscripts arrays, see ss2ii help page.","code":"[,1] [,2] [,3] [,4] [,5]  [1,] [1]  [5]  [9]  [13] [17]  [2,] [2]  [6]  [10] [14] [18]  [3,] [3]  [7]  [11] [15] [19]  [4,] [4]  [8]  [12] [16] [20]"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa02_squarebrackets_indx_fundamentals.html","id":"indexing-types","dir":"Reference","previous_headings":"","what":"Indexing Types","title":"Indexing Fundamentals of 'squarebrackets' — aaa02_squarebrackets_indx_fundamentals","text":"Base 'R' supports indexing logical, integer, character vectors.  'squarebrackets' supports also (albeit improvements), also supports additional methods indexing. Whole numbers  Whole numbers basic form index selection.  forms indexing 'squarebrackets' internally translated integer (double > (2^31 - 1)) indexing first, ensuring consistency.  Indexing integer/numeric indices 'squarebrackets' works base 'R', except negative values allowed.  indexing starts 1 inclusive. Logical  Selecting indices logical vector 'squarebrackets' works base 'R', except recycling allowed. Characters  selecting indices using character vector, base 'R' selects first matches names.  'squarebrackets', however, selects matches:   Character indices internally translated integer indices using match_all. Imaginary Numbers (advanced users)  complex vector y structured y = + b *  Re(y) returns real numbers , Im(y) returns imaginary numbers b.  'squarebrackets' includes support indexing imaginary numbers (Im(y)).  Indexing imaginary numbers generalization indexing regular integers.  works follows:  Imaginary numbers positive integers, like 1:10 * 1i, work regular integers.  Imaginary numbers negative integers, like 1:10 * -1i, index counting backwards (.e. end).  Positive negative numbers can combined, like c(-10:-1, 1:10) * 1i.  Note Imaginary part complex vector used (Im(y));  Real part (Re(y)) ignored.  See results following code example:   Thus complex vectors allow user choose counting beginning, like regular integers, backwards counting end, combination . Missing Index Argument  NULL numeric scalar 0L can used specify missing index argument.  example, given matrix x, ss_x(x, n(0, 1:10)) equivalent x[ , 1:10].","code":"nms <- c(\"a\", letters[4:1], letters[1:5]) x <- 1:10 names(x) <- nms print(x) #' `x` has multiple elements with the name \"a\" #>  a  d  c  b  a  a  b  c  d  e #>  1  2  3  4  5  6  7  8  9 10  ii_x(x, \"a\") # extracts all indices with the name \"a\" #> a a a #> 1 5 6  ii_x(x, c(\"a\", \"a\")) # repeats all indices with the name \"a\" #> a a a a a a #> 1 5 6 1 5 6 x <- 1:30 # vector of 30 elements  ii_x(x, 1:10 * 1i) # extract first 10 elements #>  [1]  1  2  3  4  5  6  7  8  9 10  ii_x(x, 1:10 * -1i) # extract last 10 elements #>  [1] 30 29 28 27 26 25 24 23 22 21  ii_x(x, 10:1 * -1i) # last 10 elements, in tail()-like order #>  [1] 21 22 23 24 25 26 27 28 29 30  ii_x(x, c(1, -1) * 1i) # extract first and last element #> [1]  1 30"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa02_squarebrackets_indx_fundamentals.html","id":"inverting","dir":"Reference","previous_headings":"","what":"Inverting","title":"Indexing Fundamentals of 'squarebrackets' — aaa02_squarebrackets_indx_fundamentals","text":"Inverting indices means specify elements except given indices.  Consider example atomic vector month.abb (abbreviate month names).  Given vector, indices 1:5 gives c(\"Jan\" \"Feb\" \"Mar\" \"Apr\", \"May\").  Inverting indices give c(\"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\").  base 'R', inverting index done different ways.  (negative numbers numeric indexing, negation logical indexing, manually un-matching character vectors).  'squarebrackets' provides (somewhat) consistent syntax invert indices: methods end _x perform extraction;  invert extraction, .e. return object without specified subset, use methods end _wo. modification methods (_mod/_set) one can set argument inv = TRUE invert indices. EXAMPLES   ORDERING  order user gives indices inverting indices generally matter.  order indices appear original object x maintained, just like base 'R'.","code":"x <- month.abb print(x) #>  [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\"   ii_x(x, 1:5) # extract first 5 elements #> [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\"  ii_wo(x, 1:5) # return WITHOUT first 5 elements #> [1] \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\"   ii_mod(x, 1:5, rp = \"XXX\") # copy, replace first 5 elements, return result #>  [1] \"XXX\" \"XXX\" \"XXX\" \"XXX\" \"XXX\" \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\"  ii_mod(x, 1:5, inv = T, rp = \"XXX\") # same, but for all except first 5 elements #>  [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"XXX\" \"XXX\" \"XXX\" \"XXX\" \"XXX\" \"XXX\" \"XXX\""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa02_squarebrackets_indx_fundamentals.html","id":"out-of-bounds-integers-non-existing-names-and-nas","dir":"Reference","previous_headings":"","what":"Out-of-Bounds Integers, Non-Existing Names, and NAs","title":"Indexing Fundamentals of 'squarebrackets' — aaa02_squarebrackets_indx_fundamentals","text":"Integer indices bounds (including NaN NA_integer_) always give error. Character indices specify non-existing names considered form zero-length indexing.  Specifying NA names returns error. Logical indices translated internally integers using , NAs ignored.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa02_squarebrackets_indx_fundamentals.html","id":"index-less-sub-set-operations","dir":"Reference","previous_headings":"","what":"Index-less Sub-set Operations","title":"Indexing Fundamentals of 'squarebrackets' — aaa02_squarebrackets_indx_fundamentals","text":"now help page focussed performing sub-set operations indexing vector.  Performing sub-set operations long vector using index vector (may also long vector) memory-efficient.  'squarebrackets' therefore introduces index-less sub-set operations, slice_ slicev_ methods.  methods much memory computationally efficient index-based sub-set methods (also bit better environment!).  slice_ methods perform sequence based sub-set operations.  slicev_ methods (notice \"v\" end) perform value-based sub-set operations.  Though method intentionally kept relatively simple, still involved enough warrant help page;  details value-based index-less sub-set operations, please see squarebrackets_slicev.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa02_squarebrackets_indx_fundamentals.html","id":"regarding-performance","dir":"Reference","previous_headings":"","what":"Regarding Performance","title":"Indexing Fundamentals of 'squarebrackets' — aaa02_squarebrackets_indx_fundamentals","text":"Integer vectors created : operator \"compact ALTREP\" integer vectors, provide fastest way specify indices.  Indexing names (.e. character vectors) slowest.  Complex vectors imaginary numbers somewhat middle terms speed.  Index-less sub-set operations usually faster memory efficient index-based sub-set operation.  performance important, use index-less sub-set operations, use compact ALTREP integer indices.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa02_squarebrackets_indx_fundamentals.html","id":"indexing-in-recursive-subsets","dir":"Reference","previous_headings":"","what":"Indexing in Recursive Subsets","title":"Indexing Fundamentals of 'squarebrackets' — aaa02_squarebrackets_indx_fundamentals","text":"now help page focussed indexing regular (\"shallow\") subsets.  section discuss indexing recursive subsets.  One differences atomic recursive objects, recursive objects support recursive subsets, atomic objects .  Bear mind every element recursive object reference another object.  Consider following list x:   Regular subsets, AKA surface-level subset operations ([, [<- base 'R'), operate recursive object .  .e. ii_x(x, 1), equivalently x[1], returns list list(= 1:10):   Recursive subset operations ([[, [[<-, $ base 'R'), hand, operate object subset recursive object references .  .e. lst_rec(x, 1), equivalently x[[1]], returns integer vector 1:10:   Recursive objects can refer recursive objects, can refer recursive objects, .  Recursive subsets can go however deep want.  , example, extract character vector month.abb aforementioned list x, one need : lst_rec(x, c(\"C\",\"B\")), (base R: x$C$B):   LIMITATIONS  Indexing recursive subsets significantly limited regular (\"shallow\") subsets: Recursive subset operations using lst_rec/lst_recin support positive integer vectors character vectors. Imaginary numbers (using complex vectors) logical vectors supported. Since recursive subset operation operates single element, specifying index character vector selects first matching element (just like base 'R'), matches. Inverting indices also available recursive indexing. Unlike regular sub-setting, --bounds specification indices acceptable, can used add new values lists.","code":"x <- list(    A = 1:10,    B = letters,    C = list(A = 11:20, B = month.abb) ) ii_x(x, 1) # equivalent to x[1]; returns list(A = 1:10) #> $A #>  [1]  1  2  3  4  5  6  7  8  9 10 lst_rec(x, 1) # equivalent to x[[1]]; returns 1:10 #>  [1]  1  2  3  4  5  6  7  8  9 10 lst_rec(x, c(\"C\",\"B\")) # equivalent to x$C$B #>  [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\"  # or:  lst_rec(x, c(3, 2)) # equivalent to x[[3]][[2]] #>  [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa02_squarebrackets_indx_fundamentals.html","id":"non-standard-evaluation","dir":"Reference","previous_headings":"","what":"Non-Standard Evaluation","title":"Indexing Fundamentals of 'squarebrackets' — aaa02_squarebrackets_indx_fundamentals","text":"'squarebrackets' designed primarily programming, seeks fully programmatically friendly.  part endeavour, 'squarebrackets' never uses Non-Standard Evaluation.  input methods functions 'squarebrackets' objects can stored variable.  Like atomic vectors, lists, formulas, etc.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa02_squarebrackets_methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods — aaa02_squarebrackets_methods","title":"Methods — aaa02_squarebrackets_methods","text":"help page gives overview methods available 'squarebrackets'.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa02_squarebrackets_methods.html","id":"main-methods","dir":"Reference","previous_headings":"","what":"Main Methods","title":"Methods — aaa02_squarebrackets_methods","text":"main methods 'squarebrackets' use naming convention A_B: tells kind object kind indices method operates ; B tells operation performed.  part, following available: ii_: operates subsets atomic objects flat/interior indices. ii2_: operates subsets recursive objects flat/interior indices. ss_: operates subsets atomic objects (dimensional) subscripts. ss2_: operates subsets recursive objects (dimensional) subscripts. slice_: uses index-less, sequence-based, efficient operations (mutatomic) long vectors. slicev_: uses index-less, value-based efficient operations (mutatomic) long vectors. B part, following available: _x: extract, exchange, duplicate (applicable) subsets. _wo: returns original object without provided subsets. _mod: modify subsets return copy. _set: modify subsets using pass--reference semantics. illustrate, take methods used extracting subsets (_x).  y atomic, following holds (roughly speaking): ii_x(y, ) corresponds y[] ss_x(y, n(, k), c(1, 3)) corresponds y[, , k] y list (.e. recursive), following holds (roughly speaking): ii2_x(y, ) corresponds y[] y[[]] (depending arguments given ii2_x()) ss2_x(y, n(, k), c(1, 3)) corresponds y[, , k] y[[, , k]] (depending arguments given ss2_x())","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa02_squarebrackets_methods.html","id":"other-methods","dir":"Reference","previous_headings":"","what":"Other Methods","title":"Methods — aaa02_squarebrackets_methods","text":"Besides main methods, 'squarebrackets' provides additional methods neatly fit methods.  First, lst_ set methods, deal sub-set operations relevant (nested) lists, types supported objects.  Second, idx method, works recursive non-recursive objects, transforms/translates indices used R's default copy--modify semantics.  Finally, sb_ sb2_ sets methods, cover miscellaneous operations atomic recursive objects, respectively.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa02_squarebrackets_methods.html","id":"finding-the-appropriate-help-pages","dir":"Reference","previous_headings":"","what":"Finding the Appropriate Help Pages","title":"Methods — aaa02_squarebrackets_methods","text":"knowledge naming convention main methods, one can easily find information particular method usign ? operator.  find modifying recursive objects subscripts using Pass--Reference semantics, type : ?ss2_set","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa03_squarebrackets_indx_fundamentals.html","id":null,"dir":"Reference","previous_headings":"","what":"Indexing Fundamentals — aaa03_squarebrackets_indx_fundamentals","title":"Indexing Fundamentals — aaa03_squarebrackets_indx_fundamentals","text":"help page explains fundamentals regarding 'squarebrackets' treats indexing.  familiarity base R's [ [<- operators required follow help page.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa03_squarebrackets_indx_fundamentals.html","id":"indexing-forms","dir":"Reference","previous_headings":"","what":"Indexing Forms","title":"Indexing Fundamentals — aaa03_squarebrackets_indx_fundamentals","text":"Consider following representation array indices (case) 5 4 matrix:   numbers 1 20 interior representation, referred documentation \"interior indices\" (abbreviated \"ii\"), also known \"flat indices\".  numbers edges representations, 1 5 rows 1 4 columns, referred documentation \"subscripts\" (abbreviated \"ss\"), also known \"dimensional indices\".  Thus 'squarebracets' supports 2 forms indexing:  Indexing interior indices, indexing subscripts.  Arrays support interior indices well subscripts.  Vectors support interiod indices.  Data.frames support subscripts.  One can operate flat/interior indices (often simply referred \"indices\") using ii_/ ii2_ methods;  primarily use argument.  One can operate subscripts (= dimensional indices) using ss_/ ss2_ methods;  primarily use s, d argument pair.  relationship flat/interior indices subscripts arrays, see sub2ind help page.","code":"[,1] [,2] [,3] [,4]  [1,]    1    6   11   16  [2,]    2    7   12   17  [3,]    3    8   13   18  [4,]    4    9   14   19  [5,]    5   10   15   20"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa03_squarebrackets_indx_fundamentals.html","id":"indexing-types","dir":"Reference","previous_headings":"","what":"Indexing Types","title":"Indexing Fundamentals — aaa03_squarebrackets_indx_fundamentals","text":"Base 'R' supports indexing logical, integer, character vectors.  'squarebrackets' supports also (albeit improvements), also supports additional methods indexing. Whole numbers  Whole numbers basic form index selection.  forms indexing 'squarebrackets' internally translated integer (double > (2^31 - 1)) indexing first, ensuring consistency.  Indexing integer/numeric indices 'squarebrackets' works base 'R', except negative values allowed.  indexing starts 1 inclusive. Logical  Selecting indices logical vector 'squarebrackets' works base 'R', except recycling allowed. Characters  selecting indices using character vector, base 'R' selects first matches names.  'squarebrackets', however, selects matches:   Character indices internally translated integer indices using match_all. Imaginary Numbers  complex vector y structured y = + b *  Re(y) returns , Im(y) returns b.  squarebrackets' includes support indexing imaginary numbers (Im(y)) complex vectors.  Indexing imaginary numbers generalization indexing regular integers.  works follows:  Imaginary numbers positive integers, like 1:10 * 1i, work regular integers.  Imaginary numbers negative integers, like 1:10 * -1i, index counting backwards (.e. end).  Positive negative numbers can combined, like c(-10:1, 1:10) * 1i.  Note Imaginary part complex vector used (Im(y));  Real part (Re(y)) ignored.  See results following code example:   Thus complex vectors allow user choose counting beginning, like regular integers, backwards counting end, combination . Missing Index Argument  NULL numeric scalar 0L can used specify missing index argument.  example, given matrix x, ss_x(x, n(0, 1:10)) equivalent x[ , 1:10].","code":"nms <- c(\"a\", letters[4:1], letters[1:5]) x <- 1:10 names(x) <- nms print(x) #' `x` has multiple elements with the name \"a\" #>  a  d  c  b  a  a  b  c  d  e #>  1  2  3  4  5  6  7  8  9 10  ii_x(x, \"a\") # extracts all indices with the name \"a\" #> a a a #> 1 5 6  ii_x(x, c(\"a\", \"a\")) # repeats all indices with the name \"a\" #> a a a a a a #> 1 5 6 1 5 6 x <- 1:30 # vector of 30 elements  ii_x(x, 1:10 * 1i) # extract first 10 elements #>  [1]  1  2  3  4  5  6  7  8  9 10  ii_x(x, 1:10 * -1i) # extract last 10 elements #>  [1] 30 29 28 27 26 25 24 23 22 21  ii_x(x, 10:1 * -1i) # last 10 elements, in tail()-like order #>  [1] 21 22 23 24 25 26 27 28 29 30  ii_x(x, c(1, -1) * 1i) # extract first and last element #> [1]  1 30"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa03_squarebrackets_indx_fundamentals.html","id":"inverting","dir":"Reference","previous_headings":"","what":"Inverting","title":"Indexing Fundamentals — aaa03_squarebrackets_indx_fundamentals","text":"Inverting indices means specify elements except given indices.  Consider example atomic vector month.abb (abbreviate month names).  Given vector, indices 1:5 gives c(\"Jan\" \"Feb\" \"Mar\" \"Apr\", \"May\").  Inverting indices give c(\"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\").  base 'R', inverting index done different ways.  (negative numbers numeric indexing, negation logical indexing, manually un-matching character vectors).  'squarebrackets' provides (somewhat) consistent syntax invert indices: methods end _x perform extraction;  invert extraction, .e. return object without specified subset, use methods end _wo. modification methods (_mod_/_set_) one can set argument inv = TRUE invert indices. EXAMPLES   ORDERING  order user gives indices inverting indices generally matter.  order indices appear original object x maintained, just like base 'R'.","code":"x <- month.abb print(x) #>  [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\"   ii_x(x, 1:5) # extract first 5 elements #> [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\"  ii_wo(x, 1:5) # return WITHOUT first 5 elements #> [1] \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\"   ii_mod(x, 1:5, rp = \"XXX\") # copy, replace first 5 elements, return result #>  [1] \"XXX\" \"XXX\" \"XXX\" \"XXX\" \"XXX\" \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\"  ii_mod(x, 1:5, inv = T, rp = \"XXX\") # same, but for all except first 5 elements #>  [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"XXX\" \"XXX\" \"XXX\" \"XXX\" \"XXX\" \"XXX\" \"XXX\""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa03_squarebrackets_indx_fundamentals.html","id":"out-of-bounds-integers-non-existing-names-and-nas","dir":"Reference","previous_headings":"","what":"Out-of-Bounds Integers, Non-Existing Names, and NAs","title":"Indexing Fundamentals — aaa03_squarebrackets_indx_fundamentals","text":"Integer indices bounds (including NaN NA_integer_) always give error. Character indices specify non-existing names considered form zero-length indexing.  Specifying NA names returns error. Logical indices translated internally integers using , NAs ignored.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa03_squarebrackets_indx_fundamentals.html","id":"index-less-sub-set-operations","dir":"Reference","previous_headings":"","what":"Index-less Sub-set Operations","title":"Indexing Fundamentals — aaa03_squarebrackets_indx_fundamentals","text":"now help page focussed performing sub-set operations indexing vector.  Performing sub-set operations long vector using index vector (may also long vector) memory-efficient.  'squarebrackets' therefore introduces index-less sub-set operations, slice_ slicev_ methods.  methods much memory computationally efficient index-based sub-set methods (also bit better environment!).  slice_ methods perform sequence based sub-set operations.  slicev_ methods (notice \"v\" end) perform value-based sub-set operations.  Though method intentionally kept relatively simple, still involved enough warrant help page;  details value-based index-less sub-set operations, please see squarebrackets_slicev.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa03_squarebrackets_indx_fundamentals.html","id":"regarding-performance","dir":"Reference","previous_headings":"","what":"Regarding Performance","title":"Indexing Fundamentals — aaa03_squarebrackets_indx_fundamentals","text":"Integer vectors created : operator \"compact ALTREP\" integer vectors, provide fastest way specify indices.  Indexing names (.e. character vectors) slowest.  Complex vectors imaginary numbers somewhat middle terms speed.  Index-less sub-set operations usually faster memory efficient index-based sub-set operation.  performance important, use index-less sub-set operations, use compact ALTREP integer indices.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa03_squarebrackets_indx_fundamentals.html","id":"indexing-in-recursive-subsets","dir":"Reference","previous_headings":"","what":"Indexing in Recursive Subsets","title":"Indexing Fundamentals — aaa03_squarebrackets_indx_fundamentals","text":"now help page focussed indexing regular (\"shallow\") subsets.  section discuss indexing recursive subsets.  One differences atomic recursive objects, recursive objects support recursive subsets, atomic objects .  Bear mind every element recursive object reference another object.  Consider following list x:   Regular subsets, AKA surface-level subset operations ([, [<- base 'R'), operate recursive object .  .e. ii2_x(x, 1), equivalently x[1], returns list list(= 1:10):   Recursive subset operations ([[, [[<-, $ base 'R'), hand, operate object subset recursive object references .  .e. lst_rec(x, 1), equivalently x[[1]], returns integer vector 1:10:   Recursive objects can refer recursive objects, can refer recursive objects, .  Recursive subsets can go however deep want.  , example, extract character vector month.abb aforementioned list x, one need : lst_rec(x, c(\"C\",\"B\")), (base R: x$C$B):   LIMITATIONS  Indexing recursive subsets significantly limited regular (\"shallow\") subsets: Recursive subset operations using lst_rec/lst_recin support positive integer vectors character vectors. Imaginary numbers (using complex vectors) logical vectors supported. Since recursive subset operation operates single element, specifying index character vector selects first matching element (just like base 'R'), matches. Inverting indices also available recursive indexing. Unlike regular sub-setting, --bounds specification indices acceptable, can used add new values lists.","code":"x <- list(    A = 1:10,    B = letters,    C = list(A = 11:20, B = month.abb) ) ii2_x(x, 1) # equivalent to x[1]; returns list(A = 1:10) #> $A #>  [1]  1  2  3  4  5  6  7  8  9 10 lst_rec(x, 1) # equivalent to x[[1]]; returns 1:10 #>  [1]  1  2  3  4  5  6  7  8  9 10 lst_rec(x, c(\"C\",\"B\")) # equivalent to x$C$B #>  [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\"  # or:  lst_rec(x, c(3, 2)) # equivalent to x[[3]][[2]] #>  [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa03_squarebrackets_indx_fundamentals.html","id":"non-standard-evaluation","dir":"Reference","previous_headings":"","what":"Non-Standard Evaluation","title":"Indexing Fundamentals — aaa03_squarebrackets_indx_fundamentals","text":"'squarebrackets' designed primarily programming, seeks fully programmatically friendly.  part endeavour, 'squarebrackets' never uses Non-Standard Evaluation.  input methods functions 'squarebrackets' objects can stored variable.  Like atomic vectors, lists, formulas, etc.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa03_squarebrackets_supported_structures.html","id":null,"dir":"Reference","previous_headings":"","what":"Supported Structures — aaa03_squarebrackets_supported_structures","title":"Supported Structures — aaa03_squarebrackets_supported_structures","text":"'squarebrackets' supports common S3 objects, primarily use square brackets sub-set operations (hence name package).  One can generally divide structures supported 'squarebrackets' along 3 key properties: atomic vs recursive:  Types logical, integer, double, complex, character, raw atomic.  Lists data.frames recursive. dimensionality:  Whether object vector, array, data.frame.  Note matrix simply array 2 dimensions. mutability:  Base R's S3 classes (except Environments) generally immutable:  Modifying object create copy (called 'copy--modify').  'squarebrackets also supports data.tables mutatomic objects, mutable:  desired, one can modify without copy using pass--reference semantics. Supported Structures 'squarebrackets' supports following immutable structures: basic atomic classes  (atomic vectors arrays). factor. basic list classes  (recursive vectors arrays). data.frame  (including classes tibble, sf-data.frame sf-tibble). 'squarebrackets' supports following mutable structures: mutatomic  (mutatomic vectors arrays); data.table  (including classes tidytable, sf-data.table, sf-tidytable). methods provided 'squarebrackets', like method, can extended ('R' package authors) support additional classes already supported natively 'squarebrackets'.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa03_squarebrackets_supported_structures.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Supported Structures — aaa03_squarebrackets_supported_structures","text":"Atomic vs Recursive  Atomic recursive objects quite different ways: homo- heterogeneous: atomic object can values one data type.  recursive objects can hold values combination data types. nesting: Recursive objects can nested, atomic objects nested. copy coercion effect: One can coerce copy subset recursive object, without copying rest object. atomic objects, however, coercion copy operation coerces copies entire vector (ignoring attributes). vectorization: vectorized operations generally work atomic objects, whereas recursive objects often require loops apply-like functions.  Therefore, transforming recursive objects using *_mod *_set methods, 'squarebrackets' apply transformation via lapply. recursive subsets: Recursive objects distinguish \"regular\" subset operations (base R using [, [<-), recursive subset operations (base R using [[, [[<-).  See lst_rec method dropl helper function.  atomic objects, 2 meaningful difference (safe perhaps minor attribute handling). views: recursive objects, one can create View recursive subset (see also squarebrackets_coercion).  Subset views exist atomic objects. Dimensionality  'squarebrackets' supports dimensionless vector objects (.e. ndim == 0L).  squarebrackets' supports arrays (see .array .matrix); note matrix simply array 2 dimensions.  'squarebrackets' also supports data.frame-like objects (see .data.frame).  Specifically, squarebrackets' supports wide variety data.frame classes: data.frame, data.table, tibble, tidytable;  'squarebrackets' also supports 'sf'-package compatible counter-parts: sf-data.frame, sf-data.table, sf-tibble, sf-tidytable.  Dimensionless vectors dimensional arrays supported atomic recursive forms.  Data.frame-like objects, contrast, exist recursive form (, stated, supported 'squarebrackets').  Recursive vectors, recursive matrices, recursive arrays, collectively referred \"lists\" 'squarebrackets' documentation.  Note dimensionality data.frame-like objects dimensionality (recursive) arrays/matrices.  example:  array/matrix x, holds length(x) == prod(dim(x)).  data.frame x, case length(x) == ncol(x). Mutable vs Immutable  base R's S3 classes (except Environments) generally immutable:  Modifying object create copy (called 'copy--modify').  explicit pass--reference semantics.  Supported mutable structures: 'squarebrackets' supports mutable data.table class  (thus also tidytable, inherits data.table). 'squarebrackets' supports mutatomic class. mutatomic objects atomic objects, except mutable (hence name). Supported immutable structures:  Atomic recursive vectors/matrices/arrays, data.frames, tibbles.  functions 'squarebrackets' package word \"set\" name perform pass--reference modification, thus work mutable structures.  functions work way mutable immutable structures. Derived Atomic Vector  special class objects Derived Atomic Vector structures:  structures derived atomic objects, behave differently.  example:  Factors, datetime, POSIXct derived atomic vectors.  attributes special methods make behave differently.  'squarebrackets' treats derived atomic classes regular atomic vectors.  highly specialized packages handle objects derived atomic objects.  example, 'anytime' package handle date-time objects.  'squarebrackets  provide explicit support factors. Supported S3 structures  Key-Values storage S3 structures, environments, supported 'squarebrackets'.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa04_squarebrackets_indx_args.html","id":null,"dir":"Reference","previous_headings":"","what":"Index Arguments in the Generic Sub-setting Methods — aaa04_squarebrackets_indx_args","title":"Index Arguments in the Generic Sub-setting Methods — aaa04_squarebrackets_indx_args","text":"several types arguments can used generic methods 'squarebrackets' specify indices perform operations : : specify interior (.e. dimensionless) indices. s, d: specify subscripts arbitrary dimensions dimensional object supported 'squarebrackets' (.e. arrays data.frame-like objects). margin, slice: specify indices one particular dimension (arrays data.frame-like objects).  Currently used idx method. tabular indices (row, col, obs, vars): specify rows columns tabular objects (matrices data.frames). fundamentals indexing 'squarebrackets', see squarebrackets_indx_fundamentals.  help page x refers object subset operations performed.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa04_squarebrackets_indx_args.html","id":"argument-i","dir":"Reference","previous_headings":"","what":"Argument i","title":"Index Arguments in the Generic Sub-setting Methods — aaa04_squarebrackets_indx_args","text":"following can specified argument : NULL 0L, corresponds missing argument. vector length 0, case indices selected operation (.e. empty selection). numeric vector strictly positive whole numbers giving indices. complex vector, explained squarebrackets_indx_fundamentals. logical vector, length x, giving indices select operation. character vector index names.  object multiple indices given name, corresponding indices selected operation. function takes input x, returns logical vector, giving element indices select operation.  atomic objects, interpreted (x).  recursive objects, interpreted lapply(x, ). Using arguments corresponds something like following:   function, corresponds following:","code":"ii_x(x, i = i) # ==> x[i]   # if `x` is atomic  ii_x(x, i = i) # ==> x[i]  # if `x` is recursive ii_x(x, i = i) # ==> x[i(x)] # if `x` is atomic  ii_x(x, i = i) # ==> x[lapply(x, i)] # if `x` is recursive"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa04_squarebrackets_indx_args.html","id":"argument-pair-s-d","dir":"Reference","previous_headings":"","what":"Argument Pair s, d","title":"Index Arguments in the Generic Sub-setting Methods — aaa04_squarebrackets_indx_args","text":"s, d argument pair, inspired abind::asub function 'abind' package, primary indexing argument sub-set operations dimensional objects.  s argument specifies subscripts (.e. dimensional indices).  d argument gives dimensions s holds (.e. d specifies \"non-missing\" margins).  d argument must integer vector. s must atomic vector, list length 1, list length d.  s list length 1, internally recycled become length d.  s atomic vector, internally treated list(s), (previous case) recycled become length d.  element s s list, s whole s atomic, can following: NULL 0L, corresponds missing index argument. vector length 0, case indices selected operation (.e. empty selection). numeric vector strictly positive whole numbers indices specified dimension select operation. complex vector, explained squarebrackets_indx_fundamentals. logical vector length corresponding dimension size, giving indices specified dimension select operation. character vector giving dimnames select.  dimension multiple indices given name, corresponding indices selected operation. Note following: stated, d specifies index margins non-missing.  d length 0, taken \"index margins missing\". default value d 1:ndim(x). keep syntax short, user can use n function instead list() specify s. EXAMPLES  examples clarity, using atomic array x 3 dimensions: ss_x(x, n(1:10, 1:5), c(1, 3)), extracts first 10 rows, columns, first 5 layers, array x. ss_x(x, n(1:10, 0L, 1:5)) . ss_x(x, n(1:10), 2)  extracts first 10 columns array x. ss_x(x, 1:10),  extracts first 10 rows, columns, layers array x. ss_x(x, 1:10, c(1, 3)),  extracts first 10 rows, columns, first 10 layers, array x. .e.:   brief explanation relationship flat indices () subscripts (s, d) arrays, see ss2ii.","code":"ss_x(x, n(1:10, 1:5), c(1, 3)) # ==> x[1:10, , 1:5, drop = FALSE]  ss_x(x, n(1:10, 0L, 1:5))      # ==> x[1:10, , 1:5, drop = FALSE]  ss_x(x, 1:10, 2)               # ==> x[ , 1:10, , drop = FALSE]  ss_x(x, 1:10)                  # ==> x[1:10, 1:10, 1:10, drop = FALSE]  ss_x(x, 1:10, c(1, 3))         # ==> x[1:10, , 1:10, drop = FALSE]"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa04_squarebrackets_indx_args.html","id":"argument-pair-margin-slice","dir":"Reference","previous_headings":"","what":"Argument Pair margin, slice","title":"Index Arguments in the Generic Sub-setting Methods — aaa04_squarebrackets_indx_args","text":"Relevant idx method.  margin argument specifies dimension argument slice used.  .e. margin = 1, slice selects rows;  margin = 2, slice selects columns;  etc.  slice argument can following: NULL 0L, corresponds missing index argument. numeric vector strictly positive whole numbers dimension indices select operation. complex vector, explained squarebrackets_indx_fundamentals. logical vector length corresponding dimension size, giving dimension indices select operation. character vector index names.  dimension multiple indices given name, corresponding indices selected operation. One also give vector length 0 slice;  Argument slice used idx method , result idx meant used inside regular [ [<- operators.  Thus effect zero-length index specification depends rule-set [.class(x) [<-.class(x).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa04_squarebrackets_indx_args.html","id":"arguments-row-col","dir":"Reference","previous_headings":"","what":"Arguments row, col","title":"Index Arguments in the Generic Sub-setting Methods — aaa04_squarebrackets_indx_args","text":"Specifies rows columns matrix. argument row col can following: NULL 0L, corresponds missing index argument. vector length 0, case indices selected operation (.e. empty selection). numeric vector strictly positive whole numbers dimension indices select operation. complex vector, explained squarebrackets_indx_fundamentals. logical vector length corresponding dimension size, giving dimension indices select operation. character vector index names.  dimension multiple indices given name, corresponding indices selected operation.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa04_squarebrackets_indx_args.html","id":"arguments-obs-vars","dir":"Reference","previous_headings":"","what":"Arguments obs, vars","title":"Index Arguments in the Generic Sub-setting Methods — aaa04_squarebrackets_indx_args","text":"obs argument specifies indices observations (.e. rows) data.frame-like objects.  vars argument specifies indices variables (.e. columns) data.frame-like objects.  obs  vars arguments inspired subset select arguments, respectively, base R's subset.data.frame method. However, obs  vars arguments use non-standard evaluation, keep 'squarebrackets' fully programmatically friendly. obs Argument  obs argument can following: NULL 0L, corresponds missing index argument. vector length 0, case indices selected operation (.e. empty selection). numeric vector strictly positive whole numbers row indices select operation. complex vector, explained squarebrackets_indx_fundamentals. logical vector length number rows, giving row indices select operation. one-sided formula, single logical expression using column names data.frame, giving condition observation/row indices selected operation. perform operation observations holds height > 2 sex != \"female\", specify following formula:   formula linked environment, variables found data set searched environment. vars Argument  vars argument can following NULL (default) 0L, corresponds missing argument. vector length 0, case indices selected operation (.e. empty selection). numeric vector strictly positive whole numbers column indices select operation. complex vector, explained squarebrackets_indx_fundamentals. logical vector length number columns, giving column indices select operation. character vector giving colnames select.  Note 'squarebrackets' assumes data.frame-like objects unique column names. function returns logical vector, giving column indices select operation.  example, select numeric variables, specify vars = .numeric. two-sided formula, side consists single term, giving range names select.  example, select variables including variables \"height\" \"weight\", specify following: vars =  heigth ~ weight. EXAMPLE using obs, vars arguments corresponds something like following:","code":"obs = ~ (height > 2) & (sex != \"female\") sbt_x(x, obs, vars) # ==> subset(x, ...obs..., ...vars...)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa04_squarebrackets_indx_args.html","id":"argument-inv","dir":"Reference","previous_headings":"","what":"Argument inv","title":"Index Arguments in the Generic Sub-setting Methods — aaa04_squarebrackets_indx_args","text":"Relevant _mod,_set, idx methods.  default, inv = FALSE, translates indices like normally.  inv = TRUE, inverse indices taken.  Consider, example, atomic matrix x;  using ss_mod(x, 1:2, 2L, tf = tf) corresponds something like following:   using ss_mod(x, vars = 1:2, inv = TRUE, tf = tf) corresponds something like following:   NOTE  order user gives indices inv = TRUE generally matter.  order indices appear original object x maintained, just like base 'R'.  Therefore, replacing multiple values order replacement matters, better keep inv = FALSE, default.  replacement single value transformation function, inv = TRUE can used without considering ordering.","code":"x[, 1:2] <- tf(x[, 1:2]) x x[, -1:-2] <- tf(x[, -1:-2]) x"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa04_squarebrackets_indx_args.html","id":"all-missing-indices","dir":"Reference","previous_headings":"","what":"All Missing Indices","title":"Index Arguments in the Generic Sub-setting Methods — aaa04_squarebrackets_indx_args","text":"NULL 0L indexing arguments correspond missing argument.  s, d, specifying d length 0 also corresponds subscripts missing.  Thus, _x _wo methods, using missing indexing arguments indexing arguments corresponds something like following:   Similarly, _mod _set methods, using missing NULL indexing arguments corresponds something like following:   true even inv = TRUE.","code":"x[] x[] <- rp # for replacement x[] <- tf(x) # for transformation"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa04_squarebrackets_indx_args.html","id":"drop","dir":"Reference","previous_headings":"","what":"Drop","title":"Index Arguments in the Generic Sub-setting Methods — aaa04_squarebrackets_indx_args","text":"Sub-setting generic methods 'squarebrackets' R-package using dimensional arguments (s, d, row, col obs, vars) always use drop = FALSE.  drop potentially redundant (.e. single level) dimensions, use drop function, like :","code":"ss_x(x, s, d) |> drop() # ==> x[..., drop = TRUE]"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa04_squarebrackets_indx_args.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Index Arguments in the Generic Sub-setting Methods — aaa04_squarebrackets_indx_args","text":"Plate T, Heiberger R (2016). abind: Combine Multidimensional Arrays. R package version 1.4-5, https://CRAN.R-project.org/package=abind.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa05_squarebrackets_modify.html","id":null,"dir":"Reference","previous_headings":"","what":"Regarding Modification — aaa05_squarebrackets_modify","title":"Regarding Modification — aaa05_squarebrackets_modify","text":"help page describes main modification semantics available 'squarebrackets'.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa05_squarebrackets_modify.html","id":"base-r-s-default-modification","dir":"Reference","previous_headings":"","what":"Base R's default modification","title":"Regarding Modification — aaa05_squarebrackets_modify","text":"average users, R's default copy--modify semantics fine.  benefits indexing arguments 'squarebrackets' can combined [<- operator, idx method.  result idx() method can used inside regular square-brackets operators.  example like :   thus allowing user benefit convenient index translations 'squarebrackets', whilst still using R's default copy--modification semantics (instead semantics provided 'squarebrackets').","code":"x <- array(...) my_indices <- idx(x, s, d) x[my_indices] <- value  y <- data.frame(...) rows <- idx(y, 1:10, 1, inv = TRUE) cols <- idx(y, c(\"a\", \"b\"), 2) y[rows, cols] <- value"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa05_squarebrackets_modify.html","id":"explicit-copy","dir":"Reference","previous_headings":"","what":"Explicit Copy","title":"Regarding Modification — aaa05_squarebrackets_modify","text":"'squarebrackets' provides _mod method modify (shallow) copy.  method returns modified object.  recursive objects, ii_mod/ss_mod returns original object, modified subsets copied, thus preventing unnecessary usage memory.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa05_squarebrackets_modify.html","id":"pass-by-reference","dir":"Reference","previous_headings":"","what":"Pass-by-Reference","title":"Regarding Modification — aaa05_squarebrackets_modify","text":"'squarebrackets' provides *_set methods modify reference, meaning copy made .  Pass--Reference fastest memory efficient.  also involved modification forms, requires thought.  See squarebrackets_PassByReference information.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa05_squarebrackets_modify.html","id":"replacement-and-transformation-in-atomic-objects","dir":"Reference","previous_headings":"","what":"Replacement and Transformation in Atomic Objects","title":"Regarding Modification — aaa05_squarebrackets_modify","text":"rp argument used replace values specified indices values specified rp. Using rp argument modification methods, corresponds something like following:   tf argument used transform values specified indices transformation function tf. Using tf argument corresponds something like following:   tf function returns object appropriate type size (tf pass--reference function).","code":"x[...] <- rp x[...] <- tf(x[...])"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa05_squarebrackets_modify.html","id":"replacement-and-transformation-in-lists","dir":"Reference","previous_headings":"","what":"Replacement and Transformation in Lists","title":"Regarding Modification — aaa05_squarebrackets_modify","text":"rp tf arguments work mostly way recursive objects.  slight differences. Argument rp  'squarebrackets' demands rp always provided list S3 methods recursive vectors, matrices, arrays (.e. lists).  prevent ambiguity respect replacement recycled distributed specified indices  (See Footnote 1 ). Argument tf  functions (base) 'R' vectorized atomic objects, lists  (see Footnote 2 ).  'squarebrackets' therefore apply transformation function tf via lapply, like :","code":"x[...] <- lapply(x[...], tf)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa05_squarebrackets_modify.html","id":"replacement-and-transformation-in-data-frame-like-objects","dir":"Reference","previous_headings":"","what":"Replacement and Transformation in data.frame-like Objects","title":"Regarding Modification — aaa05_squarebrackets_modify","text":"Replacement transformations data.frame-like objects bit flexible Lists. rp always demanded list data.frame-like objects, appropriate (example, replacing multiple columns, column list.)  Bear mind every column data.frame like element list;  .lapply used transformations across multiple columns.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa05_squarebrackets_modify.html","id":"recycling-and-coercion","dir":"Reference","previous_headings":"","what":"Recycling and Coercion","title":"Regarding Modification — aaa05_squarebrackets_modify","text":"Recycling allowed modification methods.  , example, length(rp) must equal length selected subset, equal 1.  using Pass--Reference semantics, user extra mindful auto-coercion rules.  See squarebrackets_coercion details.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa05_squarebrackets_modify.html","id":"footnotes","dir":"Reference","previous_headings":"","what":"Footnotes","title":"Regarding Modification — aaa05_squarebrackets_modify","text":"Footnote 1  Consider following replacement base 'R':   happen?  x[1] list(1:2) x[2] also list(1:2)?  x[1] list(2) x[2] list(1)?  turns latter happen; somewhat ambiguous code.  prevent ambiguity code, 'squarebrackets' demands rp always provided list. Footnote 2  functions (base) 'R' vectorized atomic objects, lists.  One reasons following:  atomic vector x type t, every single element x scalar type t.  However, every element list x can virtually anything:  atomic object, another list, unevaluated expression, even dark magic like quote(expr =).  difficult make vectorized function object many unknowns.  Therefore, vast majority cases, one needs loop list elements.","code":"x <-list(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) x[1:2] <- 2:1"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa06_squarebrackets_options.html","id":null,"dir":"Reference","previous_headings":"","what":"squarebrackets Options — aaa06_squarebrackets_options","title":"squarebrackets Options — aaa06_squarebrackets_options","text":"help page explains various global options can set 'squarebrackets' package, affects functionality.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa06_squarebrackets_options.html","id":"check-duplicates","dir":"Reference","previous_headings":"","what":"Check Duplicates","title":"squarebrackets Options — aaa06_squarebrackets_options","text":"\\(\\ast\\)_x methods methods providing duplicate indices actually make sense.  methods, make sense.  Giving duplicate indices usually break anything; however, replacing/transforming removing subsets, almost certainly intention provide duplicate indices.  Providing duplicate indices anyway might lead unexpected results.  Therefore, methods giving duplicate indices make sense, chkdup argument present.  argument controls whether method question checks duplicates (TRUE) (FALSE).  Setting chkdup = TRUE means method question check duplicate indices, give error finds .  Setting chkdup = FALSE disable checks, saves time computation power, thus efficient.  Since checking duplicates can expensive, set FALSE default.  default can changed squarebrackets.chkdup option.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa06_squarebrackets_options.html","id":"sticky","dir":"Reference","previous_headings":"","what":"Sticky","title":"squarebrackets Options — aaa06_squarebrackets_options","text":"slice_x, slice_wo, slicev_x methods can already handle names (use.names argument), attributes specific mutatomic class, attributes specific factor class.  Attributes names, specific mutatomic class, specific factor class - henceforth referred \"attributes\" - treated differently.  slice_x, slice_wo, slicev_x methods handle \"\" attributes, determined sticky option argument.  sticky = FALSE, slice_x, slice_wo, slicev_x methods drop attributes.  setting sticky = TRUE, attributes, except comment tsp, preserved;  key advantage , classes use static attributes (.e. classes use attributes change sub-setting), automatically supported sticky = TRUE, separate methods written slice_x, slice_wo, slicev_x methods.  Attributes specific classes like difftime, Date, POSIXct, roman, hexmode, octmode, , use static attributes.  Instead setting sticky = TRUE sticky = FALSE, one can also specify classes use static attributes using current R session.  fact, 'squarebrackets' loaded, squarebrackets.sticky option set follows:   default setting, sticky = TRUE  \"difftime\", \"Date\", \"POSIXct\", \"roman\", \"hexmode\", \"octmode\", \"broadcaster\".  Also default setting, sticky = FALSE classes.  reason slice_x, slice_wo, slicev_x methods need sticky option, following.  Unlike ii_, ii_, ss_, ss_ methods, slice_x, slice_wo, slicev_x methods wrappers around [ [<- operators.  Therefore, [ - S3 methods highly specialized classes readily available slice_x, slice_wo, slicev_x methods.  turn means important class-specific attributes automatically preserved.  sticky option convenient way support large number classes, without write specific methods .  specialized classes use attributes change sub-setting, separate dispatches slice_x, slice_wo, slicev_x methods need written.  Package authors welcome create method dispatches classes methods.","code":"squarebrackets.sticky = c(    \"difftime\", \"Date\", \"POSIXct\", \"roman\", \"hexmode\", \"octmode\", \"broadcaster\" )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa07_squarebrackets_method_dispatch.html","id":null,"dir":"Reference","previous_headings":"","what":"Method Dispatch of 'squarebrackets' — aaa07_squarebrackets_method_dispatch","title":"Method Dispatch of 'squarebrackets' — aaa07_squarebrackets_method_dispatch","text":"help page gives additional details regarding S3 method dispatch used 'squarebrackets'.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa07_squarebrackets_method_dispatch.html","id":"ellipsis","dir":"Reference","previous_headings":"","what":"Ellipsis","title":"Method Dispatch of 'squarebrackets' — aaa07_squarebrackets_method_dispatch","text":"Due S3 method dispatch system works 'R', generic methods ellipsis argument (...).  user's safety, 'squarebrackets' check user accidentally add arguments make sense method (like specifying inv argument calling ii_x).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa08_squarebrackets_slicev.html","id":null,"dir":"Reference","previous_headings":"","what":"On Index-Less Value-Based Sub-Set Operations — aaa08_squarebrackets_slicev","title":"On Index-Less Value-Based Sub-Set Operations — aaa08_squarebrackets_slicev","text":"help page explains details arguments used slicev_ methods countv function.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa08_squarebrackets_slicev.html","id":"the-basic-idea","dir":"Reference","previous_headings":"","what":"The Basic Idea","title":"On Index-Less Value-Based Sub-Set Operations — aaa08_squarebrackets_slicev","text":"basic idea follows.  Let x y 2 atomic vectors length (type).  Let v atomic scalar type y.  Given result r condition y == v, basic idea perform following sub-set operations:   default argument specification r = TRUE.  course one can invert relationship specifying argument r = FALSE, get something like following:   y allowed vector x, course.  basic idea, however, can become complicated, depending atomic type y, discussed next section.","code":"slicev_x(x, y = y, v = v)            # ==> x[y == v] slicev_set(x, y = y, v = v, rp = rp) # ==> x[y == v] <- rp slicev_set(x, y = y, v = v, tf = tf) # ==> x[y == v] <- tf(x[y == v]) countv(y,v = v)                      # ==> sum(y == v) slicev_x(x, y = y, v = v, r = FALSE)             # ==> x[y != v] slicev_set(x, y = y, v = v, r = FALSE, rp = rp)  # ==> x[y != v] <- rp slicev_set(x, y = y, v = v, r = FALSE, tf = tf)  # ==> x[y != v] <- tf(x[y != v]) countv(y, v = v, r = FALSE)                  # ==> sum(y != v)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa08_squarebrackets_slicev.html","id":"details-per-atomic-type","dir":"Reference","previous_headings":"","what":"Details per Atomic Type","title":"On Index-Less Value-Based Sub-Set Operations — aaa08_squarebrackets_slicev","text":"Logical, Raw, Complex  y type logical, raw, complex, slicev works exactly explained previous section. y v must atomic type. Numeric  y type integer double (collectively referred \"numeric\"), basic idea laid-still holds:  one can use atomic vector y atomic scalar v perform sub-set operations like x[y == v].  one may interested range numbers, rather one specific number (especially considering things like measurement error, machine precision, greater-/larger-relationships).  numeric y, one can also supply v length 2.  length(v) == 2L, slicev_/ countv check whether y inside (outside r = FALSE) bounded range given v.  .e. :   Note y v must numeric , type.  .e. one can y type integer v type double, without problems. Character  y type character, basic idea still something like x[y == v].  searching string v sub-setting purposes, one may want take consideration things like different spelling, spacing, even encodings string.  Implementing every form fuzzy matching encoding matching computationally intensive, also quite beyond scope package.  Instead, user may supply character vector v arbitrary length, containing variations (terms spelling, spacing, encoding, whatever) strings look .  vector given v (instead single string), following check performed:","code":"y >= v[1] & y <= v[2]  # if r = TRUE y < v[1] | y > v[2]    # if r = FALSE y %in% v   # if r = TRUE !y %in% v  # if r = FALSE"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa08_squarebrackets_slicev.html","id":"factors","dir":"Reference","previous_headings":"","what":"Factors","title":"On Index-Less Value-Based Sub-Set Operations — aaa08_squarebrackets_slicev","text":"Technically, factor type integer, special behaviour extend treated differently 'R'.  similarly treated slicev_/ countv_ methods functions.  y factor, v can given : single string (matching one levels y); single integer (matching one unique values unclass(y)); factor length 1, levels level-ordering y. Note factors NA levels supported, passing factor y result error.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa08_squarebrackets_slicev.html","id":"smaller-than-greater-than","dir":"Reference","previous_headings":"","what":"Smaller Than, Greater Than","title":"On Index-Less Value-Based Sub-Set Operations — aaa08_squarebrackets_slicev","text":"numeric y, one can specify range v, explained earlier.  note one can also specify something like v = c(-Inf, 4), essentially corresponds condition y <= 4.  Thus, v specifies range, \"greater-\" \"smaller-\" comparisons also possible.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa08_squarebrackets_slicev.html","id":"handling-nas-and-nan","dir":"Reference","previous_headings":"","what":"Handling NAs and NaN","title":"On Index-Less Value-Based Sub-Set Operations — aaa08_squarebrackets_slicev","text":"also handle NAs NaNs.  na argument can used specify y NA.  na = FALSE, NA values y always ignored.  extracted (slicev_x), replaced (slicev_set), counted (countv).  na = TRUE, NA values y always included.  included extractions (slicev_x), replacements (slicev_set), counts (countv).  One can also specify na = NA, ignore v completely, explicitly look NAs/NaNs y instead - like :   Handling NAs works atomic types.  y type complex, value y[] considered NA Re(y[]) NA/NaN /Im(y[]) NA/NaN.  Argument v never allowed contain NA/NaN.","code":"slicev_x(x, y = y, na = NA)                        # ==> x[is.na(y)] slicev_x(x, y = y, na = NA, r = FALSE)             # ==> x[!is.na(y)] slicev_set(x, y = y, na = NA, rp = rp)             # ==> x[is.na(y)] <- rp slicev_set(x, y = y, na = NA, r = FALSE, rp = rp)  # ==> x[!is.na(y)] <- rp slicev_set(x, y = y, na = NA, tf = tf)             # ==> x[is.na(y)] <- tf(x[is.na(y)]) slicev_set(x, y = y, na = NA, r = FALSE, tf = tf)  # ==> x[!is.na(y)] <- tf(x[!is.na(y)]) countv(y, na = NA)                                 # ==> sum(is.na(y)) countv(y, na = NA, r = FALSE)                      # ==> sum(!is.na(y))"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa08_squarebrackets_slicev.html","id":"from-to","dir":"Reference","previous_headings":"","what":"From, To","title":"On Index-Less Value-Based Sub-Set Operations — aaa08_squarebrackets_slicev","text":"Like slice methods, one can specify range within perform sub-set operations, using , arguments.  example, wish extract values x holds y != v, want extractions index 10 100, one can specify following: slicev_x(x, y = y, v = v, r = FALSE, = 10, = 100.  Just like slice, ,argument can also used reverse order result, specifying higher value .  step-size slicev/countv functions always 1L ( -1L > ).  Also like slice, , can imaginary numbers also, explained cp_seq.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa08_squarebrackets_slicev.html","id":"inverting","dir":"Reference","previous_headings":"","what":"Inverting","title":"On Index-Less Value-Based Sub-Set Operations — aaa08_squarebrackets_slicev","text":"countv() slicev_set() \"invert\" argument, likewise slicev_wo() function.  One can invert sub-set condition, specifying r = FALSE.  r = FALSE inverts condition; invert range specified , .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa08_squarebrackets_slicev.html","id":"ellipsis","dir":"Reference","previous_headings":"","what":"Ellipsis","title":"On Index-Less Value-Based Sub-Set Operations — aaa08_squarebrackets_slicev","text":"ellipsis (...) intentionally placed right first argument (x slicev_ y countv) force user explicitly name arguments, avoid lot unnecessary confusion.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa08_squarebrackets_slicev.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"On Index-Less Value-Based Sub-Set Operations — aaa08_squarebrackets_slicev","text":"","code":"# basic idea ==== nms <- c(letters, LETTERS, month.abb, month.name) |> rep_len(1e6) x <- mutatomic(1:1e6, names = nms) head(x) #> a b c d e f  #> 1 2 3 4 5 6  #> mutatomic  #> typeof:  integer   # memory efficient form of sum(x <= 10): countv(x, v = c(-Inf, 10)) #> [1] 10  # extract all elements of x with the name \"a\": slicev_x(x, y = names(x), v = \"a\") |> head() #>   a   a   a   a   a   a  #>   1  77 153 229 305 381  #> mutatomic  #> typeof:  integer   # find all x smaller than or equal to 5, and replace with `-1000`: slicev_set(x, y = x, v = c(-Inf, 5), rp = -1000L) head(x, n = 10) #>     a     b     c     d     e     f     g     h     i     j  #> -1000 -1000 -1000 -1000 -1000     6     7     8     9    10  #> mutatomic  #> typeof:  integer    ################################################################################ # Numeric range ==== # x <- mutatomic(1:1e6) head(x) #> [1] 1 2 3 4 5 6 #> mutatomic  #> typeof:  integer  slicev_x(x, v= c(-Inf, 5)) # x[x <= 5] #> [1] 1 2 3 4 5 #> mutatomic  #> typeof:  integer    ################################################################################ # Character ==== # if(require(stringi)) {   x <- stringi::stri_rand_shuffle(rep(\"hello\", 1e5))   head(x)   slicev_x(x, v = \"hello\") |> head() # find \"hello\"      # find 2 possible misspellings of \"hello\":   slicev_x(x, v = c(\"holle\", \"helol\")) |> head()    } #> Loading required package: stringi #> [1] \"holle\" \"helol\" \"holle\" \"holle\" \"helol\" \"helol\""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa09_squarebrackets_PassByReference.html","id":null,"dir":"Reference","previous_headings":"","what":"Regarding Modification By Reference — aaa09_squarebrackets_PassByReference","title":"Regarding Modification By Reference — aaa09_squarebrackets_PassByReference","text":"help page describes modification using \"pass--reference\" semantics handled 'squarebrackets' package.  \"Pass--reference\" refers modifying mutable object, subset mutable object, without making copies .  help page explain basics pass--reference semantics, treated prior knowledge.  functions/methods 'squarebrackets' package word \"set\" name use pass--reference semantics.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa09_squarebrackets_PassByReference.html","id":"advantages-and-disadvantages","dir":"Reference","previous_headings":"","what":"Advantages and Disadvantages","title":"Regarding Modification By Reference — aaa09_squarebrackets_PassByReference","text":"main advantage pass--reference much less memory required modify objects, modification also generally faster.  several disadvantages.  First, coercion rules slightly different: see squarebrackets_coercion.  Second, 2 variables refer exactly object (.e. address), changing one variable also changes ones.  .e. following code,   modifies just x, also y.  true even one variables locked (see bindingIsLocked).  .e. following code,   modifies x y without error, even though y locked constant.","code":"x <- y <- mutatomic(1:16) ii_set(x, 1:6, rp = 8) x <- mutatomic(1:16) y <- x lockBinding(\"y\", environment()) ii_set(x, i = 1:6, rp = 8)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa09_squarebrackets_PassByReference.html","id":"mutable-vs-immutable-classes","dir":"Reference","previous_headings":"","what":"Mutable vs Immutable Classes","title":"Regarding Modification By Reference — aaa09_squarebrackets_PassByReference","text":"exception environments, base R's S3 classes treated immutable:  Modifying object 'R' make copy object, something called 'copy--modify' semantics.  prominent mutable S3 class data.table class, mutable data.frame class, supported 'squarebrackets'.  Similarly, 'squarebrackets' adds class mutable atomic objects: mutatomic.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa09_squarebrackets_PassByReference.html","id":"material-vs-immaterial-objects","dir":"Reference","previous_headings":"","what":"Material vs Immaterial objects","title":"Regarding Modification By Reference — aaa09_squarebrackets_PassByReference","text":"objects 'R' material objects:  values object contains actually stored memory.  example, given x <- rnorm(1e6), x material object:  1 million values (decimal numbers, case) actually stored memory.  contrast, ActiveBindings immaterial:  objects , accessed, call function generate values fly, rather actually storing values.  Since immaterial objects actually store values memory, values obviously also changed memory.  Therefore, Pass--Reference semantics work immaterial objects.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa09_squarebrackets_PassByReference.html","id":"altrep","dir":"Reference","previous_headings":"","what":"ALTREP","title":"Regarding Modification By Reference — aaa09_squarebrackets_PassByReference","text":"mutatomic constructors (.e. mutatomic, .mutatomic, etc.) automatically materialize ALTREP objects, ensure consistent behaviour 'pass--reference' semantics.  data.table can ALTREP columns.  data.tables coerce column materialized column modified, even reference.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa09_squarebrackets_PassByReference.html","id":"mutability-rules-with-respect-to-recursive-objects","dir":"Reference","previous_headings":"","what":"Mutability Rules With Respect To Recursive Objects","title":"Regarding Modification By Reference — aaa09_squarebrackets_PassByReference","text":"Lists difficult objects contain elements, simply point  objects, one can access via list.  recursive object mutable class, subsets treated mutable, long part object.  hand, recursive object immutable class, recursive subsets retain original mutability. Example 1: Mutable data.tables  data.table mutable class.  columns data.table treated mutable;  requirement , instance, first change columns class mutatomic modify columns reference. Example 2: Immutable lists  regular list immutable class.  list immutable, recursive subsets list retain mutability.  list mutatomic objects, example, mutatomic objects remain mutable.  Therefore, following pass--reference modification work without issue:   Notice code myref address x$, therefore copy x$.  Thus changing myref also changes x$.  words: myref called \"View\" x$.","code":"x <- list(  a = mutatomic(letters[1:10]),  b = mutatomic(letters[11:20]) ) myref <- x$a ii_set(myref, 1, rp = \"xxx\")"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa09_squarebrackets_PassByReference.html","id":"input-variable","dir":"Reference","previous_headings":"","what":"Input Variable","title":"Regarding Modification By Reference — aaa09_squarebrackets_PassByReference","text":"Methods/functions perform -place modification reference works objects actually exist actual variable, similar functions style some_function(x, ...) <- value.  Thus things like following, ii_set(1:10, ...), ii_set(x$, ...), ii_set(base::letters),  work.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa09_squarebrackets_PassByReference.html","id":"lock-binding","dir":"Reference","previous_headings":"","what":"Lock Binding","title":"Regarding Modification By Reference — aaa09_squarebrackets_PassByReference","text":"Mutable classes , name suggests, meant mutable.  Locking binding mutable object fruitless.  ensure object modified methods/functions 'squarebrackets', 2 things must true: object must immutable class. binding must locked (see lockBinding).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa09_squarebrackets_PassByReference.html","id":"protection","dir":"Reference","previous_headings":"","what":"Protection","title":"Regarding Modification By Reference — aaa09_squarebrackets_PassByReference","text":"Due properties described help page, 'squarebrackets' protects user something like following:   'squarebrackets' give error running code , : addresses baseenv() protected; immutable objects disallowed (create mutable object, create copy original, thus keeping original object safe modification reference); locked bindings disallowed.","code":"# letters = base::letters ii_set(letters, i = 1, rp = \"XXX\")"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa09_squarebrackets_PassByReference.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Regarding Modification By Reference — aaa09_squarebrackets_PassByReference","text":"","code":"# the following code demonstrates how locked bindings, # such as `base::letters`, # are being safe-guarded  x <- list(a = base::letters) myref <- x$a # view of a list address(myref) == address(base::letters) # TRUE: point to the same memory #> [1] TRUE bindingIsLocked(\"letters\", baseenv()) # base::letters is locked ... #> [1] TRUE bindingIsLocked(\"myref\", environment()) # ... but this pointer is not! #> [1] FALSE  if(requireNamespace(\"tinytest\")) {   tinytest::expect_error(     ii_set(myref, i = 1, rp = \"XXX\") # this still gives an error though ...   ) } #> Loading required namespace: tinytest #> ----- PASSED      : <--> #>  call| eval(expr, envir)   is.mutatomic(myref) # ... because it's not of class `mutatomic` #> [1] FALSE   x <- list(   a = as.mutatomic(base::letters) # `as.mutatomic()` makes a copy ) myref <- x$a # view of a list address(myref) == address(base::letters) # FALSE: it's a copy #> [1] FALSE ii_set(   myref, i = 1, rp = \"XXX\"  # modifies x, does NOT modify `base::letters` ) print(x) # x is modified #> $a #>  [1] \"XXX\" \"b\"   \"c\"   \"d\"   \"e\"   \"f\"   \"g\"   \"h\"   \"i\"   \"j\"   \"k\"   \"l\"   #> [13] \"m\"   \"n\"   \"o\"   \"p\"   \"q\"   \"r\"   \"s\"   \"t\"   \"u\"   \"v\"   \"w\"   \"x\"   #> [25] \"y\"   \"z\"   #> mutatomic  #> typeof:  character  #>  base::letters # but this still the same #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" #> [20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa10_squarebrackets_coercion.html","id":null,"dir":"Reference","previous_headings":"","what":"Auto-Coercion Rules for Mutable Objects — aaa10_squarebrackets_coercion","title":"Auto-Coercion Rules for Mutable Objects — aaa10_squarebrackets_coercion","text":"help page describes auto-coercion rules mutable classes, handled 'squarebrackets' package.  useful information users wish intend employ Pass--Reference semantics provided 'squarebrackets'.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa10_squarebrackets_coercion.html","id":"mutatomic","dir":"Reference","previous_headings":"","what":"mutatomic","title":"Auto-Coercion Rules for Mutable Objects — aaa10_squarebrackets_coercion","text":"Mutable atomic objects automatically coerced fit modified subset values, modifying copy, just like regular atomic classes.  example, replacing one multiple values integer vector (type int) decimal number (type dbl) coerce entire vector type dbl.  Replacing transforming subsets mutable atomic objects reference support coercion. Thus, example, following code,   gives c(rep(8, 6) 7:16) instead c(rep(8.5, 6), 7:16), x type integer, rp interpreted type integer also.","code":"x <- mutatomic(1:16) ii_set(x, i = 1:6, rp = 8.5) #> coercing replacement to integer print(x) #>  [1]  8  8  8  8  8  8  7  8  9 10 11 12 13 14 15 16 #> mutatomic #> typeof:  integer"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa10_squarebrackets_coercion.html","id":"data-table-when-replacing-transforming-whole-columns","dir":"Reference","previous_headings":"","what":"data.table, when replacing/transforming whole columns","title":"Auto-Coercion Rules for Mutable Objects — aaa10_squarebrackets_coercion","text":"data.table actually list made mutable, column list. , replacing/transforming whole columns using data.table::set(), without specifying rows (even = 1:nrow(x)), allows completely changing type column.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa10_squarebrackets_coercion.html","id":"data-table-when-partially-replacing-transforming-columns","dir":"Reference","previous_headings":"","what":"data.table, when partially replacing/transforming columns","title":"Auto-Coercion Rules for Mutable Objects — aaa10_squarebrackets_coercion","text":"rows specified data.table::set() function (functions internally use data.table::set()), thus values columns parts(.e. rows) columns replaced, auto-coercion takes place.  .e.: replacing/transforming value integer (int) column become 1.5, coerce column decimal type (dbl); instead, replacement value 1.5 coerced integer 1.  Using R's native copy--modify semantics (example changing data.table data.frame) allows coercion even partially replacing/transforming columns.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa10_squarebrackets_coercion.html","id":"views-of-lists","dir":"Reference","previous_headings":"","what":"Views of Lists","title":"Auto-Coercion Rules for Mutable Objects — aaa10_squarebrackets_coercion","text":"Regular lists treated immutable 'squarebrackets'.  remember list (potentially hierarchical) structure references objects.  Thus, even list treated mutable, subsets list mutable classes, mutable.  example, list mutatomic objects, mutatomic objects mutable.  Therefore, following work:   Notice code myref copy x$, since address.  Thus changing myref also changes x$.  words: myref called \"view\" x$.  Notice also ii_set(x$, ...) work.  stopifnot_ma_safe2mutate give error x actual variable, similar -place functions style `myfun()<-`.  auto-coercion rules Views Lists, depends entirely object .  Thus View data.table, coercion rules data.tables apply.  View mutatomic object, coercion rules mutatomic objects apply, etc.","code":"x <- list(  a = mutatomic(letters[1:10]),  b = mutatomic(letters[11:20]) ) myref <- x$a ii_set(myref, 1, rp = \"xxx\")"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa10_squarebrackets_coercion.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Auto-Coercion Rules for Mutable Objects — aaa10_squarebrackets_coercion","text":"","code":"# Coercion examples - mutatomic ====  x <- as.mutatomic(1:16) ii_set(x, i = 1:6, rp = 8.5) # 8.5 coerced to 8, because `x` is of type `integer` #> coercing replacement to integer print(x) #>  [1]  8  8  8  8  8  8  7  8  9 10 11 12 13 14 15 16 #> mutatomic  #> typeof:  integer   #############################################################################  # Coercion examples - data.table - whole columns ====  # sbt_mod(): obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sbt_mod(   obj, vars = is.numeric,   tf = sqrt # SAFE: obs = NULL, so coercion performed ) #>            a      b        c      d #>        <num> <char>    <num> <fctr> #>  1: 1.000000      a 3.316625      a #>  2: 1.414214      b 3.464102      b #>  3: 1.732051      c 3.605551      c #>  4: 2.000000      d 3.741657      d #>  5: 2.236068      e 3.872983      e #>  6: 2.449490      f 4.000000      f #>  7: 2.645751      g 4.123106      g #>  8: 2.828427      h 4.242641      h #>  9: 3.000000      i 4.358899      i #> 10: 3.162278      j 4.472136      j  # sbt_set(): sbt_set(   obj, vars = is.numeric,   tf = sqrt # SAFE: obs = NULL, so coercion performed ) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 1.41 1.73 2 2.24 ... #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  3.32 3.46 3.61 3.74 3.87 ... #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>   #############################################################################   # Coercion examples - data.table - partial columns ====  # sbt_mod(): obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>   sbt_mod(   obj, obs = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # SAFE: coercion performed ) #>             a      b         c      d #>         <num> <char>     <num> <fctr> #>  1:  1.000000      a 11.000000      a #>  2:  1.414214      b  3.464102      b #>  3:  1.732051      c  3.605551      c #>  4:  2.000000      d  3.741657      d #>  5:  2.236068      e  3.872983      e #>  6:  2.449490      f  4.000000      f #>  7:  2.645751      g  4.123106      g #>  8:  8.000000      h 18.000000      h #>  9:  9.000000      i 19.000000      i #> 10: 10.000000      j 20.000000      j  # sbt_set(): obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sbt_set(   obj, obs = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt   # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost ) #> Warning: 1.414214 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 1 named 'a') #> Warning: 3.464102 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 3 named 'c') print(obj) #>         a      b     c      d #>     <int> <char> <int> <fctr> #>  1:     1      a    11      a #>  2:     1      b     3      b #>  3:     1      c     3      c #>  4:     2      d     3      d #>  5:     2      e     3      e #>  6:     2      f     4      f #>  7:     2      g     4      g #>  8:     8      h    18      h #>  9:     9      i    19      i #> 10:    10      j    20      j  obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sbt_set(obj, vars = is.numeric, tf = as.numeric) # first coerce type by whole columns str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sbt_set(obj,   obs = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # SAFE: coercion performed by dt_setcoe(); so no warnings )  print(obj) #>             a      b         c      d #>         <num> <char>     <num> <fctr> #>  1:  1.000000      a 11.000000      a #>  2:  1.414214      b  3.464102      b #>  3:  1.732051      c  3.605551      c #>  4:  2.000000      d  3.741657      d #>  5:  2.236068      e  3.872983      e #>  6:  2.449490      f  4.000000      f #>  7:  2.645751      g  4.123106      g #>  8:  8.000000      h 18.000000      h #>  9:  9.000000      i 19.000000      i #> 10: 10.000000      j 20.000000      j   #############################################################################  # View of List ====  x <- list(  a = data.table::data.table(cola = 1:10, colb = letters[1:10]),  b = data.table::data.table(cola = 11:20, colb = letters[11:20]) ) print(x) #> $a #>      cola   colb #>     <int> <char> #>  1:     1      a #>  2:     2      b #>  3:     3      c #>  4:     4      d #>  5:     5      e #>  6:     6      f #>  7:     7      g #>  8:     8      h #>  9:     9      i #> 10:    10      j #>  #> $b #>      cola   colb #>     <int> <char> #>  1:    11      k #>  2:    12      l #>  3:    13      m #>  4:    14      n #>  5:    15      o #>  6:    16      p #>  7:    17      q #>  8:    18      r #>  9:    19      s #> 10:    20      t #>  myref <- x$a address(myref) == address(x$a) # they are the same #> [1] TRUE sbt_set(myref, vars = \"cola\", tf = \\(x)x^2) print(x) # notice x has been changed #> $a #>      cola   colb #>     <num> <char> #>  1:     1      a #>  2:     4      b #>  3:     9      c #>  4:    16      d #>  5:    25      e #>  6:    36      f #>  7:    49      g #>  8:    64      h #>  9:    81      i #> 10:   100      j #>  #> $b #>      cola   colb #>     <int> <char> #>  1:    11      k #>  2:    12      l #>  3:    13      m #>  4:    14      n #>  5:    15      o #>  6:    16      p #>  7:    17      q #>  8:    18      r #>  9:    19      s #> 10:    20      t #>"},{"path":"https://tony-aw.github.io/squarebrackets/reference/cp_seq.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct Parameters for a Sequence Based on Margins — cp_seq","title":"Construct Parameters for a Sequence Based on Margins — cp_seq","text":"cp_seq() returns list parameters construct sequence based margins object.  internally used idx_r function slice method.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/cp_seq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct Parameters for a Sequence Based on Margins — cp_seq","text":"","code":"cp_seq(x, m = 0L, from = NULL, to = NULL, by = 1L)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/cp_seq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct Parameters for a Sequence Based on Margins — cp_seq","text":"x object compute margin-based sequence parameters. m integer complex, giving margin(s).  non-dimensional objects flat indices, specify m = 0L. integer complex, length m length 1, specifying point. integer complex, length m length 1, specifying maximally allowed end value. integer, length m length 1, specifying step size.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/cp_seq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct Parameters for a Sequence Based on Margins — cp_seq","text":"list following elements: $start:  actual starting point sequence.  simply translated regular numeric. $end:  actual ending point sequence.  .  example, following code:   specifies = 10L.  sequence actually end 10; ends 9.  Therefore, cp_seq(x, m, 1, 10, 2) return end = 9, end = 10.  allows user easily predict sequence given idx_r/slice actually end. $:  give , sign adjusted, needed. $length.:  actual vector lengths sequences , given translated parameters.","code":"seq(from = 1L, to = 10L, by = 2L) #> [1] 1 3 5 7 9"},{"path":"https://tony-aw.github.io/squarebrackets/reference/cp_seq.html","id":"arguments-details","dir":"Reference","previous_headings":"","what":"Arguments Details","title":"Construct Parameters for a Sequence Based on Margins — cp_seq","text":"Multiple dimensions  cp_seq function can construct sequence parameters needed multiple dimensions , specifying vector m.  lengths arguments recycled needed. Using  , specified, using construct following sequence:  positive, seq.int(1L, n, ).  negative, seq.int(n, 1L, ).  n maximum index (.e. length(x) dim(x)[m], depending situation). Using , ,  , , specified, stored abs(), sign  automatically adjusted ensure sensible sequence created.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/cp_seq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct Parameters for a Sequence Based on Margins — cp_seq","text":"","code":"x <- data.frame(   a = 1:10, b = letters[1:10], c = factor(letters[1:10]), d = -1:-10 ) print(x) #>     a b c   d #> 1   1 a a  -1 #> 2   2 b b  -2 #> 3   3 c c  -3 #> 4   4 d d  -4 #> 5   5 e e  -5 #> 6   6 f f  -6 #> 7   7 g g  -7 #> 8   8 h h  -8 #> 9   9 i i  -9 #> 10 10 j j -10 ind1 <- idx_r(x, 1, 2, 2* -1i) # rows 2:(nrow(x)-1) sbt_x(x, ind1) # extract the row range #>   a b c  d #> 1 2 b b -2 #> 2 3 c c -3 #> 3 4 d d -4 #> 4 5 e e -5 #> 5 6 f f -6 #> 6 7 g g -7 #> 7 8 h h -8 #> 8 9 i i -9  x <- array(1:125, c(5,5,5)) d <- 1:3 s <- idx_r(x, d, 2, 2* -1i) # 2:(n-1) for every dimension ss_x(x, s = s, d = d) # same as x[ 2:4, 2:4, 2:4, drop = FALSE] #> , , 1 #>  #>      [,1] [,2] [,3] #> [1,]   32   37   42 #> [2,]   33   38   43 #> [3,]   34   39   44 #>  #> , , 2 #>  #>      [,1] [,2] [,3] #> [1,]   57   62   67 #> [2,]   58   63   68 #> [3,]   59   64   69 #>  #> , , 3 #>  #>      [,1] [,2] [,3] #> [1,]   82   87   92 #> [2,]   83   88   93 #> [3,]   84   89   94 #>   x <- letters x[idx_r(x, 0, 2, 2* -1i)] #>  [1] \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" \"t\" #> [20] \"u\" \"v\" \"w\" \"x\" \"y\""},{"path":"https://tony-aw.github.io/squarebrackets/reference/developer_ci.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct Indices — developer_ci","title":"Construct Indices — developer_ci","text":"functions construct indices. ci_ii() constructs integer vector flat/interior indices. ci_margin() constructs integer vector indices one particular dimension margin. ci_ss() constructs list integer subscripts. ci_df() ci_margin(), except specifically designed data.frame-like objects.  separate function, things like dimnames(x)[1] rownames(x) always return output certain data.frame-like objects. ci_obs() ci_vars() construct row column indices, respectively, data.frame-like objects.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/developer_ci.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct Indices — developer_ci","text":"","code":"ci_ii(   x,   i,   inv = FALSE,   chkdup = FALSE,   uniquely_named = FALSE,   .abortcall = sys.call() )  ci_margin(   x,   slice,   margin,   inv = FALSE,   chkdup = FALSE,   uniquely_named = FALSE,   .abortcall = sys.call() )  ci_ss(   x,   s,   d = 1:ndim(x),   inv = FALSE,   chkdup = FALSE,   uniquely_named = FALSE,   .abortcall = sys.call() )  ci_df(   x,   slice,   margin,   inv = FALSE,   chkdup = FALSE,   uniquely_named = TRUE,   .abortcall = sys.call() )  ci_obs(   x,   obs,   inv = FALSE,   chkdup = FALSE,   uniquely_named = TRUE,   .abortcall = sys.call() )  ci_vars(   x,   vars,   inv = FALSE,   chkdup = FALSE,   uniquely_named = TRUE,   .abortcall = sys.call() )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/developer_ci.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct Indices — developer_ci","text":"x object indices meant. , s, d, slice, margin, obs, vars, inv See squarebrackets_indx_args. chkdup see squarebrackets_options. uniquely_named Boolean, indicating user knows -priori relevant names x unique.  set TRUE, speed may increase.  specifying TRUE relevant names unique result incorrect output. .abortcall environment error message passed .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/developer_ci.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct Indices — developer_ci","text":"integer vector constructed indices.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/developer_ci.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct Indices — developer_ci","text":"","code":"x <- matrix(1:25, 5, 5) colnames(x) <- c(\"a\", \"a\", \"b\", \"c\", \"d\") print(x) #>      a  a  b  c  d #> [1,] 1  6 11 16 21 #> [2,] 2  7 12 17 22 #> [3,] 3  8 13 18 23 #> [4,] 4  9 14 19 24 #> [5,] 5 10 15 20 25  bool <- sample(c(TRUE, FALSE), 5, TRUE) int <- 1:4 chr <- c(\"a\", \"a\") cplx <- 1:4 * -1i tci_bool(bool, nrow(x)) #> [1] 2 tci_int(int, ncol(x), inv = TRUE) #> [1] 5 tci_chr(chr, colnames(x)) #> [1] 1 2 1 2 tci_im(cplx, nrow(x)) #> [1] 5 4 3 2  ci_ii(x, 1:10 * -1i) #>  [1] 25 24 23 22 21 20 19 18 17 16 ci_margin(x, 1:4, 2) #> [1] 1 2 3 4 ci_ss(x, n(1:5 * -1i, 1:4), 1:2) #> [[1]] #> [1] 5 4 3 2 1 #>  #> [[2]] #> [1] 1 2 3 4 #>"},{"path":"https://tony-aw.github.io/squarebrackets/reference/developer_tci.html","id":null,"dir":"Reference","previous_headings":"","what":"Type Cast Indices — developer_tci","title":"Type Cast Indices — developer_tci","text":"functions typecast indices proper integer indices.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/developer_tci.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Type Cast Indices — developer_tci","text":"","code":"tci_bool(indx, n, inv = FALSE, .abortcall = sys.call())  tci_int(indx, n, inv = FALSE, chkdup = FALSE, .abortcall = sys.call())  tci_chr(   indx,   nms,   inv = FALSE,   chkdup = FALSE,   uniquely_named = FALSE,   .abortcall = sys.call() )  tci_im(indx, n, inv = FALSE, chkdup = FALSE, .abortcall = sys.call())"},{"path":"https://tony-aw.github.io/squarebrackets/reference/developer_tci.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Type Cast Indices — developer_tci","text":"indx indices typecast n relevant size, typecasting integer logical indices.  Examples: target row indices, input nrow n. target flat indices, input length n. inv Boolean, indicating indices inverted.  See squarebrackets_indx_args. .abortcall environment error message passed . chkdup see squarebrackets_options. nms relevant names, typecasting character indices.  Examples: target row indices, input row names nms. target flat indices, input flat names nms. uniquely_named Boolean, indicating user knows -priori relevant names x unique.  set TRUE, speed may increase.  specifying TRUE relevant names unique result incorrect output.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/developer_tci.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Type Cast Indices — developer_tci","text":"integer vector type-cast indices.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/developer_tci.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Type Cast Indices — developer_tci","text":"","code":"x <- matrix(1:25, 5, 5) colnames(x) <- c(\"a\", \"a\", \"b\", \"c\", \"d\") print(x) #>      a  a  b  c  d #> [1,] 1  6 11 16 21 #> [2,] 2  7 12 17 22 #> [3,] 3  8 13 18 23 #> [4,] 4  9 14 19 24 #> [5,] 5 10 15 20 25  bool <- sample(c(TRUE, FALSE), 5, TRUE) int <- 1:4 chr <- c(\"a\", \"a\") cplx <- 1:4 * -1i tci_bool(bool, nrow(x)) #> [1] 1 2 3 4 5 tci_int(int, ncol(x), inv = TRUE) #> [1] 5 tci_chr(chr, colnames(x)) #> [1] 1 2 1 2 tci_im(cplx, nrow(x)) #> [1] 5 4 3 2  ci_ii(x, 1:10 * -1i) #>  [1] 25 24 23 22 21 20 19 18 17 16 ci_margin(x, 1:4, 2) #> [1] 1 2 3 4 ci_ss(x, n(1:5 * -1i, 1:4), 1:2) #> [[1]] #> [1] 5 4 3 2 1 #>  #> [[2]] #> [1] 1 2 3 4 #>"},{"path":"https://tony-aw.github.io/squarebrackets/reference/dt.html","id":null,"dir":"Reference","previous_headings":"","what":"Functional Forms of data.table Operations — dt","title":"Functional Forms of data.table Operations — dt","text":"Functional forms special data.table operations.  functions use Non-Standard Evaluation.  functions also benefit security measures 'squarebrackets' implements pass--reference semantics. dt_aggregate() aggregates data.table tidytable, returns aggregated copy. dt_setcoe() coercively transforms columns data.table tidytable using pass--reference semantics. dt_setrm() removes columns data.table tidytable using pass--reference semantics. dt_setadd(x, new) adds columns data.table/tidytable new data.table/tidytable x, thereby modifying x using pass--reference semantics. dt_setreorder() reorders rows /variables data.table using pass--reference semantics.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/dt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functional Forms of data.table Operations — dt","text":"","code":"dt_aggregate(x, SDcols = NULL, f, by, order_by = FALSE)  dt_setcoe(   x,   vars = NULL,   inv = FALSE,   v,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  dt_setrm(   x,   vars = NULL,   inv = FALSE,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  dt_setadd(x, new)  dt_setreorder(x, roworder = NULL, varorder = NULL)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/dt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functional Forms of data.table Operations — dt","text":"x data.table tidytable. SDcols atomic vector, giving columns aggregation function f() applied . f aggregation function atomic vector, giving grouping columns. order_by Boolean, indicating aggregated result ordered columns specified . vars, inv see squarebrackets_indx_args.  Duplicates allowed. v coercive transformation function chkdup see squarebrackets_options. new data.frame-like object.  must column names already exist x. roworder integer vector length nrow(x), giving order rows re-order. Internally, numeric vector turned order using order, thus ensuring strict permutation 1:nrow(x). varorder integer character vector length ncol(x), giving new column order.  See data.table::setcolorder.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/dt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functional Forms of data.table Operations — dt","text":"dt_aggregate():  aggregated data.table object.  rest functions:  Returns: VOID. functions modify object reference.  use assignments like x <- dt_setcoe(x, ...).  Since functions return void, just get NULL.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/dt.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Functional Forms of data.table Operations — dt","text":"dt_setreorder(x, roworder = roworder) internally creates new column reorder data.table , removes new column.  column name randomized, extra care given ensure overwrite existing columns.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/dt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functional Forms of data.table Operations — dt","text":"","code":"# dt_aggregate on sf-data.table ====  if(requireNamespace(\"sf\")) {   x <- sf::st_read(system.file(\"shape/nc.shp\", package = \"sf\"))   x <- data.table::as.data.table(x)      x$region <- ifelse(x$CNTY_ID <= 2000, 'high', 'low')   d.aggr <- dt_aggregate(     x, SDcols = \"geometry\", f= sf::st_union, by = \"region\"   )      head(d.aggr) } #> Loading required namespace: sf #> Reading layer `nc' from data source  #>   `D:\\Programs\\R\\R-4.5.1\\library\\sf\\shape\\nc.shp' using driver `ESRI Shapefile' #> Simple feature collection with 100 features and 14 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 #> Geodetic CRS:  NAD27 #>    region                       geometry #>    <char>             <sfc_MULTIPOLYGON> #> 1:   high MULTIPOLYGON (((-75.78317 3... #> 2:    low MULTIPOLYGON (((-76.46926 3...    #############################################################################   # dt_setcoe ====  obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  ss2_set(   obj, obs = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost ) #> Warning: 1.414214 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 1 named 'a') #> Warning: 3.464102 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 3 named 'c') str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 1 1 2 2 2 2 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 3 3 3 3 4 4 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) dt_setcoe(obj, vars = is.numeric, v = as.numeric) # integers are now numeric str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  ss2_set(obj,   obs = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # SAFE: coercion performed; so no warnings )  str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 1.41 1.73 2 2.24 ... #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  11 3.46 3.61 3.74 3.87 ... #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>    #############################################################################   # dt_setrm ====  obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  dt_setrm(obj, vars = 1) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  3 variables: #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>   obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  dt_setrm(obj, vars = is.numeric) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  2 variables: #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>    #############################################################################   # dt_setadd ====  obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) new <- data.table::data.table(   e = sample(c(TRUE, FALSE), 10, TRUE),   f = sample(c(TRUE, FALSE), 10, TRUE) ) dt_setadd(obj, new) print(obj) #>         a      b     c      d      e      f #>     <int> <char> <int> <fctr> <lgcl> <lgcl> #>  1:     1      a    11      a   TRUE   TRUE #>  2:     2      b    12      b  FALSE   TRUE #>  3:     3      c    13      c   TRUE   TRUE #>  4:     4      d    14      d  FALSE  FALSE #>  5:     5      e    15      e   TRUE  FALSE #>  6:     6      f    16      f   TRUE  FALSE #>  7:     7      g    17      g  FALSE  FALSE #>  8:     8      h    18      h   TRUE  FALSE #>  9:     9      i    19      i  FALSE  FALSE #> 10:    10      j    20      j  FALSE  FALSE    #############################################################################   # dt_setreorder====  n <- 1e4 obj <- data.table::data.table(   a = 1L:n, b = n:1L, c = as.double(1:n), d = as.double(n:1) ) dt_setreorder(obj, roworder = n:1) head(obj) #>        a     b     c     d #>    <int> <int> <num> <num> #> 1: 10000     1 10000     1 #> 2:  9999     2  9999     2 #> 3:  9998     3  9998     3 #> 4:  9997     4  9997     4 #> 5:  9996     5  9996     5 #> 6:  9995     6  9995     6 dt_setreorder(obj, varorder = ncol(obj):1) head(obj) #>        d     c     b     a #>    <num> <num> <int> <int> #> 1:     1 10000     1 10000 #> 2:     2  9999     2  9999 #> 3:     3  9998     3  9998 #> 4:     4  9997     4  9997 #> 5:     5  9996     5  9996 #> 6:     6  9995     6  9995"},{"path":"https://tony-aw.github.io/squarebrackets/reference/exported_uilities.html","id":null,"dir":"Reference","previous_headings":"","what":"Exported Utilities — indx_x","title":"Exported Utilities — indx_x","text":"Exported utilities.  Usually user need functions.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/exported_uilities.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exported Utilities — indx_x","text":"","code":"indx_x(i, x, xnames, xsize)  indx_wo(i, x, xnames, xsize)  .is.0(x)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/exported_uilities.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exported Utilities — indx_x","text":"See squarebrackets_indx_args. x vector, vector-like object, factor, data.frame, data.frame-like object, list. xnames names dimension names xsize length dimension size","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/exported_uilities.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exported Utilities — indx_x","text":"subsetted object.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/exported_uilities.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Exported Utilities — indx_x","text":"","code":"x <- 1:10 names(x) <- letters[1:10] indx_x(1:5, x, names(x), length(x)) #> [1] 1 2 3 4 5 indx_wo(1:5, x, names(x), length(x)) #> [1]  6  7  8  9 10"},{"path":"https://tony-aw.github.io/squarebrackets/reference/helper_recursive.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper Functions for Sub-Set Operations on Recursive Objects — dropl","title":"Helper Functions for Sub-Set Operations on Recursive Objects — dropl","text":"'squarebrackets' provides helper functions sub-set operations recursive objects (lists data.frames). dropl(x) returns x[[1L]] length(x) == 1, returns x otherwise.  can used *_x *_wo methods recursive objects, one like extract contents singular selection.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/helper_recursive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper Functions for Sub-Set Operations on Recursive Objects — dropl","text":"","code":"dropl(x)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/helper_recursive.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper Functions for Sub-Set Operations on Recursive Objects — dropl","text":"x list.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/helper_recursive.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper Functions for Sub-Set Operations on Recursive Objects — dropl","text":"dropl():  length(x) == 1L, dropl(x) returns x[[1L]];  otherwise returns original x unchanged.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/helper_recursive.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Helper Functions for Sub-Set Operations on Recursive Objects — dropl","text":"","code":"obj <- as.list(1:10) ii_x(obj, 1) |> dropl() # equivalent to obj[[1L]] #> [1] 1"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx1.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert/Translate Indices (for Copy-On-Modify Substitution) — idx","title":"Convert/Translate Indices (for Copy-On-Modify Substitution) — idx","text":"idx() method converts indices.  type output depends type input index arguments given: idx(x, = , ...) converts linear indices strictly positive integer vector linear indices. idx(x, s = s, d = d, ...) converts dimensional indices strictly positive integer vector linear indices. idx(x, slice = slice, margin = margin, ...) converts indices one dimension strictly positive integer vector indices specific dimension. Vectors (atomic recursive) index argument .  Data.frame-like objects slice, margin argument pair.  Arrays (atomic recursive) s, d argument pair, well argument slice, margin argument pair.  result idx() method can used inside regular square-brackets operators.  example like :   thus allowing user benefit convenient index translations 'squarebrackets', whilst still using R's default copy--modification semantics (instead semantics provided 'squarebrackets').","code":"x <- array(...) my_ss2ii <- idx(x, s, d) x[my_ss2ii] <- value  y <- data.frame(...) rows <- idx(y, 1:10, 1, inv = TRUE) cols <- idx(y, c(\"a\", \"b\"), 2) y[rows, cols] <- value"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert/Translate Indices (for Copy-On-Modify Substitution) — idx","text":"","code":"idx(x, ...)  # Default S3 method idx(x, i, inv = FALSE, ..., chkdup = getOption(\"squarebrackets.chkdup\", FALSE))  # S3 method for class 'array' idx(   x,   s = NULL,   d = 1:ndim(x),   slice = NULL,   margin = NULL,   i = NULL,   inv = FALSE,   ...,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # S3 method for class 'data.frame' idx(   x,   slice,   margin,   inv = FALSE,   ...,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx1.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert/Translate Indices (for Copy-On-Modify Substitution) — idx","text":"x vector, matrix, array, data.frame; atomic recursive objects supported. ... see squarebrackets_method_dispatch. , s, d, margin, slice, inv See squarebrackets_indx_args.  Duplicates allowed. chkdup see squarebrackets_options.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx1.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert/Translate Indices (for Copy-On-Modify Substitution) — idx","text":"idx(x, = , ...) idx(x, s = s, d = d, ...):  strictly positive integer vector flat indices.  idx(x, margin = margin, slice = slice, ...):  strictly positive integer vector indices dimension specified margin.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx1.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert/Translate Indices (for Copy-On-Modify Substitution) — idx","text":"","code":"# atomic ====  x <- 1:10 x[idx(x, \\(x)x>5)] <- -5 print(x) #>  [1]  1  2  3  4  5 -5 -5 -5 -5 -5  x <- array(1:27, dim = c(3,3,3)) x[idx(x, n(1:2, 1:2), c(1,3))] <- -10 print(x) #> , , 1 #>  #>      [,1] [,2] [,3] #> [1,]  -10  -10  -10 #> [2,]  -10  -10  -10 #> [3,]    3    6    9 #>  #> , , 2 #>  #>      [,1] [,2] [,3] #> [1,]  -10  -10  -10 #> [2,]  -10  -10  -10 #> [3,]   12   15   18 #>  #> , , 3 #>  #>      [,1] [,2] [,3] #> [1,]   19   22   25 #> [2,]   20   23   26 #> [3,]   21   24   27 #>    ################################################################################   # recursive ====  x <- as.list(1:10) x[idx(x, \\(x)x>5)] <- -5 print(x) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 3 #>  #> [[4]] #> [1] 4 #>  #> [[5]] #> [1] 5 #>  #> [[6]] #> [1] -5 #>  #> [[7]] #> [1] -5 #>  #> [[8]] #> [1] -5 #>  #> [[9]] #> [1] -5 #>  #> [[10]] #> [1] -5 #>   x <- array(as.list(1:27), dim = c(3,3,3)) x[idx(x, n(1:2, 1:2), c(1,3))] <- -10 print(x) #> , , 1 #>  #>      [,1] [,2] [,3] #> [1,] -10  -10  -10  #> [2,] -10  -10  -10  #> [3,] 3    6    9    #>  #> , , 2 #>  #>      [,1] [,2] [,3] #> [1,] -10  -10  -10  #> [2,] -10  -10  -10  #> [3,] 12   15   18   #>  #> , , 3 #>  #>      [,1] [,2] [,3] #> [1,] 19   22   25   #> [2,] 20   23   26   #> [3,] 21   24   27   #>    x <- data.frame(   a = sample(c(TRUE, FALSE, NA), 10, TRUE),   b = 1:10,   c = rnorm(10),   d = letters[1:10],   e = factor(letters[11:20]) ) rows <- idx(x, 1:5, 1, inv = TRUE) cols <- idx(x, c(\"b\", \"a\"), 2) x[rows, cols] <- NA print(x) #>        a  b           c d e #> 1   TRUE  1 -0.31966240 a k #> 2  FALSE  2  0.26491352 b l #> 3   TRUE  3 -0.99044044 c m #> 4  FALSE  4  1.00790915 d n #> 5   TRUE  5  0.19031222 e o #> 6     NA NA -1.41032315 f p #> 7     NA NA -0.01069827 g q #> 8     NA NA  0.79808063 h r #> 9     NA NA  0.58953258 i s #> 10    NA NA -0.94363267 j t"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_by.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Grouped Indices — idx_by","title":"Compute Grouped Indices — idx_by","text":"Given: sub-set function f; object x margin m; grouping factor grp; idx_by() function takes indices per group grp.  result idx_by() can supplied indexing arguments (see squarebrackets_indx_args) perform grouped subset operations.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_by.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Grouped Indices — idx_by","text":"","code":"idx_by(x, m, f, grp, parallel = FALSE, mc.cores = 1L)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_by.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Grouped Indices — idx_by","text":"x object compute indices. m single non-negative integer giving margin compute indices.  flat indices non-dimensional objects, use m = 0L. f subset function applied per group indices.  m == 0L, indices defined setNames(1:length(x), names(x)).  m > 0L, indices defined setNames(1:dim(x)[m], dimnames(x)[[m]]).  function must produce character integer vector output.  example, subset last element per group, specify: f = last grp factor giving groups. parallel, mc.cores see .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_by.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Grouped Indices — idx_by","text":"vector indices.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_by.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Grouped Indices — idx_by","text":"","code":"# vectors ==== (a <- 1:20) #>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 (grp <- factor(rep(letters[1:5], each = 4))) #>  [1] a a a a b b b b c c c c d d d d e e e e #> Levels: a b c d e  # get the last element of `a` for each group in `grp`: s <- list(idx_by(a, 0L, last, grp)) ss_x(cbind(a, grp), s, 1L) #>       a grp #> [1,]  4   1 #> [2,]  8   2 #> [3,] 12   3 #> [4,] 16   4 #> [5,] 20   5   # data.frame ==== x <- data.frame(   a = sample(1:20),   b = letters[1:20],   group = factor(rep(letters[1:5], each = 4)) ) print(x) #>     a b group #> 1   4 a     a #> 2   9 b     a #> 3   6 c     a #> 4  13 d     a #> 5   8 e     b #> 6  14 f     b #> 7  11 g     b #> 8  16 h     b #> 9   1 i     c #> 10 20 j     c #> 11 12 k     c #> 12 19 l     c #> 13  3 m     d #> 14 18 n     d #> 15 17 o     d #> 16 15 p     d #> 17  2 q     e #> 18  5 r     e #> 19 10 s     e #> 20  7 t     e # get the first row for each group in data.frame `x`: row <- idx_by(x, 1, first, x$group) sbt_x(x, row) #>   a b group #> 1 4 a     a #> 2 8 e     b #> 3 1 i     c #> 4 3 m     d #> 5 2 q     e # get the first row for each group for which a > 10: x2 <- sbt_x(x, obs = ~ a > 10) row <- na.omit(idx_by(x2, 1, first, x2$group)) sbt_x(x2, row) #>    a b group #> 1 13 d     a #> 2 14 f     b #> 3 20 j     c #> 4 18 n     d"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_ord.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Ordered Indices — idx_ord_v","title":"Compute Ordered Indices — idx_ord_v","text":"Computes ordered indices. Similar order, except user must supply vector, list equal-length vectors, data.frame matrix (row-wise column-wise supported), input.  vector x, idx_ord_v(x) equivalent order(x).  data.frame list equal-length vectors x, p columns/elements, idx_ord_df(x) equivalent order(x[[1]], ..., x[[p]]).  matrix (array) x p rows, idx_ord_m(x, margin = 1) equivalent order(x[1, ], ..., x[p, ], ...).  matrix (array) x p columns, idx_ord_m(x, margin = 2) equivalent order(x[, 1], ..., x[, p], ...).  Note merely convenience functions, actually slightly slower order (except idx_ord_v()), due additional functionality.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_ord.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Ordered Indices — idx_ord_v","text":"","code":"idx_ord_v(   x,   na.last = TRUE,   decr = FALSE,   method = c(\"auto\", \"shell\", \"radix\") )  idx_ord_m(   x,   margin,   na.last = TRUE,   decr = FALSE,   method = c(\"auto\", \"shell\", \"radix\") )  idx_ord_df(   x,   na.last = TRUE,   decr = FALSE,   method = c(\"auto\", \"shell\", \"radix\") )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_ord.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Ordered Indices — idx_ord_v","text":"x vector, data.frame, array na.last, method see order sort. decr see argument decreasing order margin margin cut matrix/array vectors.  .e. margin = 1L cut x individual rows, apply order rows.  margin = 2L cut x columns, etc.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_ord.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Ordered Indices — idx_ord_v","text":"See order.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_ord.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Ordered Indices — idx_ord_v","text":"","code":"x <- sample(1:10) order(x) #>  [1]  7  6  1  2 10  9  5  8  4  3 idx_ord_v(x) #>  [1]  7  6  1  2 10  9  5  8  4  3 idx_ord_m(rbind(x, x), 1) #>  [1]  7  6  1  2 10  9  5  8  4  3 idx_ord_m(cbind(x, x), 2) #>  [1]  7  6  1  2 10  9  5  8  4  3 idx_ord_df(data.frame(x, x)) #>  [1]  7  6  1  2 10  9  5  8  4  3"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_r.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Integer Index Range — idx_r","title":"Compute Integer Index Range — idx_r","text":"idx_r() computes integer index range(s).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_r.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Integer Index Range — idx_r","text":"","code":"idx_r(x, m = 0L, from = NULL, to = NULL, by = 1L)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_r.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Integer Index Range — idx_r","text":"x object compute subset indices. m, , , see cp_seq.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_r.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Integer Index Range — idx_r","text":"length(m) == 1L: vector numeric indices.  length(m) > 1L: list length m, containing numeric vectors indices.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_r.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Integer Index Range — idx_r","text":"","code":"x <- data.frame(   a = 1:10, b = letters[1:10], c = factor(letters[1:10]), d = -1:-10 ) print(x) #>     a b c   d #> 1   1 a a  -1 #> 2   2 b b  -2 #> 3   3 c c  -3 #> 4   4 d d  -4 #> 5   5 e e  -5 #> 6   6 f f  -6 #> 7   7 g g  -7 #> 8   8 h h  -8 #> 9   9 i i  -9 #> 10 10 j j -10 ind1 <- idx_r(x, 1, 2, 2* -1i) # rows 2:(nrow(x)-1) sbt_x(x, ind1) # extract the row range #>   a b c  d #> 1 2 b b -2 #> 2 3 c c -3 #> 3 4 d d -4 #> 4 5 e e -5 #> 5 6 f f -6 #> 6 7 g g -7 #> 7 8 h h -8 #> 8 9 i i -9  x <- array(1:125, c(5,5,5)) d <- 1:3 s <- idx_r(x, d, 2, 2* -1i) # 2:(n-1) for every dimension ss_x(x, s = s, d = d) # same as x[ 2:4, 2:4, 2:4, drop = FALSE] #> , , 1 #>  #>      [,1] [,2] [,3] #> [1,]   32   37   42 #> [2,]   33   38   43 #> [3,]   34   39   44 #>  #> , , 2 #>  #>      [,1] [,2] [,3] #> [1,]   57   62   67 #> [2,]   58   63   68 #> [3,]   59   64   69 #>  #> , , 3 #>  #>      [,1] [,2] [,3] #> [1,]   82   87   92 #> [2,]   83   88   93 #> [3,]   84   89   94 #>   x <- letters x[idx_r(x, 0, 2, 2* -1i)] #>  [1] \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" \"t\" #> [20] \"u\" \"v\" \"w\" \"x\" \"y\""},{"path":"https://tony-aw.github.io/squarebrackets/reference/lst_rec.html","id":null,"dir":"Reference","previous_headings":"","what":"Access, Replace, Transform, Delete, or Extend Recursive Subsets — lst_rec","title":"Access, Replace, Transform, Delete, or Extend Recursive Subsets — lst_rec","text":"lst_rec() lst_recin() methods essentially convenient wrappers around [[ [[<-, respectively. lst_rec() access recursive subsets lists. lst_recin() can following things: replace transform recursive subsets list, using R's default Copy--Modify semantics, specifying rp tf argument, respectively. delete recursive subset list, using R's default Copy--Modify semantics, specifying argument rp = NULL. extending list additional recursive elements, using R's default Copy--Modify semantics.  done specifying --bounds index argument rec, entering new values argument rp.  Note adding surface level elements dimensional list delete dimension attributes list.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/lst_rec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Access, Replace, Transform, Delete, or Extend Recursive Subsets — lst_rec","text":"","code":"lst_rec(x, ...)  # Default S3 method lst_rec(x, rec, ...)  lst_recin(x, ...)  # Default S3 method lst_recin(x, rec, ..., rp, tf)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/lst_rec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Access, Replace, Transform, Delete, or Extend Recursive Subsets — lst_rec","text":"x list, list-like object. ... see squarebrackets_method_dispatch. rec strictly positive integer vector character vector, length p, lst_rec(x, rec) equivalent x[[ rec[1] ]]...[[ rec[p] ]], providing final indexing results list.  certain subset level nested list, multiple subsets name exist, first one selected performing recursive indexing name, since recursive indexing can select single element. NA, NaN, Inf, -Inf, NULL valid values rec. rp optional, allows multiple functionalities: simplest case, performs x[[rec]] <- rp, using R's default semantics.  Since replacement recursive subset, rp necessarily list ; rp can type object. Specifying rp = NULL delete (recursive) subset lst_rec(x, rec).  specify actual NULL instead deleting subset, use rp = list(NULL). rec integer, specifies --bounds subset, lst_recin() add value rp list.  empty positions filled NA. rec character, specifies non-existing name, lst_recin() add value rp list new element end. tf optional function. specified, performs x[[rec]] <- tf(x[[rec]]), using R's default Copy--Modify semantics.  support extending list like argument rp.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/lst_rec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Access, Replace, Transform, Delete, or Extend Recursive Subsets — lst_rec","text":"lst_rec():  Returns recursive subset.  lst_recin(..., rp = rp):  Returns VOID, replaces, adds, deletes specified recursive subset, using R's default Copy--Modify semantics.  lst_recin(..., tf = tf):  Returns VOID, transforms specified recursive subset, using R's default Copy--Modify semantics.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/lst_rec.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Access, Replace, Transform, Delete, or Extend Recursive Subsets — lst_rec","text":"Since recursive objects references objects, extending list deleting element list copy entire list, contrast atomic vectors.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/lst_rec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Access, Replace, Transform, Delete, or Extend Recursive Subsets — lst_rec","text":"","code":"lst <- list(   A = list(     A = list(A = \"AAA\", B = \"AAB\"),     A = list(A  = \"AA2A\", B = \"AA2B\"),     B = list(A = \"ABA\", B = \"ABB\")   ),   B = list(     A = list(A = \"BAA\", B = \"BAB\"),     B = list(A = \"BBA\", B = \"BBB\")   ),   C = list(     A = 1:10,     B = 11:20   ) )  #############################################################################  # access recursive subsets ====  lst_rec(lst, c(1,2,2)) # this gives \"AA2B\" #> [1] \"AA2B\" lst_rec(lst, c(\"A\", \"B\", \"B\")) # this gives \"ABB\" #> [1] \"ABB\" lst_rec(lst, c(2,2,1)) # this gives \"BBA\" #> [1] \"BBA\" lst_rec(lst, c(\"B\", \"B\", \"A\")) # this gives \"BBA\" #> [1] \"BBA\"   #############################################################################  # replace recursive subset with R's default in-place semantics ====  # replace \"AAB\" using R's default in-place semantics: lst_recin(   lst, c(\"A\", \"A\", \"B\"),   rp = \"THIS IS REPLACED WITH IN-PLACE SEMANTICS\" ) print(lst) #> $A #> $A$A #> $A$A$A #> [1] \"AAA\" #>  #> $A$A$B #> [1] \"THIS IS REPLACED WITH IN-PLACE SEMANTICS\" #>  #>  #> $A$A #> $A$A$A #> [1] \"AA2A\" #>  #> $A$A$B #> [1] \"AA2B\" #>  #>  #> $A$B #> $A$B$A #> [1] \"ABA\" #>  #> $A$B$B #> [1] \"ABB\" #>  #>  #>  #> $B #> $B$A #> $B$A$A #> [1] \"BAA\" #>  #> $B$A$B #> [1] \"BAB\" #>  #>  #> $B$B #> $B$B$A #> [1] \"BBA\" #>  #> $B$B$B #> [1] \"BBB\" #>  #>  #>  #> $C #> $C$A #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $C$B #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  #>     #############################################################################  # transform recursive subsets with R's default in-place semantics ====  lst_recin(lst, c(\"C\", \"A\"), tf = \\(x)x^2) # transforms lst$C$A  print(lst) #> $A #> $A$A #> $A$A$A #> [1] \"AAA\" #>  #> $A$A$B #> [1] \"THIS IS REPLACED WITH IN-PLACE SEMANTICS\" #>  #>  #> $A$A #> $A$A$A #> [1] \"AA2A\" #>  #> $A$A$B #> [1] \"AA2B\" #>  #>  #> $A$B #> $A$B$A #> [1] \"ABA\" #>  #> $A$B$B #> [1] \"ABB\" #>  #>  #>  #> $B #> $B$A #> $B$A$A #> [1] \"BAA\" #>  #> $B$A$B #> [1] \"BAB\" #>  #>  #> $B$B #> $B$B$A #> [1] \"BBA\" #>  #> $B$B$B #> [1] \"BBB\" #>  #>  #>  #> $C #> $C$A #>  [1]   1   4   9  16  25  36  49  64  81 100 #>  #> $C$B #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  #>    #############################################################################  # add/remove new recursive subsets with R's default in-place semantics ====  lst_recin(lst, c(\"C\", \"D\"), rp = \"NEW VALUE\") # adds lst$C$D print(lst) #> $A #> $A$A #> $A$A$A #> [1] \"AAA\" #>  #> $A$A$B #> [1] \"THIS IS REPLACED WITH IN-PLACE SEMANTICS\" #>  #>  #> $A$A #> $A$A$A #> [1] \"AA2A\" #>  #> $A$A$B #> [1] \"AA2B\" #>  #>  #> $A$B #> $A$B$A #> [1] \"ABA\" #>  #> $A$B$B #> [1] \"ABB\" #>  #>  #>  #> $B #> $B$A #> $B$A$A #> [1] \"BAA\" #>  #> $B$A$B #> [1] \"BAB\" #>  #>  #> $B$B #> $B$B$A #> [1] \"BBA\" #>  #> $B$B$B #> [1] \"BBB\" #>  #>  #>  #> $C #> $C$A #>  [1]   1   4   9  16  25  36  49  64  81 100 #>  #> $C$B #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  #> $C$D #> [1] \"NEW VALUE\" #>  #>   lst_recin(lst, c(\"C\", \"A\"), rp = NULL) # removes lst$C$A print(lst) # notice lst$C$A is GONE #> $A #> $A$A #> $A$A$A #> [1] \"AAA\" #>  #> $A$A$B #> [1] \"THIS IS REPLACED WITH IN-PLACE SEMANTICS\" #>  #>  #> $A$A #> $A$A$A #> [1] \"AA2A\" #>  #> $A$A$B #> [1] \"AA2B\" #>  #>  #> $A$B #> $A$B$A #> [1] \"ABA\" #>  #> $A$B$B #> [1] \"ABB\" #>  #>  #>  #> $B #> $B$A #> $B$A$A #> [1] \"BAA\" #>  #> $B$A$B #> [1] \"BAB\" #>  #>  #> $B$B #> $B$B$A #> [1] \"BBA\" #>  #> $B$B$B #> [1] \"BBB\" #>  #>  #>  #> $C #> $C$B #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  #> $C$D #> [1] \"NEW VALUE\" #>  #>    #############################################################################  # Modify View of List By Reference ====  x <- list(  a = data.table::data.table(cola = 1:10, colb = letters[1:10]),  b = data.table::data.table(cola = 11:20, colb = letters[11:20]) ) print(x) #> $a #>      cola   colb #>     <int> <char> #>  1:     1      a #>  2:     2      b #>  3:     3      c #>  4:     4      d #>  5:     5      e #>  6:     6      f #>  7:     7      g #>  8:     8      h #>  9:     9      i #> 10:    10      j #>  #> $b #>      cola   colb #>     <int> <char> #>  1:    11      k #>  2:    12      l #>  3:    13      m #>  4:    14      n #>  5:    15      o #>  6:    16      p #>  7:    17      q #>  8:    18      r #>  9:    19      s #> 10:    20      t #>  myref <- lst_rec(x, \"a\") address(myref) == address(x$a) # they are the same #> [1] TRUE sbt_set(myref, vars = \"cola\", tf = \\(x)x^2) print(x) # notice x has been changed #> $a #>      cola   colb #>     <num> <char> #>  1:     1      a #>  2:     4      b #>  3:     9      c #>  4:    16      d #>  5:    25      e #>  6:    36      f #>  7:    49      g #>  8:    64      h #>  9:    81      i #> 10:   100      j #>  #> $b #>      cola   colb #>     <int> <char> #>  1:    11      k #>  2:    12      l #>  3:    13      m #>  4:    14      n #>  5:    15      o #>  6:    16      p #>  7:    17      q #>  8:    18      r #>  9:    19      s #> 10:    20      t #>"},{"path":"https://tony-aw.github.io/squarebrackets/reference/match_all.html","id":null,"dir":"Reference","previous_headings":"","what":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","title":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","text":"Find indices vector haystack equal vector needles, taking account order vectors, duplicate values. match_all() essentially much efficient version :   Like lapply(needles, \\() (haystack == )), NAs ignored. match_all() internally calls collapse::fmatch collapse::gsplit.  Core code based suggestion Sebastian Kranz (author 'collapse' package).","code":"lapply(needles, \\(i) which(haystack == i))"},{"path":"https://tony-aw.github.io/squarebrackets/reference/match_all.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","text":"","code":"match_all(needles, haystack, unlist = TRUE)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/match_all.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","text":"needles, haystack vectors type. needles contain NA/NaN.  Long vectors supported. unlist Boolean, indicating result single unnamed integer vector (TRUE, default), named list integer vectors (FALSE).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/match_all.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","text":"integer vector, list integer vectors.  list, element list corresponds value needles.  needles /haystack empty, haystack fully NA, match_all() returns empty integer vector (unlist = TRUE), empty list (unlist = FALSE).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/match_all.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","text":"","code":"n <- 200 haystack <- sample(letters, n, TRUE) needles <- sample(letters, n/2, TRUE) indices1 <- match_all(needles, haystack) head(indices1) #> [1]  46  74 108 112 128 190"},{"path":"https://tony-aw.github.io/squarebrackets/reference/mutatomic_class.html","id":null,"dir":"Reference","previous_headings":"","what":"A Class of Mutable Atomic Objects — mutatomic_class","title":"A Class of Mutable Atomic Objects — mutatomic_class","text":"mutatomic class mutable version atomic classes.  works exactly aspects regular atomic classes.  one real difference:  Pass--reference functions 'squarebrackets' accept atomic objects class mutatomic, greater safety.  aspects, mutatomic objects R's regular atomic objects, including behaviour [<- operator .  Exposed functions (beside S3 methods): mutatomic(): create mutatomic object given data. couldb.mutatomic(): checks object become mutatomic.  objects can become mutatomic one following types: logical, integer, double, character, complex, raw.  Factors can never mutatomic.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/mutatomic_class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A Class of Mutable Atomic Objects — mutatomic_class","text":"","code":"mutatomic(data, names = NULL, dim = NULL, dimnames = NULL)  as.mutatomic(x, ...)  is.mutatomic(x)  couldb.mutatomic(x)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/mutatomic_class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A Class of Mutable Atomic Objects — mutatomic_class","text":"data atomic vector giving data fill mutatomic object. names, dim, dimnames see setNames array. x atomic object. ... method dependent arguments.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/mutatomic_class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A Class of Mutable Atomic Objects — mutatomic_class","text":"mutatomic(), .mutatomic():  Returns mutatomic object.  .mutatomic():  Returns TRUE object mutatomic, returns FALSE otherwise.  couldb.mutatomic():  Returns TRUE object one following types: logical, integer, double, character, complex, raw.  Returns FALSE otherwise.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/mutatomic_class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"A Class of Mutable Atomic Objects — mutatomic_class","text":"Always use exported functions given 'squarebrackets' create mutatomic object, make necessary safety checks.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/mutatomic_class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A Class of Mutable Atomic Objects — mutatomic_class","text":"","code":"x <- mutatomic(   1:20, dim = c(5, 4), dimnames = list(letters[1:5], letters[1:4]) ) x #>   a  b  c  d #> a 1  6 11 16 #> b 2  7 12 17 #> c 3  8 13 18 #> d 4  9 14 19 #> e 5 10 15 20 #> mutatomic  #> typeof:  integer   x <- matrix(1:10, ncol = 2) x <- as.mutatomic(x) is.mutatomic(x) #> [1] TRUE print(x) #>      [,1] [,2] #> [1,]    1    6 #> [2,]    2    7 #> [3,]    3    8 #> [4,]    4    9 #> [5,]    5   10 #> mutatomic  #> typeof:  integer  x[, 1] #> [1] 1 2 3 4 5 #> mutatomic  #> typeof:  integer  x[] <- as.double(x) #> coercing type from `integer` to `double` print(x) #>      [,1] [,2] #> [1,]    1    6 #> [2,]    2    7 #> [3,]    3    8 #> [4,]    4    9 #> [5,]    5   10 #> mutatomic  #> typeof:  double  is.mutatomic(x) #> [1] TRUE"},{"path":"https://tony-aw.github.io/squarebrackets/reference/mutatomic_developer.html","id":null,"dir":"Reference","previous_headings":"","what":"Developer Functions for the mutatomic Class — stopifnot_ma_safe2mutate","title":"Developer Functions for the mutatomic Class — stopifnot_ma_safe2mutate","text":"stopifnot_ma_safe2mutate() function checks atomic object actually safe mutate.  .internal_set_ma() function sets object class 'mutatomic' reference.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/mutatomic_developer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Developer Functions for the mutatomic Class — stopifnot_ma_safe2mutate","text":"","code":"stopifnot_ma_safe2mutate(sym, envir, .abortcall)  address(x)  .internal_set_ma(x)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/mutatomic_developer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Developer Functions for the mutatomic Class — stopifnot_ma_safe2mutate","text":"sym symbol object; .e. substitute(x). envir environment object resides; .e. parent.frame(n = 1). .abortcall environment error message passed . x atomic object","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/mutatomic_developer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Developer Functions for the mutatomic Class — stopifnot_ma_safe2mutate","text":"Nothing. gives error object safe mutate.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/mutatomic_developer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Developer Functions for the mutatomic Class — stopifnot_ma_safe2mutate","text":"","code":"testfun1 <- function(x) {   .internal_set_ma(x) }   x <- 1:10 is.mutatomic(x) #> [1] FALSE  testfun1(x) is.mutatomic(x) #> [1] TRUE print(x) #>  [1]  1  2  3  4  5  6  7  8  9 10 #> mutatomic  #> typeof:  integer"},{"path":"https://tony-aw.github.io/squarebrackets/reference/ndim.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Number of Dimensions — ndim","title":"Get Number of Dimensions — ndim","text":"ndim(x) short-hand length(dim(x)).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/ndim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Number of Dimensions — ndim","text":"","code":"ndim(x)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/ndim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Number of Dimensions — ndim","text":"x object get number dimensions .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/ndim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Number of Dimensions — ndim","text":"integer, giving number dimensions x .  vectors, gives 0L.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/ndim.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Number of Dimensions — ndim","text":"","code":"x <- 1:10 ndim(x) #> [1] 0 obj <- array(1:64, c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  ndim(obj) #> [1] 3"},{"path":"https://tony-aw.github.io/squarebrackets/reference/nest.html","id":null,"dir":"Reference","previous_headings":"","what":"Nest — n","title":"Nest — n","text":"c() function concatenates vectors lists vector (possible) else list.  analogy function, n() function nests objects list (atomic vector, atomic vectors nested).  short-hand version list function.  handy lists often needed 'squarebrackets', especially arrays.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/nest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nest — n","text":"","code":"n()"},{"path":"https://tony-aw.github.io/squarebrackets/reference/nest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nest — n","text":"list.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/nest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Nest — n","text":"","code":"obj <- array(1:64, c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  ss_x(obj, n(1:3, 1:2), c(1,3)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #>  # above is equivalent to obj[1:3, , 1:2, drop = FALSE]"},{"path":"https://tony-aw.github.io/squarebrackets/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. data.table copy, first, last","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":null,"dir":"Reference","previous_headings":"","what":"Method to Return a Copy of an Object With Modified Subsets — ii_mod","title":"Method to Return a Copy of an Object With Modified Subsets — ii_mod","text":"Methods return copy object modified subsets.  modifying subsets using R's default copy--modification semantics, see idx.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method to Return a Copy of an Object With Modified Subsets — ii_mod","text":"","code":"ii_mod(x, ...)  ss_mod(x, ...)  sbt_mod(x, ...)  # Default S3 method ii_mod(   x,   i = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # Default S3 method ss_mod(   x,   s = NULL,   d = 1:ndim(x),   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # Default S3 method sbt_mod(   x,   row = NULL,   col = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # S3 method for class 'data.frame' sbt_mod(   x,   obs = NULL,   vars = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method to Return a Copy of an Object With Modified Subsets — ii_mod","text":"x see squarebrackets_supported_structures. ... see squarebrackets_method_dispatch. , s, d, row, col, obs, vars, inv See squarebrackets_indx_args.  empty index selection returns original object unchanged. rp, tf see squarebrackets_modify. chkdup see squarebrackets_options.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Method to Return a Copy of an Object With Modified Subsets — ii_mod","text":"copy object replaced/transformed values.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Method to Return a Copy of an Object With Modified Subsets — ii_mod","text":"Transform Replace  Specifying argument tf transform subset.  Specifying rp replace subset.  One specify tf rp. either one set .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Method to Return a Copy of an Object With Modified Subsets — ii_mod","text":"","code":"# atomic objects ====  obj <- matrix(1:16, ncol = 4) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 rp <- -1:-9 ss_mod(obj, n(1:3), 1:ndim(obj), rp = rp) #>       a  b  c  a #> [1,] -1 -4 -7 13 #> [2,] -2 -5 -8 14 #> [3,] -3 -6 -9 15 #> [4,]  4  8 12 16 # above is equivalent to  obj[1:3, 1:3] <- -1:-9; obj ii_mod(obj, i = \\(x)x<=5, rp = -1:-5) #>       a  b  c  a #> [1,] -1 -5  9 13 #> [2,] -2  6 10 14 #> [3,] -3  7 11 15 #> [4,] -4  8 12 16 # above is equivalent to  obj[obj <= 5] <- -1:-5; obj ss_mod(obj, n(\"a\"), 2L, rp = -1:-8) #>       a b  c  a #> [1,] -1 5  9 -5 #> [2,] -2 6 10 -6 #> [3,] -3 7 11 -7 #> [4,] -4 8 12 -8 # above is equivalent to  obj[, which(colnames(obj) %in% \"a\")] <- -1:-8; obj ss_mod(obj, n(1:3), 1:ndim(obj), tf = \\(x) -x) #>       a  b   c  a #> [1,] -1 -5  -9 13 #> [2,] -2 -6 -10 14 #> [3,] -3 -7 -11 15 #> [4,]  4  8  12 16 # above is equivalent to  obj[1:3, 1:3] <- (-1 * obj[1:3, 1:3]); obj ii_mod(obj, i = \\(x)x <= 5, tf = \\(x) -x) #>       a  b  c  a #> [1,] -1 -5  9 13 #> [2,] -2  6 10 14 #> [3,] -3  7 11 15 #> [4,] -4  8 12 16 # above is equivalent to  obj[obj <= 5] <- (-1 * obj[obj <= 5]); obj  obj <- array(1:64, c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  ss_mod(obj, n(1:3, 1:2), c(1,3), rp = -1:-24) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   -1   -4   -7  -10 #> [2,]   -2   -5   -8  -11 #> [3,]   -3   -6   -9  -12 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]  -13  -16  -19  -22 #> [2,]  -14  -17  -20  -23 #> [3,]  -15  -18  -21  -24 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  # above is equivalent to obj[1:3, , 1:2] <- -1:-24 ii_mod(obj, i = \\(x)x <= 5, rp = -1:-5) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   -1   -5    9   13 #> [2,]   -2    6   10   14 #> [3,]   -3    7   11   15 #> [4,]   -4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  # above is equivalent to obj[obj <= 5] <- -1:-5  #############################################################################   # lists ====  obj <- list(a = 1:10, b = letters[1:11], c = 11:20) print(obj) #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  ii_mod(obj, \"a\", rp = list(1L)) #> $a #> [1] 1 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  # above is equivalent to  obj[[\"a\"]] <- 1L; obj ii_mod(obj, is.numeric, rp = list(-1:-10, -11:-20)) #> $a #>  [1]  -1  -2  -3  -4  -5  -6  -7  -8  -9 -10 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] -11 -12 -13 -14 -15 -16 -17 -18 -19 -20 #>  # above is equivalent to  obj[which(sapply(obj, is.numeric))] <- list(-1:-10, -11:-20); obj  obj <- rbind(   lapply(1:4, \\(x)sample(c(TRUE, FALSE, NA))),   lapply(1:4, \\(x)sample(1:10)),   lapply(1:4, \\(x)rnorm(10)),   lapply(1:4, \\(x)sample(letters)) ) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a            b            c            a            #> [1,] logical,3    logical,3    logical,3    logical,3    #> [2,] integer,10   integer,10   integer,10   integer,10   #> [3,] numeric,10   numeric,10   numeric,10   numeric,10   #> [4,] character,26 character,26 character,26 character,26 ss_mod(obj, n(1:3), 1:ndim(obj),rp = n(-1)) #>      a            b            c            a            #> [1,] -1           -1           -1           logical,3    #> [2,] -1           -1           -1           integer,10   #> [3,] -1           -1           -1           numeric,10   #> [4,] character,26 character,26 character,26 character,26 # above is equivalent to obj[1:3, 1:3] <- list(-1) ii_mod(obj, i = is.numeric, rp = n(-1)) #>      a            b            c            a            #> [1,] logical,3    logical,3    logical,3    logical,3    #> [2,] -1           -1           -1           -1           #> [3,] -1           -1           -1           -1           #> [4,] character,26 character,26 character,26 character,26 # above is equivalent to obj[sapply(obj, is.numeric)] <- list(-1) ss_mod(obj, n(\"a\"), 2L, rp = n(-1)) #>      a  b            c            a  #> [1,] -1 logical,3    logical,3    -1 #> [2,] -1 integer,10   integer,10   -1 #> [3,] -1 numeric,10   numeric,10   -1 #> [4,] -1 character,26 character,26 -1 # above is equivalent to # obj[, lapply(c(\"a\", \"a\"), \\(i) which(colnames(obj) == i)) |> unlist()] <- list(-1)   obj <- array(as.list(1:64), c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 1    5    9    13   #> [2,] 2    6    10   14   #> [3,] 3    7    11   15   #> [4,] 4    8    12   16   #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 17   21   25   29   #> [2,] 18   22   26   30   #> [3,] 19   23   27   31   #> [4,] 20   24   28   32   #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 33   37   41   45   #> [2,] 34   38   42   46   #> [3,] 35   39   43   47   #> [4,] 36   40   44   48   #>  ss_mod(obj, n(1:3, 1:2), c(1,3), rp = as.list(-1:-24)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,] -1   -4   -7   -10  #> [2,] -2   -5   -8   -11  #> [3,] -3   -6   -9   -12  #> [4,] 4    8    12   16   #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,] -13  -16  -19  -22  #> [2,] -14  -17  -20  -23  #> [3,] -15  -18  -21  -24  #> [4,] 20   24   28   32   #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 33   37   41   45   #> [2,] 34   38   42   46   #> [3,] 35   39   43   47   #> [4,] 36   40   44   48   #>  # above is equivalent to obj[1:3, , 1:2] <- as.list(-1:-24) ii_mod(obj, i = \\(x) x <= 5, rp = as.list(-1:-5)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,] -1   -5   9    13   #> [2,] -2   6    10   14   #> [3,] -3   7    11   15   #> [4,] -4   8    12   16   #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 17   21   25   29   #> [2,] 18   22   26   30   #> [3,] 19   23   27   31   #> [4,] 20   24   28   32   #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 33   37   41   45   #> [2,] 34   38   42   46   #> [3,] 35   39   43   47   #> [4,] 36   40   44   48   #>  # above is equivalent to obj[sapply(onj, \\(x) x <= 5)] <- as.list(-1:-5)   #############################################################################  # data.frame-like objects  - whole columns ====  obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 sbt_mod(   obj, vars = is.numeric,   tf = sqrt ) #>           a b        c d #> 1  1.000000 a 3.316625 a #> 2  1.414214 b 3.464102 b #> 3  1.732051 c 3.605551 c #> 4  2.000000 d 3.741657 d #> 5  2.236068 e 3.872983 e #> 6  2.449490 f 4.000000 f #> 7  2.645751 g 4.123106 g #> 8  2.828427 h 4.242641 h #> 9  3.000000 i 4.358899 i #> 10 3.162278 j 4.472136 j  #############################################################################  # data.frame-like objects  - partial columns ====  obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10  sbt_mod(   obj, ~ (a >= 2) & (c <= 17), is.numeric,   tf = sqrt )  #>            a b         c d #> 1   1.000000 a 11.000000 a #> 2   1.414214 b  3.464102 b #> 3   1.732051 c  3.605551 c #> 4   2.000000 d  3.741657 d #> 5   2.236068 e  3.872983 e #> 6   2.449490 f  4.000000 f #> 7   2.645751 g  4.123106 g #> 8   8.000000 h 18.000000 h #> 9   9.000000 i 19.000000 i #> 10 10.000000 j 20.000000 j sbt_mod(   obj, ~ (a >= 2) & (c <= 17), is.numeric,   tf = sqrt )  #>            a b         c d #> 1   1.000000 a 11.000000 a #> 2   1.414214 b  3.464102 b #> 3   1.732051 c  3.605551 c #> 4   2.000000 d  3.741657 d #> 5   2.236068 e  3.872983 e #> 6   2.449490 f  4.000000 f #> 7   2.645751 g  4.123106 g #> 8   8.000000 h 18.000000 h #> 9   9.000000 i 19.000000 i #> 10 10.000000 j 20.000000 j sbt_mod(   obj, ~ (a >= 2) & (c <= 17), is.numeric,   tf = sqrt )  #>            a b         c d #> 1   1.000000 a 11.000000 a #> 2   1.414214 b  3.464102 b #> 3   1.732051 c  3.605551 c #> 4   2.000000 d  3.741657 d #> 5   2.236068 e  3.872983 e #> 6   2.449490 f  4.000000 f #> 7   2.645751 g  4.123106 g #> 8   8.000000 h 18.000000 h #> 9   9.000000 i 19.000000 i #> 10 10.000000 j 20.000000 j"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods to Modify Subsets of a Mutable Object By Reference — ii_set","title":"Methods to Modify Subsets of a Mutable Object By Reference — ii_set","text":"Methods replace transform subset supported mutable object using pass--reference semantics.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods to Modify Subsets of a Mutable Object By Reference — ii_set","text":"","code":"ii_set(x, ...)  ss_set(x, ...)  sbt_set(x, ...)  # Default S3 method ii_set(   x,   i = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # Default S3 method ss_set(   x,   s = NULL,   d = 1:ndim(x),   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # Default S3 method sbt_set(   x,   row = NULL,   col = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # S3 method for class 'data.table' sbt_set(   x,   obs = NULL,   vars = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods to Modify Subsets of a Mutable Object By Reference — ii_set","text":"x variable belonging one supported mutable classes. ... see squarebrackets_method_dispatch. , s, d, row, col, obs, vars, inv See squarebrackets_indx_args.  empty index selection leaves original object unchanged. rp, tf see squarebrackets_modify. chkdup see squarebrackets_options.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Methods to Modify Subsets of a Mutable Object By Reference — ii_set","text":"Returns: VOID. method modifies object reference.  use assignments like x <- ii_set(x, ...).  Since function returns void, just get NULL.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Methods to Modify Subsets of a Mutable Object By Reference — ii_set","text":"Transform Replace  Specifying argument tf transform subset. Specifying rp replace subset. One specify tf rp. either one set .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Methods to Modify Subsets of a Mutable Object By Reference — ii_set","text":"","code":"# mutatomic objects ====  gen_mat <- function() {   obj <- as.mutatomic(matrix(1:16, ncol = 4))   colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\")   return(obj) }  obj <- obj2 <- gen_mat() print(obj) #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutatomic  #> typeof:  integer   ss_set(obj, n(1:3), 1:ndim(obj), rp = -1:-9) print(obj2) #>       a  b  c  a #> [1,] -1 -4 -7 13 #> [2,] -2 -5 -8 14 #> [3,] -3 -6 -9 15 #> [4,]  4  8 12 16 #> mutatomic  #> typeof:  integer  # above is like x[1:3, 1:3] <- -1:-9, but using pass-by-reference  obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutatomic  #> typeof:  integer   ii_set(obj, i = \\(x) x <= 5, rp = -1:-5) print(obj2) #>       a  b  c  a #> [1,] -1 -5  9 13 #> [2,] -2  6 10 14 #> [3,] -3  7 11 15 #> [4,] -4  8 12 16 #> mutatomic  #> typeof:  integer  # above is like x[x <= 5] <- -1:-5, but using pass-by-reference  obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutatomic  #> typeof:  integer   ss_set(obj, n(\"a\"), 2L, rp = cbind(-1:-4, -5:-8)) print(obj2) #>       a b  c  a #> [1,] -1 5  9 -5 #> [2,] -2 6 10 -6 #> [3,] -3 7 11 -7 #> [4,] -4 8 12 -8 #> mutatomic  #> typeof:  integer  # above is like x[, \"a\"] <- cbind(-1:-4, -5:-8), but using pass-by-reference  obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutatomic  #> typeof:  integer   ss_set(obj, n(1:3), 1:ndim(obj), tf = \\(x) -x) print(obj2) #>       a  b   c  a #> [1,] -1 -5  -9 13 #> [2,] -2 -6 -10 14 #> [3,] -3 -7 -11 15 #> [4,]  4  8  12 16 #> mutatomic  #> typeof:  integer  # above is like x[1:3, 1:3] <- -1 * x[1:3, 1:3], but using pass-by-reference  obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutatomic  #> typeof:  integer   ii_set(obj, i = \\(x) x <= 5, tf = \\(x) -x) print(obj2) #>       a  b  c  a #> [1,] -1 -5  9 13 #> [2,] -2  6 10 14 #> [3,] -3  7 11 15 #> [4,] -4  8 12 16 #> mutatomic  #> typeof:  integer  # above is like x[x <= 5] <- -1 * x[x <= 5], but using pass-by-reference  obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutatomic  #> typeof:  integer   ss_set(obj, n(\"a\"), 2L, tf = \\(x) -x) obj2 #>       a b  c   a #> [1,] -1 5  9 -13 #> [2,] -2 6 10 -14 #> [3,] -3 7 11 -15 #> [4,] -4 8 12 -16 #> mutatomic  #> typeof:  integer  # above is like x[, \"a\"] <- -1 * x[, \"a\"], but using pass-by-reference   gen_array <- function() {   as.mutatomic(array(1:64, c(4,4,3))) } obj <- obj2 <- gen_array() obj #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  #> mutatomic  #> typeof:  integer   ss_set(obj, n(1:3, 1:2, c(1, 3)), 1:3, rp = -1:-12) print(obj2) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   -1   -4    9   13 #> [2,]   -2   -5   10   14 #> [3,]   -3   -6   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   -7  -10   41   45 #> [2,]   -8  -11   42   46 #> [3,]   -9  -12   43   47 #> [4,]   36   40   44   48 #>  #> mutatomic  #> typeof:  integer  # above is like x[1:3, , 1:2] <- -1:-12, but using pass-by-reference   obj <- obj2 <- gen_array() obj #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  #> mutatomic  #> typeof:  integer  ii_set(obj, i = \\(x)x <= 5, rp = -1:-5) print(obj2) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   -1   -5    9   13 #> [2,]   -2    6   10   14 #> [3,]   -3    7   11   15 #> [4,]   -4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  #> mutatomic  #> typeof:  integer  # above is like x[x <= 5] <- -1:-5, but using pass-by-reference    #############################################################################  # data.table ====  obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sbt_set(   obj, ~ (a >= 2) & (c <= 17), is.numeric,   tf = sqrt # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost ) #> Warning: 1.414214 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 1 named 'a') #> Warning: 3.464102 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 3 named 'c') print(obj) #>         a      b     c      d #>     <int> <char> <int> <fctr> #>  1:     1      a    11      a #>  2:     1      b     3      b #>  3:     1      c     3      c #>  4:     2      d     3      d #>  5:     2      e     3      e #>  6:     2      f     4      f #>  7:     2      g     4      g #>  8:     8      h    18      h #>  9:     9      i    19      i #> 10:    10      j    20      j  obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) sbt_set(obj, vars = is.numeric, tf = as.numeric) # first coerce type by whole columns str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sbt_set(obj, ~ (a >= 2) & (c <= 17), is.numeric,   tf = sqrt # SAFE: coercion performed by column first )  print(obj) #>             a      b         c      d #>         <num> <char>     <num> <fctr> #>  1:  1.000000      a 11.000000      a #>  2:  1.414214      b  3.464102      b #>  3:  1.732051      c  3.605551      c #>  4:  2.000000      d  3.741657      d #>  5:  2.236068      e  3.872983      e #>  6:  2.449490      f  4.000000      f #>  7:  2.645751      g  4.123106      g #>  8:  8.000000      h 18.000000      h #>  9:  9.000000      i 19.000000      i #> 10: 10.000000      j 20.000000      j  obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sbt_set(   obj,   vars = is.numeric,   tf = sqrt # SAFE: obs = NULL, so coercion performed ) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 1.41 1.73 2 2.24 ... #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  3.32 3.46 3.61 3.74 3.87 ... #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_setRename.html","id":null,"dir":"Reference","previous_headings":"","what":"Safely Change the Names of a Mutable Object By Reference — sb_setRename","title":"Safely Change the Names of a Mutable Object By Reference — sb_setRename","text":"Functions rename supported mutable object using pass--reference semantics: sb_setFlatnames() renames (flat) names mutatomic object. sb_setDimnames() renames dimension names mutatomic object. sb_setVarnames() renames variable names data.table object.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_setRename.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Safely Change the Names of a Mutable Object By Reference — sb_setRename","text":"","code":"sb_setFlatnames(x, i = NULL, newnames, ...)  sb_setDimnames(x, m, newdimnames, ...)  sb_setVarnames(x, old, new, skip_absent = FALSE, ...)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_setRename.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Safely Change the Names of a Mutable Object By Reference — sb_setRename","text":"x variable belonging one supported mutable classes. logical, numeric, character, imaginary indices, indicating flatnames changed.  = NULL, names completely replaced. newnames Atomic character vector giving new names.  Specifying NULL remove names. ... see squarebrackets_method_dispatch. m integer vector giving margin(s) change names (m = 1L rows, m = 2L columns, etc.). newdimnames list length m.  first element list corresponds margin m[1], second element m[2], .  components list can either NULL, character vector length corresponding dimension.  Instead list, simply NULL can specified, remove dimnames completely. old old column names new new column names, order old skip_absent Skip items old missing (.e. absent) names(x).  Default FALSE halts error missing.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_setRename.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Safely Change the Names of a Mutable Object By Reference — sb_setRename","text":"Returns: VOID. method modifies object reference.  use assignment like names(x) <- sb_setRename(x, ...).  Since function returns void, just get NULL.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_setRename.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Safely Change the Names of a Mutable Object By Reference — sb_setRename","text":"","code":"# mutable atomic vector ==== x <- y <- mutatomic(1:10, names = letters[1:10]) print(x) #>  a  b  c  d  e  f  g  h  i  j  #>  1  2  3  4  5  6  7  8  9 10  #> mutatomic  #> typeof:  integer  sb_setFlatnames(x, newnames = rev(letters[1:10])) print(y) #>  j  i  h  g  f  e  d  c  b  a  #>  1  2  3  4  5  6  7  8  9 10  #> mutatomic  #> typeof:  integer   x <- y <- mutatomic(1:10, names = letters[1:10]) print(x) #>  a  b  c  d  e  f  g  h  i  j  #>  1  2  3  4  5  6  7  8  9 10  #> mutatomic  #> typeof:  integer  sb_setFlatnames(x, 1L, \"XXX\") print(y) #> XXX   b   c   d   e   f   g   h   i   j  #>   1   2   3   4   5   6   7   8   9  10  #> mutatomic  #> typeof:  integer   ################################################################################   # mutable atomic matrix ==== x <- mutatomic(   1:20, dim = c(5, 4), dimnames = n(letters[1:5], letters[1:4]) ) print(x) #>   a  b  c  d #> a 1  6 11 16 #> b 2  7 12 17 #> c 3  8 13 18 #> d 4  9 14 19 #> e 5 10 15 20 #> mutatomic  #> typeof:  integer  sb_setDimnames(   x,   1:2,   lapply(dimnames(x), rev) ) print(x) #>   d  c  b  a #> e 1  6 11 16 #> d 2  7 12 17 #> c 3  8 13 18 #> b 4  9 14 19 #> a 5 10 15 20 #> mutatomic  #> typeof:  integer     ################################################################################    # data.table ====  x <- data.table::data.table(   a = 1:20,   b = letters[1:20] ) print(x) #>         a      b #>     <int> <char> #>  1:     1      a #>  2:     2      b #>  3:     3      c #>  4:     4      d #>  5:     5      e #>  6:     6      f #>  7:     7      g #>  8:     8      h #>  9:     9      i #> 10:    10      j #> 11:    11      k #> 12:    12      l #> 13:    13      m #> 14:    14      n #> 15:    15      o #> 16:    16      p #> 17:    17      q #> 18:    18      r #> 19:    19      s #> 20:    20      t #>         a      b sb_setVarnames(x, old = names(x), new = rev(names(x))) print(x) #>         b      a #>     <int> <char> #>  1:     1      a #>  2:     2      b #>  3:     3      c #>  4:     4      d #>  5:     5      e #>  6:     6      f #>  7:     7      g #>  8:     8      h #>  9:     9      i #> 10:    10      j #> 11:    11      k #> 12:    12      l #> 13:    13      m #> 14:    14      n #> 15:    15      o #> 16:    16      p #> 17:    17      q #> 18:    18      r #> 19:    19      s #> 20:    20      t #>         b      a"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_wo.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods to Return Object Without Specified Subset — ii_wo","title":"Methods to Return Object Without Specified Subset — ii_wo","text":"S3 Methods return object without specified subset.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_wo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods to Return Object Without Specified Subset — ii_wo","text":"","code":"ii_wo(x, ...)  ss_wo(x, ...)  sbt_wo(x, ...)  # Default S3 method ii_wo(x, i = NULL, ..., chkdup = getOption(\"squarebrackets.chkdup\", FALSE))  # Default S3 method ss_wo(   x,   s = NULL,   d = 1:ndim(x),   ...,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # Default S3 method sbt_wo(   x,   row = NULL,   col = NULL,   ...,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # S3 method for class 'data.frame' sbt_wo(   x,   obs = NULL,   vars = NULL,   ...,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_wo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods to Return Object Without Specified Subset — ii_wo","text":"x see squarebrackets_supported_structures. ... see squarebrackets_method_dispatch. , s, d, row, col, obs, vars See squarebrackets_indx_args.  empty index selection results nothing removed, entire object returned. chkdup see squarebrackets_options.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_wo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Methods to Return Object Without Specified Subset — ii_wo","text":"copy sub-setted object.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_wo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Methods to Return Object Without Specified Subset — ii_wo","text":"","code":"# atomic objects ====  obj <- matrix(1:16, ncol = 4) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 ss_wo(obj, n(1:3), 1:ndim(obj)) #>       a #> [1,] 16 # above is equivalent to  obj[-1:-3, -1:-3, drop = FALSE] ii_wo(obj, i = \\(x) x > 5) #> [1] 1 2 3 4 5 # above is equivalent to  obj[!obj > 5] ss_wo(obj, n(\"a\"), 2L) #>      b  c #> [1,] 5  9 #> [2,] 6 10 #> [3,] 7 11 #> [4,] 8 12 # above is equivalent to  obj[, which(!colnames(obj) %in% \"a\")]  obj <- array(1:64, c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  ss_wo(obj, n(1, c(1, 3)), c(1, 3)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   18   22   26   30 #> [2,]   19   23   27   31 #> [3,]   20   24   28   32 #>  # above is equivalent to obj[-1, , c(-1, -3), drop = FALSE] ii_wo(obj, i = \\(x)x > 5) #> [1] 1 2 3 4 5 # above is equivalent to obj[!obj > 5]    #############################################################################   # lists ====  obj <- list(a = 1:10, b = letters[1:11], c = 11:20) print(obj) #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  ii_wo(obj, \"a\") #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  # above is equivalent to obj[which(!names(obj) %in% \"a\")] ii_wo(obj, 1) # obj[-1] #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  ii_wo(obj, 1:2) #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  # above is equivalent to obj[seq_len(length(obj))[-1:-2]] obj <- list(a = 1:10, b = letters[1:11], c = letters) ii_wo(obj, is.numeric) #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" #> [20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\" #>  # above is equivalent to obj[!sapply(obj, is.numeric)] # this time singular brackets? # for recusive indexing, see lst_rec()   obj <- rbind(   lapply(1:4, \\(x)sample(c(TRUE, FALSE, NA))),   lapply(1:4, \\(x)sample(1:10)),   lapply(1:4, \\(x)rnorm(10)),   lapply(1:4, \\(x)sample(letters)) ) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a            b            c            a            #> [1,] logical,3    logical,3    logical,3    logical,3    #> [2,] integer,10   integer,10   integer,10   integer,10   #> [3,] numeric,10   numeric,10   numeric,10   numeric,10   #> [4,] character,26 character,26 character,26 character,26 ss_wo(obj, n(1:3), 1:ndim(obj)) #>      a            #> [1,] character,26 # above is equivalent to obj[1:3, 1:3, drop = FALSE] ii_wo(obj, i = is.numeric) #> [[1]] #> [1]    NA  TRUE FALSE #>  #> [[2]] #>  [1] \"d\" \"r\" \"t\" \"h\" \"g\" \"x\" \"j\" \"l\" \"n\" \"o\" \"q\" \"c\" \"m\" \"k\" \"y\" \"b\" \"v\" \"a\" \"s\" #> [20] \"f\" \"p\" \"w\" \"u\" \"e\" \"z\" \"i\" #>  #> [[3]] #> [1] FALSE    NA  TRUE #>  #> [[4]] #>  [1] \"s\" \"h\" \"o\" \"v\" \"a\" \"g\" \"l\" \"y\" \"b\" \"f\" \"u\" \"e\" \"t\" \"q\" \"k\" \"x\" \"r\" \"z\" \"j\" #> [20] \"n\" \"i\" \"p\" \"m\" \"c\" \"d\" \"w\" #>  #> [[5]] #> [1] FALSE  TRUE    NA #>  #> [[6]] #>  [1] \"d\" \"x\" \"l\" \"m\" \"e\" \"z\" \"w\" \"v\" \"t\" \"f\" \"u\" \"j\" \"y\" \"p\" \"g\" \"n\" \"i\" \"b\" \"a\" #> [20] \"c\" \"q\" \"r\" \"k\" \"o\" \"s\" \"h\" #>  #> [[7]] #> [1] FALSE    NA  TRUE #>  #> [[8]] #>  [1] \"y\" \"o\" \"t\" \"e\" \"i\" \"g\" \"s\" \"j\" \"m\" \"x\" \"k\" \"d\" \"u\" \"l\" \"r\" \"h\" \"z\" \"n\" \"c\" #> [20] \"a\" \"b\" \"v\" \"p\" \"w\" \"f\" \"q\" #>  # above is equivalent to obj[sapply(obj, is.numeric)] ss_wo(obj, n(c(\"a\", \"a\")), 2L) #>      b            c            #> [1,] logical,3    logical,3    #> [2,] integer,10   integer,10   #> [3,] numeric,10   numeric,10   #> [4,] character,26 character,26 # above is equivalent to obj[, lapply(c(\"a\", \"a\"), \\(i) which(colnames(obj) == i)) |> unlist()]  obj <- array(as.list(1:64), c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 1    5    9    13   #> [2,] 2    6    10   14   #> [3,] 3    7    11   15   #> [4,] 4    8    12   16   #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 17   21   25   29   #> [2,] 18   22   26   30   #> [3,] 19   23   27   31   #> [4,] 20   24   28   32   #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 33   37   41   45   #> [2,] 34   38   42   46   #> [3,] 35   39   43   47   #> [4,] 36   40   44   48   #>  ss_wo(obj, n(1, c(1, 3)), c(1, 3)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 18   22   26   30   #> [2,] 19   23   27   31   #> [3,] 20   24   28   32   #>  # above is equivalent to obj[-1, , c(-1, -3), drop = FALSE] ii_wo(obj, i = \\(x)x>5) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 3 #>  #> [[4]] #> [1] 4 #>  #> [[5]] #> [1] 5 #>  # above is equivalent to obj[!sapply(obj, \\(x) x > 5)]    #############################################################################  # data.frame-like objects ====  obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) print(obj) #>     a b  c d #> 1   1 a 11 a #> 2   2 b 12 b #> 3   3 c 13 c #> 4   4 d 14 d #> 5   5 e 15 e #> 6   6 f 16 f #> 7   7 g 17 g #> 8   8 h 18 h #> 9   9 i 19 i #> 10 10 j 20 j sbt_wo(obj, 1:3, 1:3) #>   d #> 1 d #> 2 e #> 3 f #> 4 g #> 5 h #> 6 i #> 7 j # above is equivalent to obj[-1:-3, -1:-3, drop = FALSE] sbt_wo(obj, ~ (a > 5) & (c < 19), is.numeric) #>   b d #> 1 a a #> 2 b b #> 3 c c #> 4 d d #> 5 e e #> 6 i i #> 7 j j"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_x.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods to Extract, Exchange, or Duplicate Subsets of an Object — ii_x","title":"Methods to Extract, Exchange, or Duplicate Subsets of an Object — ii_x","text":"Methods extract, exchange, duplicate (.e. repeat x times) subsets object.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_x.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods to Extract, Exchange, or Duplicate Subsets of an Object — ii_x","text":"","code":"ii_x(x, ...)  ss_x(x, ...)  sbt_x(x, ...)  # Default S3 method ii_x(x, i = NULL, ...)  # Default S3 method ss_x(x, s = NULL, d = 1:ndim(x), ...)  # Default S3 method sbt_x(x, row = NULL, col = NULL, ...)  # S3 method for class 'data.frame' sbt_x(x, obs = NULL, vars = NULL, ...)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_x.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods to Extract, Exchange, or Duplicate Subsets of an Object — ii_x","text":"x see squarebrackets_supported_structures. ... see squarebrackets_method_dispatch. , s, d, row, col, obs, vars See squarebrackets_indx_args.  Duplicates allowed, resulting duplicated indices.  empty index selection results empty object length 0.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_x.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Methods to Extract, Exchange, or Duplicate Subsets of an Object — ii_x","text":"Returns copy sub-setted object.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_x.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Methods to Extract, Exchange, or Duplicate Subsets of an Object — ii_x","text":"","code":"# atomic objects ====  obj <- matrix(1:16, ncol = 4) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 ss_x(obj, s = n(1:3), d = 1:ndim(obj)) #>      a b  c #> [1,] 1 5  9 #> [2,] 2 6 10 #> [3,] 3 7 11 # above is equivalent to obj[1:3, 1:3, drop = FALSE] ii_x(obj, i = \\(x) x > 5) #>  [1]  6  7  8  9 10 11 12 13 14 15 16 # above is equivalent to obj[obj > 5] ss_x(obj, s = n(c(\"a\", \"a\")), d = 2L) #>      a  a a  a #> [1,] 1 13 1 13 #> [2,] 2 14 2 14 #> [3,] 3 15 3 15 #> [4,] 4 16 4 16 # above is equivalent to obj[, lapply(c(\"a\", \"a\"), \\(i) which(colnames(obj) == i)) |> unlist()]  obj <- array(1:64, c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  ss_x(obj, s = n(1:3, 1:2), d = c(1,3)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #>  # above is equivalent to obj[1:3, , 1:2, drop = FALSE] ii_x(obj, i = \\(x)x > 5) #>  [1]  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #> [26] 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 # above is equivalent to obj[obj > 5]   #############################################################################   # lists ====  obj <- list(a = 1:10, b = letters[1:11], c = 11:20) print(obj) #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  ii_x(obj, 1) # obj[1] #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  ii_x(obj, 1:2) # obj[1:2] #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  ii_x(obj, is.numeric) # obj[sapply(obj, is.numeric)] #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  # for recursive subsets, see lst_rec()   obj <- rbind(   lapply(1:4, \\(x)sample(c(TRUE, FALSE, NA))),   lapply(1:4, \\(x)sample(1:10)),   lapply(1:4, \\(x)rnorm(10)),   lapply(1:4, \\(x)sample(letters)) ) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a            b            c            a            #> [1,] logical,3    logical,3    logical,3    logical,3    #> [2,] integer,10   integer,10   integer,10   integer,10   #> [3,] numeric,10   numeric,10   numeric,10   numeric,10   #> [4,] character,26 character,26 character,26 character,26 ss_x(obj, s = n(1:3), d = 1:ndim(obj)) #>      a          b          c          #> [1,] logical,3  logical,3  logical,3  #> [2,] integer,10 integer,10 integer,10 #> [3,] numeric,10 numeric,10 numeric,10 # above is equivalent to obj[1:3, 1:3, drop = FALSE] ii_x(obj, i = is.numeric) #> [[1]] #>  [1]  5  1  2  3  6  4  9 10  7  8 #>  #> [[2]] #>  [1]  0.07172819  1.31478153  1.15483700  0.44180571 -1.48440029 -2.82319411 #>  [7] -0.29184508  0.92987800  0.85048762 -0.59685342 #>  #> [[3]] #>  [1]  5  6  9  3  2  7 10  1  8  4 #>  #> [[4]] #>  [1] -0.76882711  1.13768133  0.34711343 -0.78904510  0.66128615 -1.49914708 #>  [7] -0.04262502 -0.47177480 -0.39288135 -0.36021052 #>  #> [[5]] #>  [1]  1  6  7  5  9  8  4 10  3  2 #>  #> [[6]] #>  [1] -0.66744569  0.49342239 -0.90822077 -0.83959758  0.07614879  0.40134900 #>  [7]  0.10253661  1.04367433  0.45641635 -0.01515641 #>  #> [[7]] #>  [1] 10  1  7  2  4  8  9  5  6  3 #>  #> [[8]] #>  [1] -0.2767074  1.2920684  1.1245940  0.2695532 -1.9048980  1.2280046 #>  [7]  0.2131058  0.6866260  0.7195622  0.6227942 #>  # above is equivalent to obj[sapply(obj, is.numeric)] ss_x(obj, s = n(c(\"a\", \"a\")), d = 2L) #>      a            a            a            a            #> [1,] logical,3    logical,3    logical,3    logical,3    #> [2,] integer,10   integer,10   integer,10   integer,10   #> [3,] numeric,10   numeric,10   numeric,10   numeric,10   #> [4,] character,26 character,26 character,26 character,26 # above is equivalent to obj[, lapply(c(\"a\", \"a\"), \\(i) which(colnames(obj) == i)) |> unlist()]  obj <- array(as.list(1:64), c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 1    5    9    13   #> [2,] 2    6    10   14   #> [3,] 3    7    11   15   #> [4,] 4    8    12   16   #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 17   21   25   29   #> [2,] 18   22   26   30   #> [3,] 19   23   27   31   #> [4,] 20   24   28   32   #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 33   37   41   45   #> [2,] 34   38   42   46   #> [3,] 35   39   43   47   #> [4,] 36   40   44   48   #>  ss_x(obj, s = n(1:3, 1:2), d = c(1,3)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 1    5    9    13   #> [2,] 2    6    10   14   #> [3,] 3    7    11   15   #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 17   21   25   29   #> [2,] 18   22   26   30   #> [3,] 19   23   27   31   #>  # above is equivalent to obj[1:3, , 1:2, drop = FALSE] ii_x(obj, i = \\(x)x > 5) #> [[1]] #> [1] 6 #>  #> [[2]] #> [1] 7 #>  #> [[3]] #> [1] 8 #>  #> [[4]] #> [1] 9 #>  #> [[5]] #> [1] 10 #>  #> [[6]] #> [1] 11 #>  #> [[7]] #> [1] 12 #>  #> [[8]] #> [1] 13 #>  #> [[9]] #> [1] 14 #>  #> [[10]] #> [1] 15 #>  #> [[11]] #> [1] 16 #>  #> [[12]] #> [1] 17 #>  #> [[13]] #> [1] 18 #>  #> [[14]] #> [1] 19 #>  #> [[15]] #> [1] 20 #>  #> [[16]] #> [1] 21 #>  #> [[17]] #> [1] 22 #>  #> [[18]] #> [1] 23 #>  #> [[19]] #> [1] 24 #>  #> [[20]] #> [1] 25 #>  #> [[21]] #> [1] 26 #>  #> [[22]] #> [1] 27 #>  #> [[23]] #> [1] 28 #>  #> [[24]] #> [1] 29 #>  #> [[25]] #> [1] 30 #>  #> [[26]] #> [1] 31 #>  #> [[27]] #> [1] 32 #>  #> [[28]] #> [1] 33 #>  #> [[29]] #> [1] 34 #>  #> [[30]] #> [1] 35 #>  #> [[31]] #> [1] 36 #>  #> [[32]] #> [1] 37 #>  #> [[33]] #> [1] 38 #>  #> [[34]] #> [1] 39 #>  #> [[35]] #> [1] 40 #>  #> [[36]] #> [1] 41 #>  #> [[37]] #> [1] 42 #>  #> [[38]] #> [1] 43 #>  #> [[39]] #> [1] 44 #>  #> [[40]] #> [1] 45 #>  #> [[41]] #> [1] 46 #>  #> [[42]] #> [1] 47 #>  #> [[43]] #> [1] 48 #>  # above is equivalent to obj[sapply(obj, \\(x) x > 5)]  #############################################################################  # data.frame-like objects ====  obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) print(obj) #>     a b  c d #> 1   1 a 11 a #> 2   2 b 12 b #> 3   3 c 13 c #> 4   4 d 14 d #> 5   5 e 15 e #> 6   6 f 16 f #> 7   7 g 17 g #> 8   8 h 18 h #> 9   9 i 19 i #> 10 10 j 20 j sbt_x(obj, 1:3, 1:3) #>   a b  c #> 1 1 a 11 #> 2 2 b 12 #> 3 3 c 13 sbt_x(obj, ~ (a > 5) & (c < 19), is.numeric) #>   a  c #> 1 6 16 #> 2 7 17 #> 3 8 18"},{"path":"https://tony-aw.github.io/squarebrackets/reference/size.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the Size of an Object Along a Margin — s","title":"Get the Size of an Object Along a Margin — s","text":"s(x, m) gets size object x along margin m.  m == 0, s() gets length object.  m > 0, s() gets dim(x)[m] object.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/size.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the Size of an Object Along a Margin — s","text":"","code":"s(x, m = 0L, ...)  # Default S3 method s(x, m, ...)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/size.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the Size of an Object Along a Margin — s","text":"x object m margin. ... arguments passed methods.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/size.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the Size of an Object Along a Margin — s","text":"numeric scalar.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/size.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the Size of an Object Along a Margin — s","text":"","code":"x <- array(1:64, c(4,4,3)) print(x) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  ss <- n(c(s(x, 1), 1), c(s(x, 3), 1)) ss_x(x, ss, c(1,3)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   36   40   44   48 #> [2,]   33   37   41   45 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    4    8   12   16 #> [2,]    1    5    9   13 #>"},{"path":"https://tony-aw.github.io/squarebrackets/reference/slice.html","id":null,"dir":"Reference","previous_headings":"","what":"Efficient Sequence-based Subset Methods on (Long) Vectors — slice","title":"Efficient Sequence-based Subset Methods on (Long) Vectors — slice","text":"slice_ - methods similar ii_/ss_ - methods, except require indexing vector, designed memory efficiency.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/slice.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Efficient Sequence-based Subset Methods on (Long) Vectors — slice","text":"","code":"slice_x(x, ...)  # Default S3 method slice_x(   x,   from = NULL,   to = NULL,   by = 1L,   ...,   use.names = TRUE,   sticky = getOption(\"squarebrackets.sticky\", FALSE) )  slice_wo(x, ...)  # Default S3 method slice_wo(   x,   from = NULL,   to = NULL,   by = 1L,   ...,   use.names = TRUE,   sticky = getOption(\"squarebrackets.sticky\", FALSE) )  slice_set(x, ...)  # Default S3 method slice_set(x, from = NULL, to = NULL, by = 1L, inv = FALSE, ..., rp, tf)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/slice.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Efficient Sequence-based Subset Methods on (Long) Vectors — slice","text":"x atomic object.  slice_set must mutatomic variable. ... see squarebrackets_method_dispatch. , , see cp_seq. use.names Boolean, indicating flat names preserved.  Note , since slice_ methods operates flat indices , dimensions dimnames always dropped. sticky see squarebrackets_options. inv Boolean, indicating whether invert sequence.  TRUE, slice_set() apply replacement/transformation elements vector, except elements specified sequence. rp, tf see squarebrackets_modify.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/slice.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Efficient Sequence-based Subset Methods on (Long) Vectors — slice","text":"Similar ii_ methods.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/slice.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Efficient Sequence-based Subset Methods on (Long) Vectors — slice","text":"","code":"x <- mutatomic(1:1e7)  # extract: slice_x(x, 1, 10) #>  [1]  1  2  3  4  5  6  7  8  9 10 #> mutatomic  #> typeof:  integer   # reverse: slice_x(x, -1i, 1) |> head() #> [1] 10000000  9999999  9999998  9999997  9999996  9999995 #> mutatomic  #> typeof:  integer   # remove: slice_wo(x, 1, -11i) # all elements except the last 10 #>  [1]  9999991  9999992  9999993  9999994  9999995  9999996  9999997  9999998 #>  [9]  9999999 10000000 #> mutatomic  #> typeof:  integer   # replace every other element: x <- mutatomic(1:1e7) slice_set(x, 2, -1i, 2, rp = -1) #> coercing replacement to integer head(x) #> [1]  1 -1  3 -1  5 -1 #> mutatomic  #> typeof:  integer   # replace all elements except the first element: x <- mutatomic(1:1e7) slice_set(x, 1, 1, inv = TRUE, rp = -1) #> coercing replacement to integer head(x) #> [1]  1 -1 -1 -1 -1 -1 #> mutatomic  #> typeof:  integer"},{"path":"https://tony-aw.github.io/squarebrackets/reference/slicev.html","id":null,"dir":"Reference","previous_headings":"","what":"Efficient Value-based Subset Methods on (Long) Vectors — slicev","title":"Efficient Value-based Subset Methods on (Long) Vectors — slicev","text":"slicev_ - methods similar ii_/ss_ - methods, except require indexing vector, designed memory efficiency. counv(y, v, , ) counts often value, range values, v, occurs vector subset y[:].","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/slicev.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Efficient Value-based Subset Methods on (Long) Vectors — slicev","text":"","code":"slicev_x(x, ...)  # Default S3 method slicev_x(   x,   ...,   y = x,   v = NULL,   na = FALSE,   r = TRUE,   from = NULL,   to = NULL,   use.names = TRUE,   sticky = getOption(\"squarebrackets.sticky\", FALSE) )  slicev_set(x, ...)  # Default S3 method slicev_set(   x,   ...,   y = x,   v = NULL,   na = FALSE,   r = TRUE,   from = NULL,   to = NULL,   rp,   tf )  countv(y, ..., v = NULL, na = FALSE, r = TRUE, from = NULL, to = NULL)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/slicev.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Efficient Value-based Subset Methods on (Long) Vectors — slicev","text":"x atomic vector.  slicev_set() must mutatomic variable. ... See squarebrackets_slicev. y, v, na, r See squarebrackets_slicev. , see cp_seq. use.names Boolean, indicating flat names preserved.  Note , since slicev_ methods operates flat indices , dimensions dimnames always dropped. sticky see squarebrackets_options. rp, tf see squarebrackets_modify.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/slicev.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Efficient Value-based Subset Methods on (Long) Vectors — slicev","text":"Similar ii_ methods.  countv(): single number, giving number elements matching specified condition.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/slicev.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Efficient Value-based Subset Methods on (Long) Vectors — slicev","text":"","code":"# basic idea ==== nms <- c(letters, LETTERS, month.abb, month.name) |> rep_len(1e6) x <- mutatomic(1:1e6, names = nms) head(x) #> a b c d e f  #> 1 2 3 4 5 6  #> mutatomic  #> typeof:  integer   # memory efficient form of sum(x <= 10): countv(x, v = c(-Inf, 10)) #> [1] 10  # extract all elements of x with the name \"a\": slicev_x(x, y = names(x), v = \"a\") |> head() #>   a   a   a   a   a   a  #>   1  77 153 229 305 381  #> mutatomic  #> typeof:  integer   # find all x smaller than or equal to 5, and replace with `-1000`: slicev_set(x, y = x, v = c(-Inf, 5), rp = -1000L) head(x, n = 10) #>     a     b     c     d     e     f     g     h     i     j  #> -1000 -1000 -1000 -1000 -1000     6     7     8     9    10  #> mutatomic  #> typeof:  integer    ################################################################################ # Numeric range ==== # x <- mutatomic(1:1e6) head(x) #> [1] 1 2 3 4 5 6 #> mutatomic  #> typeof:  integer  slicev_x(x, v= c(-Inf, 5)) # x[x <= 5] #> [1] 1 2 3 4 5 #> mutatomic  #> typeof:  integer    ################################################################################ # Character ==== # if(require(stringi)) {   x <- stringi::stri_rand_shuffle(rep(\"hello\", 1e5))   head(x)   slicev_x(x, v = \"hello\") |> head() # find \"hello\"      # find 2 possible misspellings of \"hello\":   slicev_x(x, v = c(\"holle\", \"helol\")) |> head()    } #> [1] \"holle\" \"helol\" \"helol\" \"helol\" \"helol\" \"holle\""},{"path":"https://tony-aw.github.io/squarebrackets/reference/ss2ii.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Subscripts to Coordinates, Coordinates to Interior Indices, and Vice-Versa — ss2ii","title":"Convert Subscripts to Coordinates, Coordinates to Interior Indices, and Vice-Versa — ss2ii","text":"functions convert list integer subscripts integer matrix coordinates, integer matrix coordinates integer vector interior indices, vice-versa.  Inspired sub2ind function 'MatLab'. ss2coord() converts list integer subscripts integer matrix coordinates. coord2ii() converts integer matrix coordinates integer vector interior indices. ii2coord() converts integer vector interior indices integer matrix coordinates. coord2ss() converts integer matrix coordinates list integer subscripts;  performs simple (one might even say naive) conversion. ss2ii() faster memory efficient version ss2coord(sub, x.dims) |> coord2ii(x.dims) functions written memory-efficient.  coord2ii() thus opposite arrayInd, ii2coord merely convenient wrapper around arrayInd.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/ss2ii.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Subscripts to Coordinates, Coordinates to Interior Indices, and Vice-Versa — ss2ii","text":"","code":"ss2coord(sub, x.dim)  coord2ss(coord)  coord2ii(coord, x.dim, checks = TRUE)  ii2coord(ind, x.dim)  ss2ii(sub, x.dim, checks = TRUE)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/ss2ii.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Subscripts to Coordinates, Coordinates to Interior Indices, and Vice-Versa — ss2ii","text":"sub list integer subscripts.  first element list corresponds first dimension (rows), second element second dimensions (columns), etc.  length sub must equal length x.dim.  One give empty subscript; instead fill something like seq_len(dim(x)[margin]).  NOTE: coord2ss() function support duplicate subscripts. x.dim integer vector giving dimensions array question. .e. dim(x). coord integer matrix, giving coordinate indices (subscripts) convert.  row index, column dimension.  first columns corresponds first dimension, second column second dimensions, etc.  number columns coord must equal length x.dim. checks Boolean, indicating arguments checks performed.  Defaults TRUE.  Can set FALSE minor speed improvements. ind integer vector, giving interior position indices convert.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/ss2ii.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Subscripts to Coordinates, Coordinates to Interior Indices, and Vice-Versa — ss2ii","text":"ss2coord() ii2coord():  Returns integer matrix coordinates (properties described argument coord).  coord2ii():  Returns numeric vector interior indices (properties described argument ind).  coord2ss():  Returns list integer subscripts (properties described argument sub)  ss2ii():  Returns integer vector interior indices(prod(x.dim) < (2^31 - 1)), numeric vector interior indices (prod(x.dim) >= (2^31 - 1)).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/ss2ii.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert Subscripts to Coordinates, Coordinates to Interior Indices, and Vice-Versa — ss2ii","text":"base S3 vector array classes 'R' use standard Linear Algebraic convention, academic fields like Mathematics Statistics, following sense: vectors column vectors (.e. vertically aligned vectors); index counting starts 1; rows first dimension/subscript, columns second dimension/subscript, etc. Thus, orientation interior indices , example, 4-rows--5-columns matrix, follows:   4 5 matrix, subscript [1, 2] corresponds interior index 5.  Array subscripting 'squarebrackets' also follows standard convention.","code":"[,1] [,2] [,3] [,4] [,5]  [1,]    1    5    9   13   17  [2,]    2    6   10   14   18  [3,]    3    7   11   15   19  [4,]    4    8   12   16   20"},{"path":"https://tony-aw.github.io/squarebrackets/reference/ss2ii.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Convert Subscripts to Coordinates, Coordinates to Interior Indices, and Vice-Versa — ss2ii","text":"functions specifically designed duplicate indices per-sé.  efficiency, check duplicate indices either.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/ss2ii.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Subscripts to Coordinates, Coordinates to Interior Indices, and Vice-Versa — ss2ii","text":"","code":"x.dim <- c(10, 10, 3) x.len <- prod(x.dim) x <- array(1:x.len, x.dim) sub <- list(c(4, 3), c(3, 2), c(2, 3)) coord <- ss2coord(sub, x.dim) print(coord) #>      [,1] [,2] [,3] #> [1,]    4    3    2 #> [2,]    3    3    2 #> [3,]    4    2    2 #> [4,]    3    2    2 #> [5,]    4    3    3 #> [6,]    3    3    3 #> [7,]    4    2    3 #> [8,]    3    2    3 ind <- coord2ii(coord, x.dim) print(ind) #> [1] 124 123 114 113 224 223 214 213 all(x[ind] == c(x[c(4, 3), c(3, 2), c(2, 3)])) # TRUE #> [1] TRUE coord2 <- ii2coord(ind, x.dim) print(coord) #>      [,1] [,2] [,3] #> [1,]    4    3    2 #> [2,]    3    3    2 #> [3,]    4    2    2 #> [4,]    3    2    2 #> [5,]    4    3    3 #> [6,]    3    3    3 #> [7,]    4    2    3 #> [8,]    3    2    3 all(coord == coord2) # TRUE #> [1] TRUE sub2 <- coord2ss(coord2) sapply(1:3, \\(i) sub2[[i]] == sub[[i]]) |> all() # TRUE #> [1] TRUE"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"functions convert list integer subscripts integer matrix coordinates, integer matrix coordinates integer vector flat indices, vice-versa.  Inspired sub2ind function 'MatLab'. sub2coord() converts list integer subscripts integer matrix coordinates. coord2ind() converts integer matrix coordinates integer vector flat indices. ind2coord() converts integer vector flat indices integer matrix coordinates. coord2sub() converts integer matrix coordinates list integer subscripts;  performs simple (one might even say naive) conversion. sub2ind() faster memory efficient version coord2ind(sub2coord(sub, x.dims), x.dims) functions written memory-efficient.  coord2ind() thus opposite arrayInd, ind2coord merely convenient wrapper around arrayInd.  Note equivalent sub2ind function 'MatLab' actually coord2ind() function .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"","code":"sub2coord(sub, x.dim)  coord2sub(coord)  coord2ind(coord, x.dim, checks = TRUE)  ind2coord(ind, x.dim)  sub2ind(sub, x.dim, checks = TRUE)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"sub list integer subscripts.  first element list corresponds first dimension (rows), second element second dimensions (columns), etc.  length sub must equal length x.dim.  One give empty subscript; instead fill something like seq_len(dim(x)[margin]).  NOTE: coord2sub() function support duplicate subscripts. x.dim integer vector giving dimensions array question. .e. dim(x). coord integer matrix, giving coordinate indices (subscripts) convert.  row index, column dimension.  first columns corresponds first dimension, second column second dimensions, etc.  number columns coord must equal length x.dim. checks Boolean, indicating arguments checks performed.  Defaults TRUE.  Can set FALSE minor speed improvements. ind integer vector, giving flat position indices convert.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"sub2coord() ind2coord():  Returns integer matrix coordinates (properties described argument coord).  coord2ind():  Returns numeric vector flat indices (properties described argument ind).  coord2sub():  Returns list integer subscripts (properties described argument sub)  sub2ind():  Returns integer vector flat indices(prod(x.dim) < (2^31 - 1)), numeric vector flat indices (prod(x.dim) >= (2^31 - 1)).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"base S3 vector array classes 'R' use standard Linear Algebraic convention, academic fields like Mathematics Statistics, following sense: vectors column vectors (.e. vertically aligned vectors); index counting starts 1; rows first dimension/subscript, columns second dimension/subscript, etc. Thus, orientation flat indices , example, 4-rows--5-columns matrix, follows:   4 5 matrix, subscript [1, 2] corresponds flat index 5.  Array subscripting 'squarebrackets' also follows standard convention.","code":"[,1] [,2] [,3] [,4] [,5]  [1,]    1    5    9   13   17  [2,]    2    6   10   14   18  [3,]    3    7   11   15   19  [4,]    4    8   12   16   20"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"functions specifically designed duplicate indices per-sé.  efficiency, check duplicate indices either.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"","code":"x.dim <- c(10, 10, 3) x.len <- prod(x.dim) x <- array(1:x.len, x.dim) sub <- list(c(4, 3), c(3, 2), c(2, 3)) coord <- sub2coord(sub, x.dim) print(coord) #>      [,1] [,2] [,3] #> [1,]    4    3    2 #> [2,]    3    3    2 #> [3,]    4    2    2 #> [4,]    3    2    2 #> [5,]    4    3    3 #> [6,]    3    3    3 #> [7,]    4    2    3 #> [8,]    3    2    3 ind <- coord2ind(coord, x.dim) print(ind) #> [1] 124 123 114 113 224 223 214 213 all(x[ind] == c(x[c(4, 3), c(3, 2), c(2, 3)])) # TRUE #> [1] TRUE coord2 <- ind2coord(ind, x.dim) print(coord) #>      [,1] [,2] [,3] #> [1,]    4    3    2 #> [2,]    3    3    2 #> [3,]    4    2    2 #> [4,]    3    2    2 #> [5,]    4    3    3 #> [6,]    3    3    3 #> [7,]    4    2    3 #> [8,]    3    2    3 all(coord == coord2) # TRUE #> [1] TRUE sub2 <- coord2sub(coord2) sapply(1:3, \\(i) sub2[[i]] == sub[[i]]) |> all() # TRUE #> [1] TRUE"},{"path":"https://tony-aw.github.io/squarebrackets/news/index.html","id":"squarebrackets-0009006","dir":"Changelog","previous_headings":"","what":"squarebrackets 0.0.0.9006","title":"squarebrackets 0.0.0.9006","text":"Overhauled main methods: replaced {ii_, ii2_, ss_, ss2_} methods { ii_, ss_, sbt_ } Removed dt_* functions. Removed idx_ord_* functions. Renamed sub2ind friends ss2ii .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/news/index.html","id":"squarebrackets-0009005","dir":"Changelog","previous_headings":"","what":"squarebrackets 0.0.0.9005","title":"squarebrackets 0.0.0.9005","text":"0L can now used alias NULL indexing arguments. NULL 0L can now used list ss argument, convenience. Added proper tests obs, vars arguments. Improved speed array-related methods.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/news/index.html","id":"squarebrackets-0009004","dir":"Changelog","previous_headings":"","what":"squarebrackets 0.0.0.9004","title":"squarebrackets 0.0.0.9004","text":"Improved speed _set methods. Simplified internal code used matrices. Bug fix ss, d argument pair, something like 1:2, 1:2 behave differently list(1:2), 1:2 data.frames.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/news/index.html","id":"squarebrackets-0009003","dir":"Changelog","previous_headings":"","what":"squarebrackets 0.0.0.9003","title":"squarebrackets 0.0.0.9003","text":"Improved speed slice_ slicev_ methods.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/news/index.html","id":"squarebrackets-0009002","dir":"Changelog","previous_headings":"","what":"squarebrackets 0.0.0.9002","title":"squarebrackets 0.0.0.9002","text":"Renamed i_ i2_ methods ii_ ii2_, avoid confusion. Renamed ci_flat() ci_ii() ci_sub() ci_ss().","code":""},{"path":"https://tony-aw.github.io/squarebrackets/news/index.html","id":"squarebrackets-0009001","dir":"Changelog","previous_headings":"","what":"squarebrackets 0.0.0.9001","title":"squarebrackets 0.0.0.9001","text":"Placed i2_rec() i2_recin() , separate set methods: lst_ methods. Adjusted documentation tests accordance change. ss_/ss2_ methods now give error dimensional sub-set operations attempted non-dimensional objects.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/news/index.html","id":"squarebrackets-0009000","dir":"Changelog","previous_headings":"","what":"squarebrackets 0.0.0.9000","title":"squarebrackets 0.0.0.9000","text":"First “real” experimental version ‘squarebrackets’ GitHub.","code":""}]
