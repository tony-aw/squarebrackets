[{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Benchmarks - sb_x","text":"Due many checks conversions performed squarebrackets:: functions, make sub-setting programmatically beginner friendly, functions almost necessarily slower base R’s [-like operators. However, considerable effort made keep speed loss minimum. Generally, speed loss indeed negligible, cases even speed improvement (thanks heavy lifting performed ‘collapse’ package). benchmarks give one idea speed loss. just examples; speed determined great number factors.  ","code":"library(bench) library(ggplot2) library(patchwork)"},{"path":[]},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"matrix","dir":"Articles","previous_headings":"Atomic objects","what":"Matrix","title":"Benchmarks - sb_x","text":" ","code":"n <- 5e3 x.mat <- matrix(seq_len(n*n), ncol = n) colnames(x.mat) <- sample(c(letters, NA), n, TRUE) sel.rows <- 1:100 sel.cols <- rep(sample(letters[1:13]), 10) bm.sb_x.matrix <- bench::mark(   \"squarebrackets\" = sb_x(x.mat, n(sel.rows, sel.cols)),   \"base R\" = x.mat[sel.rows, lapply(sel.cols, \\(i) which(colnames(x.mat) == i)) |> unlist(), drop = FALSE],   min_iterations = 500 ) bm.sb_x.matrix summary(bm.sb_x.matrix) #> # A tibble: 2 × 6 #>   expression          min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>     <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 squarebrackets   4.96ms   5.27ms      186.    9.71MB    1.12  #> 2 base R           8.13ms   9.83ms      101.    14.6MB    0.818"},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"array-3d","dir":"Articles","previous_headings":"Atomic objects","what":"Array (3D)","title":"Benchmarks - sb_x","text":" ","code":"x.dims <- c(5000, 2000, 4) x.3d <- array(1:prod(x.dims), x.dims) sel.rows <- 1:900 sel.lyrs <- c(TRUE, FALSE, TRUE, FALSE) bm.sb_x.3d <- bench::mark(   \"squarebrackets\" =  sb_x(x.3d, n(sel.rows, sel.lyrs), c(1,3)),   \"base R + abind\" = abind::asub(x.3d, idx = list(sel.rows, sel.lyrs), dims = c(1,3)),   min_iterations = 500 ) summary(bm.sb_x.3d) #> # A tibble: 2 × 6 #>   expression          min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>     <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 squarebrackets   9.64ms   10.6ms      94.1    13.7MB     7.52 #> 2 base R + abind    9.7ms   10.7ms      92.8    13.7MB     6.56"},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"plot","dir":"Articles","previous_headings":"Atomic objects","what":"Plot","title":"Benchmarks - sb_x","text":" ","code":"#> Loading required namespace: tidyr"},{"path":[]},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"data-frame","dir":"Articles","previous_headings":"Data.frame-like objects","what":"data.frame","title":"Benchmarks - sb_x","text":" ","code":"n <- 1e5 chrmat <- matrix(   sample(letters, n*400, replace = TRUE), ncol = 400 ) intmat <- matrix(   seq.int(n*400), ncol = 400 ) x <- cbind(chrmat, intmat) |> as.data.frame() rm(list = c(\"chrmat\", \"intmat\")) colnames(x) <- make.names(colnames(x), unique = TRUE) sel.cols <- rep(sample(names(x), 10), 4) sel.rows <- 1:1000 bm.sb_x.df <- bench::mark(   \"squarebrackets\" = sb2_x(x, obs = sel.rows, vars = sel.cols),   \"base R\" = x[sel.rows, sel.cols, drop = FALSE],   min_iterations = 500 ) summary(bm.sb_x.df) #> # A tibble: 2 × 6 #>   expression          min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>     <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 squarebrackets   99.8µs    112µs     7360.     318KB     2.34 #> 2 base R          282.5µs    306µs     3097.     377KB     0"},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"data-table","dir":"Articles","previous_headings":"Data.frame-like objects","what":"data.table","title":"Benchmarks - sb_x","text":" ","code":"x <- as.data.table(x) tempfun <- function(x, i, j) {   x <- collapse::ss(x, i, j, check = TRUE)   names(x) <- make.names(names(x), unique = TRUE)   return(x) } bm.sb_x.dt <- bench::mark(   \"squarebrackets\" = sb2_x(x, sel.rows, sel.cols),   \"data.table + collapse\" = tempfun(x, sel.rows, sel.cols),   min_iterations = 1e4 ) summary(bm.sb_x.dt) #> # A tibble: 2 × 6 #>   expression                 min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>            <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 squarebrackets           134µs    147µs     6156.     342KB     1.23 #> 2 data.table + collapse    110µs    122µs     7255.     341KB     1.45"},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"plot-1","dir":"Articles","previous_headings":"Data.frame-like objects","what":"plot","title":"Benchmarks - sb_x","text":" ","code":""},{"path":"https://tony-aw.github.io/squarebrackets/articles/b_benchmarks_tf.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Benchmarks - transform operations","text":"Base R’s [<-, [[<-, $<- methods perform -place modification subsets objects using “copy--modify” semantics. ‘squarebrackets’ R-package provides 2 alternative semantics modification: “pass--reference” sb_set() method, “deep-copy” sb_mod() method. Moreover, base ‘R’ provides direct replacement , ‘squarebrackets’ provides replacement (rp argument) transformation (tf argument) mechanics. Thus, ‘squarebrackets’ base R really directly comparable terms benchmarking. Nonetheless, tried keep comparisons somewhat fair. sb_set() method generally several times (2 5 times) faster base R’s -place modification, generally uses half memory. sb_mod() method generally fast base R’s -place modification, uses amount memory. benchmarks give one idea speed loss. just examples; speed determined great number factors. keep comparisons classes fair, objects approximately 1e7 elements.  ","code":"library(bench) library(ggplot2) library(patchwork) library(tinycodet) #> Warning: package 'tinycodet' was built under R version 4.4.3 #> Run `?tinycodet::tinycodet` to open the introduction help page of 'tinycodet'. plotfun <- function(title1, bm1, title2, bm2) {    plotdat1 <- bm1 |> tidyr::unnest(cols = c(\"time\", \"gc\", \"mem_alloc\"))   plotdat1$expression <- paste(     plotdat1$expression,     \"\\n (\", as.character(plotdat1$mem_alloc), \")\"   )   p1 <- ggplot(plotdat1, aes_pro(x = ~ time, y = ~ expression, color = ~ gc)) +   ggbeeswarm::geom_quasirandom() + ggtitle(title1)    plotdat2 <- bm2 |> tidyr::unnest(cols = c(\"time\", \"gc\", \"mem_alloc\"))   plotdat2$expression <- paste(     plotdat2$expression,     \"\\n (\", as.character(plotdat2$mem_alloc), \")\"   )   p2 <- ggplot(plotdat2, aes_pro(x = ~ time, y = ~ expression, color = ~ gc)) +   ggbeeswarm::geom_quasirandom() + ggtitle(title2)    combined <- p1 + p2 & theme(legend.position = \"bottom\")   combined + plot_layout(guides = \"collect\") }"},{"path":[]},{"path":"https://tony-aw.github.io/squarebrackets/articles/b_benchmarks_tf.html","id":"matrix","dir":"Articles","previous_headings":"Atomic objects","what":"Matrix","title":"Benchmarks - transform operations","text":" ","code":"n <- 3162 # approx sqrt(1e7) x.mat <- matrix(seq_len(n*n), ncol = n) x.mat2 <- as.mutable_atomic(x.mat) colnames(x.mat) <- sample(c(letters, LETTERS, NA), n, TRUE) sel.rows <- 1:1000 sel.cols <- 1:1000 basefun <- function(x, rows, cols, tf) {   x[rows, cols] <- tf(x[rows, cols])   return(x) } base_plus_idx <- function(x, rows, cols, tf) {   x[idx(x, n(rows, cols), 1:2)] <- tf(x[idx(x, n(rows, cols), 1:2)])   return(x) } tf <- function(x) { return(-1 * x) } bm.sb_tf.matrix <- bench::mark(   \"base [<-\" =  basefun(x.mat, sel.rows, sel.cols, tf = tf),   \"idx + [<-\" = base_plus_idx(x.mat, sel.rows, sel.cols, tf = tf),   \"sb_set\" = sb_set(x.mat2, n(sel.rows, sel.cols), tf = tf),   \"sb_mod\" = sb_mod(x.mat, n(sel.rows, sel.cols), tf = tf),   check = FALSE,   min_iterations = 500 ) bm.sb_tf.matrix summary(bm.sb_tf.matrix) #> # A tibble: 4 × 6 #>   expression      min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 base [<-     23.5ms  25.68ms      38.5    87.7MB     2.03 #> 2 idx + [<-    26.2ms  29.08ms      33.7    95.4MB     2.38 #> 3 sb_set        5.4ms   6.35ms     153.     15.3MB     1.23 #> 4 sb_mod       23.6ms  25.74ms      32.3    87.7MB     1.63"},{"path":"https://tony-aw.github.io/squarebrackets/articles/b_benchmarks_tf.html","id":"array-3d","dir":"Articles","previous_headings":"Atomic objects","what":"Array (3D)","title":"Benchmarks - transform operations","text":" ","code":"x.dims <- c(1900, 1900, 3) # leads to approx 1e7 elements x.3d <- array(1:prod(x.dims), x.dims) x.3d2 <- as.mutable_atomic(x.3d) sel.rows <- 1:900 sel.lyrs <- c(TRUE, FALSE, TRUE) basefun <- function(x, rows, lyrs, tf) {   x[rows, , lyrs] <- tf(x[rows, , lyrs])   return(x) } base_plus_idx <- function(x, rows, lyrs, tf) {   x[idx(x, n(rows, lyrs), c(1, 3))] <- tf(x[idx(x, n(rows, lyrs), c(1, 3))])   return(x) } tf <- function(x) { return(-1 * x) } bm.sb_tf.3d <- bench::mark(   \"base [<-\" = basefun(x.3d, sel.rows, sel.lyrs, tf = tf ),   \"idx + [<-\" = base_plus_idx(x.3d, sel.rows, sel.lyrs, tf = tf),   \"sb_set\" =  sb_set(x.3d2, n(sel.rows, sel.lyrs), c(1,3), tf = tf),   \"sb_mod\" = sb_mod(x.3d, n(sel.rows, sel.lyrs), c(1, 3), tf = tf),   check = FALSE,   min_iterations = 500 ) summary(bm.sb_tf.3d) #> # A tibble: 4 × 6 #>   expression      min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 base [<-     30.7ms   32.7ms      29.9    67.4MB    1.05  #> 2 idx + [<-    33.1ms   36.1ms      26.7    93.5MB    1.35  #> 3 sb_set       21.2ms   22.5ms      43.9    26.1MB    0.624 #> 4 sb_mod       31.7ms   33.5ms      29.2    67.4MB    1.22"},{"path":"https://tony-aw.github.io/squarebrackets/articles/b_benchmarks_tf.html","id":"plot","dir":"Articles","previous_headings":"Atomic objects","what":"Plot","title":"Benchmarks - transform operations","text":" ","code":"#> Warning: The `trans` argument of `continuous_scale()` is deprecated as of ggplot2 3.5.0. #> ℹ Please use the `transform` argument instead. #> This warning is displayed once every 8 hours. #> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was #> generated. #> Orientation inferred to be along y-axis; override with #> `position_quasirandom(orientation = 'x')` #> Orientation inferred to be along y-axis; override with #> `position_quasirandom(orientation = 'x')`"},{"path":"https://tony-aw.github.io/squarebrackets/articles/b_benchmarks_tf.html","id":"data-frame-like","dir":"Articles","previous_headings":"","what":"Data.frame-like","title":"Benchmarks - transform operations","text":"    ","code":"n <- 1e5 ncol <- 200 # times 2 chrmat <- matrix(   sample(letters, n*ncol, replace = TRUE), ncol = ncol ) intmat <- matrix(   seq.int(n*ncol), ncol = ncol ) df <- cbind(chrmat, intmat) |> as.data.frame() colnames(df) <- make.names(colnames(df), unique = TRUE) dt <- data.table::as.data.table(df) rm(list = c(\"chrmat\", \"intmat\"))  sel.rows <- 1:1000 basefun <- function(x, rows, tf) {   x[rows, sapply(x, is.numeric)] <- lapply(x[rows, sapply(x, is.numeric)], tf)   return(x) } bm.sb_tf.df <- bench::mark(   \"base [<-\" = basefun(df, sel.rows, tf = \\(x) -1 * x),   \"sb_set\" = sb2_set(     dt, obs = sel.rows, vars = is.numeric, tf = \\(x) -1 * x   ),   \"sb_mod\" = sb2_mod(     df, obs = sel.rows, vars = is.numeric, tf = \\(x) -1 * x   ),   check = FALSE,   min_iterations = 500 ) summary(bm.sb_tf.df) #> # A tibble: 3 × 6 #>   expression      min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 base [<-    246.5µs    272µs     3357.   58.37KB        0 #> 2 sb_set       95.3µs    103µs     8688.    6.45KB        0 #> 3 sb_mod       95.3µs    108µs     8462.    6.45KB        0 #> Orientation inferred to be along y-axis; override with #> `position_quasirandom(orientation = 'x')`"},{"path":"https://tony-aw.github.io/squarebrackets/articles/c_benchmarks_lst.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Benchmarks - Vectorized Recursive Subset Operations On Nested Lists","text":"Operating recursive sub-sets nested lists requires [[ [[<- operators. operators can select single subset . Thus, operating multiple recursive sub-sets requires -loop, thus vectorized. lst_untree() function unnests tree-like nested list recursive matrix, way recursive sub-set operations can performed vectorized manner. benchmarks operating original list, list transformed lst_untree().   ","code":"x <- lapply(1:1000, \\(x) list(   list(sample(letters), sample(LETTERS)),   list(sample(month.abb), sample(month.name)),   list(sample(1:100), rnorm(100)) )) y <- lst_untree(x, 1)  foo <- bench::mark(   original = for(i in seq_along(x)) {x[[c(i, c(1,2))]]},   \"untree'd\" = sb2_x(n(seq_len(nrow(y)), 2), 1:2),   check = FALSE,   min_iterations = 1000 ) summary(foo) #> # A tibble: 2 × 6 #>   expression      min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 original     1.07ms   1.25ms      772.    38.4KB     36.4 #> 2 untree'd      7.8µs    9.2µs    99630.    96.9KB     29.9 ggplot2::autoplot(foo) #> Loading required namespace: tidyr"},{"path":"https://tony-aw.github.io/squarebrackets/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Tony Wilkes. Author, maintainer, copyright holder. Tony Plate. Contributor.           Author included 'abind' fragments Richard Heiberger. Contributor.           Author included 'abind' fragments Sebastian Krantz. Contributor.           Contributed internal code 'match_all' function","code":""},{"path":"https://tony-aw.github.io/squarebrackets/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Wilkes T (2025). squarebrackets: Subset Methods Alternatives Square Brackets Operators Programming. R package version 0.0.0.9, https://tony-aw.github.io/squarebrackets/, https://github.com/tony-aw/squarebrackets/.","code":"@Manual{,   title = {squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming},   author = {Tony Wilkes},   year = {2025},   note = {R package version 0.0.0.9, https://tony-aw.github.io/squarebrackets/},   url = {https://github.com/tony-aw/squarebrackets/}, }"},{"path":"https://tony-aw.github.io/squarebrackets/index.html","id":"squarebrackets","dir":"","previous_headings":"","what":"Subset Methods as Alternatives to the Square Brackets Operators for Programming","title":"Subset Methods as Alternatives to the Square Brackets Operators for Programming","text":"squarebrackets: Subset Methods Alternatives Square Brackets Operators Programming","code":""},{"path":"https://tony-aw.github.io/squarebrackets/index.html","id":"description","dir":"","previous_headings":"","what":"Description","title":"Subset Methods as Alternatives to the Square Brackets Operators for Programming","text":"Provides subset methods (supporting atomic recursive S3 classes) may convenient alternatives [ [<- operators, whilst maintaining similar performance. nice properties methods include, limited , following: [ [<- operators use different rule-sets different data.frame-like types (data.frames, data.tables, tibbles, tidytables, etc.). ‘squarebrackets’ methods use rule-sets different data.frame-like types. Performing dimensional subset operations array using [ [<-, requires -priori knowledge number dimensions array . ‘squarebrackets’ methods work arbitrary dimensions without requiring prior knowledge. selecting names [ [<- operators, first occurrence names selected case duplicate names. ‘squarebrackets’ methods always perform names case duplicates, just first. [[ [[<- operators allow operating recursive subset nested list. operate single recursive subset, vectorized multiple recursive subsets nested list . ‘squarebrackets’ provides way reshape nested list recursive matrix, thereby allowing vectorized operations recursive subsets nested list. [<- operator supports copy--modify semantics classes. ‘squarebrackets’ methods provides explicit pass--reference pass--value semantics, whilst still respecting things like binding-locks mutability rules. ‘squarebrackets’ supports index-less sub-set operations, memory efficient (better environment) long vectors sub-set operations using [ [<- operators.  ","code":""},{"path":"https://tony-aw.github.io/squarebrackets/index.html","id":"get-started","dir":"","previous_headings":"","what":"Get Started","title":"Subset Methods as Alternatives to the Square Brackets Operators for Programming","text":"get started see ?squarebrackets_help  ","code":""},{"path":"https://tony-aw.github.io/squarebrackets/index.html","id":"installing--loading","dir":"","previous_headings":"","what":"Installing & Loading","title":"Subset Methods as Alternatives to the Square Brackets Operators for Programming","text":"One can install ‘squarebrackets’ GitHub like : Special care taken make sure function names clear, function names unlikely conflict core R, recommended R packages, rstudioapi package, major packages fastverse. one can attach package - thus exposing functions namespace - using:  ","code":"remotes::install_github(\"https://github.com/tony-aw/squarebrackets\") library(squarebrackets)"},{"path":"https://tony-aw.github.io/squarebrackets/index.html","id":"changelog-experimental-versions","dir":"","previous_headings":"","what":"Changelog (EXPERIMENTAL VERSIONS)","title":"Subset Methods as Alternatives to the Square Brackets Operators for Programming","text":"10 March 2024: First GitHub upload - Package much experimental. 12 March 2024: Changed introduction help page bit, added dt_setadd(), added tests dt_ - functions. slightly 50,000 tests now. 15 March 2024: Added sb_setRename() method, added tests method also. 16 March 2024: Fixed bug “rcpp_set_rowcol” source code. Tweaked documentation bit. Improved tests bit. 17 March 2024: Added tests, tweaked documentation bit. 19 March 2024: methods/functions support mutable_atomic type “complex”; now fixed. Added support mutable_atomic type “raw”. Added tests atomic type handling. Added functions ma_setv(), couldb.mutable_atomic(). Added options “sb.rat” “sb.chkdup”; argument chkdup now also set FALSE default. Added badges documentation. 20 March 2024: user can now also specify coe = TRUE sb_mod.data.frame(). 24 March 2024: Methods now split methods non-recursive objects (sb_), methods recursive objects (sb2_). 26 March 2024: Replaced seq_rec() seq_rec2(). 27 March 2024: Added dt_setreorder(), added tests also. ‘abind’ now dependency, ‘abind’ based code removed, redundant. 29 March 2024: Added sb2_before.array() sb2_after.array(), added tests also. Added tests data.frame-like coercion types. Tweaked documentation bit. 30 March 2024: Removed separate NA checks, redundant. Fixed linguistic mistakes documentation. 1 April 2024: Removed sb_coe() kept sb2_coe(). Added inv argument sb_mod()/sb2_mod(), sb_set()/sb2_set(), sb2_coe(), added tests . Added idx1() Copy--Modification Substitution, added tests idx1() also.Fixed bug character subset ordering sb/sb2_mod/set/coe - generic methods. Fixed bug introduction message. Added even tests. Added idx1_dim(), added tests also. 5 April 2024: Replaced idx1/idx0 idx(). 18 May 2024: Added tests idx() method (need add ). Fixed export pattern expressions Namespace file. Adjusted documentation. 26 May 2024: Removed sb2_coe(), redundant. 6 June 2024: Removed sb(2)_before/methods favour new bind_/bind2_ implementations. Added lst_ functions. Added options help page. 30 June 2024: Re-written internal code arrays. Added support backward indexing via Complex Vector indices. Added tests. Replaced seq_names() new far flexible idx_r() function. 31 August 2024: Made tests efficient. Removed separate method dispatch factors, using default atomic vector method dispatch sufficient factors. 7 September 2024: Incorporated ALTREP functionality package. 15 September 2024: Replaced drop argument red avoid confusion base R’s drop mechanic. Small performance improvements sub2ind() sb_set.array(). 26 September 2024: Overhauled indexing complex vectors work. 28 September 2024: Split sb(2)_setRename() sb_setFlatnames(), sb_setDimnames(), sb2_setVarnames(). 10 October 2024: sb_mod() now makes partial copies data.frame-like objects instead whole copies, memory efficiency. Also removed old sb_str() sb_a() functions. Renamed ci_seq() cp_seq() (preparation next update). 19 October 2024: Removed renaming methods (sb_setRename), seq_rec2(). Added slcseq_. 5 November 2024: Renamed slcseq_ slice_. Re-organized documentation bit. Fixed examples ci tci help pages. Added bind_mat() bind2_mat(). Added ndims(). 14 November 2024: Performance improvement match_all(). 21 November 2024: Improved documentation. Slightly tweaked array argument usage. Added sticky option. Brought back renaming methods. Changed behaviour use.names argument lst_untree(). 24 November 2024: Matrices now use API arrays. Adjusted documentation accordingly. Cleaned internal code bit. 30 November 2024: binding implementations can now bind mixtures atomic recursive objects. 5 December 2024: Replaced _rm post-fixes _wo methods, avoid confusion. Coercion data.frame-like objects now happens automatically, needed, sb2_mod() method, updated documentation accordingly. Slightly re-organized documentation. 14 December 2024: Removed ma_setv() function favour new slicev_ set methods. Renamed sub,dims argument pair s,d. Changed documentation accordingly. 27 December 2024: Overhauled arguments data.frame/data.table methods functions. Now s,d argument pair primary argument set dimensional objects. 11 March 2025: Overhauled internal code arrays; ’s even faster now. Re-organised code preparation next update. Renamed ndims() ndim(). 13 April 2025: binding implementations moved ‘squarebrackets’ new R-package ‘broadcast’. 26 April 2025: Renamed mutable_atomic class mutatomic, moved entire class package, ‘squarebrackets’ now depends .  ","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa00_squarebrackets_help.html","id":null,"dir":"Reference","previous_headings":"","what":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa00_squarebrackets_help","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa00_squarebrackets_help","text":"squarebrackets:  Subset Methods Alternatives Square Brackets Operators Programming.  'squarebrackets' provides subset methods (supporting atomic recursive S3 classes) may convenient alternatives [ [<- operators, whilst maintaining similar performance.  nice properties methods include, limited , following. [ [<- operators use different rule-sets different data.frame-like types (data.frames, data.tables, tibbles, tidytables, etc.).  'squarebrackets' methods use rule-sets different data.frame-like types. Performing dimensional subset operations array using [ [<-, requires -priori knowledge number dimensions array .  'squarebrackets' methods work arbitrary dimensions without requiring prior knowledge. selecting names [ [<- operators, first occurrence names selected case duplicate names.  'squarebrackets' methods always perform names case duplicates, just first. [[ [[<- operators allow operating recursive subset nested list.  operate single recursive subset, vectorized multiple recursive subsets nested list .  'squarebrackets' provides way reshape nested list recursive matrix, thereby allowing vectorized operations recursive subsets nested list. [<- operator supports copy--modify semantics classes.  'squarebrackets' methods provides explicit pass--reference pass--value semantics, whilst still respecting things like binding-locks mutability rules. 'squarebrackets' supports index-less sub-set operations, memory efficient (better environment) long vectors sub-set operations using [ [<- operators.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa00_squarebrackets_help.html","id":"goal","dir":"Reference","previous_headings":"","what":"Goal","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa00_squarebrackets_help","text":"Among programming languages, 'R' perhaps one flexible comprehensive sub-setting functionality, provided square brackets operators ([, [<-).  situations square brackets operators occasionally less optimally convenient  Goal 'squarebrackets' package replace square-brackets operators, provide alternative sub-setting methods functions, used situations square bracket operators inconvenient.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa00_squarebrackets_help.html","id":"supported-structures","dir":"Reference","previous_headings":"","what":"Supported Structures","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa00_squarebrackets_help","text":"'squarebrackets' supports common S3 classes, primarily use square brackets sub-setting (hence name package).  'squarebrackets' supports following structures: basic atomic classes  (atomic vectors, matrices, arrays). mutatomic classes  (mutatomic vectors, matrices, arrays). factor. basic list classes  (recursive vectors, matrices, arrays). data.frame  (including classes tibble, sf-data.frame sf-tibble). data.table  (including classes tidytable, sf-data.table, sf-tidytable). See squarebrackets_supported_structures details.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa00_squarebrackets_help.html","id":"sub-set-operation-methods","dir":"Reference","previous_headings":"","what":"Sub-set Operation Methods","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa00_squarebrackets_help","text":"main focus package generic methods.  Generic methods atomic objects start sb_.  Generic methods recursive objects (list, data.frame, etc.) start sb2_.  also somewhat separate idx method, works recursive non-recursive objects.  finally slice_ methods, (currently) work (mutable) atomic vectors.  Methods access subsets (.e. extract selection, extract except selection): sb_x, sb2_x: extract, exchange, duplicate subsets. sb_wo,  sb2_wo: return object without specified subset. sb2_rec: access recursive subsets lists. slice_x: index-less efficient, sequence-based extraction subset long vector. slice_wo: index-less efficient, sequence-based returning long vector without specified subset. slicev_x: index-less efficient, value-based extraction subset long vector.  Methods modify subsets: idx: translate given indices/subscripts, purpose copy--modify substitution. sb2_recin: replace, transform, remove, add recursive subsets list, R's default Copy--Modify semantics. sb_mod, sb2_mod: return object modified (transformed replaced) subsets. Methods rename mutable object using pass--reference semantics. sb_set, sb2_set: modify (transform replace) subsets mutable object using pass--reference semantics. slice_set: index-less efficient, sequence-based modification (long) vector subset using pass--reference semantics. slicev_set: index-less efficient, value-based modification (long) vector subset using pass--reference semantics.  Methods extend re-arrange object beyond current size: sb_x, sb2_x: extract, exchange, duplicate subsets. sb2_recin: replace, transform, remove, add recursive subsets list, R's default Copy--Modify semantics. See squarebrackets_method_dispatch information 'squarebrackets' uses S3 Method dispatch.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa00_squarebrackets_help.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa00_squarebrackets_help","text":"Additional specialized sub-setting functions provided: lst_untree: unnest tree-like nested list recursive matrix, speed-vectorized sub-setting recursive subsets list. dt_-functions programmatically perform data.table-specific [-operations, security measures provided 'squarebrackets' package. couple convenience functions, helper functions creating ranges, sequences, indices (often needed sub-setting) provided: currentBindings: list lock currently existing bindings share share address input variable. n: Nested version c, short-hand list. ndim: Get number dimensions object. sub2coord, coord2ind: Convert subscripts (array indices) coordinates, coordinates flat indices, vice-versa. match_all: Find matches, one vector another, taking account order duplicate values vectors. Computing indices: idx_r compute integer index range. idx_by compute grouped indices. idx_ord_-functions compute ordered indices.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa00_squarebrackets_help.html","id":"overview-help-pages","dir":"Reference","previous_headings":"","what":"Overview Help Pages","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa00_squarebrackets_help","text":"Besides website, 'squarebrackets' comes several help pages can accessed within 'R'. squarebrackets_supported_structures:  Lists structures supported 'squarebrackets', explains related terminology. squarebrackets_indx_fundamentals:  Explains essential fundamentals indexing forms 'squarebrackets'. squarebrackets_indx_args:  Explains common indexing arguments used main S3 methods. squarebrackets_modify:  Explains essentials modification 'squarebrackets' squarebrackets_options:  Lists explains options user can specify 'squarebrackets'. squarebrackets_method_dispatch:  Gives details regarding S3 method dispatch 'squarebrackets'.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa00_squarebrackets_help.html","id":"properties-details","dir":"Reference","previous_headings":"","what":"Properties Details","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa00_squarebrackets_help","text":"alternative sub-setting methods functions provided 'squarebrackets' following properties: Programmatically friendly: Unlike base [, required know number dimensions array -priori, perform subset-operations array. Missing arguments can filled NULL, instead using dark magic like base::quote(expr =    ). Non-standard evaluation. Functions pipe-friendly. (silent) vector recycling. Extracting removing subsets uses syntax. Class consistent: sub-setting multi-dimensional objects specifying dimensions (.e. rows, columns, ...) use drop = FALSE.  matrix , matrix . methods deliver results data.frames, data.tables, tibbles, tidytables.  longer one re-learn different brackets-based sub-setting rules different types data.frame-like objects.  Powered subclass agnostic 'C'-code 'collapse' 'data.table'. Explicit copy semantics: Sub-set operations change memory allocations, always return modified (partial) copy object. sub-set operations just change values -place (similar [<- [[<- methods) user can choose method modifies object reference, choose method returns (partial) copy. Careful handling names: Sub-setting object index names returns matches given names, just first. Data.frame-like objects (see supported classes ) forced unique column names. Sub-setting arrays using x[indx1, indx2, etc.] drop names(x).  methods 'squarebrackets' drop names(x). Concise function argument names. Performance & Energy aware:  Despite many checks performed, functions kept reasonably speedy, use 'Rcpp', 'collapse', 'data.table' R-packages.  functions also made memory efficient reasonably possible, lower carbon footprint package.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa00_squarebrackets_help.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa00_squarebrackets_help","text":"badges shown documentation R-package made using services : https://shields.io/","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa00_squarebrackets_help.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa00_squarebrackets_help","text":"Author, Maintainer: Tony Wilkes tony_a_wilkes@outlook.com (ORCID)","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa01_squarebrackets_supported_structures.html","id":null,"dir":"Reference","previous_headings":"","what":"Supported Structures — aaa01_squarebrackets_supported_structures","title":"Supported Structures — aaa01_squarebrackets_supported_structures","text":"'squarebrackets' supports common S3 objects, primarily use square brackets sub-set operations (hence name package).  One can generally divide structures supported 'squarebrackets' along 3 key properties: atomic vs recursive:  Types logical, integer, double, complex, character, raw atomic.  Lists data.frames recursive. dimensionality:  Whether object vector, array, data.frame.  Note matrix simply array 2 dimensions. mutability:  Base R's S3 classes (except Environments) generally immutable:  Modifying object create copy (called 'copy--modify').  'squarebrackets also supports data.tables mutatomic objects, mutable:  desired, one can modify without copy using pass--reference semantics. Supported Structures 'squarebrackets' supports following immutable structures: basic atomic classes  (atomic vectors arrays). factor. basic list classes  (recursive vectors arrays). data.frame  (including classes tibble, sf-data.frame sf-tibble). 'squarebrackets' supports following mutable structures: mutatomic  (mutatomic vectors arrays); data.table  (including classes tidytable, sf-data.table, sf-tidytable).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa01_squarebrackets_supported_structures.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Supported Structures — aaa01_squarebrackets_supported_structures","text":"Atomic vs Recursive  sb_ methods provided 'squarebrackets' work atomic (see .atomic) objects.  sb2_ methods provided 'squarebrackets' work recursive (see .recursive) objects.  See squarebrackets_method_dispatch details method dispatch used 'squarebrackets'. Dimensionality  'squarebrackets' supports dimensionless vector objects (.e. ndim == 0L).  squarebrackets' supports arrays (see .array .matrix); note matrix simply array 2 dimensions.  'squarebrackets' also supports data.frame-like objects (see .data.frame).  Specifically, squarebrackets' supports wide variety data.frame classes: data.frame, data.table, tibble, tidytable;  'squarebrackets' also supports 'sf'-package compatible counter-parts: sf-data.frame, sf-data.table, sf-tibble, sf-tidytable.  Dimensionless vectors dimensional arrays supported atomic recursive forms.  Data.frame-like objects, contrast, exist recursive form (, stated, supported 'squarebrackets').  Recursive vectors, recursive matrices, recursive arrays, collectively referred \"lists\" 'squarebrackets' documentation.  Note dimensionality data.frame-like objects dimensionality (recursive) arrays/matrices.  example:  array/matrix x, holds length(x) == prod(dim(x)).  data.frame x, case length(x) == ncol(x). Mutable vs Immutable  base R's S3 classes (except Environments) generally immutable:  Modifying object create copy (called 'copy--modify').  explicit pass--reference semantics.  S3 objects base 'R' immutable:  Environments pass--reference semantics, supported 'squarebrackets'.  Supported mutable structures: 'squarebrackets' supports mutable data.table class  (thus also tidytable, inherits data.table). 'squarebrackets' also includes new class mutable objects:  mutatomic objects. mutatomic objects atomic objects, except mutable (hence name). Supported immutable structures:  Atomic recursive vectors/matrices/arrays, data.frames, tibbles.  functions 'squarebrackets' package word \"set\" name perform pass--reference modification, thus work mutable structures.  functions work way mutable immutable structures. Derived Atomic Vector  special class objects Derived Atomic Vector structures:  structures derived atomic objects, behave differently.  example:  Factors, datetime, POSIXct derived atomic vectors.  attributes special methods make behave differently.  'squarebrackets' treats derived atomic classes regular atomic vectors.  highly specialized packages handle objects derived atomic objects.  example, 'anytime' package handle date-time objects.  'squarebrackets  provide explicit support factors. Supported S3 structures  Key-Values storage S3 structures, environments, supported 'squarebrackets'.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa02_squarebrackets_indx_fundamentals.html","id":null,"dir":"Reference","previous_headings":"","what":"Indexing Fundamentals — aaa02_squarebrackets_indx_fundamentals","title":"Indexing Fundamentals — aaa02_squarebrackets_indx_fundamentals","text":"help page explains fundamentals regarding 'squarebrackets' treats indexing.  familiarity base R's [ [<- operators required follow help page.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa02_squarebrackets_indx_fundamentals.html","id":"indexing-types","dir":"Reference","previous_headings":"","what":"Indexing Types","title":"Indexing Fundamentals — aaa02_squarebrackets_indx_fundamentals","text":"Base 'R' supports indexing logical, integer, character vectors.  'squarebrackets' supports also (albeit improvements), also supports additional methods indexing. Whole numbers  Whole numbers basic form index selection.  forms indexing 'squarebrackets' internally translated integer (double > (2^31 - 1)) indexing first, ensuring consistency.  Indexing integer/numeric indices 'squarebrackets' works base 'R', except negative values allowed.  indexing starts 1 inclusive. Logical  Selecting indices logical vector 'squarebrackets' works base 'R', except recycling allowed. Characters  selecting indices using character vector, base 'R' selects first matches names.  'squarebrackets', however, selects matches:   Character indices internally translated integer indices using match_all. Imaginary Numbers  complex vector y structured y = + b *  Re(y) returns , Im(y) returns b.  squarebrackets' includes support indexing imaginary numbers (Im(y)) complex vectors.  Indexing imaginary numbers generalization indexing regular integers.  works follows:  Imaginary numbers positive integers, like 1:10 * 1i, work regular integers.  Imaginary numbers negative integers, like 1:10 * -1i, index counting backwards (.e. end).  Note Imaginary part complex vector used (Im(y));  Real part (Re(y)) ignored.  See results following code example:   Thus complex vectors allow user choose counting beginning, like regular integers, backwards counting end.","code":"nms <- c(\"a\", letters[4:1], letters[1:5]) x <- 1:10 names(x) <- nms print(x) #' `x` has multiple elements with the name \"a\" #>  a  d  c  b  a  a  b  c  d  e #>  1  2  3  4  5  6  7  8  9 10  sb_x(x, \"a\") # extracts all indices with the name \"a\" #> a a a #> 1 5 6  sb_x(x, c(\"a\", \"a\")) # repeats all indices with the name \"a\" #> a a a a a a #> 1 5 6 1 5 6 x <- 1:30 # vector of 30 elements  sb_x(x, 1:10 * 1i) # extract first 10 elements #>  [1]  1  2  3  4  5  6  7  8  9 10  sb_x(x, 1:10 * -1i) # extract last 10 elements #>  [1] 30 29 28 27 26 25 24 23 22 21  sb_x(x, 10:1 * -1i) # last 10 elements, in tail()-like order #>  [1] 21 22 23 24 25 26 27 28 29 30"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa02_squarebrackets_indx_fundamentals.html","id":"flat-indices-and-subscripts","dir":"Reference","previous_headings":"","what":"Flat Indices and Subscripts","title":"Indexing Fundamentals — aaa02_squarebrackets_indx_fundamentals","text":"primary indexing argument vectors (.e. dimensionless objects), argument, represents flat indices.  primary indexing argument dimensional objects supported 'squarebrackets' (.e. arrays data.frame-like objects), s, d argument pair, represent \"subscripts\".  (Given, example, 3-dimensional array, subscript [1:10, 2:5, 3:9], refers rows 1 10, columns 2 5, layers 3 9.)  s, d argument pair works consistently dimensional object supported 'squarebrackets', require -priori knowledge number dimensions object .  particularly useful arrays, can number dimensions.  Arrays matrices (matrices simply arrays 2 dimensions) support flat indices subscripts.  case flat indices, also called linear indices, specify indices array -vector, thus ignoring dimensions.  relationship flat indices subscripts arrays, see sub2ind help page.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa02_squarebrackets_indx_fundamentals.html","id":"inverting","dir":"Reference","previous_headings":"","what":"Inverting","title":"Indexing Fundamentals — aaa02_squarebrackets_indx_fundamentals","text":"Inverting indices means specify elements except given indices.  Consider example atomic vector month.abb (abbreviate month names).  Given vector, indices 1:5 gives c(\"Jan\" \"Feb\" \"Mar\" \"Apr\", \"May\").  Inverting indices give c(\"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\").  base 'R', inverting index done different ways.  (negative numbers numeric indexing, negation logical indexing, manually un-matching character vectors).  'squarebrackets' provides (somewhat) consistent syntax invert indices: methods end _x perform extraction;  invert extraction, .e. return object without specified subset, use methods end _wo. modification methods (_mod_/_set_) one can set argument inv = TRUE invert indices. EXAMPLES   ORDERING  order user gives indices inverting indices generally matter.  order indices appear original object x maintained, just like base 'R'.","code":"x <- month.abb print(x) #>  [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\"   sb_x(x, 1:5) # extract first 5 elements #> [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\"  sb_wo(x, 1:5) # return WITHOUT first 5 elements #> [1] \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\"   sb_mod(x, 1:5, rp = \"XXX\") # copy, replace first 5 elements, return result #>  [1] \"XXX\" \"XXX\" \"XXX\" \"XXX\" \"XXX\" \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\"  sb_mod(x, 1:5, inv = T, rp = \"XXX\") # same, but for all except first 5 elements #>  [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"XXX\" \"XXX\" \"XXX\" \"XXX\" \"XXX\" \"XXX\" \"XXX\""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa02_squarebrackets_indx_fundamentals.html","id":"out-of-bounds-integers-non-existing-names-and-nas","dir":"Reference","previous_headings":"","what":"Out-of-Bounds Integers, Non-Existing Names, and NAs","title":"Indexing Fundamentals — aaa02_squarebrackets_indx_fundamentals","text":"Integer indices bounds (including NaN NA_integer_) always give error. Character indices specify non-existing names considered form zero-length indexing.  Specifying NA names returns error. Logical indices translated internally integers using , NAs ignored.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa02_squarebrackets_indx_fundamentals.html","id":"index-less-sub-set-operations","dir":"Reference","previous_headings":"","what":"Index-less Sub-set Operations","title":"Indexing Fundamentals — aaa02_squarebrackets_indx_fundamentals","text":"now help page focussed performing sub-set operations indexing vector.  Performing sub-set operations long vector using index vector (may also long vector) memory-efficient.  'squarebrackets' therefore introduces index-less sub-set operations, slice_ slicev_ methods.  methods much memory computationally efficient index-based sub-set methods (also bit better environment!).  slice_ methods perform sequence based sub-set operations.  slicev_ methods (notice \"v\" end) perform value-based sub-set operations.  Though method intentionally kept relatively simple, still involved enough warrant help page;  details value-based index-less sub-set operations, please see squarebrackets_slicev.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa02_squarebrackets_indx_fundamentals.html","id":"regarding-performance","dir":"Reference","previous_headings":"","what":"Regarding Performance","title":"Indexing Fundamentals — aaa02_squarebrackets_indx_fundamentals","text":"Integer vectors created : operator \"compact ALTREP\" integer vectors, provide fastest way specify indices.  Indexing names (.e. character vectors) slowest.  Complex vectors imaginary numbers somewhat middle terms speed.  Index-less sub-set operations usually faster memory efficient index-based sub-set operation.  performance important, use index-less sub-set operations, use compact ALTREP integer indices.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa02_squarebrackets_indx_fundamentals.html","id":"indexing-in-recursive-subsets","dir":"Reference","previous_headings":"","what":"Indexing in Recursive Subsets","title":"Indexing Fundamentals — aaa02_squarebrackets_indx_fundamentals","text":"now help page focussed indexing regular (\"shallow\") subsets.  section discuss indexing recursive subsets.  One differences atomic recursive objects, recursive objects support recursive subsets, atomic objects .  Bear mind every element recursive object reference another object.  Consider following list x:   Regular subsets, AKA surface-level subset operations ([, [<- base 'R'), operate recursive object .  .e. sb2_x(x, 1), equivalently x[1], returns list list(= 1:10):   Recursive subset operations ([[, [[<-, $ base 'R'), hand, operate object subset recursive object references .  .e. sb2_rec(x, 1), equivalently x[[1]], returns integer vector 1:10:   Recursive objects can refer recursive objects, can refer recursive objects, .  Recursive subsets can go however deep want.  , example, extract character vector month.abb aforementioned list x, one need : sb2_rec(x, c(\"C\",\"B\")), (base R: x$C$B):   LIMITATIONS  Indexing recursive subsets significantly limited regular (\"shallow\") subsets: Recursive subset operations using sb2_rec/sb2_recin support positive integer vectors character vectors. Imaginary numbers (using complex vectors) logical vectors supported. Since recursive subset operation operates single element, specifying index character vector selects first matching element (just like base 'R'), matches. Inverting indices also available recursive indexing. Unlike regular sub-setting, --bounds specification indices acceptable, can used add new values lists.","code":"x <- list(    A = 1:10,    B = letters,    C = list(A = 11:20, B = month.abb) ) sb2_x(x, 1) # equivalent to x[1]; returns list(A = 1:10) #> $A #>  [1]  1  2  3  4  5  6  7  8  9 10 sb2_rec(x, 1) # equivalent to x[[1]]; returns 1:10 #>  [1]  1  2  3  4  5  6  7  8  9 10 sb2_rec(x, c(\"C\",\"B\")) # equivalent to x$C$B #>  [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\"  # or:  sb2_rec(x, c(3, 2)) # equivalent to x[[3]][[2]] #>  [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa02_squarebrackets_indx_fundamentals.html","id":"non-standard-evaluation","dir":"Reference","previous_headings":"","what":"Non-Standard Evaluation","title":"Indexing Fundamentals — aaa02_squarebrackets_indx_fundamentals","text":"'squarebrackets' designed primarily programming, seeks fully programmatically friendly.  part endeavour, 'squarebrackets' never uses Non-Standard Evaluation.  input methods functions 'squarebrackets' objects can stored variable.  Like atomic vectors, lists, formulas, etc.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa03_squarebrackets_indx_args.html","id":null,"dir":"Reference","previous_headings":"","what":"Index Arguments in the Generic Sub-setting Methods — aaa03_squarebrackets_indx_args","title":"Index Arguments in the Generic Sub-setting Methods — aaa03_squarebrackets_indx_args","text":"several types arguments can used generic methods 'squarebrackets' specify indices perform operations : : specify flat (.e. dimensionless) indices. s, d: specify indices arbitrary dimensions dimensional object supported 'squarebrackets' (.e. arrays data.frame-like objects). margin, slice: specify indices one particular dimension (arrays data.frame-like objects).  used idx method. obs, vars: specify observations /variables specifically data.frame-like objects. fundamentals indexing 'squarebrackets', see squarebrackets_indx_fundamentals.  help page x refers object subset operations performed.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa03_squarebrackets_indx_args.html","id":"argument-i","dir":"Reference","previous_headings":"","what":"Argument i","title":"Index Arguments in the Generic Sub-setting Methods — aaa03_squarebrackets_indx_args","text":"following can specified argument : NULL, corresponds missing argument. vector length 0, case indices selected operation (.e. empty selection). numeric vector strictly positive whole numbers giving indices. complex vector, explained squarebrackets_indx_fundamentals. logical vector, length x, giving indices select operation. character vector index names.  object multiple indices given name, corresponding indices selected operation. function takes input x, returns logical vector, giving element indices select operation.  atomic objects, interpreted (x).  recursive objects, interpreted lapply(x, ). Using arguments corresponds something like following:   function, corresponds following:","code":"sb_x(x, i = i) # ==> x[i]   # if `x` is atomic  sb2_x(x, i = i) # ==> x[i]  # if `x` is recursive sb_x(x, i = i) # ==> x[i(x)] # if `x` is atomic  sb2_x(x, i = i) # ==> x[lapply(x, i)] # if `x` is recursive"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa03_squarebrackets_indx_args.html","id":"argument-pair-s-d","dir":"Reference","previous_headings":"","what":"Argument Pair s, d","title":"Index Arguments in the Generic Sub-setting Methods — aaa03_squarebrackets_indx_args","text":"s, d argument pair, inspired abind::asub function 'abind' package, primary indexing argument sub-set operations dimensional objects.  s argument specifies subscripts (.e. dimensional indices).  d argument gives dimensions s holds (.e. d specifies \"non-missing\" margins).  d argument must integer vector. s must list length 1, list length d.  s list length 1, internally recycled become length d.  element s can following: vector length 0, case indices selected operation (.e. empty selection). numeric vector strictly positive whole numbers indices specified dimension select operation. complex vector, explained squarebrackets_indx_fundamentals. logical vector length corresponding dimension size, giving indices specified dimension select operation. character vector giving dimnames select.  dimension multiple indices given name, corresponding indices selected operation. Note following: stated, d specifies index margins non-missing.  d length 0, taken \"index margins missing\". default value d 1:ndim(x). keep syntax short, user can use n function instead list() specify s. EXAMPLES  examples clarity, using atomic array x 3 dimensions: sb_x(x, n(1:10, 1:5), c(1, 3))  extracts first 10 rows, columns, first 5 layers, array x. sb_x(x, n(1:10), 2)  extracts first 10 columns array x. sb_x(x, n(1:10)),  extracts first 10 rows, columns, layers array x. sb_x(x, n(1:10), c(1, 3)),  extracts first 10 rows, columns, first 10 layers, array x. .e.:   NOTE  length(d) 1, s can also given atomic vector (length), instead list length 1.  Although allowed s d atomic vectors length 1, readability code highly recommended s d explicitly named method call, case.  .e.:   brief explanation relationship flat indices () subscripts (s, d) arrays, see sub2ind.","code":"sb_x(x, n(1:10, 1:5), c(1, 3)) # ==> x[1:10, , 1:5, drop = FALSE]  sb_x(x, n(1:10), 2)               # ==> x[ , 1:10, , drop = FALSE]  sb_x(x, n(1:10))                  # ==> x[1:10, 1:10, 1:10, drop = FALSE]  sb_x(x, n(1:10), c(1, 3))         # ==> x[1:10, , 1:10, drop = FALSE] sb_x(x, 1, 1) # BAD: this is not very readable  sb_x(x, s = 1, d = 1) # This is GOOD"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa03_squarebrackets_indx_args.html","id":"argument-pair-margin-slice","dir":"Reference","previous_headings":"","what":"Argument Pair margin, slice","title":"Index Arguments in the Generic Sub-setting Methods — aaa03_squarebrackets_indx_args","text":"Relevant idx method.  margin argument specifies dimension argument slice used.  .e. margin = 1, slice selects rows;  margin = 2, slice selects columns;  etc.  slice argument can following: numeric vector strictly positive whole numbers dimension indices select operation. complex vector, explained squarebrackets_indx_fundamentals. logical vector length corresponding dimension size, giving dimension indices select operation. character vector index names.  dimension multiple indices given name, corresponding indices selected operation. One also give vector length 0 slice;  Argument slice used idx method , result idx meant used inside regular [ [<- operators.  Thus effect zero-length index specification depends rule-set [.class(x) [<-.class(x).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa03_squarebrackets_indx_args.html","id":"arguments-obs-vars","dir":"Reference","previous_headings":"","what":"Arguments obs, vars","title":"Index Arguments in the Generic Sub-setting Methods — aaa03_squarebrackets_indx_args","text":"obs argument specifies indices observations (.e. rows) data.frame-like objects.  vars argument specifies indices variables (.e. columns) data.frame-like objects.  obs  vars arguments inspired subset select arguments, respectively, base R's subset.data.frame method. However, obs  vars arguments use non-standard evaluation, keep 'squarebrackets' fully programmatically friendly. obs Argument  obs argument can following: NULL (default), corresponds missing argument. vector length 0, case indices selected operation (.e. empty selection). numeric vector strictly positive whole numbers row indices select operation. complex vector, explained squarebrackets_indx_fundamentals. logical vector length number rows, giving row indices select operation. one-sided formula, single logical expression using column names data.frame, giving condition observation/row indices selected operation. perform operation observations holds height > 2 sex != \"female\", specify following formula:   formula linked environment, variables found data set searched environment. vars Argument  vars argument can following NULL (default), corresponds missing argument. vector length 0, case indices selected operation (.e. empty selection). numeric vector strictly positive whole numbers column indices select operation. complex vector, explained squarebrackets_indx_fundamentals. logical vector length number columns, giving column indices select operation. character vector giving colnamess select.  Note 'squarebrackets' assumes data.frame-like objects unique column names. function returns logical vector, giving column indices select operation.  example, select numeric variables, specify vars = .numeric. two-sided formula, side consists single term, giving range names select.  example, select variables including variables \"height\" \"weight\", specify following: vars =  heigth ~ weight. EXAMPLE using obs, vars arguments corresponds something like following:","code":"obs = ~ (height > 2) & (sex != \"female\") sb2_x(x, obs = obs, vars = vars) # ==> subset(x, ...obs..., ...vars...)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa03_squarebrackets_indx_args.html","id":"argument-inv","dir":"Reference","previous_headings":"","what":"Argument inv","title":"Index Arguments in the Generic Sub-setting Methods — aaa03_squarebrackets_indx_args","text":"Relevant sb_mod/sb2_mod, sb_set/sb2_set, idx methods.  default, inv = FALSE, translates indices like normally.  inv = TRUE, inverse indices taken.  Consider, example, atomic matrix x;  using sb_mod(x, 1:2, 2L, tf = tf) corresponds something like following:   using sb_mod(x, vars = 1:2, inv = TRUE, tf = tf) corresponds something like following:   NOTE  order user gives indices inv = TRUE generally matter.  order indices appear original object x maintained, just like base 'R'.  Therefore, replacing multiple values order replacement matters, better keep inv = FALSE, default.  replacement single value transformation function, inv = TRUE can used without considering ordering.","code":"x[, 1:2] <- tf(x[, 1:2]) x x[, -1:-2] <- tf(x[, -1:-2]) x"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa03_squarebrackets_indx_args.html","id":"all-missing-indices","dir":"Reference","previous_headings":"","what":"All Missing Indices","title":"Index Arguments in the Generic Sub-setting Methods — aaa03_squarebrackets_indx_args","text":"NULL indexing arguments corresponds missing argument.  s, d, specifying d length 0 also corresponds subscripts missing.  Thus, sb_x/sb2_x sb_wo/sb2_wo, using missing NULL indexing arguments indexing arguments corresponds something like following:   Similarly, sb_mod/sb2_mod sb_set/sb2_set, using missing NULL indexing arguments corresponds something like following:   true even inv = TRUE /red = TRUE.","code":"x[] x[] <- rp # for replacement x[] <- tf(x) # for transformation"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa03_squarebrackets_indx_args.html","id":"disallowed-combinations-of-index-arguments","dir":"Reference","previous_headings":"","what":"Disallowed Combinations of Index Arguments","title":"Index Arguments in the Generic Sub-setting Methods — aaa03_squarebrackets_indx_args","text":"One specify  indexing arguments simultaneously; either , arguments.  One specify row filter simultaneously; either one .  One specify col vars simultaneously; either one .  One specify s, d pair slice, margin pair simultaneously; either one pair pair.  cases holds one set specified, set ignored.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa03_squarebrackets_indx_args.html","id":"drop","dir":"Reference","previous_headings":"","what":"Drop","title":"Index Arguments in the Generic Sub-setting Methods — aaa03_squarebrackets_indx_args","text":"Sub-setting generic methods 'squarebrackets' R-package using dimensional arguments (s, d, row, col filter, vars) always use drop = FALSE.  drop potentially redundant (.e. single level) dimensions, use drop function, like :","code":"sb_x(x, s, d) |> drop() # ==> x[..., drop = TRUE]"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa03_squarebrackets_indx_args.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Index Arguments in the Generic Sub-setting Methods — aaa03_squarebrackets_indx_args","text":"Plate T, Heiberger R (2016). abind: Combine Multidimensional Arrays. R package version 1.4-5, https://CRAN.R-project.org/package=abind.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa04_squarebrackets_modify.html","id":null,"dir":"Reference","previous_headings":"","what":"Regarding Modification — aaa04_squarebrackets_modify","title":"Regarding Modification — aaa04_squarebrackets_modify","text":"help page describes main modification semantics available 'squarebrackets'.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa04_squarebrackets_modify.html","id":"base-r-s-default-modification","dir":"Reference","previous_headings":"","what":"Base R's default modification","title":"Regarding Modification — aaa04_squarebrackets_modify","text":"average users, R's default copy--modify semantics fine.  benefits indexing arguments 'squarebrackets' can combined [<- operator, idx method.  result idx() method can used inside regular square-brackets operators.  example like :   thus allowing user benefit convenient index translations 'squarebrackets', whilst still using R's default copy--modification semantics (instead semantics provided 'squarebrackets').","code":"x <- array(...) my_indices <- idx(x, s, d) x[my_indices] <- value  y <- data.frame(...) rows <- idx(y, 1:10, 1, inv = TRUE) cols <- idx(y, c(\"a\", \"b\"), 2) y[rows, cols] <- value"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa04_squarebrackets_modify.html","id":"explicit-copy","dir":"Reference","previous_headings":"","what":"Explicit Copy","title":"Regarding Modification — aaa04_squarebrackets_modify","text":"'squarebrackets' provides sb_mod/sb2_mod method modify (shallow) copy.  method returns modified object.  recursive objects, sb2_mod returns original object, modified subsets copied, thus preventing unnecessary usage memory.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa04_squarebrackets_modify.html","id":"pass-by-reference","dir":"Reference","previous_headings":"","what":"Pass-by-Reference","title":"Regarding Modification — aaa04_squarebrackets_modify","text":"'squarebrackets' provides sb_set/sb2_set slice_set methods modify reference, meaning copy made .  Pass--Reference fastest memory efficient.  also involved modification forms, requires thought.  See mutatomic_PassByReference information.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa04_squarebrackets_modify.html","id":"replacement-and-transformation-in-atomic-objects","dir":"Reference","previous_headings":"","what":"Replacement and Transformation in Atomic Objects","title":"Regarding Modification — aaa04_squarebrackets_modify","text":"rp argument used replace values specified indices values specified rp. Using rp argument modification methods, corresponds something like following:   tf argument used transform values specified indices transformation function tf. Using tf argument corresponds something like following:   tf function returns object appropriate type size (tf pass--reference function).","code":"x[...] <- rp x[...] <- tf(x[...])"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa04_squarebrackets_modify.html","id":"replacement-and-transformation-in-lists","dir":"Reference","previous_headings":"","what":"Replacement and Transformation in Lists","title":"Regarding Modification — aaa04_squarebrackets_modify","text":"rp tf arguments work mostly way recursive objects.  slight differences. Argument rp  'squarebrackets' demands rp always provided list S3 methods recursive vectors, matrices, arrays (.e. lists).  prevent ambiguity respect replacement recycled distributed specified indices  (See Footnote 1 ). Argument tf  functions (base) 'R' vectorized atomic objects, lists  (see Footnote 2 ).  'squarebrackets' therefore apply transformation function tf via lapply, like :   methods recursive objects, tf argument accompanied .lapply argument.  default, .lapply = lapply.  user may supply custom lapply()-like function argument use instead.  example, perform parallel transformation, user may supply future.apply::future_lapply.  supplied function must use exact argument convention lapply, otherwise errors unexpected behaviour may occur.","code":"x[...] <- lapply(x[...], tf)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa04_squarebrackets_modify.html","id":"replacement-and-transformation-in-data-frame-like-objects","dir":"Reference","previous_headings":"","what":"Replacement and Transformation in data.frame-like Objects","title":"Regarding Modification — aaa04_squarebrackets_modify","text":"Replacement transformations data.frame-like objects bit flexible Lists. rp always demanded list data.frame-like objects, appropriate (example, replacing multiple columns, column list.)  Bear mind every column data.frame like element list;  .lapply used transformations across multiple columns.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa04_squarebrackets_modify.html","id":"recycling-and-coercion","dir":"Reference","previous_headings":"","what":"Recycling and Coercion","title":"Regarding Modification — aaa04_squarebrackets_modify","text":"Recycling allowed modification methods.  , example, length(rp) must equal length selected subset, equal 1.  using Pass--Reference semantics, user extra mindful auto-coercion rules.  See mutatomic_coercion details.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa04_squarebrackets_modify.html","id":"footnotes","dir":"Reference","previous_headings":"","what":"Footnotes","title":"Regarding Modification — aaa04_squarebrackets_modify","text":"Footnote 1  Consider following replacement base 'R':   happen?  x[1] list(1:2) x[2] also list(1:2)?  x[1] list(2) x[2] list(1)?  turns latter happen; somewhat ambiguous code.  prevent ambiguity code, 'squarebrackets' demands rp always provided list. Footnote 2  functions (base) 'R' vectorized atomic objects, lists.  One reasons following:  atomic vector x type t, every single element x scalar type t.  However, every element list x can virtually anything:  atomic object, another list, unevaluated expression, even dark magic like quote(expr =).  difficult make vectorized function object many unknowns.  Therefore, vast majority cases, one needs loop list elements.","code":"x <-list(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) x[1:2] <- 2:1"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa05_squarebrackets_options.html","id":null,"dir":"Reference","previous_headings":"","what":"squarebrackets Options — aaa05_squarebrackets_options","title":"squarebrackets Options — aaa05_squarebrackets_options","text":"help page explains various global options can set 'squarebrackets' package, affects functionality.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa05_squarebrackets_options.html","id":"check-duplicates","dir":"Reference","previous_headings":"","what":"Check Duplicates","title":"squarebrackets Options — aaa05_squarebrackets_options","text":"sb_x/sb2_x methods methods providing duplicate indices actually make sense.  methods, make sense.  Giving duplicate indices usually break anything; however, replacing/transforming removing subsets, almost certainly intention provide duplicate indices.  Providing duplicate indices anyway might lead unexpected results.  Therefore, methods giving duplicate indices make sense, chkdup argument present.  argument controls whether method question checks duplicates (TRUE) (FALSE).  Setting chkdup = TRUE means method question check duplicate indices, give error finds .  Setting chkdup = FALSE disable checks, saves time computation power, thus efficient.  Since checking duplicates can expensive, set FALSE default.  default can changed squarebrackets.chkdup option.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa05_squarebrackets_options.html","id":"sticky","dir":"Reference","previous_headings":"","what":"Sticky","title":"squarebrackets Options — aaa05_squarebrackets_options","text":"slice_x, slice_wo, slicev_x methods can already handle names (use.names argument), attributes specific mutatomic class, attributes specific factor class.  Attributes names, specific mutatomic class, specific factor class - henceforth referred \"attributes\" - treated differently.  slice_x, slice_wo, slicev_x methods handle \"\" attributes, determined sticky option argument.  sticky = FALSE, slice_x, slice_wo, slicev_x methods drop attributes.  setting sticky = TRUE, attributes, except comment tsp, preserved;  key advantage , classes use static attributes (.e. classes use attributes change sub-setting), automatically supported sticky = TRUE, separate methods written slice_x, slice_wo, slicev_x methods.  Attributes specific classes like difftime, Date, POSIXct, roman, hexmode, octmode, , use static attributes.  Instead setting sticky = TRUE sticky = FALSE, one can also specify classes use static attributes using current R session.  fact, 'squarebrackets' loaded, squarebrackets.sticky option set follows:   default setting, sticky = TRUE  \"difftime\", \"Date\", \"POSIXct\", \"roman\", \"hexmode\", \"octmode\".  Also default setting, sticky = FALSE classes.  reason slice_x, slice_wo, slicev_x methods need sticky option, following.  Unlike sb_/sb2_ methods, slice_x, slice_wo, slicev_x methods wrappers around [ [<- operators.  Therefore, [ - S3 methods highly specialized classes readily available slice_x, slice_wo, slicev_x methods.  turn means important class-specific attributes automatically preserved.  sticky option convenient way support large number classes, without write specific methods .  specialized classes use attributes change sub-setting, separate dispatches slice_x, slice_wo, slicev_x methods need written.  Package authors welcome create method dispatches classes methods.","code":"squarebrackets.sticky = c(    \"difftime\", \"Date\", \"POSIXct\", \"roman\", \"hexmode\", \"octmode\" )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa06_squarebrackets_method_dispatch.html","id":null,"dir":"Reference","previous_headings":"","what":"Method Dispatch of 'squarebrackets' — aaa06_squarebrackets_method_dispatch","title":"Method Dispatch of 'squarebrackets' — aaa06_squarebrackets_method_dispatch","text":"help page gives additional details regarding S3 method dispatch used 'squarebrackets'.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa06_squarebrackets_method_dispatch.html","id":"atomic-vs-recursive","dir":"Reference","previous_headings":"","what":"Atomic vs Recursive","title":"Method Dispatch of 'squarebrackets' — aaa06_squarebrackets_method_dispatch","text":"Atomic recursive objects quite different ways: homo- heterogeneous: atomic object can values one data type.  recursive objects can hold values combination data types. nesting: Recursive objects can nested, atomic objects nested. copy coercion effect: One can coerce copy subset recursive object, without copying rest object.  atomic objects, however, coercion copy operation coerces copies entire vector (ignoring attributes). vectorization: vectorized operations generally work atomic objects, whereas recursive objects often require loops apply-like functions. recursive subsets: Recursive objects distinguish \"regular\" subset operations (base R using [, [<-), recursive subset operations (base R using [[, [[<-).  See example sb2_rec method, red = TRUE argument sb2_x sb2_wo methods.  atomic objects, 2 meaningful difference (safe perhaps minor attribute handling). views: recursive objects, one can create view recursive subset.  Subset views exist atomic objects. Despite non-trivial differences, S3 method dispatch distinguish atomic recursive objects.  .e. S3 methods check object , example, array,  atomic array recursive array.  (S3 method dispatch actually distinguish basic atomic recursive vectors, dimensional objects like arrays, problematic specific package).  Therefore, methods 'squarebrackets' perform subset operations object, come atomic (sb_) recursive (sb2_) form.  idx method operates indices object, operate object , distinction atomic recursive form.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa06_squarebrackets_method_dispatch.html","id":"manual-dispatch","dir":"Reference","previous_headings":"","what":"Manual Dispatch","title":"Method Dispatch of 'squarebrackets' — aaa06_squarebrackets_method_dispatch","text":"'squarebrackets' package intentionally exports function S3 method dispatch system.  handy programming purposes.  example: one can explicitly alias specific dispatch method, one desires.  example like :   certain circumstances, might help code clear.","code":"array_x <- function(x, ...) {     if(is.atomic(x)) {      sb_x.array(x, ...)    }    else if(is.recursive(x)) {      sb2_x.array(x, ...)    }  }"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa06_squarebrackets_method_dispatch.html","id":"ellipsis","dir":"Reference","previous_headings":"","what":"Ellipsis","title":"Method Dispatch of 'squarebrackets' — aaa06_squarebrackets_method_dispatch","text":"Due S3 method dispatch system works 'R', generic methods ellipsis argument (...).  user's safety, 'squarebrackets' check user accidentally add arguments make sense method (like specifying inv argument calling sb_x).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa07_squarebrackets_PassByReference.html","id":null,"dir":"Reference","previous_headings":"","what":"Regarding Modification By Reference — aaa07_squarebrackets_PassByReference","title":"Regarding Modification By Reference — aaa07_squarebrackets_PassByReference","text":"help page describes modification using \"pass--reference\" semantics handled 'squarebrackets' package.  help page explain basics pass--reference semantics, treated prior knowledge.  functions/methods 'squarebrackets' package word \"set\" name use pass--reference semantics.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa07_squarebrackets_PassByReference.html","id":"advantages-and-disadvantages","dir":"Reference","previous_headings":"","what":"Advantages and Disadvantages","title":"Regarding Modification By Reference — aaa07_squarebrackets_PassByReference","text":"main advantage pass--reference much less memory required modify objects, modification also generally faster.  several disadvantages.  First, coercion rules slightly different: see squarebrackets_coercion.  Second, 2 variables refer exactly object, changing one variable also changes ones.  .e. following code,   modifies just x, also y.  true even one variables locked (see bindingIsLocked).  .e. following code,   modifies x y without error, even though y locked constant.","code":"x <- y <- mutable_atomic(1:16) sb_set(x, i = 1:6, rp = 8) x <- mutable_atomic(1:16) y <- x lockBinding(\"y\", environment()) sb_set(x, i = 1:6, rp = 8)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa07_squarebrackets_PassByReference.html","id":"mutable-vs-immutable-classes","dir":"Reference","previous_headings":"","what":"Mutable vs Immutable Classes","title":"Regarding Modification By Reference — aaa07_squarebrackets_PassByReference","text":"exception environments, base R's S3 classes treated immutable:  Modifying object 'R' make copy object, something called 'copy--modify' semantics.  prominent mutable S3 class data.table class, mutable data.frame class, supported 'squarebrackets'.  Similarly, 'squarebrackets' adds class mutable atomic objects: mutable_atomic.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa07_squarebrackets_PassByReference.html","id":"material-vs-immaterial-objects","dir":"Reference","previous_headings":"","what":"Material vs Immaterial objects","title":"Regarding Modification By Reference — aaa07_squarebrackets_PassByReference","text":"objects 'R' material objects:  values object contains actually stored memory.  example, given x <- rnorm(1e6), x material object:  1 million values (decimal numbers, case) actually stored memory.  contrast, ActiveBindings immaterial:  objects , accessed, call function generate values fly, rather actually storing values.  Since immaterial objects actually store values memory, values obviously also changed memory.  Therefore, Pass--Reference semantics work immaterial objects.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa07_squarebrackets_PassByReference.html","id":"altrep","dir":"Reference","previous_headings":"","what":"ALTREP","title":"Regarding Modification By Reference — aaa07_squarebrackets_PassByReference","text":"mutable_atomic constructors (.e. mutable_atomic, .mutable_atomic, etc.) automatically materialize ALTREP objects, ensure consistent behaviour 'pass--reference' semantics.  data.table can ALTREP columns.  data.tables coerce column materialized column modified, even reference.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa07_squarebrackets_PassByReference.html","id":"mutability-rules-with-respect-to-recursive-objects","dir":"Reference","previous_headings":"","what":"Mutability Rules With Respect To Recursive Objects","title":"Regarding Modification By Reference — aaa07_squarebrackets_PassByReference","text":"Lists difficult objects contain elements, simply point  objects, one can access via list.  recursive object mutable class, subsets treated mutable, long part object.  hand, recursive object immutable class, recursive subsets retain original mutability. Example 1: Mutable data.tables  data.table mutable class.  columns data.table treated mutable;  requirement , instance, first change columns class mutable_atomic modify columns reference. Example 2: Immutable lists  regular list immutable class.  list immutable, recursive subsets list retain mutability.  list data.table objects, example, data.tables remain mutable.  Therefore, following pass--reference modification work without issue:   Notice code myref address x$, therefore copy x$.  Thus changing myref also changes x$.  words: myref called \"View\" x$.","code":"x <- list(  a = data.table::data.table(cola = 1:10, colb = letters[1:10]),  b = data.table::data.table(cola = 11:20, colb = letters[11:20]) ) myref <- x$a sb2_set(myref, vars = \"cola\", tf = \\(x)x^2)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa07_squarebrackets_PassByReference.html","id":"input-variable","dir":"Reference","previous_headings":"","what":"Input Variable","title":"Regarding Modification By Reference — aaa07_squarebrackets_PassByReference","text":"Methods/functions perform -place modification reference works objects actually exist actual variable, similar functions style some_function(x, ...) <- value.  Thus things like following, sb_set(1:10, ...), sb2_set(x$, ...), sb_set(base::letters),  work.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa07_squarebrackets_PassByReference.html","id":"lock-binding","dir":"Reference","previous_headings":"","what":"Lock Binding","title":"Regarding Modification By Reference — aaa07_squarebrackets_PassByReference","text":"Mutable classes , name suggests, meant mutable.  Locking binding mutable object mostly fruitless (completely; see currentBindings function).  ensure object modified methods/functions 'squarebrackets', 2 things must true: object must immutable class. binding must locked (see lockBinding).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa07_squarebrackets_PassByReference.html","id":"protection","dir":"Reference","previous_headings":"","what":"Protection","title":"Regarding Modification By Reference — aaa07_squarebrackets_PassByReference","text":"Due properties described help page, 'squarebrackets' protects user something like following:   'squarebrackets' give error running code , : addresses baseenv() protected; immutable objects disallowed (create mutable object, create copy original, thus keeping original object safe modification reference); locked bindings disallowed.","code":"# letters = base::letters sb_set(letters, i = 1, rp = \"XXX\")"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa07_squarebrackets_PassByReference.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Regarding Modification By Reference — aaa07_squarebrackets_PassByReference","text":"","code":"# the following code demonstrates how locked bindings, # such as `base::letters`, # are being safe-guarded  x <- list(a = base::letters) myref <- x$a # view of a list address(myref) == address(base::letters) # TRUE: point to the same memory #> [1] TRUE bindingIsLocked(\"letters\", baseenv()) # base::letters is locked ... #> [1] TRUE bindingIsLocked(\"myref\", environment()) # ... but this pointer is not! #> [1] FALSE  if(requireNamespace(\"tinytest\")) {   tinytest::expect_error(     sb_set(myref, i = 1, rp = \"XXX\") # this still gives an error though ...   ) } #> Loading required namespace: tinytest #> ----- PASSED      : <--> #>  call| eval(expr, envir)   is.mutable_atomic(myref) # ... because it's not of class `mutable_atomic` #> [1] FALSE   x <- list(   a = as.mutable_atomic(base::letters) # `as.mutable_atomic()` makes a copy ) myref <- x$a # view of a list address(myref) == address(base::letters) # FALSE: it's a copy #> [1] FALSE sb_set(   myref, i = 1, rp = \"XXX\"  # modifies x, does NOT modify `base::letters` ) print(x) # x is modified #> $a #>  [1] \"XXX\" \"b\"   \"c\"   \"d\"   \"e\"   \"f\"   \"g\"   \"h\"   \"i\"   \"j\"   \"k\"   \"l\"   #> [13] \"m\"   \"n\"   \"o\"   \"p\"   \"q\"   \"r\"   \"s\"   \"t\"   \"u\"   \"v\"   \"w\"   \"x\"   #> [25] \"y\"   \"z\"   #> mutable_atomic  #> typeof:  character  #>  base::letters # but this still the same #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" #> [20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa07_squarebrackets_slicev.html","id":null,"dir":"Reference","previous_headings":"","what":"On Index-Less Value-Based Sub-Set Operations — aaa07_squarebrackets_slicev","title":"On Index-Less Value-Based Sub-Set Operations — aaa07_squarebrackets_slicev","text":"help page explains details arguments used slicev_ methods countv function.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa07_squarebrackets_slicev.html","id":"the-basic-idea","dir":"Reference","previous_headings":"","what":"The Basic Idea","title":"On Index-Less Value-Based Sub-Set Operations — aaa07_squarebrackets_slicev","text":"basic idea follows.  Let x y 2 atomic vectors length (type).  Let v atomic scalar type y.  Given result r condition y == v, basic idea perform following sub-set operations:   default argument specification r = TRUE.  course one can invert relationship specifying argument r = FALSE, get something like following:   y allowed vector x, course.  basic idea, however, can become complicated, depending atomic type y, discussed next section.","code":"slicev_x(x, y = y, v = v)            # ==> x[y == v] slicev_set(x, y = y, v = v, rp = rp) # ==> x[y == v] <- rp slicev_set(x, y = y, v = v, tf = tf) # ==> x[y == v] <- tf(x[y == v]) countv(y,v = v)                      # ==> sum(y == v) slicev_x(x, y = y, v = v, r = FALSE)             # ==> x[y != v] slicev_set(x, y = y, v = v, r = FALSE, rp = rp)  # ==> x[y != v] <- rp slicev_set(x, y = y, v = v, r = FALSE, tf = tf)  # ==> x[y != v] <- tf(x[y != v]) countv(y, v = v, r = FALSE)                  # ==> sum(y != v)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa07_squarebrackets_slicev.html","id":"details-per-atomic-type","dir":"Reference","previous_headings":"","what":"Details per Atomic Type","title":"On Index-Less Value-Based Sub-Set Operations — aaa07_squarebrackets_slicev","text":"Logical, Raw, Complex  y type logical, raw, complex, slicev works exactly explained previous section. y v must atomic type. Numeric  y type integer double (collectively referred \"numeric\"), basic idea laid-still holds:  one can use atomic vector y atomic scalar v perform sub-set operations like x[y == v].  one may interested range numbers, rather one specific number (especially considering things like measurement error, machine precision, greater-/larger-relationships).  numeric y, one can also supply v length 2.  length(v) == 2L, slicev_/ countv check whether y inside (outside r = FALSE) bounded range given v.  .e. :   Note y v must numeric , type.  .e. one can y type integer v type double, without problems. Character  y type character, basic idea still something like x[y == v].  searching string v sub-setting purposes, one may want take consideration things like different spelling, spacing, even encodings string.  Implementing every form fuzzy matching encoding matching computationally intensive, also quite beyond scope package.  Instead, user may supply character vector v arbitrary length, containing variations (terms spelling, spacing, encoding, whatever) strings look .  vector given v (instead single string), following check performed:","code":"y >= v[1] & y <= v[2]  # if r = TRUE y < v[1] | y > v[2]    # if r = FALSE y %in% v   # if r = TRUE !y %in% v  # if r = FALSE"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa07_squarebrackets_slicev.html","id":"factors","dir":"Reference","previous_headings":"","what":"Factors","title":"On Index-Less Value-Based Sub-Set Operations — aaa07_squarebrackets_slicev","text":"Technically, factor type integer, special behaviour extend treated differently 'R'.  similarly treated slicev_/ countv_ methods functions.  y factor, v can given : single string (matching one levels y); single integer (matching one unique values unclass(y)); factor length 1, levels level-ordering y. Note factors NA levels supported, passing factor y result error.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa07_squarebrackets_slicev.html","id":"smaller-than-greater-than","dir":"Reference","previous_headings":"","what":"Smaller Than, Greater Than","title":"On Index-Less Value-Based Sub-Set Operations — aaa07_squarebrackets_slicev","text":"numeric y, one can specify range v, explained earlier.  note one can also specify something like v = c(-Inf, 4), essentially corresponds condition y <= 4.  Thus, v specifies range, \"greater-\" \"smaller-\" comparisons also possible.  also holds y type complex.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa07_squarebrackets_slicev.html","id":"handling-nas-and-nan","dir":"Reference","previous_headings":"","what":"Handling NAs and NaN","title":"On Index-Less Value-Based Sub-Set Operations — aaa07_squarebrackets_slicev","text":"also handle NAs NaNs.  na argument can used specify y NA.  na = FALSE, NA values y always ignored.  extracted (slicev_x), replaced (slicev_set), counted (countv).  na = TRUE, NA values y always included.  included extractions (slicev_x), replacements (slicev_set), counts (countv).  One can also specify na = NA, ignore v completely, explicitly look NAs/NaNs y instead - like :   Handling NAs works atomic types.  y type complex, value y[] considered NA Re(y[]) NA/NaN /Im(y[]) NA/NaN.  Argument v never allowed contain NA/NaN.","code":"slicev_x(x, y = y, na = NA)                        # ==> x[is.na(y)] slicev_x(x, y = y, na = NA, r = FALSE)             # ==> x[!is.na(y)] slicev_set(x, y = y, na = NA, rp = rp)             # ==> x[is.na(y)] <- rp slicev_set(x, y = y, na = NA, r = FALSE, rp = rp)  # ==> x[!is.na(y)] <- rp slicev_set(x, y = y, na = NA, tf = tf)             # ==> x[is.na(y)] <- tf(x[is.na(y)]) slicev_set(x, y = y, na = NA, r = FALSE, tf = tf)  # ==> x[!is.na(y)] <- tf(x[!is.na(y)]) countv(y, na = NA)                                 # ==> sum(is.na(y)) countv(y, na = NA, r = FALSE)                      # ==> sum(!is.na(y))"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa07_squarebrackets_slicev.html","id":"from-to","dir":"Reference","previous_headings":"","what":"From, To","title":"On Index-Less Value-Based Sub-Set Operations — aaa07_squarebrackets_slicev","text":"Like slice methods, one can specify range within perform sub-set operations, using , arguments.  example, wish extract values x holds y != v, want extractions index 10 100, one can specify following: slicev_x(x, y = y, v = v, r = FALSE, = 10, = 100.  Just like slice, ,argument can also used reverse order result, specifying higher value .  step-size slicev/countv functions always 1L ( -1L > ).  Also like slice, , can imaginary numbers also, explained cp_seq.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa07_squarebrackets_slicev.html","id":"inverting","dir":"Reference","previous_headings":"","what":"Inverting","title":"On Index-Less Value-Based Sub-Set Operations — aaa07_squarebrackets_slicev","text":"countv() slicev_set() \"invert\" argument, likewise slicev_wo() function.  One can invert sub-set condition, specifying r = FALSE.  r = FALSE inverts condition; invert range specified , .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa07_squarebrackets_slicev.html","id":"ellipsis","dir":"Reference","previous_headings":"","what":"Ellipsis","title":"On Index-Less Value-Based Sub-Set Operations — aaa07_squarebrackets_slicev","text":"ellipsis (...) intentionally placed right first argument (x slicev_ y countv) force user explicitly name arguments, avoid lot unnecessary confusion.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa07_squarebrackets_slicev.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"On Index-Less Value-Based Sub-Set Operations — aaa07_squarebrackets_slicev","text":"","code":"# basic idea ==== nms <- c(letters, LETTERS, month.abb, month.name) |> rep_len(1e6) x <- mutatomic::mutatomic(1:1e6, names = nms) head(x) #> a b c d e f  #> 1 2 3 4 5 6  #> mutatomic  #> typeof:  integer   # memory efficient form of sum(x <= 10): countv(x, v = c(-Inf, 10)) #> [1] 10  # extract all elements of x with the name \"a\": slicev_x(x, y = names(x), v = \"a\") |> head() #>   a   a   a   a   a   a  #>   1  77 153 229 305 381  #> mutatomic  #> typeof:  integer   # find all x smaller than or equal to 5, and replace with `-1000`: slicev_set(x, y = x, v = c(-Inf, 5), rp = -1000L) head(x, n = 10) #>     a     b     c     d     e     f     g     h     i     j  #> -1000 -1000 -1000 -1000 -1000     6     7     8     9    10  #> mutatomic  #> typeof:  integer    ################################################################################ # Numeric range ==== # x <- mutatomic::mutatomic(1:1e6) head(x) #> [1] 1 2 3 4 5 6 #> mutatomic  #> typeof:  integer  slicev_x(x, v= c(-Inf, 5)) # x[x <= 5] #> [1] 1 2 3 4 5 #> mutatomic  #> typeof:  integer    ################################################################################ # Character ==== # x <- stringi::stri_rand_shuffle(rep(\"hello\", 1e5)) head(x) #> [1] \"holle\" \"hlleo\" \"loehl\" \"hlleo\" \"leloh\" \"elohl\" slicev_x(x, v = \"hello\") |> head() # find \"hello\" #> [1] \"hello\" \"hello\" \"hello\" \"hello\" \"hello\" \"hello\"  # find 2 possible misspellings of \"hello\": slicev_x(x, v = c(\"holle\", \"helol\")) |> head() #> [1] \"holle\" \"helol\" \"holle\" \"holle\" \"helol\" \"helol\""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa08_squarebrackets_coercion.html","id":null,"dir":"Reference","previous_headings":"","what":"Auto-Coercion Rules for Mutable Objects — aaa08_squarebrackets_coercion","title":"Auto-Coercion Rules for Mutable Objects — aaa08_squarebrackets_coercion","text":"help page describes auto-coercion rules mutable classes, handled 'squarebrackets' package.  useful information users wish intend employ Pass--Reference semantics provided 'squarebrackets'.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa08_squarebrackets_coercion.html","id":"mutable-atomic","dir":"Reference","previous_headings":"","what":"mutable_atomic","title":"Auto-Coercion Rules for Mutable Objects — aaa08_squarebrackets_coercion","text":"Mutable atomic objects automatically coerced fit modified subset values, modifying copy, just like regular atomic classes.  example, replacing one multiple values integer vector (type int) decimal number (type dbl) coerce entire vector type dbl.  Replacing transforming subsets mutable atomic objects reference support coercion. Thus, example, following code,   gives c(rep(8, 6) 7:16) instead c(rep(8.5, 6), 7:16), x type integer, rp interpreted type integer also.","code":"x <- mutable_atomic(1:16) sb_set(x, i = 1:6, rp = 8.5) #> coercing replacement to integer print(x) #>  [1]  8  8  8  8  8  8  7  8  9 10 11 12 13 14 15 16 #> mutable_atomic #> typeof:  integer"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa08_squarebrackets_coercion.html","id":"data-table-when-replacing-transforming-whole-columns","dir":"Reference","previous_headings":"","what":"data.table, when replacing/transforming whole columns","title":"Auto-Coercion Rules for Mutable Objects — aaa08_squarebrackets_coercion","text":"data.table actually list made mutable, column list. , replacing/transforming whole columns, without specifying rows (even 1:nrow(x)), allows completely changing type column.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa08_squarebrackets_coercion.html","id":"data-table-when-partially-replacing-transforming-columns","dir":"Reference","previous_headings":"","what":"data.table, when partially replacing/transforming columns","title":"Auto-Coercion Rules for Mutable Objects — aaa08_squarebrackets_coercion","text":"rows specified sb2_set method, thus whole columns parts columns replaced transformed, auto-coercion takes place.  .e.: replacing/transforming value integer (int) column become 1.5, coerce column decimal type (dbl); instead, replacement value 1.5 coerced integer 1.  sb2_mod method, however, allows coercion just like regular data.frame objects.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa08_squarebrackets_coercion.html","id":"views-of-lists","dir":"Reference","previous_headings":"","what":"Views of Lists","title":"Auto-Coercion Rules for Mutable Objects — aaa08_squarebrackets_coercion","text":"Regular lists treated immutable 'squarebrackets'.  remember list (potentially hierarchical) structure references objects.  Thus, even list treated mutable, subsets list mutable classes, mutable.  example, list data.table objects, data.tables mutable.  Therefore, following work:   Notice code myref copy x$, since address.  Thus changing myref also changes x$.  words: myref called \"view\" x$.  Notice also sb2_set(x$, ...) work, since sb_set/sb2_set requires actual variables, similar -place functions style `myfun()<-`.  auto-coercion rules Views Lists, depends entirely object .  Thus View data.table, coercion rules data.tables apply.  View mutable_atomic matrix, coercion rules mutable_atomic matrices apply, etc.","code":"x <- list(  a = data.table::data.table(cola = 1:10, colb = letters[1:10]),  b = data.table::data.table(cola = 11:20, colb = letters[11:20]) ) myref <- x$a sb2_set(myref, vars = \"cola\", tf = \\(x)x^2)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa08_squarebrackets_coercion.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Auto-Coercion Rules for Mutable Objects — aaa08_squarebrackets_coercion","text":"","code":"# Coercion examples - mutable_atomic ====  x <- as.mutable_atomic(1:16) sb_set(x, i = 1:6, rp = 8.5) # 8.5 coerced to 8, because `x` is of type `integer` #> coercing replacement to integer print(x) #>  [1]  8  8  8  8  8  8  7  8  9 10 11 12 13 14 15 16 #> mutable_atomic  #> typeof:  integer   #############################################################################  # Coercion examples - data.table - whole columns ====  # sb_mod(): obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb2_mod(   obj, vars = is.numeric,   tf = sqrt # SAFE: row=NULL & obs = NULL, so coercion performed ) #>            a      b        c      d #>        <num> <char>    <num> <fctr> #>  1: 1.000000      a 3.316625      a #>  2: 1.414214      b 3.464102      b #>  3: 1.732051      c 3.605551      c #>  4: 2.000000      d 3.741657      d #>  5: 2.236068      e 3.872983      e #>  6: 2.449490      f 4.000000      f #>  7: 2.645751      g 4.123106      g #>  8: 2.828427      h 4.242641      h #>  9: 3.000000      i 4.358899      i #> 10: 3.162278      j 4.472136      j  # sb_set(): sb2_set(   obj, vars = is.numeric,   tf = sqrt # SAFE: row=NULL & obs = NULL, so coercion performed ) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 1.41 1.73 2 2.24 ... #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  3.32 3.46 3.61 3.74 3.87 ... #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>   #############################################################################   # Coercion examples - data.table - partial columns ====  # sb_mod(): obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>   sb2_mod(   obj, obs = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # SAFE: coercion performed ) #>             a      b         c      d #>         <num> <char>     <num> <fctr> #>  1:  1.000000      a 11.000000      a #>  2:  1.414214      b  3.464102      b #>  3:  1.732051      c  3.605551      c #>  4:  2.000000      d  3.741657      d #>  5:  2.236068      e  3.872983      e #>  6:  2.449490      f  4.000000      f #>  7:  2.645751      g  4.123106      g #>  8:  8.000000      h 18.000000      h #>  9:  9.000000      i 19.000000      i #> 10: 10.000000      j 20.000000      j  # sb_set(): obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb2_set(   obj, obs = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt   # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost ) #> Warning: 1.414214 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 1 named 'a') #> Warning: 3.464102 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 3 named 'c') print(obj) #>         a      b     c      d #>     <int> <char> <int> <fctr> #>  1:     1      a    11      a #>  2:     1      b     3      b #>  3:     1      c     3      c #>  4:     2      d     3      d #>  5:     2      e     3      e #>  6:     2      f     4      f #>  7:     2      g     4      g #>  8:     8      h    18      h #>  9:     9      i    19      i #> 10:    10      j    20      j  obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  dt_setcoe(obj, vars = is.numeric, v = as.numeric) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb2_set(obj,   obs = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # SAFE: coercion performed by dt_setcoe(); so no warnings )  print(obj) #>             a      b         c      d #>         <num> <char>     <num> <fctr> #>  1:  1.000000      a 11.000000      a #>  2:  1.414214      b  3.464102      b #>  3:  1.732051      c  3.605551      c #>  4:  2.000000      d  3.741657      d #>  5:  2.236068      e  3.872983      e #>  6:  2.449490      f  4.000000      f #>  7:  2.645751      g  4.123106      g #>  8:  8.000000      h 18.000000      h #>  9:  9.000000      i 19.000000      i #> 10: 10.000000      j 20.000000      j   #############################################################################  # View of List ====  x <- list(  a = data.table::data.table(cola = 1:10, colb = letters[1:10]),  b = data.table::data.table(cola = 11:20, colb = letters[11:20]) ) print(x) #> $a #>      cola   colb #>     <int> <char> #>  1:     1      a #>  2:     2      b #>  3:     3      c #>  4:     4      d #>  5:     5      e #>  6:     6      f #>  7:     7      g #>  8:     8      h #>  9:     9      i #> 10:    10      j #>  #> $b #>      cola   colb #>     <int> <char> #>  1:    11      k #>  2:    12      l #>  3:    13      m #>  4:    14      n #>  5:    15      o #>  6:    16      p #>  7:    17      q #>  8:    18      r #>  9:    19      s #> 10:    20      t #>  myref <- x$a address(myref) == address(x$a) # they are the same #> [1] TRUE sb2_set(myref, vars = \"cola\", tf = \\(x)x^2) print(x) # notice x has been changed #> $a #>      cola   colb #>     <num> <char> #>  1:     1      a #>  2:     4      b #>  3:     9      c #>  4:    16      d #>  5:    25      e #>  6:    36      f #>  7:    49      g #>  8:    64      h #>  9:    81      i #> 10:   100      j #>  #> $b #>      cola   colb #>     <int> <char> #>  1:    11      k #>  2:    12      l #>  3:    13      m #>  4:    14      n #>  5:    15      o #>  6:    16      p #>  7:    17      q #>  8:    18      r #>  9:    19      s #> 10:    20      t #>"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa09_squarebrackets_slicev.html","id":null,"dir":"Reference","previous_headings":"","what":"On Index-Less Value-Based Sub-Set Operations — aaa09_squarebrackets_slicev","title":"On Index-Less Value-Based Sub-Set Operations — aaa09_squarebrackets_slicev","text":"help page explains details arguments used slicev_ methods countv function.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa09_squarebrackets_slicev.html","id":"the-basic-idea","dir":"Reference","previous_headings":"","what":"The Basic Idea","title":"On Index-Less Value-Based Sub-Set Operations — aaa09_squarebrackets_slicev","text":"basic idea follows.  Let x y 2 atomic vectors length (type).  Let v atomic scalar type y.  Given result r condition y == v, basic idea perform following sub-set operations:   default argument specification r = TRUE.  course one can invert relationship specifying argument r = FALSE, get something like following:   y allowed vector x, course.  basic idea, however, can become complicated, depending atomic type y, discussed next section.","code":"slicev_x(x, y = y, v = v)            # ==> x[y == v] slicev_set(x, y = y, v = v, rp = rp) # ==> x[y == v] <- rp slicev_set(x, y = y, v = v, tf = tf) # ==> x[y == v] <- tf(x[y == v]) countv(y,v = v)                      # ==> sum(y == v) slicev_x(x, y = y, v = v, r = FALSE)             # ==> x[y != v] slicev_set(x, y = y, v = v, r = FALSE, rp = rp)  # ==> x[y != v] <- rp slicev_set(x, y = y, v = v, r = FALSE, tf = tf)  # ==> x[y != v] <- tf(x[y != v]) countv(y, v = v, r = FALSE)                  # ==> sum(y != v)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa09_squarebrackets_slicev.html","id":"details-per-atomic-type","dir":"Reference","previous_headings":"","what":"Details per Atomic Type","title":"On Index-Less Value-Based Sub-Set Operations — aaa09_squarebrackets_slicev","text":"Logical, Raw, Complex  y type logical, raw, complex, slicev works exactly explained previous section. y v must atomic type. Numeric  y type integer double (collectively referred \"numeric\"), basic idea laid-still holds:  one can use atomic vector y atomic scalar v perform sub-set operations like x[y == v].  one may interested range numbers, rather one specific number (especially considering things like measurement error, machine precision, greater-/larger-relationships).  numeric y, one can also supply v length 2.  length(v) == 2L, slicev_/ countv check whether y inside (outside r = FALSE) bounded range given v.  .e. :   Note y v must numeric , type.  .e. one can y type integer v type double, without problems. Character  y type character, basic idea still something like x[y == v].  searching string v sub-setting purposes, one may want take consideration things like different spelling, spacing, even encodings string.  Implementing every form fuzzy matching encoding matching computationally intensive, also quite beyond scope package.  Instead, user may supply character vector v arbitrary length, containing variations (terms spelling, spacing, encoding, whatever) strings look .  vector given v (instead single string), following check performed:","code":"y >= v[1] & y <= v[2]  # if r = TRUE y < v[1] | y > v[2]    # if r = FALSE y %in% v   # if r = TRUE !y %in% v  # if r = FALSE"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa09_squarebrackets_slicev.html","id":"factors","dir":"Reference","previous_headings":"","what":"Factors","title":"On Index-Less Value-Based Sub-Set Operations — aaa09_squarebrackets_slicev","text":"Technically, factor type integer, special behaviour extend treated differently 'R'.  similarly treated slicev_/ countv_ methods functions.  y factor, v can given : single string (matching one levels y); single integer (matching one unique values unclass(y)); factor length 1, levels level-ordering y. Note factors NA levels supported, passing factor y result error.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa09_squarebrackets_slicev.html","id":"smaller-than-greater-than","dir":"Reference","previous_headings":"","what":"Smaller Than, Greater Than","title":"On Index-Less Value-Based Sub-Set Operations — aaa09_squarebrackets_slicev","text":"numeric y, one can specify range v, explained earlier.  note one can also specify something like v = c(-Inf, 4), essentially corresponds condition y <= 4.  Thus, v specifies range, \"greater-\" \"smaller-\" comparisons also possible.  also holds y type complex.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa09_squarebrackets_slicev.html","id":"handling-nas-and-nan","dir":"Reference","previous_headings":"","what":"Handling NAs and NaN","title":"On Index-Less Value-Based Sub-Set Operations — aaa09_squarebrackets_slicev","text":"also handle NAs NaNs.  na argument can used specify y NA.  na = FALSE, NA values y always ignored.  extracted (slicev_x), replaced (slicev_set), counted (countv).  na = TRUE, NA values y always included.  included extractions (slicev_x), replacements (slicev_set), counts (countv).  One can also specify na = NA, ignore v completely, explicitly look NAs/NaNs y instead - like :   Handling NAs works atomic types.  y type complex, value y[] considered NA Re(y[]) NA/NaN /Im(y[]) NA/NaN.  Argument v never allowed contain NA/NaN.","code":"slicev_x(x, y = y, na = NA)                        # ==> x[is.na(y)] slicev_x(x, y = y, na = NA, r = FALSE)             # ==> x[!is.na(y)] slicev_set(x, y = y, na = NA, rp = rp)             # ==> x[is.na(y)] <- rp slicev_set(x, y = y, na = NA, r = FALSE, rp = rp)  # ==> x[!is.na(y)] <- rp slicev_set(x, y = y, na = NA, tf = tf)             # ==> x[is.na(y)] <- tf(x[is.na(y)]) slicev_set(x, y = y, na = NA, r = FALSE, tf = tf)  # ==> x[!is.na(y)] <- tf(x[!is.na(y)]) countv(y, na = NA)                                 # ==> sum(is.na(y)) countv(y, na = NA, r = FALSE)                      # ==> sum(!is.na(y))"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa09_squarebrackets_slicev.html","id":"from-to","dir":"Reference","previous_headings":"","what":"From, To","title":"On Index-Less Value-Based Sub-Set Operations — aaa09_squarebrackets_slicev","text":"Like slice methods, one can specify range within perform sub-set operations, using , arguments.  example, wish extract values x holds y != v, want extractions index 10 100, one can specify following: slicev_x(x, y = y, v = v, r = FALSE, = 10, = 100.  Just like slice, ,argument can also used reverse order result, specifying higher value .  step-size slicev/countv functions always 1L ( -1L > ).  Also like slice, , can imaginary numbers also, explained cp_seq.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa09_squarebrackets_slicev.html","id":"inverting","dir":"Reference","previous_headings":"","what":"Inverting","title":"On Index-Less Value-Based Sub-Set Operations — aaa09_squarebrackets_slicev","text":"countv() slicev_set() \"invert\" argument, likewise slicev_wo() function.  One can invert sub-set condition, specifying r = FALSE.  r = FALSE inverts condition; invert range specified , .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa09_squarebrackets_slicev.html","id":"ellipsis","dir":"Reference","previous_headings":"","what":"Ellipsis","title":"On Index-Less Value-Based Sub-Set Operations — aaa09_squarebrackets_slicev","text":"ellipsis (...) intentionally placed right first argument (x slicev_ y countv) force user explicitly name arguments, avoid lot unnecessary confusion.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa09_squarebrackets_slicev.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"On Index-Less Value-Based Sub-Set Operations — aaa09_squarebrackets_slicev","text":"","code":"# basic idea ==== nms <- c(letters, LETTERS, month.abb, month.name) |> rep_len(1e6) x <- mutable_atomic(1:1e6, names = nms) head(x) #> a b c d e f  #> 1 2 3 4 5 6  #> mutable_atomic  #> typeof:  integer   # memory efficient form of sum(x <= 10): countv(x, v = c(-Inf, 10)) #> [1] 10  # extract all elements of x with the name \"a\": slicev_x(x, y = names(x), v = \"a\") |> head() #>   a   a   a   a   a   a  #>   1  77 153 229 305 381  #> mutable_atomic  #> typeof:  integer   # find all x smaller than or equal to 5, and replace with `-1000`: slicev_set(x, y = x, v = c(-Inf, 5), rp = -1000L) head(x, n = 10) #>     a     b     c     d     e     f     g     h     i     j  #> -1000 -1000 -1000 -1000 -1000     6     7     8     9    10  #> mutable_atomic  #> typeof:  integer    ################################################################################ # Numeric range ==== # x <- mutable_atomic(1:1e6) head(x) #> [1] 1 2 3 4 5 6 #> mutable_atomic  #> typeof:  integer  slicev_x(x, v= c(-Inf, 5)) # x[x <= 5] #> [1] 1 2 3 4 5 #> mutable_atomic  #> typeof:  integer    ################################################################################ # Character ==== # x <- stringi::stri_rand_shuffle(rep(\"hello\", 1e5)) head(x) #> [1] \"holle\" \"hlleo\" \"loehl\" \"hlleo\" \"leloh\" \"elohl\" slicev_x(x, v = \"hello\") |> head() # find \"hello\" #> [1] \"hello\" \"hello\" \"hello\" \"hello\" \"hello\" \"hello\"  # find 2 possible misspellings of \"hello\": slicev_x(x, v = c(\"holle\", \"helol\")) |> head() #> [1] \"holle\" \"helol\" \"holle\" \"holle\" \"helol\" \"helol\""},{"path":"https://tony-aw.github.io/squarebrackets/reference/bind.html","id":null,"dir":"Reference","previous_headings":"","what":"Dimensional Binding of Objects — bind","title":"Dimensional Binding of Objects — bind","text":"bind_implementations provide dimensional binding functionalities.  possible, bind_ functions return mutable classes.  following implementations available: bind_mat() binds dimensionless (atomic/recursive) vectors (atomic/recursive) matrices row- column-wise.  result atomic, returns mutable_atomic matrix; otherwise returns recursive matrix. bind_array() binds (atomic/recursive) arrays (atomic/recursive) matrices.  result atomic, returns mutable_atomic array; otherwise returns recursive array. bind_dt() binds data.tables data.frame-like objects.  Returns data.table.  Faster .call(cbind, ...) .call(rbind, ...) regular data.frame objects. Note naming convention binding implementations \"bind_\" followed resulting class (abbreviated).  .e. bind_mat returns matrix, can bind matrices vectors.  bind_array returns array, can bind arrays matrices.  bind_dt returns data.table, can bind data.tables, also data.frame-like objects.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/bind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dimensional Binding of Objects — bind","text":"","code":"bind_mat(arg.list, along, name_deparse = TRUE, comnames_from = 1L)  bind_array(   arg.list,   along,   name_along = TRUE,   comnames_from = 1L,   name_flat = FALSE )  bind_dt(arg.list, along, ...)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/bind.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dimensional Binding of Objects — bind","text":"arg.list list appropriate objects.  arg.list named, names used names dimension along output, far possible. along single integer, indicating dimension along bind dimensions.  .e. use along = 1 row-binding, along = 2 column-binding, etc.  arrays, additional flexibility available: Specifying along = 0 bind arrays new dimension first, making along new first dimension. Specifying along = n+1, n last available dimension, create additional dimension (n+1) bind arrays along new dimension. name_deparse Boolean, bind_mat().  Indicates dimension along named.  Uses naming method rbind/cbind . comnames_from either integer scalar NULL, bind_mat()  bind_array().  Indicates object arg.list used naming shared dimension.  NULL, communal names given.  example:  binding columns matrices, matrices share rownames.  Using comnames_from = 10 result bind_array() using rownames(arg.list[[10]]) rownames output. name_along Boolean, bind_array().  Indicates dimension along named. name_flat Boolean, bind_array().  Indicates flat indices named.  Note setting TRUE reduce performance considerably. ... arguments passed rbindlist.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/bind.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dimensional Binding of Objects — bind","text":"bound object.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/bind.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Dimensional Binding of Objects — bind","text":"bind_array() modified version fantastic abind::abind function Tony Plare & Richard Heiberger (2016), following ways: bind_array() primarily differs abind::abind can handle recursive arrays properly  (original abind::abind function unlist everything atomic arrays, ruining structure). unlike abind::abind, bind_array() binds (atomic/recursive) arrays matrices. bind_array()attempt convert things arrays arrays, give error instead.  saves computation time prevents unexpected results. bind_array() results atomic array, mutable_atomic array. bind_array() streamlined naming options. bind_mat() modified version rbind/cbind.  primary differences bind_mat() gives error fractional recycling attempted (like binding  1:3 1:10).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/bind.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Dimensional Binding of Objects — bind","text":"Plate T, Heiberger R (2016). abind: Combine Multidimensional Arrays. R package version 1.4-5, https://CRAN.R-project.org/package=abind.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/bind.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dimensional Binding of Objects — bind","text":"","code":"# bind_array ====  # here, atomic and recursive matrices are mixed, # resulting in a recursive matrix  # creating the arrays x <- c(   lapply(1:3, \\(x)sample(c(TRUE, FALSE, NA))),   lapply(1:3, \\(x)sample(1:10)),   lapply(1:3, \\(x)rnorm(10)),   lapply(1:3, \\(x)sample(letters)) ) x <- matrix(x, 4, 3, byrow = TRUE) dimnames(x) <- n(letters[1:4], LETTERS[1:3]) print(x) #>   A            B            C            #> a logical,3    logical,3    logical,3    #> b integer,10   integer,10   integer,10   #> c numeric,10   numeric,10   numeric,10   #> d character,26 character,26 character,26  y <- matrix(1:12, 4, 3) print(y) #>      [,1] [,2] [,3] #> [1,]    1    5    9 #> [2,]    2    6   10 #> [3,]    3    7   11 #> [4,]    4    8   12  # binding the arrays arg.list <- list(x = x, y = y) bind_array(arg.list, along = 0L) # binds on new dimension before first #> , , A #>  #>   a         b          c          d            #> x logical,3 integer,10 numeric,10 character,26 #> y 1         2          3          4            #>  #> , , B #>  #>   a         b          c          d            #> x logical,3 integer,10 numeric,10 character,26 #> y 5         6          7          8            #>  #> , , C #>  #>   a         b          c          d            #> x logical,3 integer,10 numeric,10 character,26 #> y 9         10         11         12           #>  bind_array(arg.list, along = 1L) # binds on first dimension #>     A            B            C            #> a   logical,3    logical,3    logical,3    #> b   integer,10   integer,10   integer,10   #> c   numeric,10   numeric,10   numeric,10   #> d   character,26 character,26 character,26 #> y.1 1            5            9            #> y.2 2            6            10           #> y.3 3            7            11           #> y.4 4            8            12           bind_array(arg.list, along = 2L) #>   A            B            C            y.1 y.2 y.3 #> a logical,3    logical,3    logical,3    1   5   9   #> b integer,10   integer,10   integer,10   2   6   10  #> c numeric,10   numeric,10   numeric,10   3   7   11  #> d character,26 character,26 character,26 4   8   12  bind_array(arg.list, along = 3L) # bind on new dimension after last #> , , x #>  #>   A            B            C            #> a logical,3    logical,3    logical,3    #> b integer,10   integer,10   integer,10   #> c numeric,10   numeric,10   numeric,10   #> d character,26 character,26 character,26 #>  #> , , y #>  #>   A B C  #> a 1 5 9  #> b 2 6 10 #> c 3 7 11 #> d 4 8 12 #>     ################################################################################  # bind_mat ====  # here, atomic and recursive matrices are mixed, # resulting in a recursive matrix  x <- c(   lapply(1:3, \\(x)sample(c(TRUE, FALSE, NA))),   lapply(1:3, \\(x)sample(1:10)),   lapply(1:3, \\(x)rnorm(10)),   lapply(1:3, \\(x)sample(letters)) ) x <- matrix(x, 4, 3, byrow = TRUE) dimnames(x) <- n(letters[1:4], LETTERS[1:3]) print(x) #>   A            B            C            #> a logical,3    logical,3    logical,3    #> b integer,10   integer,10   integer,10   #> c numeric,10   numeric,10   numeric,10   #> d character,26 character,26 character,26  y <- matrix(1:12, 4, 3) print(y) #>      [,1] [,2] [,3] #> [1,]    1    5    9 #> [2,]    2    6   10 #> [3,]    3    7   11 #> [4,]    4    8   12  bind_mat(n(x = x, y = y), 2L) #>   A            B            C                   #> a logical,3    logical,3    logical,3    1 5 9  #> b integer,10   integer,10   integer,10   2 6 10 #> c numeric,10   numeric,10   numeric,10   3 7 11 #> d character,26 character,26 character,26 4 8 12    ################################################################################  # bind_dt ====   x <- data.frame(a = 1:12, b = month.abb) # data.frame y <- data.table::data.table(a = 1:12, b = month.abb) # data.table  bind_dt(n(x = x, y = y), 2L) # column bind #>       x.a    x.b   y.a    y.b #>     <int> <char> <int> <char> #>  1:     1    Jan     1    Jan #>  2:     2    Feb     2    Feb #>  3:     3    Mar     3    Mar #>  4:     4    Apr     4    Apr #>  5:     5    May     5    May #>  6:     6    Jun     6    Jun #>  7:     7    Jul     7    Jul #>  8:     8    Aug     8    Aug #>  9:     9    Sep     9    Sep #> 10:    10    Oct    10    Oct #> 11:    11    Nov    11    Nov #> 12:    12    Dec    12    Dec  bind_dt(n(x = x, y = y), 1L) # row bind #>         a      b #>     <int> <char> #>  1:     1    Jan #>  2:     2    Feb #>  3:     3    Mar #>  4:     4    Apr #>  5:     5    May #>  6:     6    Jun #>  7:     7    Jul #>  8:     8    Aug #>  9:     9    Sep #> 10:    10    Oct #> 11:    11    Nov #> 12:    12    Dec #> 13:     1    Jan #> 14:     2    Feb #> 15:     3    Mar #> 16:     4    Apr #> 17:     5    May #> 18:     6    Jun #> 19:     7    Jul #> 20:     8    Aug #> 21:     9    Sep #> 22:    10    Oct #> 23:    11    Nov #> 24:    12    Dec #>         a      b"},{"path":"https://tony-aw.github.io/squarebrackets/reference/class_mutable_atomic.html","id":null,"dir":"Reference","previous_headings":"","what":"Mutable Atomic Classes — class_mutable_atomic","title":"Mutable Atomic Classes — class_mutable_atomic","text":"mutable_atomic class mutable version atomic classes.  works exactly aspects regular atomic classes, one real difference:  'squarebrackets' methods functions perform modification reference (basically methods functions \"set\" name) accept mutable_atomic, accept regular atomic.  See squarebrackets_PassByReference details.  Like data.table, [<- performs R's default copy--modification semantics.  modification  reference, use sb_set.  Exposed functions (beside S3 methods): mutable_atomic(): create mutable_atomic object given data. couldb.mutable_atomic(): checks object become mutable_atomic.  objects can become mutable_atomic one following types: logical, integer, double, character, complex, raw.  Factors can never mutable_atomic. typecast.mutable_atomic() type-casts possibly reshapes (mutable) atomic object, returns mutable_atomic object.  preserve dimension names dimensions changed.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/class_mutable_atomic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mutable Atomic Classes — class_mutable_atomic","text":"","code":"mutable_atomic(data, names = NULL, dim = NULL, dimnames = NULL)  as.mutable_atomic(x, ...)  # Default S3 method as.mutable_atomic(x, ...)  is.mutable_atomic(x)  couldb.mutable_atomic(x)  typecast.mutable_atomic(x, type = typeof(x), dims = dim(x))  # S3 method for class 'mutable_atomic' c(..., use.names = TRUE)  # S3 method for class 'mutable_atomic' x[...]  # S3 method for class 'mutable_atomic' x[...] <- value  # S3 method for class 'mutable_atomic' format(x, ...)  # S3 method for class 'mutable_atomic' print(x, ...)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/class_mutable_atomic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mutable Atomic Classes — class_mutable_atomic","text":"data atomic vector giving data fill mutable_atomic object. names, dim, dimnames see setNames array. x atomic object. ... method dependent arguments. type string giving type; see typeof. dims integer vector, giving new dimensions. use.names Boolean, indicating names preserved. value see Extract.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/class_mutable_atomic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mutable Atomic Classes — class_mutable_atomic","text":"mutable_atomic(), .mutable_atomic(), typecast.mutable_atomic():  Returns mutable_atomic object.  .mutable_atomic():  Returns TRUE object mutable_atomic, returns FALSE otherwise.  couldb.mutable_atomic():  Returns TRUE object one following types: logical, integer, double, character, complex, raw.  Returns FALSE otherwise.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/class_mutable_atomic.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"Mutable Atomic Classes — class_mutable_atomic","text":"Always use exported functions given 'squarebrackets' create mutable_atomic object, make necessary checks.  Circumventing checks may break things!","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/class_mutable_atomic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mutable Atomic Classes — class_mutable_atomic","text":"","code":"x <- mutable_atomic(   1:20, dim = c(5, 4), dimnames = list(letters[1:5], letters[1:4]) ) x #>   a  b  c  d #> a 1  6 11 16 #> b 2  7 12 17 #> c 3  8 13 18 #> d 4  9 14 19 #> e 5 10 15 20 #> mutable_atomic  #> typeof:  integer  typecast.mutable_atomic(x, \"character\") #>      [,1] [,2] [,3] [,4] #> [1,] \"1\"  \"6\"  \"11\" \"16\" #> [2,] \"2\"  \"7\"  \"12\" \"17\" #> [3,] \"3\"  \"8\"  \"13\" \"18\" #> [4,] \"4\"  \"9\"  \"14\" \"19\" #> [5,] \"5\"  \"10\" \"15\" \"20\" #> mutable_atomic  #> typeof:  character   x <- matrix(1:10, ncol = 2) x <- as.mutable_atomic(x) is.mutable_atomic(x) #> [1] TRUE print(x) #>      [,1] [,2] #> [1,]    1    6 #> [2,]    2    7 #> [3,]    3    8 #> [4,]    4    9 #> [5,]    5   10 #> mutable_atomic  #> typeof:  integer  x[, 1] #> [1] 1 2 3 4 5 #> mutable_atomic  #> typeof:  integer  x[] <- as.double(x) #> coercing type from `integer` to `double` print(x) #>      [,1] [,2] #> [1,]    1    6 #> [2,]    2    7 #> [3,]    3    8 #> [4,]    4    9 #> [5,]    5   10 #> mutable_atomic  #> typeof:  double  is.mutable_atomic(x) #> [1] TRUE"},{"path":"https://tony-aw.github.io/squarebrackets/reference/cp_seq.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct Parameters for a Sequence Based on Margins — cp_seq","title":"Construct Parameters for a Sequence Based on Margins — cp_seq","text":"cp_seq() returns list parameters construct sequence based margins object.  internally used idx_r function slice method.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/cp_seq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct Parameters for a Sequence Based on Margins — cp_seq","text":"","code":"cp_seq(x, m = 0L, from = NULL, to = NULL, by = 1L)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/cp_seq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct Parameters for a Sequence Based on Margins — cp_seq","text":"x object compute margin-based sequence parameters. m integer complex, giving margin(s).  non-dimensional objects flat indices, specify m = 0L. integer complex, length m length 1, specifying point. integer complex, length m length 1, specifying maximally allowed end value. integer, length m length 1, specifying step size.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/cp_seq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct Parameters for a Sequence Based on Margins — cp_seq","text":"list following elements: $start:  actual starting point sequence.  simply translated regular numeric. $end:  actual ending point sequence.  .  example, following code:   specifies = 10L.  sequence actually end 10; ends 9.  Therefore, cp_seq(x, m, 1, 10, 2) return end = 9, end = 10.  allows user easily predict sequence given idx_r/slice actually end. $:  give , sign adjusted, needed. $length.:  actual vector lengths sequences , given translated parameters.","code":"seq(from = 1L, to = 10L, by = 2L) #> [1] 1 3 5 7 9"},{"path":"https://tony-aw.github.io/squarebrackets/reference/cp_seq.html","id":"arguments-details","dir":"Reference","previous_headings":"","what":"Arguments Details","title":"Construct Parameters for a Sequence Based on Margins — cp_seq","text":"Multiple dimensions  cp_seq function can construct sequence parameters needed multiple dimensions , specifying vector m.  lengths arguments recycled needed. Using  , specified, using construct following sequence:  positive, seq.int(1L, n, ).  negative, seq.int(n, 1L, ).  n maximum index (.e. length(x) dim(x)[m], depending situation). Using , ,  , , specified, stored abs(), sign  automatically adjusted ensure sensible sequence created.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/cp_seq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct Parameters for a Sequence Based on Margins — cp_seq","text":"","code":"x <- data.frame(   a = 1:10, b = letters[1:10], c = factor(letters[1:10]), d = -1:-10 ) print(x) #>     a b c   d #> 1   1 a a  -1 #> 2   2 b b  -2 #> 3   3 c c  -3 #> 4   4 d d  -4 #> 5   5 e e  -5 #> 6   6 f f  -6 #> 7   7 g g  -7 #> 8   8 h h  -8 #> 9   9 i i  -9 #> 10 10 j j -10 ind1 <- idx_r(x, 1, 2, 2* -1i) # rows 2:(nrow(x)-1) sb2_x(x, ind1, 1L) # extract the row range #>   a b c  d #> 1 2 b b -2 #> 2 3 c c -3 #> 3 4 d d -4 #> 4 5 e e -5 #> 5 6 f f -6 #> 6 7 g g -7 #> 7 8 h h -8 #> 8 9 i i -9  x <- array(1:125, c(5,5,5)) d <- 1:3 s <- idx_r(x, d, 2, 2* -1i) # 2:(n-1) for every dimension sb_x(x, s = s, d = d) # same as x[ 2:4, 2:4, 2:4, drop = FALSE] #> , , 1 #>  #>      [,1] [,2] [,3] #> [1,]   32   37   42 #> [2,]   33   38   43 #> [3,]   34   39   44 #>  #> , , 2 #>  #>      [,1] [,2] [,3] #> [1,]   57   62   67 #> [2,]   58   63   68 #> [3,]   59   64   69 #>  #> , , 3 #>  #>      [,1] [,2] [,3] #> [1,]   82   87   92 #> [2,]   83   88   93 #> [3,]   84   89   94 #>   x <- letters x[idx_r(x, 0, 2, 2* -1i)] #>  [1] \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" \"t\" #> [20] \"u\" \"v\" \"w\" \"x\" \"y\""},{"path":"https://tony-aw.github.io/squarebrackets/reference/currentBindings.html","id":null,"dir":"Reference","previous_headings":"","what":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","text":"currentBindings(x, action = \"list\")  lists currently existing objects sharing address x, given environment. currentBindings(x, action = \"checklock\")  searches currently existing objects sharing address x, given environment, reports locked locked. currentBindings(x, action = \"lockbindings\")  searches currently existing objects sharing address x, given environment, locks using lockBinding.  See also squarebrackets_PassByReference information regarding relation locked bindings pass--reference modifications.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/currentBindings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","text":"","code":"currentBindings(x, action = \"list\", env = NULL)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/currentBindings.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","text":"x existing variable whose address use searching bindings. action single string, giving action perform.  Must one following: \"list\" (default). \"checklock\". \"lockbindings\". env environment look objects.  NULL (default), caller environment used.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/currentBindings.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","text":"currentBindings(x, action = \"list\"):  Returns character vector.  currentBindings(x, action = \"checklock\"):  Returns named logical vector.  names give names bindings,  associated value indicates whether binding locked (TRUE) locked (FALSE).  currentBindings(x, action = \"lockbindings\"):  Returns VOID. just locks currently existing bindings.  unlock bindings, remove objects (see rm).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/currentBindings.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","text":"lockBinding function locks binding object, preventing modification.  'R' also uses locked bindings prevent modification objects package namespaces.  pass--reference semantics 'squarebrackets' principle respect , disallows modification objects reference.  However, lockBinding lock address/pointer object, one particular binding object.  problematic; consider following example:   code, x y share address, thus pointing memory, yet y actually locked.  Since x locked, modifying x allowed.  since sb_set()/sb2_set() performs modification reference, y still modified, despite locked.  currentBindings() function allows user : find currently existing bindings caller environment sharing address x, locking bindings.","code":"x <- mutable_atomic(1:16) y <- x lockBinding(\"y\", environment()) sb_set(x, i = 1:6, rp = 8)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/currentBindings.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","text":"currentBindings() function locks currently existing bindings specified environment;  bindings created calling currentBindings() automatically locked.  Thus, every time user creates new binding object, user wishes locked, currentBindings() must called .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/currentBindings.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","text":"","code":"x <- as.mutable_atomic(1:10) y <- x lockBinding(\"y\", environment()) currentBindings(x) #> searching environment: <0000023bc2c06298> #> [1] \"x\" \"y\" currentBindings(x, \"checklock\") # only y is locked #> searching environment: <0000023bc2c06298> #>     x     y  #> FALSE  TRUE    # since only y is locked, we can still modify y through x by reference: sb_set(x, i = 1, rp = -1) #> coercing replacement to integer print(y) # modified! #>  [1] -1  2  3  4  5  6  7  8  9 10 #> mutable_atomic  #> typeof:  integer  rm(list= c(\"y\")) # clean up   # one can fix this by locking ALL bindings: y <- x currentBindings(x, \"lockbindings\") # lock all #> searching environment: <0000023bc2c06298> currentBindings(x, \"checklock\") # all bindings are locked, including y #> searching environment: <0000023bc2c06298> #>    x    y  #> TRUE TRUE  # the 'squarebrackets' package respects the lock of a binding, # provided all bindings of an address are locked; # so this will give an error, as it should:  if(requireNamespace(\"tinytest\")) {   tinytest::expect_error(     sb_set(x, i = 1, rp = -1),     pattern = \"object is locked\"   ) } #> ----- PASSED      : <--> #>  call| eval(expr, envir)   # creating a new variable will NOT automatically be locked: z <- y # new variable; will not be locked! currentBindings(x, \"checklock\") # z is not locked #> searching environment: <0000023bc2c06298> #>     x     y     z  #>  TRUE  TRUE FALSE  currentBindings(x, \"lockbindings\") # we must re-run this #> searching environment: <0000023bc2c06298> currentBindings(x, \"checklock\") # now z is also locked #> searching environment: <0000023bc2c06298> #>    x    y    z  #> TRUE TRUE TRUE   if(requireNamespace(\"tinytest\")) {   tinytest::expect_error( # now z is also protected     sb_set(z, i = 1, rp = -1),     pattern = \"object is locked\"   ) } #> ----- PASSED      : <--> #>  call| eval(expr, envir)    rm(list= c(\"x\", \"y\", \"z\")) # clean up"},{"path":"https://tony-aw.github.io/squarebrackets/reference/developer_ci.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct Indices — developer_ci","title":"Construct Indices — developer_ci","text":"functions construct flat dimensional indices. ci_flat() constructs integer vector flat indices. ci_margin() constructs integer vector indices one particular dimension margin. ci_sub() constructs list integer subscripts. ci_df() ci_margin(), except specifically designed data.frame-like objects.  separate function, things like dimnames(x)[1] rownames(x) always return output certain data.frame-like objects. ci_obs() ci_vars() construct row column indices, respectively, data.frame-like objects.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/developer_ci.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct Indices — developer_ci","text":"","code":"ci_flat(   x,   i,   inv = FALSE,   chkdup = FALSE,   uniquely_named = FALSE,   .abortcall = sys.call() )  ci_margin(   x,   slice,   margin,   inv = FALSE,   chkdup = FALSE,   uniquely_named = FALSE,   .abortcall = sys.call() )  ci_sub(   x,   s,   d,   inv = FALSE,   chkdup = FALSE,   uniquely_named = FALSE,   .abortcall = sys.call() )  ci_df(   x,   slice,   margin,   inv = FALSE,   chkdup = FALSE,   uniquely_named = TRUE,   .abortcall = sys.call() )  ci_obs(   x,   obs,   inv = FALSE,   chkdup = FALSE,   uniquely_named = TRUE,   .abortcall = sys.call() )  ci_vars(   x,   vars,   inv = FALSE,   chkdup = FALSE,   uniquely_named = TRUE,   .abortcall = sys.call() )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/developer_ci.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct Indices — developer_ci","text":"x object indices meant. , s, d, slice, margin, obs, vars, inv See squarebrackets_indx_args. chkdup see squarebrackets_options. uniquely_named Boolean, indicating user knows -priori relevant names x unique.  set TRUE, speed may increase.  specifying TRUE relevant names unique result incorrect output. .abortcall environment error message passed .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/developer_ci.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct Indices — developer_ci","text":"integer vector constructed indices.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/developer_ci.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct Indices — developer_ci","text":"","code":"x <- matrix(1:25, 5, 5) colnames(x) <- c(\"a\", \"a\", \"b\", \"c\", \"d\") print(x) #>      a  a  b  c  d #> [1,] 1  6 11 16 21 #> [2,] 2  7 12 17 22 #> [3,] 3  8 13 18 23 #> [4,] 4  9 14 19 24 #> [5,] 5 10 15 20 25  bool <- sample(c(TRUE, FALSE), 5, TRUE) int <- 1:4 chr <- c(\"a\", \"a\") cplx <- 1:4 * -1i tci_bool(bool, nrow(x)) #> [1] 2 tci_int(int, ncol(x), inv = TRUE) #> [1] 5 tci_chr(chr, colnames(x)) #> [1] 1 2 1 2 tci_cplx(cplx, nrow(x)) #> [1] 5 4 3 2  ci_flat(x, 1:10 * -1i) #>  [1] 25 24 23 22 21 20 19 18 17 16 ci_margin(x, 1:4, 2) #> [1] 1 2 3 4 ci_sub(x, n(1:5 * -1i, 1:4), 1:2) #> [[1]] #> [1] 5 4 3 2 1 #>  #> [[2]] #> [1] 1 2 3 4 #>"},{"path":"https://tony-aw.github.io/squarebrackets/reference/developer_tci.html","id":null,"dir":"Reference","previous_headings":"","what":"Type Cast Indices — developer_tci","title":"Type Cast Indices — developer_tci","text":"functions typecast indices proper integer indices.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/developer_tci.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Type Cast Indices — developer_tci","text":"","code":"tci_bool(indx, n, inv = FALSE, .abortcall = sys.call())  tci_int(indx, n, inv = FALSE, chkdup = FALSE, .abortcall = sys.call())  tci_chr(   indx,   nms,   inv = FALSE,   chkdup = FALSE,   uniquely_named = FALSE,   .abortcall = sys.call() )  tci_cplx(indx, n, inv = FALSE, chkdup = FALSE, .abortcall = sys.call())"},{"path":"https://tony-aw.github.io/squarebrackets/reference/developer_tci.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Type Cast Indices — developer_tci","text":"indx indices typecast n relevant size, typecasting integer logical indices.  Examples: target row indices, input nrow n. target flat indices, input length n. inv Boolean, indicating indices inverted.  See squarebrackets_indx_args. .abortcall environment error message passed . chkdup see squarebrackets_options. nms relevant names, typecasting character indices.  Examples: target row indices, input row names nms. target flat indices, input flat names nms. uniquely_named Boolean, indicating user knows -priori relevant names x unique.  set TRUE, speed may increase.  specifying TRUE relevant names unique result incorrect output.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/developer_tci.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Type Cast Indices — developer_tci","text":"integer vector type-cast indices.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/developer_tci.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Type Cast Indices — developer_tci","text":"","code":"x <- matrix(1:25, 5, 5) colnames(x) <- c(\"a\", \"a\", \"b\", \"c\", \"d\") print(x) #>      a  a  b  c  d #> [1,] 1  6 11 16 21 #> [2,] 2  7 12 17 22 #> [3,] 3  8 13 18 23 #> [4,] 4  9 14 19 24 #> [5,] 5 10 15 20 25  bool <- sample(c(TRUE, FALSE), 5, TRUE) int <- 1:4 chr <- c(\"a\", \"a\") cplx <- 1:4 * -1i tci_bool(bool, nrow(x)) #> [1] 1 2 3 4 5 tci_int(int, ncol(x), inv = TRUE) #> [1] 5 tci_chr(chr, colnames(x)) #> [1] 1 2 1 2 tci_cplx(cplx, nrow(x)) #> [1] 5 4 3 2  ci_flat(x, 1:10 * -1i) #>  [1] 25 24 23 22 21 20 19 18 17 16 ci_margin(x, 1:4, 2) #> [1] 1 2 3 4 ci_sub(x, n(1:5 * -1i, 1:4), 1:2) #> [[1]] #> [1] 5 4 3 2 1 #>  #> [[2]] #> [1] 1 2 3 4 #>"},{"path":"https://tony-aw.github.io/squarebrackets/reference/dt.html","id":null,"dir":"Reference","previous_headings":"","what":"Functional Forms of data.table Operations — dt","title":"Functional Forms of data.table Operations — dt","text":"Functional forms special data.table operations.  functions use Non-Standard Evaluation.  functions also benefit security measures 'squarebrackets' implements pass--reference semantics. dt_aggregate() aggregates data.table tidytable, returns aggregated copy. dt_setcoe() coercively transforms columns data.table tidytable using pass--reference semantics. dt_setrm() removes columns data.table tidytable using pass--reference semantics. dt_setadd(x, new) adds columns data.table/tidytable new data.table/tidytable x, thereby modifying x using pass--reference semantics. dt_setreorder() reorders rows /variables data.table using pass--reference semantics.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/dt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functional Forms of data.table Operations — dt","text":"","code":"dt_aggregate(x, SDcols = NULL, f, by, order_by = FALSE)  dt_setcoe(   x,   vars = NULL,   inv = FALSE,   v,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  dt_setrm(   x,   vars = NULL,   inv = FALSE,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  dt_setadd(x, new)  dt_setreorder(x, roworder = NULL, varorder = NULL)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/dt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functional Forms of data.table Operations — dt","text":"x data.table tidytable. SDcols atomic vector, giving columns aggregation function f() applied . f aggregation function atomic vector, giving grouping columns. order_by Boolean, indicating aggregated result ordered columns specified . vars, inv see squarebrackets_indx_args.  Duplicates allowed. v coercive transformation function chkdup see squarebrackets_options. new data.frame-like object.  must column names already exist x. roworder integer vector length nrow(x), giving order rows re-order. Internally, numeric vector turned order using order, thus ensuring strict permutation 1:nrow(x). varorder integer character vector length ncol(x), giving new column order.  See data.table::setcolorder.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/dt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functional Forms of data.table Operations — dt","text":"dt_aggregate():  aggregated data.table object.  rest functions:  Returns: VOID. functions modify object reference.  use assignments like x <- dt_setcoe(x, ...).  Since functions return void, just get NULL.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/dt.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Functional Forms of data.table Operations — dt","text":"dt_setreorder(x, roworder = roworder) internally creates new column reorder data.table , removes new column.  column name randomized, extra care given ensure overwrite existing columns.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/dt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functional Forms of data.table Operations — dt","text":"","code":"# dt_aggregate on sf-data.table ====  if(requireNamespace(\"sf\")) {   x <- sf::st_read(system.file(\"shape/nc.shp\", package = \"sf\"))   x <- data.table::as.data.table(x)      x$region <- ifelse(x$CNTY_ID <= 2000, 'high', 'low')   d.aggr <- dt_aggregate(     x, SDcols = \"geometry\", f= sf::st_union, by = \"region\"   )      head(d.aggr) } #> Loading required namespace: sf #> Reading layer `nc' from data source `D:\\Programs\\R-4.4.0\\library\\sf\\shape\\nc.shp' using driver `ESRI Shapefile' #> Simple feature collection with 100 features and 14 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 #> Geodetic CRS:  NAD27 #>    region                       geometry #>    <char>             <sfc_MULTIPOLYGON> #> 1:   high MULTIPOLYGON (((-75.78317 3... #> 2:    low MULTIPOLYGON (((-76.46926 3...    #############################################################################   # dt_setcoe ====  obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb2_set(   obj, obs = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost ) #> Warning: 1.414214 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 1 named 'a') #> Warning: 3.464102 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 3 named 'c') str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 1 1 2 2 2 2 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 3 3 3 3 4 4 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) dt_setcoe(obj, vars = is.numeric, v = as.numeric) # integers are now numeric str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb2_set(obj,   obs = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # SAFE: coercion performed; so no warnings )  str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 1.41 1.73 2 2.24 ... #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  11 3.46 3.61 3.74 3.87 ... #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>    #############################################################################   # dt_setrm ====  obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  dt_setrm(obj, vars = 1) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  3 variables: #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>   obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  dt_setrm(obj, vars = is.numeric) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  2 variables: #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>    #############################################################################   # dt_setadd ====  obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) new <- data.table::data.table(   e = sample(c(TRUE, FALSE), 10, TRUE),   f = sample(c(TRUE, FALSE), 10, TRUE) ) dt_setadd(obj, new) print(obj) #>         a      b     c      d      e      f #>     <int> <char> <int> <fctr> <lgcl> <lgcl> #>  1:     1      a    11      a   TRUE   TRUE #>  2:     2      b    12      b  FALSE   TRUE #>  3:     3      c    13      c   TRUE   TRUE #>  4:     4      d    14      d  FALSE  FALSE #>  5:     5      e    15      e   TRUE  FALSE #>  6:     6      f    16      f   TRUE  FALSE #>  7:     7      g    17      g  FALSE  FALSE #>  8:     8      h    18      h   TRUE  FALSE #>  9:     9      i    19      i  FALSE  FALSE #> 10:    10      j    20      j  FALSE  FALSE    #############################################################################   # dt_setreorder====  n <- 1e4 obj <- data.table::data.table(   a = 1L:n, b = n:1L, c = as.double(1:n), d = as.double(n:1) ) dt_setreorder(obj, roworder = n:1) head(obj) #>        a     b     c     d #>    <int> <int> <num> <num> #> 1: 10000     1 10000     1 #> 2:  9999     2  9999     2 #> 3:  9998     3  9998     3 #> 4:  9997     4  9997     4 #> 5:  9996     5  9996     5 #> 6:  9995     6  9995     6 dt_setreorder(obj, varorder = ncol(obj):1) head(obj) #>        d     c     b     a #>    <num> <num> <int> <int> #> 1:     1 10000     1 10000 #> 2:     2  9999     2  9999 #> 3:     3  9998     3  9998 #> 4:     4  9997     4  9997 #> 5:     5  9996     5  9996 #> 6:     6  9995     6  9995"},{"path":"https://tony-aw.github.io/squarebrackets/reference/exported_uilities.html","id":null,"dir":"Reference","previous_headings":"","what":"Exported Utilities — indx_x","title":"Exported Utilities — indx_x","text":"Exported utilities.  Usually user need functions.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/exported_uilities.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exported Utilities — indx_x","text":"","code":"indx_x(i, x, xnames, xsize)  indx_wo(i, x, xnames, xsize)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/exported_uilities.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exported Utilities — indx_x","text":"See squarebrackets_indx_args. x vector, vector-like object, factor, data.frame, data.frame-like object, list. xnames names dimension names xsize length dimension size","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/exported_uilities.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exported Utilities — indx_x","text":"subsetted object.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/exported_uilities.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Exported Utilities — indx_x","text":"","code":"x <- 1:10 names(x) <- letters[1:10] indx_x(1:5, x, names(x), length(x)) #> [1] 1 2 3 4 5 indx_wo(1:5, x, names(x), length(x)) #> [1]  6  7  8  9 10"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx1.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert/Translate Indices (for Copy-On-Modify Substitution) — idx","title":"Convert/Translate Indices (for Copy-On-Modify Substitution) — idx","text":"idx() method converts indices.  type output depends type input index arguments given: idx(x, = , ...) converts linear indices strictly positive integer vector linear indices. idx(x, s = s, d = d, ...) converts dimensional indices strictly positive integer vector linear indices. idx(x, slice = slice, margin = margin, ...) converts indices one dimension strictly positive integer vector indices specific dimension. Vectors (atomic recursive) index argument .  Data.frame-like objects slice, margin argument pair.  Arrays (atomic recursive) s, d argument pair, well argument slice, margin argument pair.  result idx() method can used inside regular square-brackets operators.  example like :   thus allowing user benefit convenient index translations 'squarebrackets', whilst still using R's default copy--modification semantics (instead semantics provided 'squarebrackets').","code":"x <- array(...) my_sub2ind <- idx(x, s, d) x[my_sub2ind] <- value  y <- data.frame(...) rows <- idx(y, 1:10, 1, inv = TRUE) cols <- idx(y, c(\"a\", \"b\"), 2) y[rows, cols] <- value"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert/Translate Indices (for Copy-On-Modify Substitution) — idx","text":"","code":"idx(x, ...)  # Default S3 method idx(x, i, inv = FALSE, ..., chkdup = getOption(\"squarebrackets.chkdup\", FALSE))  # S3 method for class 'array' idx(   x,   s = NULL,   d = 1:ndim(x),   slice = NULL,   margin = NULL,   i = NULL,   inv = FALSE,   ...,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # S3 method for class 'data.frame' idx(   x,   slice,   margin,   inv = FALSE,   ...,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx1.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert/Translate Indices (for Copy-On-Modify Substitution) — idx","text":"x vector, matrix, array, data.frame; atomic recursive objects supported. ... see squarebrackets_method_dispatch. , s, d, margin, slice, inv See squarebrackets_indx_args.  Duplicates allowed. chkdup see squarebrackets_options.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx1.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert/Translate Indices (for Copy-On-Modify Substitution) — idx","text":"idx(x, = , ...) idx(x, s = s, d = d, ...):  strictly positive integer vector flat indices.  idx(x, margin = margin, slice = slice, ...):  strictly positive integer vector indices dimension specified margin.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx1.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert/Translate Indices (for Copy-On-Modify Substitution) — idx","text":"","code":"# atomic ====  x <- 1:10 x[idx(x, \\(x)x>5)] <- -5 print(x) #>  [1]  1  2  3  4  5 -5 -5 -5 -5 -5  x <- array(1:27, dim = c(3,3,3)) x[idx(x, n(1:2, 1:2), c(1,3))] <- -10 print(x) #> , , 1 #>  #>      [,1] [,2] [,3] #> [1,]  -10  -10  -10 #> [2,]  -10  -10  -10 #> [3,]    3    6    9 #>  #> , , 2 #>  #>      [,1] [,2] [,3] #> [1,]  -10  -10  -10 #> [2,]  -10  -10  -10 #> [3,]   12   15   18 #>  #> , , 3 #>  #>      [,1] [,2] [,3] #> [1,]   19   22   25 #> [2,]   20   23   26 #> [3,]   21   24   27 #>    ################################################################################   # recursive ====  x <- as.list(1:10) x[idx(x, \\(x)x>5)] <- -5 print(x) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 3 #>  #> [[4]] #> [1] 4 #>  #> [[5]] #> [1] 5 #>  #> [[6]] #> [1] -5 #>  #> [[7]] #> [1] -5 #>  #> [[8]] #> [1] -5 #>  #> [[9]] #> [1] -5 #>  #> [[10]] #> [1] -5 #>   x <- array(as.list(1:27), dim = c(3,3,3)) x[idx(x, n(1:2, 1:2), c(1,3))] <- -10 print(x) #> , , 1 #>  #>      [,1] [,2] [,3] #> [1,] -10  -10  -10  #> [2,] -10  -10  -10  #> [3,] 3    6    9    #>  #> , , 2 #>  #>      [,1] [,2] [,3] #> [1,] -10  -10  -10  #> [2,] -10  -10  -10  #> [3,] 12   15   18   #>  #> , , 3 #>  #>      [,1] [,2] [,3] #> [1,] 19   22   25   #> [2,] 20   23   26   #> [3,] 21   24   27   #>    x <- data.frame(   a = sample(c(TRUE, FALSE, NA), 10, TRUE),   b = 1:10,   c = rnorm(10),   d = letters[1:10],   e = factor(letters[11:20]) ) rows <- idx(x, 1:5, 1, inv = TRUE) cols <- idx(x, c(\"b\", \"a\"), 2) x[rows, cols] <- NA print(x) #>        a  b           c d e #> 1   TRUE  1 -0.24301788 a k #> 2  FALSE  2  0.09305645 b l #> 3  FALSE  3  0.04682464 c m #> 4  FALSE  4 -1.16805345 d n #> 5   TRUE  5  0.03247200 e o #> 6     NA NA -0.67331493 f p #> 7     NA NA -1.64588928 g q #> 8     NA NA -0.13946087 h r #> 9     NA NA -0.36253040 i s #> 10    NA NA  2.13264138 j t"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_by.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Grouped Indices — idx_by","title":"Compute Grouped Indices — idx_by","text":"Given: sub-set function f; object x margin m; grouping factor grp; idx_by() function takes indices per group grp.  result idx_by() can supplied indexing arguments (see squarebrackets_indx_args) perform grouped subset operations.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_by.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Grouped Indices — idx_by","text":"","code":"idx_by(x, m, f, grp, parallel = FALSE, mc.cores = 1L)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_by.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Grouped Indices — idx_by","text":"x object compute indices. m single non-negative integer giving margin compute indices.  flat indices non-dimensional objects, use m = 0L. f subset function applied per group indices.  m == 0L, indices defined setNames(1:length(x), names(x)).  m > 0L, indices defined setNames(1:dim(x)[m], dimnames(x)[[m]]).  function must produce character integer vector output.  example, subset last element per group, specify: f = last grp factor giving groups. parallel, mc.cores see .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_by.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Grouped Indices — idx_by","text":"vector indices.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_by.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Grouped Indices — idx_by","text":"","code":"# vectors ==== (a <- 1:20) #>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 (grp <- factor(rep(letters[1:5], each = 4))) #>  [1] a a a a b b b b c c c c d d d d e e e e #> Levels: a b c d e  # get the last element of `a` for each group in `grp`: s <- list(idx_by(a, 0L, last, grp)) sb_x(cbind(a, grp), s, 1L) #>       a grp #> [1,]  4   1 #> [2,]  8   2 #> [3,] 12   3 #> [4,] 16   4 #> [5,] 20   5   # data.frame ==== x <- data.frame(   a = sample(1:20),   b = letters[1:20],   group = factor(rep(letters[1:5], each = 4)) ) print(x) #>     a b group #> 1  19 a     a #> 2  18 b     a #> 3  14 c     a #> 4   1 d     a #> 5   5 e     b #> 6   6 f     b #> 7   8 g     b #> 8   9 h     b #> 9  10 i     c #> 10 12 j     c #> 11 16 k     c #> 12  7 l     c #> 13 11 m     d #> 14 17 n     d #> 15  3 o     d #> 16 20 p     d #> 17  2 q     e #> 18 13 r     e #> 19  4 s     e #> 20 15 t     e # get the first row for each group in data.frame `x`: row <- idx_by(x, 1, first, x$group) sb2_x(x, row, 1L) #>    a b group #> 1 19 a     a #> 2  5 e     b #> 3 10 i     c #> 4 11 m     d #> 5  2 q     e # get the first row for each group for which a > 10: x2 <- sb2_x(x, obs = ~ a > 10) row <- na.omit(idx_by(x2, 1, first, x2$group)) sb2_x(x2, row, 1L) #>    a b group #> 1 19 a     a #> 2 12 j     c #> 3 11 m     d #> 4 13 r     e"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_ord.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Ordered Indices — idx_ord_v","title":"Compute Ordered Indices — idx_ord_v","text":"Computes ordered indices. Similar order, except user must supply vector, list equal-length vectors, data.frame matrix (row-wise column-wise supported), input.  vector x, idx_ord_v(x) equivalent order(x).  data.frame list equal-length vectors x, p columns/elements, idx_ord_df(x) equivalent order(x[[1]], ..., x[[p]]).  matrix (array) x p rows, idx_ord_m(x, margin = 1) equivalent order(x[1, ], ..., x[p, ], ...).  matrix (array) x p columns, idx_ord_m(x, margin = 2) equivalent order(x[, 1], ..., x[, p], ...).  Note merely convenience functions, actually slightly slower order (except idx_ord_v()), due additional functionality.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_ord.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Ordered Indices — idx_ord_v","text":"","code":"idx_ord_v(   x,   na.last = TRUE,   decr = FALSE,   method = c(\"auto\", \"shell\", \"radix\") )  idx_ord_m(   x,   margin,   na.last = TRUE,   decr = FALSE,   method = c(\"auto\", \"shell\", \"radix\") )  idx_ord_df(   x,   na.last = TRUE,   decr = FALSE,   method = c(\"auto\", \"shell\", \"radix\") )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_ord.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Ordered Indices — idx_ord_v","text":"x vector, data.frame, array na.last, method see order sort. decr see argument decreasing order margin margin cut matrix/array vectors.  .e. margin = 1L cut x individual rows, apply order rows.  margin = 2L cut x columns, etc.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_ord.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Ordered Indices — idx_ord_v","text":"See order.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_ord.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Ordered Indices — idx_ord_v","text":"","code":"x <- sample(1:10) order(x) #>  [1]  7  6  1  2 10  9  5  8  4  3 idx_ord_v(x) #>  [1]  7  6  1  2 10  9  5  8  4  3 idx_ord_m(rbind(x, x), 1) #>  [1]  7  6  1  2 10  9  5  8  4  3 idx_ord_m(cbind(x, x), 2) #>  [1]  7  6  1  2 10  9  5  8  4  3 idx_ord_df(data.frame(x, x)) #>  [1]  7  6  1  2 10  9  5  8  4  3"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_r.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Integer Index Range — idx_r","title":"Compute Integer Index Range — idx_r","text":"idx_r() computes integer index range(s).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_r.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Integer Index Range — idx_r","text":"","code":"idx_r(x, m = 0L, from = NULL, to = NULL, by = 1L)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_r.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Integer Index Range — idx_r","text":"x object compute subset indices. m, , , see cp_seq.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_r.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Integer Index Range — idx_r","text":"length(m) == 1L: vector numeric indices.  length(m) > 1L: list length m, containing numeric vectors indices.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_r.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Integer Index Range — idx_r","text":"","code":"x <- data.frame(   a = 1:10, b = letters[1:10], c = factor(letters[1:10]), d = -1:-10 ) print(x) #>     a b c   d #> 1   1 a a  -1 #> 2   2 b b  -2 #> 3   3 c c  -3 #> 4   4 d d  -4 #> 5   5 e e  -5 #> 6   6 f f  -6 #> 7   7 g g  -7 #> 8   8 h h  -8 #> 9   9 i i  -9 #> 10 10 j j -10 ind1 <- idx_r(x, 1, 2, 2* -1i) # rows 2:(nrow(x)-1) sb2_x(x, ind1, 1L) # extract the row range #>   a b c  d #> 1 2 b b -2 #> 2 3 c c -3 #> 3 4 d d -4 #> 4 5 e e -5 #> 5 6 f f -6 #> 6 7 g g -7 #> 7 8 h h -8 #> 8 9 i i -9  x <- array(1:125, c(5,5,5)) d <- 1:3 s <- idx_r(x, d, 2, 2* -1i) # 2:(n-1) for every dimension sb_x(x, s = s, d = d) # same as x[ 2:4, 2:4, 2:4, drop = FALSE] #> , , 1 #>  #>      [,1] [,2] [,3] #> [1,]   32   37   42 #> [2,]   33   38   43 #> [3,]   34   39   44 #>  #> , , 2 #>  #>      [,1] [,2] [,3] #> [1,]   57   62   67 #> [2,]   58   63   68 #> [3,]   59   64   69 #>  #> , , 3 #>  #>      [,1] [,2] [,3] #> [1,]   82   87   92 #> [2,]   83   88   93 #> [3,]   84   89   94 #>   x <- letters x[idx_r(x, 0, 2, 2* -1i)] #>  [1] \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" \"t\" #> [20] \"u\" \"v\" \"w\" \"x\" \"y\""},{"path":"https://tony-aw.github.io/squarebrackets/reference/lst.html","id":null,"dir":"Reference","previous_headings":"","what":"Unnest Tree-like List into a Recursive Matrix or Flattened Recursive Vector — lst","title":"Unnest Tree-like List into a Recursive Matrix or Flattened Recursive Vector — lst","text":"[[, [[<-, sb2_rec, sb2_recin, can perform recursive subset operations nested list.  recursive subset operations operate single element.  Performing recursive subset operations multiple elements vectorized, requires (potentially slow) loop.  lst_untree() function takes nested tree-like list, turns recursive matrix (matrix list-elements), allowing vectorized subset operations performed nested list. lst_untree() can also simply flatten list, making non-nested list.  See Examples section understand list arranged named.  lst_nlists() counts total number recursive list-elements inside list.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/lst.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unnest Tree-like List into a Recursive Matrix or Flattened Recursive Vector — lst","text":"","code":"lst_nlists(x)  lst_untree(x, margin, use.names = TRUE)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/lst.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Unnest Tree-like List into a Recursive Matrix or Flattened Recursive Vector — lst","text":"x tree-like nested list. margin single integer, indicating result arranged: margin = 0 produces simple flattened recursive vector (.e. list) without dimensions. margin = 1 produces recursive matrix (.e. matrix list-elements),  length(x) rows n columns,  n = sapply(x, lst_nlists) |> max().  Empty elements filled list(NULL). margin = 2 produces recursive matrix (.e. matrix list-elements),  length(x) columns n rows,  n = sapply(x, lst_nlists) |> max().  Empty elements filled list(NULL). use.names Boolean, indicating result named.  See section \"use.names\" information.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/lst.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Unnest Tree-like List into a Recursive Matrix or Flattened Recursive Vector — lst","text":"lst_untree():  non-nested (dimensional) list.  Note margin = 1 margin = 2, lst_untree() returns recursive matrix (.e. recursive array 2 dimensions), data.frame.  turn nested list data.frame instead, one option use: rrapply(x, = \"melt\")  lst_nlists():  single integer, giving total number recursive list-elements given list.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/lst.html","id":"use-names","dir":"Reference","previous_headings":"","what":"use.names","title":"Unnest Tree-like List into a Recursive Matrix or Flattened Recursive Vector — lst","text":"margin = 0 use.names = TRUE  margin = 0 use.names = TRUE, every element flattened list named.  Names nested elements, x[[\"\"]][[\"B\"]][[\"C\"]], become \".B.C\", behaviour rapply function (lst_untree() calls internally).  therefore advised use dots (\".\") list names, use underscores (\"_\") instead, calling lst_untree().  See rrapply::rrapply function renaming (forms transforming) recursive subsets lists. margin = 1 use.names = TRUE  margin == 1 use.names = TRUE, rows resulting recursive matrix equal names(x), recursive names assigned. margin = 2 use.names = TRUE  margin == 2 use.names = TRUE, columns resulting recursive matrix equal names(x), recursive names assigned. use.names = FALSE  use.names = FALSE, result names assigned .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/lst.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Unnest Tree-like List into a Recursive Matrix or Flattened Recursive Vector — lst","text":"","code":"# show-casing how the list-elements are arranged and named ====  x <- list(   A = list(     A = list(A = \"AAA\", B = \"AAB\"),     A = list(A  = \"AA2A\", B = \"AA2B\"),     B = list(A = \"ABA\", B = \"ABB\"),     C = letters   ),   Y = list(     Z = list(Z = \"YZZ\", Y = \"YZY\"),     Y = list(Z = \"YYZ\", Y = \"YYY\"),     X = \"YX\"   ) )   # un-tree column-wise: sapply(x, lst_nlists) |> max() # number of rows `y` will have #> [1] 7 y <- lst_untree(x, margin = 2L, use.names = TRUE) dim(y) #> [1] 7 2 print(y) #>      A            Y     #> [1,] \"AAA\"        \"YZZ\" #> [2,] \"AAB\"        \"YZY\" #> [3,] \"AA2A\"       \"YYZ\" #> [4,] \"AA2B\"       \"YYY\" #> [5,] \"ABA\"        \"YX\"  #> [6,] \"ABB\"        NULL  #> [7,] character,26 NULL  sb2_x(y, n(1:3, 1:2), 1:ndim(y)) # vectorized selection of multiple recursive elements #>      A      Y     #> [1,] \"AAA\"  \"YZZ\" #> [2,] \"AAB\"  \"YZY\" #> [3,] \"AA2A\" \"YYZ\"   # un-tree row-wise: sapply(x, lst_nlists) |> max() # number of columns `y` will have #> [1] 7 y <- lst_untree(x, margin = 1L, use.names = TRUE) dim(y) #> [1] 2 7 print(y) #>   [,1]  [,2]  [,3]   [,4]   [,5]  [,6]  [,7]         #> A \"AAA\" \"AAB\" \"AA2A\" \"AA2B\" \"ABA\" \"ABB\" character,26 #> Y \"YZZ\" \"YZY\" \"YYZ\"  \"YYY\"  \"YX\"  NULL  NULL         sb2_x(y, n(1:2, 1:3), 1:ndim(y))  # vectorized selection of multiple recursive elements #>   [,1]  [,2]  [,3]   #> A \"AAA\" \"AAB\" \"AA2A\" #> Y \"YZZ\" \"YZY\" \"YYZ\"    # simple flattened list: y <- lst_untree(x, margin = 0, use.names = TRUE) print(y) #> $A.A.A #> [1] \"AAA\" #>  #> $A.A.B #> [1] \"AAB\" #>  #> $A.A.A #> [1] \"AA2A\" #>  #> $A.A.B #> [1] \"AA2B\" #>  #> $A.B.A #> [1] \"ABA\" #>  #> $A.B.B #> [1] \"ABB\" #>  #> $A.C #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" #> [20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\" #>  #> $Y.Z.Z #> [1] \"YZZ\" #>  #> $Y.Z.Y #> [1] \"YZY\" #>  #> $Y.Y.Z #> [1] \"YYZ\" #>  #> $Y.Y.Y #> [1] \"YYY\" #>  #> $Y.X #> [1] \"YX\" #>  y[[\"Y.Z.Y\"]] #> [1] \"YZY\" x[[c(\"Y\", \"Z\", \"Y\")]] # equivalent in the original list #> [1] \"YZY\"   ################################################################################  # showcasing that only list-elements are recursively flattened ==== # i.e. atomic vectors in recursive subsets remain atomic  x <- lapply(1:10, \\(x)list(sample(letters), sample(1:10)))  sapply(x, lst_nlists) |> max() #> [1] 2 y <- lst_untree(x, margin = 1) dim(y) #> [1] 10  2 print(y) #>       [,1]         [,2]       #>  [1,] character,26 integer,10 #>  [2,] character,26 integer,10 #>  [3,] character,26 integer,10 #>  [4,] character,26 integer,10 #>  [5,] character,26 integer,10 #>  [6,] character,26 integer,10 #>  [7,] character,26 integer,10 #>  [8,] character,26 integer,10 #>  [9,] character,26 integer,10 #> [10,] character,26 integer,10  lst_untree(x, margin = 1) #>       [,1]         [,2]       #>  [1,] character,26 integer,10 #>  [2,] character,26 integer,10 #>  [3,] character,26 integer,10 #>  [4,] character,26 integer,10 #>  [5,] character,26 integer,10 #>  [6,] character,26 integer,10 #>  [7,] character,26 integer,10 #>  [8,] character,26 integer,10 #>  [9,] character,26 integer,10 #> [10,] character,26 integer,10   ################################################################################  # showcasing vectorized sub-setting ==== x <- lapply(1:10, \\(x) list(   list(sample(letters[1:10]), sample(LETTERS[1:10])),   list(sample(month.abb), sample(month.name)),   list(sample(1:10), rnorm(10)) )) y <- lst_untree(x, 1)  # getting the first recursive elements in the second level/depth in base R: for(i in seq_along(x)) {   x[[c(i, c(1L, 1L))]] |> print() # for-loop, slow } #>  [1] \"f\" \"a\" \"h\" \"j\" \"b\" \"d\" \"e\" \"c\" \"g\" \"i\" #>  [1] \"j\" \"f\" \"b\" \"i\" \"g\" \"h\" \"e\" \"d\" \"a\" \"c\" #>  [1] \"a\" \"e\" \"b\" \"j\" \"i\" \"c\" \"h\" \"f\" \"g\" \"d\" #>  [1] \"a\" \"c\" \"e\" \"d\" \"b\" \"g\" \"h\" \"i\" \"f\" \"j\" #>  [1] \"i\" \"d\" \"c\" \"j\" \"e\" \"g\" \"b\" \"h\" \"a\" \"f\" #>  [1] \"e\" \"f\" \"i\" \"c\" \"b\" \"g\" \"j\" \"a\" \"h\" \"d\" #>  [1] \"e\" \"h\" \"b\" \"d\" \"g\" \"a\" \"c\" \"f\" \"j\" \"i\" #>  [1] \"b\" \"a\" \"i\" \"h\" \"g\" \"d\" \"e\" \"j\" \"f\" \"c\" #>  [1] \"i\" \"f\" \"e\" \"g\" \"c\" \"a\" \"d\" \"h\" \"b\" \"j\" #>  [1] \"i\" \"b\" \"a\" \"d\" \"j\" \"e\" \"f\" \"h\" \"c\" \"g\"  # the same, but vectorized using the untree'd list: sb2_x(y, n(1:nrow(y), 1L), 1:ndim(y)) |> drop() |> print() # vectorized, fast #> [[1]] #>  [1] \"f\" \"a\" \"h\" \"j\" \"b\" \"d\" \"e\" \"c\" \"g\" \"i\" #>  #> [[2]] #>  [1] \"j\" \"f\" \"b\" \"i\" \"g\" \"h\" \"e\" \"d\" \"a\" \"c\" #>  #> [[3]] #>  [1] \"a\" \"e\" \"b\" \"j\" \"i\" \"c\" \"h\" \"f\" \"g\" \"d\" #>  #> [[4]] #>  [1] \"a\" \"c\" \"e\" \"d\" \"b\" \"g\" \"h\" \"i\" \"f\" \"j\" #>  #> [[5]] #>  [1] \"i\" \"d\" \"c\" \"j\" \"e\" \"g\" \"b\" \"h\" \"a\" \"f\" #>  #> [[6]] #>  [1] \"e\" \"f\" \"i\" \"c\" \"b\" \"g\" \"j\" \"a\" \"h\" \"d\" #>  #> [[7]] #>  [1] \"e\" \"h\" \"b\" \"d\" \"g\" \"a\" \"c\" \"f\" \"j\" \"i\" #>  #> [[8]] #>  [1] \"b\" \"a\" \"i\" \"h\" \"g\" \"d\" \"e\" \"j\" \"f\" \"c\" #>  #> [[9]] #>  [1] \"i\" \"f\" \"e\" \"g\" \"c\" \"a\" \"d\" \"h\" \"b\" \"j\" #>  #> [[10]] #>  [1] \"i\" \"b\" \"a\" \"d\" \"j\" \"e\" \"f\" \"h\" \"c\" \"g\" #>"},{"path":"https://tony-aw.github.io/squarebrackets/reference/match_all.html","id":null,"dir":"Reference","previous_headings":"","what":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","title":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","text":"Find indices vector haystack equal vector needles, taking account order vectors, duplicate values. match_all() essentially much efficient version :   Like lapply(needles, \\() (haystack == )), NAs ignored. match_all() internally calls collapse::fmatch collapse::gsplit.  Core code based suggestion Sebastian Kranz (author 'collapse' package).","code":"lapply(needles, \\(i) which(haystack == i))"},{"path":"https://tony-aw.github.io/squarebrackets/reference/match_all.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","text":"","code":"match_all(needles, haystack, unlist = TRUE)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/match_all.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","text":"needles, haystack vectors type. needles contain NA/NaN.  Long vectors supported. unlist Boolean, indicating result single unnamed integer vector (TRUE, default), named list integer vectors (FALSE).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/match_all.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","text":"integer vector, list integer vectors.  list, element list corresponds value needles.  needles /haystack empty, haystack fully NA, match_all() returns empty integer vector (unlist = TRUE), empty list (unlist = FALSE).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/match_all.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","text":"","code":"n <- 200 haystack <- sample(letters, n, TRUE) needles <- sample(letters, n/2, TRUE) indices1 <- match_all(needles, haystack) head(indices1) #> [1]  24  26  43  72  80 121"},{"path":"https://tony-aw.github.io/squarebrackets/reference/ndim.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Number of Dimensions — ndim","title":"Get Number of Dimensions — ndim","text":"ndim(x) short-hand length(dim(x)).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/ndim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Number of Dimensions — ndim","text":"","code":"ndim(x)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/ndim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Number of Dimensions — ndim","text":"x object get number dimensions .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/ndim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Number of Dimensions — ndim","text":"integer, giving number dimensions x .  vectors, gives 0L.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/ndim.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Number of Dimensions — ndim","text":"","code":"x <- 1:10 ndim(x) #> [1] 0 obj <- array(1:64, c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  ndim(obj) #> [1] 3"},{"path":"https://tony-aw.github.io/squarebrackets/reference/nest.html","id":null,"dir":"Reference","previous_headings":"","what":"Nest — n","title":"Nest — n","text":"c() function concatenates vectors lists vector (possible) else list.  analogy function, n() function nests objects list (atomic vector, atomic vectors nested).  short-hand version list function.  handy lists often needed 'squarebrackets', especially arrays.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/nest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nest — n","text":"","code":"n()"},{"path":"https://tony-aw.github.io/squarebrackets/reference/nest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nest — n","text":"list.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/nest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Nest — n","text":"","code":"obj <- array(1:64, c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  sb_x(obj, n(1:3, 1:2), c(1,3)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #>  # above is equivalent to obj[1:3, , 1:2, drop = FALSE]"},{"path":"https://tony-aw.github.io/squarebrackets/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. data.table address, copy, first, last","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb2_rec.html","id":null,"dir":"Reference","previous_headings":"","what":"Access, Replace, Transform, Delete, or Extend Recursive Subsets — sb2_rec","title":"Access, Replace, Transform, Delete, or Extend Recursive Subsets — sb2_rec","text":"sb2_rec() sb2_recin() methods essentially convenient wrappers around [[ [[<-, respectively.  Unlike [[ [[<-, actually S3 methods, package authors can create additional method dispatches. sb2_rec() access recursive subsets lists. sb2_recin() can following things: replace transform recursive subsets list, using R's default Copy--Modify semantics, specifying rp tf argument, respectively. delete recursive subset list, using R's default Copy--Modify semantics, specifying argument rp = NULL. extending list additional recursive elements, using R's default Copy--Modify semantics.  done specifying --bounds index argument rec, entering new values argument rp.  Note adding surface level elements dimensional list delete dimension attributes list.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb2_rec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Access, Replace, Transform, Delete, or Extend Recursive Subsets — sb2_rec","text":"","code":"sb2_rec(x, ...)  # Default S3 method sb2_rec(x, rec, ...)  sb2_recin(x, ...)  # Default S3 method sb2_recin(x, rec, ..., rp, tf)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb2_rec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Access, Replace, Transform, Delete, or Extend Recursive Subsets — sb2_rec","text":"x list, list-like object. ... see squarebrackets_method_dispatch. rec strictly positive integer vector character vector, length p, sb2_rec(x, rec) equivalent x[[ rec[1] ]]...[[ rec[p] ]], providing final indexing results list.  certain subset level nested list, multiple subsets name exist, first one selected performing recursive indexing name, since recursive indexing can select single element. NA, NaN, Inf, -Inf valid values rec. rp optional, allows multiple functionalities: simplest case, performs x[[rec]] <- rp, using R's default semantics.  Since replacement recursive subset, rp necessarily list ; rp can type object. Specifying rp = NULL delete (recursive) subset sb(x, rec).  specify actual NULL instead deleting subset, use rp = list(NULL). rec integer, specifies --bounds subset, sb2_recin() add value rp list.  empty positions filled NA. rec character, specifies non-existing name, sb2_recin() add value rp list new element end. tf optional function. specified, performs x[[rec]] <- tf(x[[rec]]), using R's default Copy--Modify semantics.  support extending list like argument rp.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb2_rec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Access, Replace, Transform, Delete, or Extend Recursive Subsets — sb2_rec","text":"sb2_rec():  Returns recursive subset.  sb2_recin(..., rp = rp):  Returns VOID, replaces, adds, deletes specified recursive subset, using R's default Copy--Modify semantics.  sb2_recin(..., tf = tf):  Returns VOID, transforms specified recursive subset, using R's default Copy--Modify semantics.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb2_rec.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Access, Replace, Transform, Delete, or Extend Recursive Subsets — sb2_rec","text":"Since recursive objects references objects, extending list deleting element list copy entire list, contrast atomic vectors.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb2_rec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Access, Replace, Transform, Delete, or Extend Recursive Subsets — sb2_rec","text":"","code":"lst <- list(   A = list(     A = list(A = \"AAA\", B = \"AAB\"),     A = list(A  = \"AA2A\", B = \"AA2B\"),     B = list(A = \"ABA\", B = \"ABB\")   ),   B = list(     A = list(A = \"BAA\", B = \"BAB\"),     B = list(A = \"BBA\", B = \"BBB\")   ),   C = list(     A = 1:10,     B = 11:20   ) )  #############################################################################  # access recursive subsets ====  sb2_rec(lst, c(1,2,2)) # this gives \"AA2B\" #> [1] \"AA2B\" sb2_rec(lst, c(\"A\", \"B\", \"B\")) # this gives \"ABB\" #> [1] \"ABB\" sb2_rec(lst, c(2,2,1)) # this gives \"BBA\" #> [1] \"BBA\" sb2_rec(lst, c(\"B\", \"B\", \"A\")) # this gives \"BBA\" #> [1] \"BBA\"   #############################################################################  # replace recursive subset with R's default in-place semantics ====  # replace \"AAB\" using R's default in-place semantics: sb2_recin(   lst, c(\"A\", \"A\", \"B\"),   rp = \"THIS IS REPLACED WITH IN-PLACE SEMANTICS\" ) print(lst) #> $A #> $A$A #> $A$A$A #> [1] \"AAA\" #>  #> $A$A$B #> [1] \"THIS IS REPLACED WITH IN-PLACE SEMANTICS\" #>  #>  #> $A$A #> $A$A$A #> [1] \"AA2A\" #>  #> $A$A$B #> [1] \"AA2B\" #>  #>  #> $A$B #> $A$B$A #> [1] \"ABA\" #>  #> $A$B$B #> [1] \"ABB\" #>  #>  #>  #> $B #> $B$A #> $B$A$A #> [1] \"BAA\" #>  #> $B$A$B #> [1] \"BAB\" #>  #>  #> $B$B #> $B$B$A #> [1] \"BBA\" #>  #> $B$B$B #> [1] \"BBB\" #>  #>  #>  #> $C #> $C$A #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $C$B #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  #>     #############################################################################  # transform recursive subsets with R's default in-place semantics ====  sb2_recin(lst, c(\"C\", \"A\"), tf = \\(x)x^2) # transforms lst$C$A  print(lst) #> $A #> $A$A #> $A$A$A #> [1] \"AAA\" #>  #> $A$A$B #> [1] \"THIS IS REPLACED WITH IN-PLACE SEMANTICS\" #>  #>  #> $A$A #> $A$A$A #> [1] \"AA2A\" #>  #> $A$A$B #> [1] \"AA2B\" #>  #>  #> $A$B #> $A$B$A #> [1] \"ABA\" #>  #> $A$B$B #> [1] \"ABB\" #>  #>  #>  #> $B #> $B$A #> $B$A$A #> [1] \"BAA\" #>  #> $B$A$B #> [1] \"BAB\" #>  #>  #> $B$B #> $B$B$A #> [1] \"BBA\" #>  #> $B$B$B #> [1] \"BBB\" #>  #>  #>  #> $C #> $C$A #>  [1]   1   4   9  16  25  36  49  64  81 100 #>  #> $C$B #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  #>    #############################################################################  # add/remove new recursive subsets with R's default in-place semantics ====  sb2_recin(lst, c(\"C\", \"D\"), rp = \"NEW VALUE\") # adds lst$C$D print(lst) #> $A #> $A$A #> $A$A$A #> [1] \"AAA\" #>  #> $A$A$B #> [1] \"THIS IS REPLACED WITH IN-PLACE SEMANTICS\" #>  #>  #> $A$A #> $A$A$A #> [1] \"AA2A\" #>  #> $A$A$B #> [1] \"AA2B\" #>  #>  #> $A$B #> $A$B$A #> [1] \"ABA\" #>  #> $A$B$B #> [1] \"ABB\" #>  #>  #>  #> $B #> $B$A #> $B$A$A #> [1] \"BAA\" #>  #> $B$A$B #> [1] \"BAB\" #>  #>  #> $B$B #> $B$B$A #> [1] \"BBA\" #>  #> $B$B$B #> [1] \"BBB\" #>  #>  #>  #> $C #> $C$A #>  [1]   1   4   9  16  25  36  49  64  81 100 #>  #> $C$B #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  #> $C$D #> [1] \"NEW VALUE\" #>  #>   sb2_recin(lst, c(\"C\", \"A\"), rp = NULL) # removes lst$C$A print(lst) # notice lst$C$A is GONE #> $A #> $A$A #> $A$A$A #> [1] \"AAA\" #>  #> $A$A$B #> [1] \"THIS IS REPLACED WITH IN-PLACE SEMANTICS\" #>  #>  #> $A$A #> $A$A$A #> [1] \"AA2A\" #>  #> $A$A$B #> [1] \"AA2B\" #>  #>  #> $A$B #> $A$B$A #> [1] \"ABA\" #>  #> $A$B$B #> [1] \"ABB\" #>  #>  #>  #> $B #> $B$A #> $B$A$A #> [1] \"BAA\" #>  #> $B$A$B #> [1] \"BAB\" #>  #>  #> $B$B #> $B$B$A #> [1] \"BBA\" #>  #> $B$B$B #> [1] \"BBB\" #>  #>  #>  #> $C #> $C$B #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  #> $C$D #> [1] \"NEW VALUE\" #>  #>    #############################################################################  # Modify View of List By Reference ====  x <- list(  a = data.table::data.table(cola = 1:10, colb = letters[1:10]),  b = data.table::data.table(cola = 11:20, colb = letters[11:20]) ) print(x) #> $a #>      cola   colb #>     <int> <char> #>  1:     1      a #>  2:     2      b #>  3:     3      c #>  4:     4      d #>  5:     5      e #>  6:     6      f #>  7:     7      g #>  8:     8      h #>  9:     9      i #> 10:    10      j #>  #> $b #>      cola   colb #>     <int> <char> #>  1:    11      k #>  2:    12      l #>  3:    13      m #>  4:    14      n #>  5:    15      o #>  6:    16      p #>  7:    17      q #>  8:    18      r #>  9:    19      s #> 10:    20      t #>  myref <- sb2_rec(x, \"a\") address(myref) == address(x$a) # they are the same #> [1] TRUE sb2_set(myref, vars = \"cola\", tf = \\(x)x^2) print(x) # notice x has been changed #> $a #>      cola   colb #>     <num> <char> #>  1:     1      a #>  2:     4      b #>  3:     9      c #>  4:    16      d #>  5:    25      e #>  6:    36      f #>  7:    49      g #>  8:    64      h #>  9:    81      i #> 10:   100      j #>  #> $b #>      cola   colb #>     <int> <char> #>  1:    11      k #>  2:    12      l #>  3:    13      m #>  4:    14      n #>  5:    15      o #>  6:    16      p #>  7:    17      q #>  8:    18      r #>  9:    19      s #> 10:    20      t #>"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":null,"dir":"Reference","previous_headings":"","what":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"S3 Method return copy object modified subsets.  Use sb_mod(x, ...) x atomic object; returns full copy.  Use sb2_mod(x, ...) x recursive object (.e. list data.frame-like); returns partial copy.  modifying subsets using R's default copy--modification semantics, see idx.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"","code":"sb_mod(x, ...)  # Default S3 method sb_mod(   x,   i = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # S3 method for class 'array' sb_mod(   x,   s = NULL,   d = 1:ndim(x),   i = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  sb2_mod(x, ...)  # Default S3 method sb2_mod(   x,   i = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE),   .lapply = lapply )  # S3 method for class 'array' sb2_mod(   x,   s = NULL,   d = 1:ndim(x),   i = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE),   .lapply = lapply )  # S3 method for class 'data.frame' sb2_mod(   x,   s = NULL,   d = 1:2,   obs = NULL,   vars = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE),   .lapply = lapply )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"x see squarebrackets_supported_structures. ... see squarebrackets_method_dispatch. , s, d, obs, vars, inv See squarebrackets_indx_args.  empty index selection returns original object unchanged. rp, tf, .lapply see squarebrackets_modify. chkdup see squarebrackets_options.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"copy object replaced/transformed values.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"Transform Replace  Specifying argument tf transform subset.  Specifying rp replace subset.  One specify tf rp. either one set .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"","code":"# atomic objects ====  obj <- matrix(1:16, ncol = 4) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 rp <- -1:-9 sb_mod(obj, n(1:3), 1:ndim(obj), rp = rp) #>       a  b  c  a #> [1,] -1 -4 -7 13 #> [2,] -2 -5 -8 14 #> [3,] -3 -6 -9 15 #> [4,]  4  8 12 16 # above is equivalent to  obj[1:3, 1:3] <- -1:-9; obj sb_mod(obj, i = \\(x)x<=5, rp = -1:-5) #>       a  b  c  a #> [1,] -1 -5  9 13 #> [2,] -2  6 10 14 #> [3,] -3  7 11 15 #> [4,] -4  8 12 16 # above is equivalent to  obj[obj <= 5] <- -1:-5; obj sb_mod(obj, n(\"a\"), 2L, rp = -1:-8) #>       a b  c  a #> [1,] -1 5  9 -5 #> [2,] -2 6 10 -6 #> [3,] -3 7 11 -7 #> [4,] -4 8 12 -8 # above is equivalent to  obj[, which(colnames(obj) %in% \"a\")] <- -1:-8; obj sb_mod(obj, n(1:3), 1:ndim(obj), tf = \\(x) -x) #>       a  b   c  a #> [1,] -1 -5  -9 13 #> [2,] -2 -6 -10 14 #> [3,] -3 -7 -11 15 #> [4,]  4  8  12 16 # above is equivalent to  obj[1:3, 1:3] <- (-1 * obj[1:3, 1:3]); obj sb_mod(obj, i = \\(x)x <= 5, tf = \\(x) -x) #>       a  b  c  a #> [1,] -1 -5  9 13 #> [2,] -2  6 10 14 #> [3,] -3  7 11 15 #> [4,] -4  8 12 16 # above is equivalent to  obj[obj <= 5] <- (-1 * obj[obj <= 5]); obj  obj <- array(1:64, c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  sb_mod(obj, n(1:3, 1:2), c(1,3), rp = -1:-24) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   -1   -4   -7  -10 #> [2,]   -2   -5   -8  -11 #> [3,]   -3   -6   -9  -12 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]  -13  -16  -19  -22 #> [2,]  -14  -17  -20  -23 #> [3,]  -15  -18  -21  -24 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  # above is equivalent to obj[1:3, , 1:2] <- -1:-24 sb_mod(obj, i = \\(x)x <= 5, rp = -1:-5) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   -1   -5    9   13 #> [2,]   -2    6   10   14 #> [3,]   -3    7   11   15 #> [4,]   -4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  # above is equivalent to obj[obj <= 5] <- -1:-5  #############################################################################   # lists ====  obj <- list(a = 1:10, b = letters[1:11], c = 11:20) print(obj) #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  sb2_mod(obj, \"a\", rp = list(1L)) #> $a #> [1] 1 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  # above is equivalent to  obj[[\"a\"]] <- 1L; obj sb2_mod(obj, is.numeric, rp = list(-1:-10, -11:-20)) #> $a #>  [1]  -1  -2  -3  -4  -5  -6  -7  -8  -9 -10 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] -11 -12 -13 -14 -15 -16 -17 -18 -19 -20 #>  # above is equivalent to  obj[which(sapply(obj, is.numeric))] <- list(-1:-10, -11:-20); obj  obj <- rbind(   lapply(1:4, \\(x)sample(c(TRUE, FALSE, NA))),   lapply(1:4, \\(x)sample(1:10)),   lapply(1:4, \\(x)rnorm(10)),   lapply(1:4, \\(x)sample(letters)) ) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a            b            c            a            #> [1,] logical,3    logical,3    logical,3    logical,3    #> [2,] integer,10   integer,10   integer,10   integer,10   #> [3,] numeric,10   numeric,10   numeric,10   numeric,10   #> [4,] character,26 character,26 character,26 character,26 sb2_mod(obj, n(1:3), 1:ndim(obj),rp = n(-1)) #>      a            b            c            a            #> [1,] -1           -1           -1           logical,3    #> [2,] -1           -1           -1           integer,10   #> [3,] -1           -1           -1           numeric,10   #> [4,] character,26 character,26 character,26 character,26 # above is equivalent to obj[1:3, 1:3] <- list(-1) sb2_mod(obj, i = is.numeric, rp = n(-1)) #>      a            b            c            a            #> [1,] logical,3    logical,3    logical,3    logical,3    #> [2,] -1           -1           -1           -1           #> [3,] -1           -1           -1           -1           #> [4,] character,26 character,26 character,26 character,26 # above is equivalent to obj[sapply(obj, is.numeric)] <- list(-1) sb2_mod(obj, n(\"a\"), 2L, rp = n(-1)) #>      a  b            c            a  #> [1,] -1 logical,3    logical,3    -1 #> [2,] -1 integer,10   integer,10   -1 #> [3,] -1 numeric,10   numeric,10   -1 #> [4,] -1 character,26 character,26 -1 # above is equivalent to # obj[, lapply(c(\"a\", \"a\"), \\(i) which(colnames(obj) == i)) |> unlist()] <- list(-1)   obj <- array(as.list(1:64), c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 1    5    9    13   #> [2,] 2    6    10   14   #> [3,] 3    7    11   15   #> [4,] 4    8    12   16   #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 17   21   25   29   #> [2,] 18   22   26   30   #> [3,] 19   23   27   31   #> [4,] 20   24   28   32   #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 33   37   41   45   #> [2,] 34   38   42   46   #> [3,] 35   39   43   47   #> [4,] 36   40   44   48   #>  sb2_mod(obj, n(1:3, 1:2), c(1,3), rp = as.list(-1:-24)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,] -1   -4   -7   -10  #> [2,] -2   -5   -8   -11  #> [3,] -3   -6   -9   -12  #> [4,] 4    8    12   16   #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,] -13  -16  -19  -22  #> [2,] -14  -17  -20  -23  #> [3,] -15  -18  -21  -24  #> [4,] 20   24   28   32   #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 33   37   41   45   #> [2,] 34   38   42   46   #> [3,] 35   39   43   47   #> [4,] 36   40   44   48   #>  # above is equivalent to obj[1:3, , 1:2] <- as.list(-1:-24) sb2_mod(obj, i = \\(x) x <= 5, rp = as.list(-1:-5)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,] -1   -5   9    13   #> [2,] -2   6    10   14   #> [3,] -3   7    11   15   #> [4,] -4   8    12   16   #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 17   21   25   29   #> [2,] 18   22   26   30   #> [3,] 19   23   27   31   #> [4,] 20   24   28   32   #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 33   37   41   45   #> [2,] 34   38   42   46   #> [3,] 35   39   43   47   #> [4,] 36   40   44   48   #>  # above is equivalent to obj[sapply(onj, \\(x) x <= 5)] <- as.list(-1:-5)   #############################################################################  # data.frame-like objects  - whole columns ====  obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 sb2_mod(   obj, vars = is.numeric,   tf = sqrt ) #>           a b        c d #> 1  1.000000 a 3.316625 a #> 2  1.414214 b 3.464102 b #> 3  1.732051 c 3.605551 c #> 4  2.000000 d 3.741657 d #> 5  2.236068 e 3.872983 e #> 6  2.449490 f 4.000000 f #> 7  2.645751 g 4.123106 g #> 8  2.828427 h 4.242641 h #> 9  3.000000 i 4.358899 i #> 10 3.162278 j 4.472136 j  #############################################################################  # data.frame-like objects  - partial columns ====  obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10  sb2_mod(   obj, obs = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt )  #>            a b         c d #> 1   1.000000 a 11.000000 a #> 2   1.414214 b  3.464102 b #> 3   1.732051 c  3.605551 c #> 4   2.000000 d  3.741657 d #> 5   2.236068 e  3.872983 e #> 6   2.449490 f  4.000000 f #> 7   2.645751 g  4.123106 g #> 8   8.000000 h 18.000000 h #> 9   9.000000 i 19.000000 i #> 10 10.000000 j 20.000000 j sb2_mod(   obj, obs = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt )  #>            a b         c d #> 1   1.000000 a 11.000000 a #> 2   1.414214 b  3.464102 b #> 3   1.732051 c  3.605551 c #> 4   2.000000 d  3.741657 d #> 5   2.236068 e  3.872983 e #> 6   2.449490 f  4.000000 f #> 7   2.645751 g  4.123106 g #> 8   8.000000 h 18.000000 h #> 9   9.000000 i 19.000000 i #> 10 10.000000 j 20.000000 j sb2_mod(   obj, obs = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt )  #>            a b         c d #> 1   1.000000 a 11.000000 a #> 2   1.414214 b  3.464102 b #> 3   1.732051 c  3.605551 c #> 4   2.000000 d  3.741657 d #> 5   2.236068 e  3.872983 e #> 6   2.449490 f  4.000000 f #> 7   2.645751 g  4.123106 g #> 8   8.000000 h 18.000000 h #> 9   9.000000 i 19.000000 i #> 10 10.000000 j 20.000000 j"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":null,"dir":"Reference","previous_headings":"","what":"Method to Modify Subsets of a Mutable Object By Reference — sb_set","title":"Method to Modify Subsets of a Mutable Object By Reference — sb_set","text":"S3 Method replace transform subset supported mutable object using pass--reference semantics  Use sb_set(x, ...) x atomic object (.e. mutatomic).  Use sb2_set(x, ...) x recursive object (.e. data.table).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method to Modify Subsets of a Mutable Object By Reference — sb_set","text":"","code":"sb_set(x, ...)  # Default S3 method sb_set(   x,   i = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # S3 method for class 'array' sb_set(   x,   s = NULL,   d = 1:ndim(x),   i = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  sb2_set(x, ...)  # Default S3 method sb2_set(x, ...)  # S3 method for class 'data.table' sb2_set(   x,   s = NULL,   d = 1:2,   obs = NULL,   vars = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE),   .lapply = lapply )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method to Modify Subsets of a Mutable Object By Reference — sb_set","text":"x variable belonging one supported mutable classes. ... see squarebrackets_method_dispatch. , s, d, obs, vars, inv See squarebrackets_indx_args.  empty index selection leaves original object unchanged. rp, tf, .lapply see squarebrackets_modify. chkdup see squarebrackets_options.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Method to Modify Subsets of a Mutable Object By Reference — sb_set","text":"Returns: VOID. method modifies object reference.  use assignments like x <- sb_set(x, ...).  Since function returns void, just get NULL.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Method to Modify Subsets of a Mutable Object By Reference — sb_set","text":"Transform Replace  Specifying argument tf transform subset. Specifying rp replace subset. One specify tf rp. either one set .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Method to Modify Subsets of a Mutable Object By Reference — sb_set","text":"","code":"# mutatomic objects ====  gen_mat <- function() {   obj <- mutatomic::as.mutatomic(matrix(1:16, ncol = 4))   colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\")   return(obj) }  obj <- obj2 <- gen_mat() print(obj) #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutatomic  #> typeof:  integer   sb_set(obj, n(1:3), 1:ndim(obj), rp = -1:-9) print(obj2) #>       a  b  c  a #> [1,] -1 -4 -7 13 #> [2,] -2 -5 -8 14 #> [3,] -3 -6 -9 15 #> [4,]  4  8 12 16 #> mutatomic  #> typeof:  integer  # above is like x[1:3, 1:3] <- -1:-9, but using pass-by-reference  obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutatomic  #> typeof:  integer   sb_set(obj, i = \\(x) x <= 5, rp = -1:-5) print(obj2) #>       a  b  c  a #> [1,] -1 -5  9 13 #> [2,] -2  6 10 14 #> [3,] -3  7 11 15 #> [4,] -4  8 12 16 #> mutatomic  #> typeof:  integer  # above is like x[x <= 5] <- -1:-5, but using pass-by-reference  obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutatomic  #> typeof:  integer   sb_set(obj, n(\"a\"), 2L, rp = cbind(-1:-4, -5:-8)) print(obj2) #>       a b  c  a #> [1,] -1 5  9 -5 #> [2,] -2 6 10 -6 #> [3,] -3 7 11 -7 #> [4,] -4 8 12 -8 #> mutatomic  #> typeof:  integer  # above is like x[, \"a\"] <- cbind(-1:-4, -5:-8), but using pass-by-reference  obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutatomic  #> typeof:  integer   sb_set(obj, n(1:3), 1:ndim(obj), tf = \\(x) -x) print(obj2) #>       a  b   c  a #> [1,] -1 -5  -9 13 #> [2,] -2 -6 -10 14 #> [3,] -3 -7 -11 15 #> [4,]  4  8  12 16 #> mutatomic  #> typeof:  integer  # above is like x[1:3, 1:3] <- -1 * x[1:3, 1:3], but using pass-by-reference  obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutatomic  #> typeof:  integer   sb_set(obj, i = \\(x) x <= 5, tf = \\(x) -x) print(obj2) #>       a  b  c  a #> [1,] -1 -5  9 13 #> [2,] -2  6 10 14 #> [3,] -3  7 11 15 #> [4,] -4  8 12 16 #> mutatomic  #> typeof:  integer  # above is like x[x <= 5] <- -1 * x[x <= 5], but using pass-by-reference  obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutatomic  #> typeof:  integer   sb_set(obj, n(\"a\"), 2L, tf = \\(x) -x) obj2 #>       a b  c   a #> [1,] -1 5  9 -13 #> [2,] -2 6 10 -14 #> [3,] -3 7 11 -15 #> [4,] -4 8 12 -16 #> mutatomic  #> typeof:  integer  # above is like x[, \"a\"] <- -1 * x[, \"a\"], but using pass-by-reference   gen_array <- function() {   mutatomic::as.mutatomic(array(1:64, c(4,4,3))) } obj <- obj2 <- gen_array() obj #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  #> mutatomic  #> typeof:  integer   sb_set(obj, n(1:3, 1:2, c(1, 3)), 1:3, rp = -1:-12) print(obj2) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   -1   -4    9   13 #> [2,]   -2   -5   10   14 #> [3,]   -3   -6   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   -7  -10   41   45 #> [2,]   -8  -11   42   46 #> [3,]   -9  -12   43   47 #> [4,]   36   40   44   48 #>  #> mutatomic  #> typeof:  integer  # above is like x[1:3, , 1:2] <- -1:-12, but using pass-by-reference   obj <- obj2 <- gen_array() obj #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  #> mutatomic  #> typeof:  integer  sb_set(obj, i = \\(x)x <= 5, rp = -1:-5) print(obj2) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   -1   -5    9   13 #> [2,]   -2    6   10   14 #> [3,]   -3    7   11   15 #> [4,]   -4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  #> mutatomic  #> typeof:  integer  # above is like x[x <= 5] <- -1:-5, but using pass-by-reference    #############################################################################  # data.table ====  obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb2_set(   obj, obs = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost ) #> Warning: 1.414214 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 1 named 'a') #> Warning: 3.464102 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 3 named 'c') print(obj) #>         a      b     c      d #>     <int> <char> <int> <fctr> #>  1:     1      a    11      a #>  2:     1      b     3      b #>  3:     1      c     3      c #>  4:     2      d     3      d #>  5:     2      e     3      e #>  6:     2      f     4      f #>  7:     2      g     4      g #>  8:     8      h    18      h #>  9:     9      i    19      i #> 10:    10      j    20      j  obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) dt_setcoe(obj, vars = is.numeric, v = as.numeric) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb2_set(obj,   obs = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # SAFE: coercion performed by dt_setcoe(); so no warnings )  print(obj) #>             a      b         c      d #>         <num> <char>     <num> <fctr> #>  1:  1.000000      a 11.000000      a #>  2:  1.414214      b  3.464102      b #>  3:  1.732051      c  3.605551      c #>  4:  2.000000      d  3.741657      d #>  5:  2.236068      e  3.872983      e #>  6:  2.449490      f  4.000000      f #>  7:  2.645751      g  4.123106      g #>  8:  8.000000      h 18.000000      h #>  9:  9.000000      i 19.000000      i #> 10: 10.000000      j 20.000000      j  obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb2_set(   obj, vars = is.numeric,   tf = sqrt # SAFE: row=NULL & obs = NULL, so coercion performed ) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 1.41 1.73 2 2.24 ... #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  3.32 3.46 3.61 3.74 3.87 ... #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_setRename.html","id":null,"dir":"Reference","previous_headings":"","what":"Safely Change the Names of a Mutable Object By Reference — sb_setRename","title":"Safely Change the Names of a Mutable Object By Reference — sb_setRename","text":"Functions rename supported mutable object using pass--reference semantics: sb_setFlatnames() renames (flat) names mutatomic object. sb_setDimnames() renames dimension names mutatomic object. sb2_setVarnames() renames variable names data.table object.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_setRename.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Safely Change the Names of a Mutable Object By Reference — sb_setRename","text":"","code":"sb_setFlatnames(x, i = NULL, newnames, ...)  sb_setDimnames(x, m, newdimnames, ...)  sb2_setVarnames(x, old, new, skip_absent = FALSE, ...)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_setRename.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Safely Change the Names of a Mutable Object By Reference — sb_setRename","text":"x variable belonging one supported mutable classes. logical, numeric, character, imaginary indices, indicating flatnames changed.  = NULL, names completely replaced. newnames Atomic character vector giving new names.  Specifying NULL remove names. ... see squarebrackets_method_dispatch. m integer vector giving margin(s) change names (m = 1L rows, m = 2L columns, etc.). newdimnames list length m.  first element list corresponds margin m[1], second element m[2], .  components list can either NULL, character vector length corresponding dimension.  Instead list, simply NULL can specified, remove dimnames completely. old old column names new new column names, order old skip_absent Skip items old missing (.e. absent) names(x).  Default FALSE halts error missing.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_setRename.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Safely Change the Names of a Mutable Object By Reference — sb_setRename","text":"Returns: VOID. method modifies object reference.  use assignment like names(x) <- sb_setRename(x, ...).  Since function returns void, just get NULL.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_setRename.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Safely Change the Names of a Mutable Object By Reference — sb_setRename","text":"","code":"# mutable atomic vector ==== x <- y <- mutatomic::mutatomic(1:10, names = letters[1:10]) print(x) #>  a  b  c  d  e  f  g  h  i  j  #>  1  2  3  4  5  6  7  8  9 10  #> mutatomic  #> typeof:  integer  sb_setFlatnames(x, newnames = rev(letters[1:10])) print(y) #>  j  i  h  g  f  e  d  c  b  a  #>  1  2  3  4  5  6  7  8  9 10  #> mutatomic  #> typeof:  integer   x <- y <- mutatomic::mutatomic(1:10, names = letters[1:10]) print(x) #>  a  b  c  d  e  f  g  h  i  j  #>  1  2  3  4  5  6  7  8  9 10  #> mutatomic  #> typeof:  integer  sb_setFlatnames(x, 1L, \"XXX\") print(y) #> XXX   b   c   d   e   f   g   h   i   j  #>   1   2   3   4   5   6   7   8   9  10  #> mutatomic  #> typeof:  integer   ################################################################################   # mutable atomic matrix ==== x <- mutatomic::mutatomic(   1:20, dim = c(5, 4), dimnames = n(letters[1:5], letters[1:4]) ) print(x) #>   a  b  c  d #> a 1  6 11 16 #> b 2  7 12 17 #> c 3  8 13 18 #> d 4  9 14 19 #> e 5 10 15 20 #> mutatomic  #> typeof:  integer  sb_setDimnames(   x,   1:2,   lapply(dimnames(x), rev) ) print(x) #>   d  c  b  a #> e 1  6 11 16 #> d 2  7 12 17 #> c 3  8 13 18 #> b 4  9 14 19 #> a 5 10 15 20 #> mutatomic  #> typeof:  integer     ################################################################################    # data.table ====  x <- data.table::data.table(   a = 1:20,   b = letters[1:20] ) print(x) #>         a      b #>     <int> <char> #>  1:     1      a #>  2:     2      b #>  3:     3      c #>  4:     4      d #>  5:     5      e #>  6:     6      f #>  7:     7      g #>  8:     8      h #>  9:     9      i #> 10:    10      j #> 11:    11      k #> 12:    12      l #> 13:    13      m #> 14:    14      n #> 15:    15      o #> 16:    16      p #> 17:    17      q #> 18:    18      r #> 19:    19      s #> 20:    20      t #>         a      b sb2_setVarnames(x, old = names(x), new = rev(names(x))) print(x) #>         b      a #>     <int> <char> #>  1:     1      a #>  2:     2      b #>  3:     3      c #>  4:     4      d #>  5:     5      e #>  6:     6      f #>  7:     7      g #>  8:     8      h #>  9:     9      i #> 10:    10      j #> 11:    11      k #> 12:    12      l #> 13:    13      m #> 14:    14      n #> 15:    15      o #> 16:    16      p #> 17:    17      q #> 18:    18      r #> 19:    19      s #> 20:    20      t #>         b      a"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_wo.html","id":null,"dir":"Reference","previous_headings":"","what":"Method to Return Object Without Specified Subset — sb_wo","title":"Method to Return Object Without Specified Subset — sb_wo","text":"S3 Method return object without specified subset. sb_wo()/ sb2_wo() essentially inverse sb_x/sb2_x.  Use sb_wo(x, ...) x atomic object.  Use sb2_wo(x, ...) x recursive object (.e. list data.frame-like).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_wo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method to Return Object Without Specified Subset — sb_wo","text":"","code":"sb_wo(x, ...)  # Default S3 method sb_wo(x, i = NULL, ..., chkdup = getOption(\"squarebrackets.chkdup\", FALSE))  # S3 method for class 'array' sb_wo(   x,   s = NULL,   d = 1:ndim(x),   i = NULL,   ...,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  sb2_wo(x, ...)  # Default S3 method sb2_wo(   x,   i = NULL,   red = FALSE,   ...,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # S3 method for class 'array' sb2_wo(   x,   s = NULL,   d = 1:ndim(x),   i = NULL,   red = FALSE,   ...,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # S3 method for class 'data.frame' sb2_wo(   x,   s = NULL,   d = 1:2,   obs = NULL,   vars = NULL,   ...,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_wo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method to Return Object Without Specified Subset — sb_wo","text":"x see squarebrackets_supported_structures. ... see squarebrackets_method_dispatch. , s, d, obs, vars See squarebrackets_indx_args.  empty index selection results nothing removed, entire object returned. chkdup see squarebrackets_options. red Boolean, recursive objects , indicating result reduced.  red = TRUE, selecting single element give simplified result, like using [[]].  red = FALSE, list always returned regardless number elements.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_wo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Method to Return Object Without Specified Subset — sb_wo","text":"copy sub-setted object.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_wo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Method to Return Object Without Specified Subset — sb_wo","text":"","code":"# atomic objects ====  obj <- matrix(1:16, ncol = 4) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 sb_wo(obj, n(1:3), 1:ndim(obj)) #>       a #> [1,] 16 # above is equivalent to  obj[-1:-3, -1:-3, drop = FALSE] sb_wo(obj, i = \\(x) x > 5) #> [1] 1 2 3 4 5 # above is equivalent to  obj[!obj > 5] sb_wo(obj, n(\"a\"), 2L) #>      b  c #> [1,] 5  9 #> [2,] 6 10 #> [3,] 7 11 #> [4,] 8 12 # above is equivalent to  obj[, which(!colnames(obj) %in% \"a\")]  obj <- array(1:64, c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  sb_wo(obj, n(1, c(1, 3)), c(1, 3)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   18   22   26   30 #> [2,]   19   23   27   31 #> [3,]   20   24   28   32 #>  # above is equivalent to obj[-1, , c(-1, -3), drop = FALSE] sb_wo(obj, i = \\(x)x > 5) #> [1] 1 2 3 4 5 # above is equivalent to obj[!obj > 5]    #############################################################################   # lists ====  obj <- list(a = 1:10, b = letters[1:11], c = 11:20) print(obj) #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  sb2_wo(obj, \"a\") #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  # above is equivalent to obj[which(!names(obj) %in% \"a\")] sb2_wo(obj, 1) # obj[-1] #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  sb2_wo(obj, 1:2) #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  # above is equivalent to obj[seq_len(length(obj))[-1:-2]] sb2_wo(obj, is.numeric, red = TRUE) #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" # above is equivalent to obj[[!sapply(obj, is.numeric)]] IF this returns a single element obj <- list(a = 1:10, b = letters[1:11], c = letters) sb2_wo(obj, is.numeric) #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" #> [20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\" #>  # above is equivalent to obj[!sapply(obj, is.numeric)] # this time singular brackets? # for recusive indexing, see sb2_rec()   obj <- rbind(   lapply(1:4, \\(x)sample(c(TRUE, FALSE, NA))),   lapply(1:4, \\(x)sample(1:10)),   lapply(1:4, \\(x)rnorm(10)),   lapply(1:4, \\(x)sample(letters)) ) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a            b            c            a            #> [1,] logical,3    logical,3    logical,3    logical,3    #> [2,] integer,10   integer,10   integer,10   integer,10   #> [3,] numeric,10   numeric,10   numeric,10   numeric,10   #> [4,] character,26 character,26 character,26 character,26 sb2_wo(obj, n(1:3), 1:ndim(obj)) #>      a            #> [1,] character,26 # above is equivalent to obj[1:3, 1:3, drop = FALSE] sb2_wo(obj, i = is.numeric) #> [[1]] #> [1] FALSE    NA  TRUE #>  #> [[2]] #>  [1] \"s\" \"u\" \"e\" \"r\" \"j\" \"q\" \"z\" \"o\" \"k\" \"w\" \"b\" \"g\" \"l\" \"c\" \"h\" \"x\" \"d\" \"m\" \"f\" #> [20] \"y\" \"t\" \"a\" \"n\" \"v\" \"i\" \"p\" #>  #> [[3]] #> [1] FALSE    NA  TRUE #>  #> [[4]] #>  [1] \"j\" \"u\" \"n\" \"b\" \"d\" \"y\" \"o\" \"t\" \"q\" \"g\" \"a\" \"e\" \"l\" \"c\" \"p\" \"r\" \"v\" \"x\" \"w\" #> [20] \"f\" \"s\" \"z\" \"k\" \"i\" \"m\" \"h\" #>  #> [[5]] #> [1]    NA FALSE  TRUE #>  #> [[6]] #>  [1] \"j\" \"t\" \"m\" \"f\" \"c\" \"w\" \"i\" \"p\" \"q\" \"n\" \"k\" \"x\" \"r\" \"y\" \"h\" \"a\" \"e\" \"o\" \"s\" #> [20] \"g\" \"b\" \"d\" \"v\" \"z\" \"l\" \"u\" #>  #> [[7]] #> [1] FALSE  TRUE    NA #>  #> [[8]] #>  [1] \"c\" \"x\" \"v\" \"s\" \"n\" \"g\" \"w\" \"o\" \"k\" \"d\" \"h\" \"r\" \"y\" \"j\" \"e\" \"m\" \"t\" \"p\" \"u\" #> [20] \"q\" \"a\" \"i\" \"l\" \"z\" \"f\" \"b\" #>  # above is equivalent to obj[sapply(obj, is.numeric)] sb2_wo(obj, n(c(\"a\", \"a\")), 2L) #>      b            c            #> [1,] logical,3    logical,3    #> [2,] integer,10   integer,10   #> [3,] numeric,10   numeric,10   #> [4,] character,26 character,26 # above is equivalent to obj[, lapply(c(\"a\", \"a\"), \\(i) which(colnames(obj) == i)) |> unlist()]  obj <- array(as.list(1:64), c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 1    5    9    13   #> [2,] 2    6    10   14   #> [3,] 3    7    11   15   #> [4,] 4    8    12   16   #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 17   21   25   29   #> [2,] 18   22   26   30   #> [3,] 19   23   27   31   #> [4,] 20   24   28   32   #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 33   37   41   45   #> [2,] 34   38   42   46   #> [3,] 35   39   43   47   #> [4,] 36   40   44   48   #>  sb2_wo(obj, n(1, c(1, 3)), c(1, 3)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 18   22   26   30   #> [2,] 19   23   27   31   #> [3,] 20   24   28   32   #>  # above is equivalent to obj[-1, , c(-1, -3), drop = FALSE] sb2_wo(obj, i = \\(x)x>5) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 3 #>  #> [[4]] #> [1] 4 #>  #> [[5]] #> [1] 5 #>  # above is equivalent to obj[!sapply(obj, \\(x) x > 5)]    #############################################################################  # data.frame-like objects ====  obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) print(obj) #>     a b  c d #> 1   1 a 11 a #> 2   2 b 12 b #> 3   3 c 13 c #> 4   4 d 14 d #> 5   5 e 15 e #> 6   6 f 16 f #> 7   7 g 17 g #> 8   8 h 18 h #> 9   9 i 19 i #> 10 10 j 20 j sb2_wo(obj, n(1:3)) #>   d #> 1 d #> 2 e #> 3 f #> 4 g #> 5 h #> 6 i #> 7 j # above is equivalent to obj[-1:-3, -1:-3, drop = FALSE] sb2_wo(obj, obs = ~ (a > 5) & (c < 19), vars = is.numeric) #>   b d #> 1 a a #> 2 b b #> 3 c c #> 4 d d #> 5 e e #> 6 i i #> 7 j j"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_x.html","id":null,"dir":"Reference","previous_headings":"","what":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","title":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","text":"S3 Method extract, exchange, duplicate (.e. repeat x times) subsets object.  Use sb_x(x, ...) x atomic object.  Use sb2_x(x, ...) x recursive object (.e. list data.frame-like).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_x.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","text":"","code":"sb_x(x, ...)  # Default S3 method sb_x(x, i = NULL, ...)  # S3 method for class 'array' sb_x(x, s = NULL, d = 1:ndim(x), i = NULL, ...)  sb2_x(x, ...)  # Default S3 method sb2_x(x, i = NULL, red = FALSE, ...)  # S3 method for class 'array' sb2_x(x, s = NULL, d = 1:ndim(x), i = NULL, red = FALSE, ...)  # S3 method for class 'data.frame' sb2_x(x, s = NULL, d = 1:2, obs = NULL, vars = NULL, ...)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_x.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","text":"x see squarebrackets_supported_structures. ... see squarebrackets_method_dispatch. , s, d, obs, vars See squarebrackets_indx_args.  Duplicates allowed, resulting duplicated indices.  empty index selection results empty object length 0. red Boolean, recursive objects , indicating result reduced.  red = TRUE, selecting single element give simplified result, like using [[]].  red = FALSE, list always returned regardless number elements.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_x.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","text":"Returns copy sub-setted object.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_x.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","text":"","code":"# atomic objects ====  obj <- matrix(1:16, ncol = 4) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 sb_x(obj, s = n(1:3), d = 1:ndim(obj)) #>      a b  c #> [1,] 1 5  9 #> [2,] 2 6 10 #> [3,] 3 7 11 # above is equivalent to obj[1:3, 1:3, drop = FALSE] sb_x(obj, i = \\(x) x > 5) #>  [1]  6  7  8  9 10 11 12 13 14 15 16 # above is equivalent to obj[obj > 5] sb_x(obj, s = n(c(\"a\", \"a\")), d = 2L) #>      a  a a  a #> [1,] 1 13 1 13 #> [2,] 2 14 2 14 #> [3,] 3 15 3 15 #> [4,] 4 16 4 16 # above is equivalent to obj[, lapply(c(\"a\", \"a\"), \\(i) which(colnames(obj) == i)) |> unlist()]  obj <- array(1:64, c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  sb_x(obj, s = n(1:3, 1:2), d = c(1,3)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #>  # above is equivalent to obj[1:3, , 1:2, drop = FALSE] sb_x(obj, i = \\(x)x > 5) #>  [1]  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #> [26] 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 # above is equivalent to obj[obj > 5]   #############################################################################   # lists ====  obj <- list(a = 1:10, b = letters[1:11], c = 11:20) print(obj) #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  sb2_x(obj, 1) # obj[1] #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  sb2_x(obj, 1, red = TRUE) # obj[[1]] #>  [1]  1  2  3  4  5  6  7  8  9 10 sb2_x(obj, 1:2) # obj[1:2] #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  sb2_x(obj, is.numeric) # obj[sapply(obj, is.numeric)] #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  # for recursive subsets, see sb2_rec()   obj <- rbind(   lapply(1:4, \\(x)sample(c(TRUE, FALSE, NA))),   lapply(1:4, \\(x)sample(1:10)),   lapply(1:4, \\(x)rnorm(10)),   lapply(1:4, \\(x)sample(letters)) ) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a            b            c            a            #> [1,] logical,3    logical,3    logical,3    logical,3    #> [2,] integer,10   integer,10   integer,10   integer,10   #> [3,] numeric,10   numeric,10   numeric,10   numeric,10   #> [4,] character,26 character,26 character,26 character,26 sb2_x(obj, s = n(1:3), d = 1:ndim(obj)) #>      a          b          c          #> [1,] logical,3  logical,3  logical,3  #> [2,] integer,10 integer,10 integer,10 #> [3,] numeric,10 numeric,10 numeric,10 # above is equivalent to obj[1:3, 1:3, drop = FALSE] sb2_x(obj, i = is.numeric) #> [[1]] #>  [1]  8  6  2  1  7  5 10  3  9  4 #>  #> [[2]] #>  [1]  0.202493293  0.914193807 -0.002633041 -0.008976732 -1.055932842 #>  [6] -1.482293021  0.835772000  0.664829113  0.587805034  1.881691165 #>  #> [[3]] #>  [1]  5  8  1  2  6  3  4  9 10  7 #>  #> [[4]] #>  [1]  0.191267828  0.091180034  0.088849182  0.013563179 -0.503294209 #>  [6] -0.044526335  0.008540177  1.536942473 -1.758370991  0.991151967 #>  #> [[5]] #>  [1]  6  3  7  5  1  2  9  8  4 10 #>  #> [[6]] #>  [1] -0.48986190  0.09620816 -0.72105567 -0.52654039  0.93644414  0.03017120 #>  [7] -0.53227516  0.71932370 -1.86197699 -0.80301152 #>  #> [[7]] #>  [1] 10  6  4  7  5  1  9  3  8  2 #>  #> [[8]] #>  [1] -0.69259498 -0.24644614 -1.91997821  0.58031323  0.57228003 -1.80208883 #>  [7]  0.08493117 -1.65377413 -0.21165244 -1.03938355 #>  # above is equivalent to obj[sapply(obj, is.numeric)] sb2_x(obj, s = n(c(\"a\", \"a\")), d = 2L) #>      a            a            a            a            #> [1,] logical,3    logical,3    logical,3    logical,3    #> [2,] integer,10   integer,10   integer,10   integer,10   #> [3,] numeric,10   numeric,10   numeric,10   numeric,10   #> [4,] character,26 character,26 character,26 character,26 # above is equivalent to obj[, lapply(c(\"a\", \"a\"), \\(i) which(colnames(obj) == i)) |> unlist()]  obj <- array(as.list(1:64), c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 1    5    9    13   #> [2,] 2    6    10   14   #> [3,] 3    7    11   15   #> [4,] 4    8    12   16   #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 17   21   25   29   #> [2,] 18   22   26   30   #> [3,] 19   23   27   31   #> [4,] 20   24   28   32   #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 33   37   41   45   #> [2,] 34   38   42   46   #> [3,] 35   39   43   47   #> [4,] 36   40   44   48   #>  sb2_x(obj, s = n(1:3, 1:2), d = c(1,3)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 1    5    9    13   #> [2,] 2    6    10   14   #> [3,] 3    7    11   15   #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 17   21   25   29   #> [2,] 18   22   26   30   #> [3,] 19   23   27   31   #>  # above is equivalent to obj[1:3, , 1:2, drop = FALSE] sb2_x(obj, i = \\(x)x > 5) #> [[1]] #> [1] 6 #>  #> [[2]] #> [1] 7 #>  #> [[3]] #> [1] 8 #>  #> [[4]] #> [1] 9 #>  #> [[5]] #> [1] 10 #>  #> [[6]] #> [1] 11 #>  #> [[7]] #> [1] 12 #>  #> [[8]] #> [1] 13 #>  #> [[9]] #> [1] 14 #>  #> [[10]] #> [1] 15 #>  #> [[11]] #> [1] 16 #>  #> [[12]] #> [1] 17 #>  #> [[13]] #> [1] 18 #>  #> [[14]] #> [1] 19 #>  #> [[15]] #> [1] 20 #>  #> [[16]] #> [1] 21 #>  #> [[17]] #> [1] 22 #>  #> [[18]] #> [1] 23 #>  #> [[19]] #> [1] 24 #>  #> [[20]] #> [1] 25 #>  #> [[21]] #> [1] 26 #>  #> [[22]] #> [1] 27 #>  #> [[23]] #> [1] 28 #>  #> [[24]] #> [1] 29 #>  #> [[25]] #> [1] 30 #>  #> [[26]] #> [1] 31 #>  #> [[27]] #> [1] 32 #>  #> [[28]] #> [1] 33 #>  #> [[29]] #> [1] 34 #>  #> [[30]] #> [1] 35 #>  #> [[31]] #> [1] 36 #>  #> [[32]] #> [1] 37 #>  #> [[33]] #> [1] 38 #>  #> [[34]] #> [1] 39 #>  #> [[35]] #> [1] 40 #>  #> [[36]] #> [1] 41 #>  #> [[37]] #> [1] 42 #>  #> [[38]] #> [1] 43 #>  #> [[39]] #> [1] 44 #>  #> [[40]] #> [1] 45 #>  #> [[41]] #> [1] 46 #>  #> [[42]] #> [1] 47 #>  #> [[43]] #> [1] 48 #>  # above is equivalent to obj[sapply(obj, \\(x) x > 5)]  #############################################################################  # data.frame-like objects ====  obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) print(obj) #>     a b  c d #> 1   1 a 11 a #> 2   2 b 12 b #> 3   3 c 13 c #> 4   4 d 14 d #> 5   5 e 15 e #> 6   6 f 16 f #> 7   7 g 17 g #> 8   8 h 18 h #> 9   9 i 19 i #> 10 10 j 20 j sb2_x(obj, n(1:3)) # obj[1:3, 1:3, drop = FALSE] #>   a b  c #> 1 1 a 11 #> 2 2 b 12 #> 3 3 c 13 sb2_x(obj, obs = ~ (a > 5) & (c < 19), vars = is.numeric) #>   a  c #> 1 6 16 #> 2 7 17 #> 3 8 18"},{"path":"https://tony-aw.github.io/squarebrackets/reference/setapply.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply Functions Over mutable_atomic Matrix Margins By Reference — setapply","title":"Apply Functions Over mutable_atomic Matrix Margins By Reference — setapply","text":"setapply() function applies functions rows columns mutable_atomic matrix, pass--reference semantics.  setapply() bit faster uses less memory apply.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/setapply.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply Functions Over mutable_atomic Matrix Margins By Reference — setapply","text":"","code":"setapply(x, MARGIN, FUN)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/setapply.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply Functions Over mutable_atomic Matrix Margins By Reference — setapply","text":"x mutable_atomic 2-dimensional array (.e. matrix).  Arrays 2 dimensions supported. MARGIN single integer scalar, giving subscript apply function . 1 indicates rows, 2 indicates columns. FUN function applied.  function must return vector type x, appropriate length (.e. length ncol(x) MARGIN == 1 length nrow(x) MARGIN == 2).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/setapply.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply Functions Over mutable_atomic Matrix Margins By Reference — setapply","text":"Returns: VOID. function modifies object reference.  use assignment like x <- setapply(x, ...).  Since function returns void, just get NULL.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/setapply.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply Functions Over mutable_atomic Matrix Margins By Reference — setapply","text":"","code":"# re-order elements matrix by reference ==== x <- mutable_atomic(1:20, dim = c(5,4)) print(x) #>      [,1] [,2] [,3] [,4] #> [1,]    1    6   11   16 #> [2,]    2    7   12   17 #> [3,]    3    8   13   18 #> [4,]    4    9   14   19 #> [5,]    5   10   15   20 #> mutable_atomic  #> typeof:  integer  setapply(x, 1, FUN = \\(x)x[c(4,1,3,2)]) print(x) #>      [,1] [,2] [,3] [,4] #> [1,]   16    1   11    6 #> [2,]   17    2   12    7 #> [3,]   18    3   13    8 #> [4,]   19    4   14    9 #> [5,]   20    5   15   10 #> mutable_atomic  #> typeof:  integer    # sort elements of matrix by reference ==== x <- mutable_atomic(20:1, dim = c(5,4)) print(x) #>      [,1] [,2] [,3] [,4] #> [1,]   20   15   10    5 #> [2,]   19   14    9    4 #> [3,]   18   13    8    3 #> [4,]   17   12    7    2 #> [5,]   16   11    6    1 #> mutable_atomic  #> typeof:  integer  setapply(x, 2, FUN = sort) print(x) #>      [,1] [,2] [,3] [,4] #> [1,]   16   11    6    1 #> [2,]   17   12    7    2 #> [3,]   18   13    8    3 #> [4,]   19   14    9    4 #> [5,]   20   15   10    5 #> mutable_atomic  #> typeof:  integer"},{"path":"https://tony-aw.github.io/squarebrackets/reference/slice.html","id":null,"dir":"Reference","previous_headings":"","what":"Efficient Sequence-based Subset Methods on (Long) Vectors — slice","title":"Efficient Sequence-based Subset Methods on (Long) Vectors — slice","text":"slice_ - methods similar sb_ - methods, except require indexing vector, designed memory efficiency.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/slice.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Efficient Sequence-based Subset Methods on (Long) Vectors — slice","text":"","code":"slice_x(x, ...)  # Default S3 method slice_x(   x,   from = NULL,   to = NULL,   by = 1L,   ...,   use.names = TRUE,   sticky = getOption(\"squarebrackets.sticky\", FALSE) )  slice_wo(x, ...)  # Default S3 method slice_wo(   x,   from = NULL,   to = NULL,   by = 1L,   ...,   use.names = TRUE,   sticky = getOption(\"squarebrackets.sticky\", FALSE) )  slice_set(x, ...)  # Default S3 method slice_set(x, from = NULL, to = NULL, by = 1L, inv = FALSE, ..., rp, tf)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/slice.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Efficient Sequence-based Subset Methods on (Long) Vectors — slice","text":"x atomic object.  slice_set must mutatomic variable. ... see squarebrackets_method_dispatch. , , see cp_seq. use.names Boolean, indicating flat names preserved.  Note , since slice_ methods operates flat indices , dimensions dimnames always dropped. sticky see squarebrackets_options. inv Boolean, indicating whether invert sequence.  TRUE, slice_set() apply replacement/transformation elements vector, except elements specified sequence. rp, tf see squarebrackets_modify.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/slice.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Efficient Sequence-based Subset Methods on (Long) Vectors — slice","text":"Similar sb_ methods.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/slice.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Efficient Sequence-based Subset Methods on (Long) Vectors — slice","text":"","code":"x <- mutatomic::mutatomic(1:1e7)  # extract: slice_x(x, 1, 10) #>  [1]  1  2  3  4  5  6  7  8  9 10 #> mutatomic  #> typeof:  integer   # reverse: slice_x(x, -1i, 1) |> head() #> [1] 10000000  9999999  9999998  9999997  9999996  9999995 #> mutatomic  #> typeof:  integer   # remove: slice_wo(x, 1, -11i) # all elements except the last 10 #>  [1]  9999991  9999992  9999993  9999994  9999995  9999996  9999997  9999998 #>  [9]  9999999 10000000 #> mutatomic  #> typeof:  integer   # replace every other element: x <- mutatomic::mutatomic(1:1e7) slice_set(x, 2, -1i, 2, rp = -1) #> coercing replacement to integer head(x) #> [1]  1 -1  3 -1  5 -1 #> mutatomic  #> typeof:  integer   # replace all elements except the first element: x <- mutatomic::mutatomic(1:1e7) slice_set(x, 1, 1, inv = TRUE, rp = -1) #> coercing replacement to integer head(x) #> [1]  1 -1 -1 -1 -1 -1 #> mutatomic  #> typeof:  integer"},{"path":"https://tony-aw.github.io/squarebrackets/reference/slicev.html","id":null,"dir":"Reference","previous_headings":"","what":"Efficient Value-based Subset Methods on (Long) Vectors — slicev","title":"Efficient Value-based Subset Methods on (Long) Vectors — slicev","text":"slicev_ - methods similar sb_ - methods, except require indexing vector, designed memory efficiency. counv(y, v, , ) counts often value, range values, v, occurs vector subset y[:].","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/slicev.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Efficient Value-based Subset Methods on (Long) Vectors — slicev","text":"","code":"slicev_x(x, ...)  # Default S3 method slicev_x(   x,   ...,   y = x,   v = NULL,   na = FALSE,   r = TRUE,   from = NULL,   to = NULL,   use.names = TRUE,   sticky = getOption(\"squarebrackets.sticky\", FALSE) )  slicev_set(x, ...)  # Default S3 method slicev_set(   x,   ...,   y = x,   v = NULL,   na = FALSE,   r = TRUE,   from = NULL,   to = NULL,   rp,   tf )  countv(y, ..., v = NULL, na = FALSE, r = TRUE, from = NULL, to = NULL)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/slicev.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Efficient Value-based Subset Methods on (Long) Vectors — slicev","text":"x atomic vector.  slicev_set() must mutatomic variable. ... See squarebrackets_slicev. y, v, na, r See squarebrackets_slicev. , see cp_seq. use.names Boolean, indicating flat names preserved.  Note , since slicev_ methods operates flat indices , dimensions dimnames always dropped. sticky see squarebrackets_options. rp, tf see squarebrackets_modify.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/slicev.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Efficient Value-based Subset Methods on (Long) Vectors — slicev","text":"Similar sb_ methods.  countv(): single number, giving number elements matching specified condition.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/slicev.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Efficient Value-based Subset Methods on (Long) Vectors — slicev","text":"","code":"# basic idea ==== nms <- c(letters, LETTERS, month.abb, month.name) |> rep_len(1e6) x <- mutatomic::mutatomic(1:1e6, names = nms) head(x) #> a b c d e f  #> 1 2 3 4 5 6  #> mutatomic  #> typeof:  integer   # memory efficient form of sum(x <= 10): countv(x, v = c(-Inf, 10)) #> [1] 10  # extract all elements of x with the name \"a\": slicev_x(x, y = names(x), v = \"a\") |> head() #>   a   a   a   a   a   a  #>   1  77 153 229 305 381  #> mutatomic  #> typeof:  integer   # find all x smaller than or equal to 5, and replace with `-1000`: slicev_set(x, y = x, v = c(-Inf, 5), rp = -1000L) head(x, n = 10) #>     a     b     c     d     e     f     g     h     i     j  #> -1000 -1000 -1000 -1000 -1000     6     7     8     9    10  #> mutatomic  #> typeof:  integer    ################################################################################ # Numeric range ==== # x <- mutatomic::mutatomic(1:1e6) head(x) #> [1] 1 2 3 4 5 6 #> mutatomic  #> typeof:  integer  slicev_x(x, v= c(-Inf, 5)) # x[x <= 5] #> [1] 1 2 3 4 5 #> mutatomic  #> typeof:  integer    ################################################################################ # Character ==== # x <- stringi::stri_rand_shuffle(rep(\"hello\", 1e5)) head(x) #> [1] \"elohl\" \"oehll\" \"hleol\" \"ohell\" \"leolh\" \"olhle\" slicev_x(x, v = \"hello\") |> head() # find \"hello\" #> [1] \"hello\" \"hello\" \"hello\" \"hello\" \"hello\" \"hello\"  # find 2 possible misspellings of \"hello\": slicev_x(x, v = c(\"holle\", \"helol\")) |> head() #> [1] \"helol\" \"holle\" \"helol\" \"holle\" \"helol\" \"holle\""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"functions convert list integer subscripts integer matrix coordinates, integer matrix coordinates integer vector flat indices, vice-versa.  Inspired sub2ind function 'MatLab'. sub2coord() converts list integer subscripts integer matrix coordinates. coord2ind() converts integer matrix coordinates integer vector flat indices. ind2coord() converts integer vector flat indices integer matrix coordinates. coord2sub() converts integer matrix coordinates list integer subscripts;  performs simple (one might even say naive) conversion. sub2ind() faster memory efficient version coord2ind(sub2coord(sub, x.dims), x.dims) functions written memory-efficient.  coord2ind() thus opposite arrayInd, ind2coord merely convenient wrapper around arrayInd.  Note equivalent sub2ind function 'MatLab' actually coord2ind() function .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"","code":"sub2coord(sub, x.dim)  coord2sub(coord)  coord2ind(coord, x.dim, checks = TRUE)  ind2coord(ind, x.dim)  sub2ind(sub, x.dim, checks = TRUE)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"sub list integer subscripts.  first element list corresponds first dimension (rows), second element second dimensions (columns), etc.  length sub must equal length x.dim.  One give empty subscript; instead fill something like seq_len(dim(x)[margin]).  NOTE: coord2sub() function support duplicate subscripts. x.dim integer vector giving dimensions array question. .e. dim(x). coord integer matrix, giving coordinate indices (subscripts) convert.  row index, column dimension.  first columns corresponds first dimension, second column second dimensions, etc.  number columns coord must equal length x.dim. checks Boolean, indicating arguments checks performed.  Defaults TRUE.  Can set FALSE minor speed improvements. ind integer vector, giving flat position indices convert.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"sub2coord() ind2coord():  Returns integer matrix coordinates (properties described argument coord).  coord2ind():  Returns numeric vector flat indices (properties described argument ind).  coord2sub():  Returns list integer subscripts (properties described argument sub)  sub2ind():  Returns integer vector flat indices(prod(x.dim) < (2^31 - 1)), numeric vector flat indices (prod(x.dim) >= (2^31 - 1)).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"base S3 vector array classes 'R' use standard Linear Algebraic convention, academic fields like Mathematics Statistics, following sense: vectors column vectors (.e. vertically aligned vectors); index counting starts 1; rows first dimension/subscript, columns second dimension/subscript, etc. Thus, orientation flat indices , example, 4-rows--5-columns matrix, follows:   4 5 matrix, subscript [1, 2] corresponds flat index 5.  Array subscripting 'squarebrackets' also follows standard convention.","code":"[,1] [,2] [,3] [,4] [,5]  [1,]    1    5    9   13   17  [2,]    2    6   10   14   18  [3,]    3    7   11   15   19  [4,]    4    8   12   16   20"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"functions specifically designed duplicate indices per-sé.  efficiency, check duplicate indices either.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"","code":"x.dim <- c(10, 10, 3) x.len <- prod(x.dim) x <- array(1:x.len, x.dim) sub <- list(c(4, 3), c(3, 2), c(2, 3)) coord <- sub2coord(sub, x.dim) print(coord) #>      [,1] [,2] [,3] #> [1,]    4    3    2 #> [2,]    3    3    2 #> [3,]    4    2    2 #> [4,]    3    2    2 #> [5,]    4    3    3 #> [6,]    3    3    3 #> [7,]    4    2    3 #> [8,]    3    2    3 ind <- coord2ind(coord, x.dim) print(ind) #> [1] 124 123 114 113 224 223 214 213 all(x[ind] == c(x[c(4, 3), c(3, 2), c(2, 3)])) # TRUE #> [1] TRUE coord2 <- ind2coord(ind, x.dim) print(coord) #>      [,1] [,2] [,3] #> [1,]    4    3    2 #> [2,]    3    3    2 #> [3,]    4    2    2 #> [4,]    3    2    2 #> [5,]    4    3    3 #> [6,]    3    3    3 #> [7,]    4    2    3 #> [8,]    3    2    3 all(coord == coord2) # TRUE #> [1] TRUE sub2 <- coord2sub(coord2) sapply(1:3, \\(i) sub2[[i]] == sub[[i]]) |> all() # TRUE #> [1] TRUE"}]
