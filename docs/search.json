[{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Benchmarks - sb_x","text":"Due many checks conversions performed squarebrackets:: functions, make sub-setting programmatically beginner friendly, functions almost necessarily slower base R’s [-like operators. However, considerable effort made keep speed loss minimum. Generally, speed loss indeed negligible, cases even speed improvement (thanks heavy lifting performed ‘collapse’ package). benchmarks give one idea speed loss. just examples; speed determined great number factors.  ","code":"library(bench) library(ggplot2) library(patchwork)"},{"path":[]},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"matrix","dir":"Articles","previous_headings":"Atomic objects","what":"Matrix","title":"Benchmarks - sb_x","text":" ","code":"n <- 5e3 x.mat <- matrix(seq_len(n*n), ncol = n) colnames(x.mat) <- sample(c(letters, NA), n, TRUE) sel.rows <- 1:100 sel.cols <- rep(sample(letters[1:13]), 10) bm.sb_x.matrix <- bench::mark(   \"sb_x\" = sb_x(x.mat, sel.rows, sel.cols),   \"base R\" = x.mat[sel.rows, lapply(sel.cols, \\(i) which(colnames(x.mat) == i)) |> unlist(), drop = FALSE],   min_iterations = 500 ) bm.sb_x.matrix summary(bm.sb_x.matrix) #> # A tibble: 2 × 6 #>   expression          min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>     <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 squarebrackets   4.99ms   5.56ms      177.    9.82MB     28.3 #> 2 base R           7.81ms    8.9ms      111.   14.67MB     16.6"},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"array-3d","dir":"Articles","previous_headings":"Atomic objects","what":"Array (3D)","title":"Benchmarks - sb_x","text":" ","code":"x.dims <- c(5000, 2000, 4) x.3d <- array(1:prod(x.dims), x.dims) sel.rows <- 1:900 sel.lyrs <- c(TRUE, FALSE, TRUE, FALSE) bm.sb_x.3d <- bench::mark(   \"squarebrackets\" =  sb_x(x.3d, n(sel.rows, sel.lyrs), c(1,3)),   \"base R + abind\" = abind::asub(x.3d, idx = list(sel.rows, sel.lyrs), dims = c(1,3)),   min_iterations = 500 ) summary(bm.sb_x.3d) #> # A tibble: 2 × 6 #>   expression          min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>     <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 squarebrackets   9.64ms   10.6ms      94.1    13.7MB     7.52 #> 2 base R + abind    9.7ms   10.7ms      92.8    13.7MB     6.56"},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"plot","dir":"Articles","previous_headings":"Atomic objects","what":"Plot","title":"Benchmarks - sb_x","text":" ","code":"#> Loading required namespace: tidyr"},{"path":[]},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"data-frame","dir":"Articles","previous_headings":"Data.frame-like objects","what":"data.frame","title":"Benchmarks - sb_x","text":" ","code":"n <- 1e5 chrmat <- matrix(   sample(letters, n*400, replace = TRUE), ncol = 400 ) intmat <- matrix(   seq.int(n*400), ncol = 400 ) x <- cbind(chrmat, intmat) |> as.data.frame() rm(list = c(\"chrmat\", \"intmat\")) colnames(x) <- make.names(colnames(x), unique = TRUE) sel.cols <- rep(sample(names(x), 10), 4) sel.rows <- 1:1000 bm.sb_x.df <- bench::mark(   \"squarebrackets\" = sb2_x(x, sel.rows, sel.cols),   \"collapse::ss\" = collapse::ss(x, sel.rows, match(sel.cols, names(x))),   \"base R\" = x[sel.rows, match(sel.cols, names(x)), drop = FALSE],   min_iterations = 1e4 ) summary(bm.sb_x.df) #> # A tibble: 2 × 6 #>   expression          min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>     <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 squarebrackets    124µs    193µs     4466.     441KB     8.95 #> 2 base R            345µs    879µs     1052.     362KB     2.11"},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"data-table","dir":"Articles","previous_headings":"Data.frame-like objects","what":"data.table","title":"Benchmarks - sb_x","text":" ","code":"x <- as.data.table(x) tempfun <- function(x, i, j) {   x <- collapse::ss(x, i, j, check = TRUE)   names(x) <- make.names(names(x), unique = TRUE)   return(x) } bm.sb_x.dt <- bench::mark(   \"squarebrackets\" = sb2_x(x, sel.rows, sel.cols),   \"data.table + collapse\" = tempfun(x, sel.rows, match(sel.cols, names(x))),   min_iterations = 1e4 ) summary(bm.sb_x.dt) #> # A tibble: 2 × 6 #>   expression                 min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>            <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 squarebrackets           112µs    125µs     7610.     324KB     4.57 #> 2 data.table + collapse    106µs    124µs     5508.     339KB     0"},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"plot-1","dir":"Articles","previous_headings":"Data.frame-like objects","what":"plot","title":"Benchmarks - sb_x","text":" ","code":""},{"path":"https://tony-aw.github.io/squarebrackets/articles/b_benchmarks_tf.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Benchmarks - transform operations","text":"Base R’s [<-, [[<-, $<- methods perform -place modification subsets objects using “copy--modify” semantics. ‘squarebrackets’ R-package provides 2 alternative semantics modification: “pass--reference” sb_set() method, “deep-copy” sb_mod() method. Moreover, base ‘R’ provides direct replacement , ‘squarebrackets’ provides replacement (rp argument) transformation (tf argument) mechanics. Thus, ‘squarebrackets’ base R really directly comparable terms benchmarking. Nonetheless, tried keep comparisons somewhat fair. sb_set() method generally several times (2 5 times) faster base R’s -place modification, generally uses half memory. sb_mod() method generally fast base R’s -place modification, uses amount memory. benchmarks give one idea speed loss. just examples; speed determined great number factors. keep comparisons classes fair, objects approximately 1e7 elements.  ","code":"library(bench) library(ggplot2) library(patchwork) library(tinycodet) #> Run `?tinycodet::tinycodet` to open the introduction help page of 'tinycodet'. plotfun <- function(title1, bm1, title2, bm2) {    plotdat1 <- bm1 |> tidyr::unnest(cols = c(\"time\", \"gc\", \"mem_alloc\"))   plotdat1$expression <- paste(     plotdat1$expression,     \"\\n (\", as.character(plotdat1$mem_alloc), \")\"   )   p1 <- ggplot(plotdat1, aes_pro(x = ~ time, y = ~ expression, color = ~ gc)) +   ggbeeswarm::geom_quasirandom() + ggtitle(title1)    plotdat2 <- bm2 |> tidyr::unnest(cols = c(\"time\", \"gc\", \"mem_alloc\"))   plotdat2$expression <- paste(     plotdat2$expression,     \"\\n (\", as.character(plotdat2$mem_alloc), \")\"   )   p2 <- ggplot(plotdat2, aes_pro(x = ~ time, y = ~ expression, color = ~ gc)) +   ggbeeswarm::geom_quasirandom() + ggtitle(title2)    combined <- p1 + p2 & theme(legend.position = \"bottom\")   combined + plot_layout(guides = \"collect\") }"},{"path":[]},{"path":"https://tony-aw.github.io/squarebrackets/articles/b_benchmarks_tf.html","id":"matrix","dir":"Articles","previous_headings":"Atomic objects","what":"Matrix","title":"Benchmarks - transform operations","text":" ","code":"n <- 3162 # approx sqrt(1e7) x.mat <- matrix(seq_len(n*n), ncol = n) x.mat2 <- as.mutable_atomic(x.mat) colnames(x.mat) <- sample(c(letters, LETTERS, NA), n, TRUE) sel.rows <- 1:1000 sel.cols <- 1:1000 basefun <- function(x, rows, cols, tf) {   x[rows, cols] <- tf(x[rows, cols])   return(x) } tf <- function(x) { return(-1 * x) } bm.sb_tf.matrix <- bench::mark(   \"base [<-\" =  basefun(x.mat, sel.rows, sel.cols, tf = tf),   \"sb_set\" = sb_set(x.mat2, sel.rows, sel.cols, tf = tf),   \"sb_mod\" = sb_mod(x.mat, sel.rows, sel.cols, tf = tf),   check = FALSE,   min_iterations = 500 ) bm.sb_tf.matrix summary(bm.sb_tf.matrix) #> # A tibble: 3 × 6 #>   expression      min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 base [<-    23.86ms  29.02ms      33.9    87.7MB     46.4 #> 2 sb_set       4.83ms   6.07ms     165.     15.4MB     14.7 #> 3 sb_mod      24.82ms  29.69ms      32.5    87.8MB     29.5"},{"path":"https://tony-aw.github.io/squarebrackets/articles/b_benchmarks_tf.html","id":"array-3d","dir":"Articles","previous_headings":"Atomic objects","what":"Array (3D)","title":"Benchmarks - transform operations","text":" ","code":"x.dims <- c(1900, 1900, 3) # leads to approx 1e7 elements x.3d <- array(1:prod(x.dims), x.dims) x.3d2 <- as.mutable_atomic(x.3d) sel.rows <- 1:900 sel.lyrs <- c(TRUE, FALSE, TRUE) basefun <- function(x, rows, lyrs, tf) {   x[rows, , lyrs] <- tf(x[rows, , lyrs])   return(x) } tf <- function(x) { return(-1 * x) } bm.sb_tf.3d <- bench::mark(   \"base [<-\" = basefun(x.3d, sel.rows, sel.lyrs, tf = tf ),   \"sb_set\" =  sb_set(x.3d2, n(sel.rows, sel.lyrs), c(1,3), tf = tf),   \"sb_mod\" = sb_mod(x.3d, n(sel.rows, sel.lyrs), c(1, 3), tf = tf),   check = FALSE,   min_iterations = 500 ) summary(bm.sb_tf.3d) #> # A tibble: 3 × 6 #>   expression      min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 base [<-     48.5ms     52ms      19.0   121.8MB     44.8 #> 2 sb_set       22.2ms   26.9ms      37.1    52.3MB     10.9 #> 3 sb_mod       45.5ms   52.9ms      18.8   121.8MB     21.9"},{"path":"https://tony-aw.github.io/squarebrackets/articles/b_benchmarks_tf.html","id":"plot","dir":"Articles","previous_headings":"Atomic objects","what":"Plot","title":"Benchmarks - transform operations","text":" ","code":"#> Warning: The `trans` argument of `continuous_scale()` is deprecated as of ggplot2 3.5.0. #> ℹ Please use the `transform` argument instead. #> This warning is displayed once every 8 hours. #> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was #> generated. #> Orientation inferred to be along y-axis; override with #> `position_quasirandom(orientation = 'x')` #> Orientation inferred to be along y-axis; override with #> `position_quasirandom(orientation = 'x')`"},{"path":"https://tony-aw.github.io/squarebrackets/articles/b_benchmarks_tf.html","id":"data-frame-like","dir":"Articles","previous_headings":"","what":"Data.frame-like","title":"Benchmarks - transform operations","text":"    ","code":"n <- 1e5 ncol <- 200 # times 2 chrmat <- matrix(   sample(letters, n*ncol, replace = TRUE), ncol = ncol ) intmat <- matrix(   seq.int(n*ncol), ncol = ncol ) x <- cbind(chrmat, intmat) |> as.data.frame() colnames(x) <- make.names(colnames(x), unique = TRUE) x2 <- data.table::as.data.table(x) rm(list = c(\"chrmat\", \"intmat\"))  sel.rows <- 1:1000 basefun <- function(x, rows, tf) {   x[rows, sapply(x, is.numeric)] <- lapply(x[rows, sapply(x, is.numeric)], tf)   return(x) } bm.sb_tf.df <- bench::mark(   \"base [<-\" = basefun(x, sel.rows, tf = \\(x) -1 * x),   \"sb_set\" = sb2_set.data.table(     x2, rows = sel.rows, vars = is.numeric, tf = \\(x) -1 * x   ),   \"sb_mod\" = sb2_mod.data.frame(     x, rows = sel.rows, vars = is.numeric, tf = \\(x) -1 * x, coe = TRUE   ),   check = FALSE,   min_iterations = 500 ) summary(bm.sb_tf.df) #> # A tibble: 3 × 6 #>   expression      min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 base [<-    237.9µs    307µs     3060.    62.3KB     12.3 #> 2 sb_set       84.3µs    122µs     7339.   932.8KB      0   #> 3 sb_mod      100.5µs    131µs     7400.    46.7KB      0 #> Orientation inferred to be along y-axis; override with #> `position_quasirandom(orientation = 'x')`"},{"path":"https://tony-aw.github.io/squarebrackets/articles/c_benchmarks_lst.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Benchmarks - Vectorized Recursive Subset Operations On Nested Lists","text":"Operating recursive sub-sets nested lists requires [[ [[<- operators. operators can select single subset . Thus, operating multiple recursive sub-sets requires -loop, thus vectorized. lst_untree() function unnests tree-like nested list recursive matrix, way recursive sub-set operations can performed vectorized manner. benchmarks operating original list, list transformed lst_untree().   ","code":"x <- lapply(1:1000, \\(x) list(   list(sample(letters), sample(LETTERS)),   list(sample(month.abb), sample(month.name)),   list(sample(1:100), rnorm(100)) )) y <- lst_untree(x, 1)  foo <- bench::mark(   original = for(i in seq_along(x)) {x[[c(i, c(1,2))]]},   \"untree'd\" = sb2_x(n(seq_len(nrow(y)), 2), 1:2),   check = FALSE,   min_iterations = 1000 ) summary(foo) #> # A tibble: 2 × 6 #>   expression      min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 original     1.09ms    1.3ms      730.    38.4KB     16.4 #> 2 untree'd        8µs    9.1µs   101700.    82.7KB     20.3 ggplot2::autoplot(foo) #> Loading required namespace: tidyr"},{"path":"https://tony-aw.github.io/squarebrackets/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Tony Wilkes. Author, maintainer, copyright holder. Tony Plate. Contributor.            Author included 'abind' fragments Richard Heiberger. Contributor.            Author included 'abind' fragments Sebastian Krantz. Contributor.            Contributed internal code 'match_all' function","code":""},{"path":"https://tony-aw.github.io/squarebrackets/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Wilkes T (2024). squarebrackets: Subset Methods Alternatives Square Brackets Operators Programming. R package version 0.0.0.9, https://tony-aw.github.io/squarebrackets/, https://github.com/tony-aw/squarebrackets/.","code":"@Manual{,   title = {squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming},   author = {Tony Wilkes},   year = {2024},   note = {R package version 0.0.0.9, https://tony-aw.github.io/squarebrackets/},   url = {https://github.com/tony-aw/squarebrackets/}, }"},{"path":"https://tony-aw.github.io/squarebrackets/index.html","id":"squarebrackets","dir":"","previous_headings":"","what":"Subset Methods as Alternatives to the Square Brackets Operators for Programming","title":"Subset Methods as Alternatives to the Square Brackets Operators for Programming","text":"squarebrackets: Subset Methods Alternatives Square Brackets Operators Programming","code":""},{"path":"https://tony-aw.github.io/squarebrackets/index.html","id":"description","dir":"","previous_headings":"","what":"Description","title":"Subset Methods as Alternatives to the Square Brackets Operators for Programming","text":"Provides subset methods (supporting atomic recursive S3 classes) may convenient alternatives [ [<- operators, whilst maintaining similar performance. nice properties methods include, limited , following: [ [<- operators use different rule-sets different data.frame-like types (data.frames, data.tables, tibbles, tidytables, etc.). ‘squarebrackets’ methods use rule-sets different data.frame-like types. Performing dimensional subset operations array using [ [<-, requires -priori knowledge number dimensions array . ‘squarebrackets’ methods work arbitrary dimensions without requiring prior knowledge. selecting names [ [<- operators, first occurrence names selected case duplicate names. ‘squarebrackets’ methods always perform names case duplicates, just first. [[ [[<- operators allow operating recursive subset nested list. operate single recursive subset, vectorized multiple recursive subsets nested list . ‘squarebrackets’ provides way reshape nested list recursive matrix, thereby allowing vectorized operations recursive subsets nested list. [<- operator supports copy--modify semantics classes. ‘squarebrackets’ methods provides explicit pass--reference pass--value semantics, whilst still respecting things like binding-locks mutability rules. ‘squarebrackets’ supports index-less sub-set operations, memory efficient long vectors sub-set operations using [ [<- operators.  ","code":""},{"path":"https://tony-aw.github.io/squarebrackets/index.html","id":"get-started","dir":"","previous_headings":"","what":"Get Started","title":"Subset Methods as Alternatives to the Square Brackets Operators for Programming","text":"get started see ?squarebrackets_help  ","code":""},{"path":"https://tony-aw.github.io/squarebrackets/index.html","id":"installing--loading","dir":"","previous_headings":"","what":"Installing & Loading","title":"Subset Methods as Alternatives to the Square Brackets Operators for Programming","text":"One can install ‘squarebrackets’ GitHub like : Special care taken make sure function names clear, function names unlikely conflict core R, recommended R packages, rstudioapi package, major packages fastverse. one can attach package - thus exposing functions namespace - using:  ","code":"remotes::install_github(\"https://github.com/tony-aw/squarebrackets\") library(squarebrackets)"},{"path":"https://tony-aw.github.io/squarebrackets/index.html","id":"changelog-experimental-versions","dir":"","previous_headings":"","what":"Changelog (EXPERIMENTAL VERSIONS)","title":"Subset Methods as Alternatives to the Square Brackets Operators for Programming","text":"10 March 2024: First GitHub upload - Package much experimental. 12 March 2024: Changed introduction help page bit, added dt_setadd(), added tests dt_ - functions. slightly 50,000 tests now. 15 March 2024: Added sb_setRename() method, added tests method also. 16 March 2024: Fixed bug “rcpp_set_rowcol” source code. Tweaked documentation bit. Improved tests bit. 17 March 2024: Added tests, tweaked documentation bit. 19 March 2024: methods/functions support mutable_atomic type “complex”; now fixed. Added support mutable_atomic type “raw”. Added tests atomic type handling. Added functions ma_setv(), couldb.mutable_atomic(). Added options “sb.rat” “sb.chkdup”; argument chkdup now also set FALSE default. Added badges documentation. 20 March 2024: user can now also specify coe = TRUE sb_mod.data.frame(). 24 March 2024: Methods now split methods non-recursive objects (sb_), methods recursive objects (sb2_). 26 March 2024: Replaced seq_rec() seq_rec2(). 27 March 2024: Added dt_setreorder(), added tests also. ‘abind’ now dependency, ‘abind’ based code removed, redundant. 29 March 2024: Added sb2_before.array() sb2_after.array(), added tests also. Added tests data.frame-like coercion types. Tweaked documentation bit. 30 March 2024: Removed separate NA checks, redundant. Fixed linguistic mistakes documentation. 1 April 2024: Removed sb_coe() kept sb2_coe(). Added inv argument sb_mod()/sb2_mod(), sb_set()/sb2_set(), sb2_coe(), added tests . Added idx1() Copy--Modification Substitution, added tests idx1() also.Fixed bug character subset ordering sb/sb2_mod/set/coe - generic methods. Fixed bug introduction message. Added even tests. Added idx1_dim(), added tests also. 5 April 2024: Replaced idx1/idx0 idx(). 18 May 2024: Added tests idx() method (need add ). Fixed export pattern expressions Namespace file. Adjusted documentation. 26 May 2024: Removed sb2_coe(), redundant. 6 June 2024: Removed sb(2)_before/methods favour new bind_/bind2_ implementations. Added lst_ functions. Added options help page. 30 June 2024: Re-written internal code arrays. Added support backward indexing via Complex Vector indices. Added tests. Replaced seq_names() new far flexible idx_r() function. 31 August 2024: Made tests efficient. Removed separate method dispatch factors, using default atomic vector method dispatch sufficient factors. 7 September 2024: Incorporated ALTREP functionality package. 15 September 2024: Replaced drop argument red avoid confusion base R’s drop mechanic. Small performance improvements sub2ind() sb_set.array(). 26 September 2024: Overhauled indexing complex vectors work. 28 September 2024: Split sb(2)_setRename() sb_setFlatnames(), sb_setDimnames(), sb2_setVarnames(). 10 October 2024: sb_mod() now makes partial copies data.frame-like objects instead whole copies, memory efficiency. Also removed old sb_str() sb_a() functions. Renamed ci_seq() cp_seq() (preparation next update). 19 October 2024: Removed renaming methods (sb_setRename), seq_rec2(). Added slcseq_. 5 November 2024: Renamed slcseq_ slice_. Re-organized documentation bit. Fixed examples ci tci help pages. Added bind_mat() bind2_mat(). Added ndims(). 14 November 2024: Performance improvement match_all(). 21 November 2024: Improved documentation. Slightly tweaked array argument usage. Added sticky option. Brought back renaming methods. Changed behaviour use.names argument lst_untree(). 24 November 2024: Matrices now use API arrays. Adjusted documentation accordingly. Cleaned internal code bit. 30 November 2024: binding implementations can now bind mixtures atomic recursive objects. 5 December 2024: replaced _rm post-fixes _wo methods, avoid confusion. Coercion data.frame-like objects now happens automatically, needed, sb2_mod() method, updated documentation accordingly. Slightly re-organized documentation.  ","code":""},{"path":"https://tony-aw.github.io/squarebrackets/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 Tony Wilkes Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa00_squarebrackets_help.html","id":null,"dir":"Reference","previous_headings":"","what":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa00_squarebrackets_help","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa00_squarebrackets_help","text":"squarebrackets:  Subset Methods Alternatives Square Brackets Operators Programming.  'squarebrackets' provides subset methods (supporting atomic recursive S3 classes) may convenient alternatives [ [<- operators, whilst maintaining similar performance.  nice properties methods include, limited , following. [ [<- operators use different rule-sets different data.frame-like types (data.frames, data.tables, tibbles, tidytables, etc.).  'squarebrackets' methods use rule-sets different data.frame-like types. Performing dimensional subset operations array using [ [<-, requires -priori knowledge number dimensions array .  'squarebrackets' methods work arbitrary dimensions without requiring prior knowledge. selecting names [ [<- operators, first occurrence names selected case duplicate names.  'squarebrackets' methods always perform names case duplicates, just first. [[ [[<- operators allow operating recursive subset nested list.  operate single recursive subset, vectorized multiple recursive subsets nested list .  'squarebrackets' provides way reshape nested list recursive matrix, thereby allowing vectorized operations recursive subsets nested list. [<- operator supports copy--modify semantics classes.  'squarebrackets' methods provides explicit pass--reference pass--value semantics, whilst still respecting things like binding-locks mutability rules. 'squarebrackets' supports index-less sub-set operations, memory efficient sub-set operations using [ [<- operators.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa00_squarebrackets_help.html","id":"goal","dir":"Reference","previous_headings":"","what":"Goal","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa00_squarebrackets_help","text":"Among programming languages, 'R' perhaps one flexible comprehensive sub-setting functionality, provided square brackets operators ([, [<-).  situations square brackets operators occasionally less optimally convenient  Goal 'squarebrackets' package replace square-brackets operators, provide alternative sub-setting methods functions, used situations square bracket operators inconvenient.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa00_squarebrackets_help.html","id":"supported-structures","dir":"Reference","previous_headings":"","what":"Supported Structures","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa00_squarebrackets_help","text":"'squarebrackets' supports common S3 classes, primarily use square brackets sub-setting (hence name package).  'squarebrackets' supports following structures: basic atomic classes  (atomic vectors, matrices, arrays). mutable_atomic classes  (mutable_atomic vectors, matrices, arrays). factor. basic list classes  (recursive vectors, matrices, arrays). data.frame  (including classes tibble, sf-data.frame sf-tibble). data.table  (including classes tidytable, sf-data.table, sf-tidytable). See squarebrackets_supported_structures details.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa00_squarebrackets_help.html","id":"sub-set-operation-methods-amp-binding-implementations","dir":"Reference","previous_headings":"","what":"Sub-set Operation Methods & Binding Implementations","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa00_squarebrackets_help","text":"main focus package generic methods dimensional binding implementations.  Generic methods atomic objects start sb_.  Generic methods recursive objects (list, data.frame, etc.) start sb2_.  also somewhat separate idx method, works recursive non-recursive objects.  binding implementations dimensional objects start bind_.  finally slice_ methods, (currently) work (mutable) atomic vectors.  Methods access subsets (.e. extract selection, extract except selection): sb_x, sb2_x: extract, exchange, duplicate subsets. sb_wo,  sb2_wo: return object without specified subset. sb2_rec: access recursive subsets lists. slice_x, slice_wo: efficiently extract subset long vector, return long vector without subset.  Methods modify subsets: idx: translate given indices/subscripts, purpose copy--modify substitution. sb2_recin: replace, transform, remove, add recursive subsets list, R's default Copy--Modify semantics. sb_mod, sb2_mod: return object modified (transformed replaced) subsets. Methods rename mutable object using pass--reference semantics. sb_set, sb2_set: modify (transform replace) subsets mutable object using pass--reference semantics. slice_set: efficiently modify (long) vector subset using pass--reference semantics.  Methods binding implementations, extend re-arrange object beyond current size: bind_:  implementations binding dimensional objects. sb_x, sb2_x: extract, exchange, duplicate subsets. sb2_recin: replace, transform, remove, add recursive subsets list, R's default Copy--Modify semantics. See squarebrackets_method_dispatch information 'squarebrackets' uses S3 Method dispatch.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa00_squarebrackets_help.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa00_squarebrackets_help","text":"Additional specialized sub-setting functions provided: lst_untree: unnest tree-like nested list recursive matrix, speed-vectorized sub-setting recursive subsets list. dt_-functions programmatically perform data.table-specific [-operations, security measures provided 'squarebrackets' package. setapply: apply functions mutable matrix margins using pass--reference semantics. ma_setv: Find & Replace values mutable_atomic objects using pass--reference semantics.  considerably faster memory efficient using sb_set . couple convenience functions, helper functions creating ranges, sequences, indices (often needed sub-setting) provided: currentBindings: list lock currently existing bindings share share address input variable. n: Nested version c, short-hand list. ndims: Get number dimensions object. sub2coord, coord2ind: Convert subscripts (array indices) coordinates, coordinates flat indices, vice-versa. match_all: Find matches, one vector another, taking account order duplicate values vectors. Computing indices: idx_r compute integer index range. idx_by compute grouped indices. idx_ord_-functions compute ordered indices.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa00_squarebrackets_help.html","id":"overview-help-pages","dir":"Reference","previous_headings":"","what":"Overview Help Pages","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa00_squarebrackets_help","text":"Besides website, 'squarebrackets' comes several help pages can accessed within 'R'. MAIN DOCUMENTATION: squarebrackets_supported_structures:  lists structures supported 'squarebrackets', explains related terminology. squarebrackets_indx_fundamentals:  explains essential fundamentals indexing forms 'squarebrackets'. squarebrackets_indx_args:  explains common indexing arguments used main S3 methods. squarebrackets_modify:  explains essentials modification 'squarebrackets' squarebrackets_options:  lists explains options user can specify 'squarebrackets'. squarebrackets_method_dispatch:  gives details regarding S3 method dispatch 'squarebrackets'. PASS--REFERENCE DOCUMENTATION: planning using pass--reference functionality 'squarebrackets', need read following help pages: squarebrackets_PassByReference:  explains Pass--Reference semantics, important consequences. squarebrackets_coercion:  explains difference coercion rules modification Pass--Reference semantics modification copy (.e. pass--value) supported mutable structures.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa00_squarebrackets_help.html","id":"properties-details","dir":"Reference","previous_headings":"","what":"Properties Details","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa00_squarebrackets_help","text":"alternative sub-setting methods functions provided 'squarebrackets' following properties: Programmatically friendly: Unlike base [, required know number dimensions array -priori, perform subset-operations array. Missing arguments can filled NULL, instead using dark magic like base::quote(expr =    ). Non-standard evaluation. Functions pipe-friendly. (silent) vector recycling. Extracting removing subsets uses syntax. Class consistent: sub-setting multi-dimensional objects specifying dimensions (.e. rows, columns, ...) use drop = FALSE.  matrix , matrix . methods deliver results data.frames, data.tables, tibbles, tidytables.  longer one re-learn different brackets-based sub-setting rules different types data.frame-like objects.  Powered subclass agnostic 'C'-code 'collapse' 'data.table'. Explicit copy semantics: Sub-set operations change memory allocations, always return modified (partial) copy object. sub-set operations just change values -place (similar [<- [[<- methods) user can choose method modifies object reference, choose method returns (partial) copy. Careful handling names: Sub-setting object index names returns matches given names, just first. Data.frame-like objects (see supported classes ) forced unique column names. Sub-setting arrays using x[indx1, indx2, etc.] drop names(x).  methods 'squarebrackets' drop names(x). Concise function argument names. Performance aware:  Despite many checks performed, functions kept reasonably speedy, use 'Rcpp', 'collapse', 'data.table' R-packages.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa00_squarebrackets_help.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa00_squarebrackets_help","text":"badges shown documentation R-package made using services : https://shields.io/","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa00_squarebrackets_help.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa00_squarebrackets_help","text":"Author, Maintainer: Tony Wilkes tony_a_wilkes@outlook.com (ORCID)","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa01_squarebrackets_supported_structures.html","id":null,"dir":"Reference","previous_headings":"","what":"Supported Structures — aaa01_squarebrackets_supported_structures","title":"Supported Structures — aaa01_squarebrackets_supported_structures","text":"'squarebrackets' supports common S3 objects, primarily use square brackets sub-set operations (hence name package).  One can generally divide structures supported 'squarebrackets' along 3 key properties: atomic vs recursive:  Types logical, integer, double, complex, character, raw atomic.  Lists data.frames recursive. dimensionality:  Whether object vector, matrix, array, data.frame. mutability:  Base R's S3 classes (except Environments) generally immutable:  Modifying object create copy (called 'copy--modify').  'squarebrackets also supports data.tables mutable_atomic objects, mutable:  desired, one can modify without copy using pass--reference semantics. Supported Structures 'squarebrackets' supports following immutable structures: basic atomic classes  (atomic vectors, matrices, arrays). factor. basic list classes  (recursive vectors, matrices, arrays). data.frame  (including classes tibble, sf-data.frame sf-tibble). 'squarebrackets' supports following mutable structures: mutable_atomic  (mutable_atomic vectors, matrices, arrays); data.table  (including classes tidytable, sf-data.table, sf-tidytable).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa01_squarebrackets_supported_structures.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Supported Structures — aaa01_squarebrackets_supported_structures","text":"Atomic vs Recursive  sb_ methods provided 'squarebrackets' work atomic (see .atomic) objects.  sb2_ methods provided 'squarebrackets' work recursive (see .recursive) objects.  See squarebrackets_method_dispatch details method dispatch used 'squarebrackets'. Dimensionality  'squarebrackets' supports dimensionless vector objects (.e. ndims == 0L).  squarebrackets' supports arrays (see .array .matrix); note matrix simply array 2 dimensions.  'squarebrackets' also supports data.frame-like objects (see .data.frame).  Specifically, squarebrackets' supports wide variety data.frame classes: data.frame, data.table, tibble, tidytable;  'squarebrackets' also supports 'sf'-package compatible counter-parts: sf-data.frame, sf-data.table, sf-tibble, sf-tidytable.  Dimensionless vectors dimensional arrays supported atomic recursive forms.  Data.frame-like objects, contrast, exist recursive form (, stated, supported 'squarebrackets').  Recursive vectors, recursive matrices, recursive arrays, collectively referred \"lists\" 'squarebrackets' documentation.  Note dimensionality data.frame-like objects dimensionality (recursive) arrays/matrices.  array/matrix x, holds length(x) == prod(dim(x)).  data.frame x, case length(x) == ncol(x). Mutable vs Immutable  base R's S3 classes (except Environments) generally immutable:  Modifying object create copy (called 'copy--modify').  explicit pass--reference semantics.  S3 objects base 'R' immutable:  Environments pass--reference semantics, supported 'squarebrackets'.  'squarebrackets' supports mutable data.table class (thus also tidytable, inherits data.table).  'squarebrackets' also includes new class mutable objects: mutable_atomic objects. mutable_atomic objects atomic objects, except mutable (hence name).  supported immutable structures :  Atomic recursive vectors/matrices/arrays, data.frames, tibbles.  functions 'squarebrackets' package word \"set\" name perform pass--reference modification, thus work mutable structures.  functions work way mutable immutable structures. Derived Atomic Vector  special class objects Derived Atomic Vector structures:  structures derived atomic objects, behave differently.  example:  Factors, datetime, POSIXct derived atomic vectors.  attributes special methods make behave differently.  'squarebrackets' treats derived atomic classes regular atomic vectors.  highly specialized packages handle objects derived atomic objects.  example, 'anytime' package handle date-time objects.  'squarebrackets provide explicit support factors. Supported S3 structures  Key-Values storage S3 structures, environments, supported 'squarebrackets'.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa02_squarebrackets_indx_fundamentals.html","id":null,"dir":"Reference","previous_headings":"","what":"Indexing Fundamentals — aaa02_squarebrackets_indx_fundamentals","title":"Indexing Fundamentals — aaa02_squarebrackets_indx_fundamentals","text":"help page explains fundamentals regarding 'squarebrackets' treats indexing.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa02_squarebrackets_indx_fundamentals.html","id":"indexing-types","dir":"Reference","previous_headings":"","what":"Indexing Types","title":"Indexing Fundamentals — aaa02_squarebrackets_indx_fundamentals","text":"Base 'R' supports indexing logical, integer, character vectors.  'squarebrackets' supports also (albeit improvements), also supports additional methods indexing. Whole numbers  Whole numbers basic form index selection.  forms indexing 'squarebrackets' internally translated integer (double > (2^31 - 1)) indexing first, ensuring consistency.  Indexing integer/numeric indices 'squarebrackets' works base 'R', except negative values allowed.  indexing starts 1, inclusive (matching indices selected). Logical  Selecting indices logical vector 'squarebrackets' works base 'R', except recycling allowed. Characters  selecting indices using character vector, base 'R' selects first matches names.  'squarebrackets', however, selects matches:   Character indices internally translated integer indices using match_all. Imaginary Numbers  complex vector y structured y = + b *  Re(y) returns , Im(y) returns b.  squarebrackets' includes support indexing imaginary numbers (Im(y)) complex vectors.  Indexing imaginary numbers generalization indexing regular integers.  works follows:  Imaginary numbers positive integers, like 1:10 * 1i, work regular integers.  Imaginary numbers negative integers, like 1:10 * -1i, index counting backwards (.e. end).  Note Imaginary part complex vector used (Im(y));  Real part (Re(y)) ignored.  See results following code example:   Thus complex vectors allow user choose counting beginning, like regular integers, backwards counting end.","code":"nms <- c(\"a\", letters[4:1], letters[1:5]) x <- 1:10 names(x) <- nms print(x) #' `x` has multiple elements with the name \"a\" #>  a  d  c  b  a  a  b  c  d  e  #>  1  2  3  4  5  6  7  8  9 10  sb_x(x, \"a\") # extracts all indices with the name \"a\" #> a a a  #> 1 5 6  sb_x(x, c(\"a\", \"a\")) # repeats all indices with the name \"a\" #> a a a a a a  #> 1 5 6 1 5 6 x <- 1:30 # vector of 30 elements  sb_x(x, 1:10 * 1i) # extract first 10 elements #>  [1]  1  2  3  4  5  6  7  8  9 10  sb_x(x, 1:10 * -1i) # extract last 10 elements #>  [1] 30 29 28 27 26 25 24 23 22 21  sb_x(x, 10:1 * -1i) # last 10 elements, in tail()-like order #>  [1] 21 22 23 24 25 26 27 28 29 30"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa02_squarebrackets_indx_fundamentals.html","id":"basic-indexing-in-dimensionless-vectors","dir":"Reference","previous_headings":"","what":"Basic Indexing in Dimensionless Vectors","title":"Indexing Fundamentals — aaa02_squarebrackets_indx_fundamentals","text":"Indexing vector straight-forward, similar base 'R'.  expression like sb_x(x, ), example, equivalent x[].","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa02_squarebrackets_indx_fundamentals.html","id":"basic-indexing-in-arrays","dir":"Reference","previous_headings":"","what":"Basic Indexing in Arrays","title":"Indexing Fundamentals — aaa02_squarebrackets_indx_fundamentals","text":"Arrays matrices (matrices simply arrays 2 dimensions) distinguish flat indices subscripts.  Flat indices, also called linear indices, specifies indices array -vector, thus ignoring dimensions.  expression like sb_x(x, ) (equivalent x[]), vector, specifies flat indices.  Matrices arrays also subscripts.  Array subscripts work specifying multiple indexing vectors, can different sizes, vector specifies positions specific dimension.  Given, example, 3-dimensional array, subscript (1:10, 2:5, 3:9), refers rows 1 10, columns 2 5, layers 3 9.  base S3 vector classes 'R' use standard Linear Algebraic convention, academic fields like Mathematics Statistics, following sense: vectors column vectors (.e. vertically aligned vectors); index counting starts 1; rows first dimension/subscript, columns second dimension/subscript, etc. Thus, orientation flat indices , example, 4-rows--5-columns matrix, follows:   4 4 matrix, subscript (1, 2) corresponds flat index 5.  array subscripts 'squarebrackets' also follow convention.  S3 methods 'squarebrackets' implement subscripts sub, dims argument pair.  argument pair allows specifying indices array, without requiring -priori knowledge number dimensions array .","code":"[,1] [,2] [,3] [,4] [,5]  [1,]    1    5    9   13   17  [2,]    2    6   10   14   18  [3,]    3    7   11   15   19  [4,]    4    8   12   16   20"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa02_squarebrackets_indx_fundamentals.html","id":"basic-indexing-in-data-frame-like-objects","dir":"Reference","previous_headings":"","what":"Basic Indexing in data.frame-like Objects","title":"Indexing Fundamentals — aaa02_squarebrackets_indx_fundamentals","text":"Data.frames distinguish row- column indices.  equivalent base 'R'.  Technically speaking, column indices data.frame-like object equal flat indices.  .e. data.frame, x[] essentially x[, ], safe attribute handling.  avoid confusion, 'squarebrackets' argument flat indices data.frame methods.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa02_squarebrackets_indx_fundamentals.html","id":"inverting","dir":"Reference","previous_headings":"","what":"Inverting","title":"Indexing Fundamentals — aaa02_squarebrackets_indx_fundamentals","text":"Inverting indices entails specify elements except given indices.  Consider example atomic vector month.abb (abbreviate month names).  Given vector, indices 1:5 gives c(\"Jan\" \"Feb\" \"Mar\" \"Apr\", \"May\").  Inverting indices give c(\"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\").  base 'R', inverting index done different ways.  (negative numbers numeric indexing, negation logical indexing, manually un-matching character vectors).  'squarebrackets' provides (somewhat) consistent syntax invert indices: methods end _x perform extraction;  invert extraction, .e. return object without specified subset, use methods end _wo. modification methods (_mod_/_set_) one can set argument inv = TRUE invert indices. NOTE ORDERING  order user gives indices inverting indices generally matter.  order indices appear original object x maintained, just like base 'R'.  Therefore, replacing multiple values order replacement matters, better keep inv = FALSE, default.  replacement single value transformation function, inv = TRUE can used without considering ordering. EXAMPLES   ___","code":"x <- month.abb print(x) #>  [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\"   sb_x(x, 1:5) # extract first 5 elements #> [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\"  sb_wo(x, 1:5) # return WITHOUT first 5 elements #> [1] \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\"   sb_mod(x, 1:5, rp = \"XXX\") # copy, replace first 5 elements, return result #>  [1] \"XXX\" \"XXX\" \"XXX\" \"XXX\" \"XXX\" \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\"  sb_mod(x, 1:5, inv = T, rp = \"XXX\") # same, but for all except first 5 elements #>  [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"XXX\" \"XXX\" \"XXX\" \"XXX\" \"XXX\" \"XXX\" \"XXX\""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa02_squarebrackets_indx_fundamentals.html","id":"regarding-performance","dir":"Reference","previous_headings":"","what":"Regarding Performance","title":"Indexing Fundamentals — aaa02_squarebrackets_indx_fundamentals","text":"Integer vectors created : operator \"ALTREP\" integer vectors, provide fastest way specify indices.  Indexing names (.e. character vectors) slowest.  Complex vectors imaginary numbers somewhat middle terms speed. performance important, use ALTREP integer indices.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa02_squarebrackets_indx_fundamentals.html","id":"indexing-in-recursive-subsets","dir":"Reference","previous_headings":"","what":"Indexing in Recursive Subsets","title":"Indexing Fundamentals — aaa02_squarebrackets_indx_fundamentals","text":"now help page focussed indexing regular (\"shallow\") subsets.  section discuss indexing recursive subsets.  One differences atomic recursive objects, recursive objects support recursive subsets, atomic objects .  Bear mind every element recursive object reference another object.  Consider following list x:   Regular subsets, AKA surface-level subset operations ([, [<- base 'R'), operate recursive object .  .e. sb2_x(x, 1), equivalently x[1], returns list list(= 1:10):   Recursive subset operations ([[, [[<- base 'R'), hand, operate object subset recursive object references .  .e. sb2_rec(x, 1), equivalently x[[1]], returns integer vector 1:10:   Recursive objects can refer recursive objects, can refer recursive objects, .  Recursive subsets can go however deep want.  , example, extract character vector month.abb aforementioned list x, one need : sb2_rec(x, c(\"C\",\"B\")), (base R: x[[\"C\"]][[\"B\"]]):   IMPORTANT  Indexing recursive subsets significantly limited regular (\"shallow\") subsets: Recursive subset operations using sb2_rec/sb2_recin support positive integer vectors character vectors. Imaginary numbers (using complex vectors) logical vectors supported. Since recursive subset operation operates single element, specifying index character vector selects first matching element (just like base 'R'), matches. Inverting indices also available recursive indexing.","code":"x <- list(    A = 1:10,    B = letters,    C = list(A = 11:20, B = month.abb) ) sb2_x(x, 1) # equivalent to x[1]; returns list(A = 1:10) #> $A #>  [1]  1  2  3  4  5  6  7  8  9 10 sb2_rec(x, 1) # equivalent to x[[1]]; returns 1:10 #>  [1]  1  2  3  4  5  6  7  8  9 10 sb2_rec(x, c(\"C\",\"B\")) # equivalent to x[[\"C\"]][[\"B\"]] #>  [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\"  # or:  sb2_rec(x, c(3, 2)) # equivalent to x[[3]][[2]] #>  [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa03_squarebrackets_indx_args.html","id":null,"dir":"Reference","previous_headings":"","what":"Index Arguments in the Generic Sub-setting Methods — aaa03_squarebrackets_indx_args","title":"Index Arguments in the Generic Sub-setting Methods — aaa03_squarebrackets_indx_args","text":"several types arguments can used generic methods 'squarebrackets' specify indices perform operations : : specify flat (.e. dimensionless) indices. sub, dims: specify indices arbitrary dimensions arrays (including matrices, inherit arrays). margin, slice: specify indices one particular dimension. row, col: specify rows /columns specifically data.frame-like objects. filter, vars: specify rows /columns specifically data.frame-like objects. Thus essentially 3 APIs: one vectors, one arrays matrices, one data.frame-like objects.  fundamentals indexing 'squarebrackets', see squarebrackets_indx_fundamentals.  help page x refers object subset operations performed.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa03_squarebrackets_indx_args.html","id":"argument-i","dir":"Reference","previous_headings":"","what":"Argument i","title":"Index Arguments in the Generic Sub-setting Methods — aaa03_squarebrackets_indx_args","text":"following can specified argument : NULL, corresponds missing argument. vector length 0, case indices selected operation (.e. empty selection). numeric vector strictly positive whole numbers indices. complex vector, explained squarebrackets_indx_fundamentals. logical vector, length x, giving indices select operation. character vector index names.  object multiple indices given name, corresponding indices selected operation. function takes input x, returns logical vector, giving element indices select operation.  atomic objects, interpreted (x).  recursive objects, interpreted lapply(x, ). Using arguments corresponds something like following:   function, corresponds following:","code":"sb_x(x, i = i) # ==> x[i]   # if `x` is atomic  sb2_x(x, i = i) # ==> x[i]  # if `x` is recursive sb_x(x, i = i) # ==> x[i(x)] # if `x` is atomic  sb2_x(x, i = i) # ==> x[lapply(x, i)] # if `x` is recursive"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa03_squarebrackets_indx_args.html","id":"argument-pair-sub-dims","dir":"Reference","previous_headings":"","what":"Argument Pair sub, dims","title":"Index Arguments in the Generic Sub-setting Methods — aaa03_squarebrackets_indx_args","text":"sub, dims argument pair inspired abind::asub function 'abind' package (see reference ).  sub argument specifies subscripts.  dims argument gives dimensions subscripts sub holds (.e. dims specifies \"non-missing\" margins).  dims argument must integer vector. sub must either following: list length length(dims). list length 1;  case sub recycled length(dims). atomic vector;  functionally equivalent specifying sub list length 1. element sub sub list, sub sub atomic vector, can following: vector length 0, case indices selected operation (.e. empty selection). numeric vector strictly positive whole numbers indices specified dimension select operation. complex vector, explained squarebrackets_indx_fundamentals. logical vector length corresponding dimension size, giving indices specified dimension select operation. character vector giving dimnames select.  dimension multiple indices given name, corresponding indices selected operation. Note also following: stated, dims specifies index margins non-missing.  dims length 0, taken \"index margins missing\". default value dims 1:ndims(x). keep syntax short, user can use n function instead list() specify sub.  examples clarity, using atomic array x 3 dimensions: sb_x(x, n(1:10, 1:5), c(1, 3))  extracts first 10 rows, columns, first 5 layers, array x.  equivalence base 'R' : x[1:10, , 1:5, drop = FALSE]. sb_x(x, 1:10, 2)  extracts first 10 columns array x.  equivalence base 'R' : x[, 1:10, , drop = FALSE] sb_x(x, 1:10),  extracts first 10 rows, columns, layers array x.  equivalence base 'R' : x[1:10, 1:10, 1:10, drop = FALSE]. sb_x(x, 1:10, c(1, 3)),  extracts first 10 rows, columns, first 10 layers, array x.  equivalence base 'R' : x[1:10, , 1:10, drop = FALSE]. .e.:   Note specifying list length 1 sub (like sub = n(1:10)) equivalent specifying atomic vector sub (like sub = 1:10).  brief explanation relationship flat indices (), dimensional subscripts (sub, dims), see squarebrackets_indx_fundamentals.","code":"sb_x(x, n(1:10, 1:5), c(1, 3)) # ==> x[1:10, , 1:5, drop = FALSE]  sb_x(x, 1:10, 2)               # ==> x[ , 1:10, , drop = FALSE]  sb_x(x, 1:10)                  # ==> x[1:10, 1:10, 1:10, drop = FALSE]  sb_x(x, 1:10, c(1, 3))         # ==> x[1:10, , 1:10, drop = FALSE]"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa03_squarebrackets_indx_args.html","id":"argument-pair-margin-slice","dir":"Reference","previous_headings":"","what":"Argument Pair margin, slice","title":"Index Arguments in the Generic Sub-setting Methods — aaa03_squarebrackets_indx_args","text":"Relevant idx method.  margin argument specifies dimension argument slice used.  .e. margin = 1, slice selects rows;  margin = 2, slice selects columns;  etc.  slice argument can following: numeric vector strictly positive whole numbers dimension indices select operation. complex vector, explained squarebrackets_indx_fundamentals. logical vector length corresponding dimension size, giving dimension indices select operation. character vector index names.  dimension multiple indices given name, corresponding indices selected operation. One also give vector length 0 slice;  Argument slice used idx method , result idx meant used inside regular [ [<- operators.  Thus effect zero-length index specification depends rule-set [.class(x) [<-.class(x).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa03_squarebrackets_indx_args.html","id":"arguments-row-col","dir":"Reference","previous_headings":"","what":"Arguments row, col","title":"Index Arguments in the Generic Sub-setting Methods — aaa03_squarebrackets_indx_args","text":"following can specified arguments row / col: NULL (default), corresponds missing argument. vector length 0, case indices selected operation (.e. empty selection). numeric vector strictly positive whole numbers indices specified dimension select operation. complex vector, explained squarebrackets_indx_fundamentals. logical vector length corresponding dimension size, giving indices specified dimension select operation. character vector giving dimnames select.  dimension multiple indices given name, corresponding indices selected operation. Using row, col arguments corresponds something like following:","code":"sb2_x(x, row, col) # ==> x[row, col, drop = FALSE]"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa03_squarebrackets_indx_args.html","id":"arguments-filter-vars","dir":"Reference","previous_headings":"","what":"Arguments filter, vars","title":"Index Arguments in the Generic Sub-setting Methods — aaa03_squarebrackets_indx_args","text":"filter must one-sided formula single logical expression using column names data.frame, giving condition observation/row indices selected operation.  example, perform operation rows column height > 2 column sex != \"female\", specify following formula:   formula linked environment, variables found data set searched environment. vars must function returns logical vector, giving column indices select operation.  example, select numeric columns, specify vars = .numeric.","code":"~ (height > 2) & (sex != \"female\")"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa03_squarebrackets_indx_args.html","id":"argument-inv","dir":"Reference","previous_headings":"","what":"Argument inv","title":"Index Arguments in the Generic Sub-setting Methods — aaa03_squarebrackets_indx_args","text":"Relevant sb_mod/sb2_mod, sb_set/sb2_set, idx methods.  default, inv = FALSE, translates indices like normally.  inv = TRUE, inverse indices taken.  Consider, example, atomic matrix x;  using sb_mod(x, 1:2, 2L, tf = tf) corresponds something like following:   using sb_mod(x, col = 1:2, inv = TRUE, tf = tf) corresponds something like following:   NOTE  order user gives indices inv = TRUE generally matter.  order indices appear original object x maintained, just like base 'R'.  Therefore, replacing multiple values order replacement matters, better keep inv = FALSE, default.  replacement single value transformation function, inv = TRUE can used without considering ordering.","code":"x[, 1:2] <- tf(x[, 1:2]) x x[, -1:-2] <- tf(x[, -1:-2]) x"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa03_squarebrackets_indx_args.html","id":"all-null-indices","dir":"Reference","previous_headings":"","what":"All NULL indices","title":"Index Arguments in the Generic Sub-setting Methods — aaa03_squarebrackets_indx_args","text":"NULL indexing arguments corresponds missing argument.  Thus, sb_x/sb2_x sb_wo/sb2_wo, using NULL indexing arguments corresponds something like following:   Similarly, sb_mod/sb2_mod sb_set/sb2_set, using NULL corresponds something like following:   true even inv = TRUE /red = TRUE.","code":"x[] x[] <- rp # for replacement x[] <- tf(x) # for transformation"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa03_squarebrackets_indx_args.html","id":"out-of-bounds-integers-non-existing-names-and-nas","dir":"Reference","previous_headings":"","what":"Out-of-Bounds Integers, Non-Existing Names, and NAs","title":"Index Arguments in the Generic Sub-setting Methods — aaa03_squarebrackets_indx_args","text":"Integer indices bounds (including NaN NA_integer_) always give error. Specifying non-existing names (including NA_character_) indices considered form zero-length indexing. Logical indices translated internally integers using , NAs ignored.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa03_squarebrackets_indx_args.html","id":"disallowed-combinations-of-index-arguments","dir":"Reference","previous_headings":"","what":"Disallowed Combinations of Index Arguments","title":"Index Arguments in the Generic Sub-setting Methods — aaa03_squarebrackets_indx_args","text":"One specify  indexing arguments simultaneously; either , arguments.  One specify row filter simultaneously; either one .  One specify col vars simultaneously; either one .  One specify sub, dims pair slice, margin pair simultaneously; either one pair pair.  cases holds one set specified, set ignored.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa03_squarebrackets_indx_args.html","id":"drop","dir":"Reference","previous_headings":"","what":"Drop","title":"Index Arguments in the Generic Sub-setting Methods — aaa03_squarebrackets_indx_args","text":"Sub-setting generic methods 'squarebrackets' R-package using dimensional arguments (sub, dims, row, col filter, vars) always use drop = FALSE.  drop potentially redundant (.e. single level) dimensions, use drop function, like :","code":"sb_x(x, sub, dims) |> drop() # ==> x[..., drop = TRUE]"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa03_squarebrackets_indx_args.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Index Arguments in the Generic Sub-setting Methods — aaa03_squarebrackets_indx_args","text":"Plate T, Heiberger R (2016). abind: Combine Multidimensional Arrays. R package version 1.4-5, https://CRAN.R-project.org/package=abind.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa04_squarebrackets_method_dispatch.html","id":null,"dir":"Reference","previous_headings":"","what":"Method Dispatch of 'squarebrackets' — aaa04_squarebrackets_method_dispatch","title":"Method Dispatch of 'squarebrackets' — aaa04_squarebrackets_method_dispatch","text":"help page gives additional details regarding S3 method dispatch used 'squarebrackets'.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa04_squarebrackets_method_dispatch.html","id":"atomic-vs-recursive","dir":"Reference","previous_headings":"","what":"Atomic vs Recursive","title":"Method Dispatch of 'squarebrackets' — aaa04_squarebrackets_method_dispatch","text":"Atomic recursive objects quite different ways: homo- heterogeneous: atomic object can values one data type.  recursive objects can hold values combination data types. nesting: Recursive objects can nested, atomic objects nested. copy coercion effect: One can coerce copy subset recursive object, without copying rest object.  atomic objects, however, coercion copy operation coerces copies entire vector (ignoring attributes). vectorization: vectorized operations generally work atomic objects, whereas recursive objects often require loops apply-like functions. recursive subsets: Recursive objects distinguish \"regular\" subset operations (base R using [, [<-), recursive subset operations (base R using [[, [[<-).  See example sb2_rec method, red = TRUE argument sb2_x sb2_wo methods.  atomic objects, 2 meaningful difference (safe perhaps minor attribute handling). views: recursive objects, one can create view recursive subset.  Subset views exist atomic objects. main S3 methods perform subset operation object, come atomic (sb_) recursive (sb2_) form.  idx method operates indices object, operate object , distinction atomic recursive form.  split atomic recursive forms method dispatches done several reasons: many nuances keep track user atomic recursive objects.  splitting methods atomic recursive objects, user choose sb_ sb2_, 'squarebrackets' can handle rest user. giving atomic recursive separate methods, becomes syntactically clear consequences subset-operation:  entire object coerced copied? transformation function go lapply? operation affecting shallow subsets? etc. S3 classes, like array matrix classes, available atomic recursive forms.  S3 method dispatch distinguish atomic recursive objects, despite aforementioned differences 2.  'squarebrackets' uses separate method dispatch atomic recursive form. Package authors can create separate sub-set operation methods atomic recursive objects using 'squarebrackets'.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa04_squarebrackets_method_dispatch.html","id":"manual-dispatch","dir":"Reference","previous_headings":"","what":"Manual Dispatch","title":"Method Dispatch of 'squarebrackets' — aaa04_squarebrackets_method_dispatch","text":"'squarebrackets' package intentionally exports function S3 method dispatch system.  handy programming purposes.  example: one can explicitly alias specific dispatch method, one desires.  example like :   certain circumstances, might help code clear.","code":"array_x <- function(x, ...) {     if(is.atomic(x)) {      sb_x.array(x, ...)    }    else if(is.recursive(x)) {      sb2_x.array(x, ...)    }     }"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa04_squarebrackets_method_dispatch.html","id":"ellipsis","dir":"Reference","previous_headings":"","what":"Ellipsis","title":"Method Dispatch of 'squarebrackets' — aaa04_squarebrackets_method_dispatch","text":"Due S3 method dispatch system works 'R', generic methods ellipsis argument (...).  user's safety, 'squarebrackets' check user accidentally add arguments make sense method (like specifying inv argument calling sb_x).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa04_squarebrackets_modify.html","id":null,"dir":"Reference","previous_headings":"","what":"Regarding Modification — aaa04_squarebrackets_modify","title":"Regarding Modification — aaa04_squarebrackets_modify","text":"help page describes main modification semantics available 'squarebrackets'.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa04_squarebrackets_modify.html","id":"base-r-s-default-modification","dir":"Reference","previous_headings":"","what":"Base R's default modification","title":"Regarding Modification — aaa04_squarebrackets_modify","text":"average users, R's default copy--modify semantics fine.  benefits indexing arguments 'squarebrackets' can combined [<- operator, idx method.  result idx() method can used inside regular square-brackets operators.  example like :   thus allowing user benefit convenient index translations 'squarebrackets', whilst still using R's default copy--modification semantics (instead semantics provided 'squarebrackets').","code":"x <- array(...) my_indices <- idx(x, sub, dims) x[my_indices] <- value  y <- data.frame(...) rows <- idx(y, 1:10, 1, inv = TRUE) cols <- idx(y, c(\"a\", \"b\"), 2) y[rows, cols] <- value"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa04_squarebrackets_modify.html","id":"explicit-copy","dir":"Reference","previous_headings":"","what":"Explicit Copy","title":"Regarding Modification — aaa04_squarebrackets_modify","text":"'squarebrackets' provides sb_mod/sb2_mod method modify copy.  method always copies modification.  recursive objects, sb2_mod returns original object, modified subsets copied, thus preventing unnecessary usage memory.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa04_squarebrackets_modify.html","id":"pass-by-reference","dir":"Reference","previous_headings":"","what":"Pass-by-Reference","title":"Regarding Modification — aaa04_squarebrackets_modify","text":"'squarebrackets' provides sb_set/sb2_set slice_set methods modify reference, meaning copy made .  Pass--Reference fastest memory efficient.  also involved modification forms, requires thought.  See squarebrackets_PassByReference information.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa04_squarebrackets_modify.html","id":"replacement-and-transformation-in-atomic-objects","dir":"Reference","previous_headings":"","what":"Replacement and Transformation in Atomic Objects","title":"Regarding Modification — aaa04_squarebrackets_modify","text":"rp argument used replace values specified indices values specified rp. Using rp argument modification methods, corresponds something like following:   tf argument used transform values specified indices transformation function tf. Using tf argument corresponds something like following:   tf function returns object appropriate type size (tf pass--reference function).","code":"x[...] <- rp x[...] <- tf(x[...])"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa04_squarebrackets_modify.html","id":"replacement-and-transformation-in-lists","dir":"Reference","previous_headings":"","what":"Replacement and Transformation in Lists","title":"Regarding Modification — aaa04_squarebrackets_modify","text":"rp tf arguments work mostly way recursive objects.  slight differences. Argument rp  'squarebrackets' demands rp always provided list S3 methods recursive vectors, matrices, arrays (.e. lists).  prevent ambiguity respect replacement recycled distributed specified indices  (See Footnote 1 ). Argument tf  functions (base) 'R' vectorized atomic objects, lists  (see Footnote 2 ).  'squarebrackets' therefore apply transformation function tf via lapply, like :   methods recursive objects, tf argument accompanied .lapply argument.  default, .lapply = lapply.  user may supply custom lapply()-like function argument use instead.  example, perform parallel transformation, user may supply future.apply::future_lapply.  supplied function must use exact argument convention lapply, otherwise errors unexpected behaviour may occur.","code":"x[...] <- lapply(x[...], tf)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa04_squarebrackets_modify.html","id":"replacement-and-transformation-in-data-frame-like-objects","dir":"Reference","previous_headings":"","what":"Replacement and Transformation in data.frame-like Objects","title":"Regarding Modification — aaa04_squarebrackets_modify","text":"Replacement transformations data.frame-like objects bit flexible Lists. rp always demanded list data.frame-like objects, appropriate (example, replacing multiple columns, column list.)  rp given list, unclassed unnamed used replace values.  ensure consistency accross supported data.frame types.  Bear mind every column data.frame like element list;  .lapply used transformations across multiple columns.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa04_squarebrackets_modify.html","id":"recycling-and-coercion","dir":"Reference","previous_headings":"","what":"Recycling and Coercion","title":"Regarding Modification — aaa04_squarebrackets_modify","text":"Recycling allowed modification methods.  , example, length(rp) must equal length selected subset, equal 1.  using Pass--Reference semantics, user extra mindful auto-coercion rules.  See squarebrackets_coercion details.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa04_squarebrackets_modify.html","id":"footnotes","dir":"Reference","previous_headings":"","what":"Footnotes","title":"Regarding Modification — aaa04_squarebrackets_modify","text":"Footnote 1  Consider following replacement base 'R':   happen?  x[1] list(1:2) x[2] also list(1:2)?  x[1] list(2) x[2] list(1)?  turns latter happen; somewhat ambiguous code.  prevent ambiguity code, 'squarebrackets' demands rp always provided list. Footnote 2  functions (base) 'R' vectorized atomic objects, lists.  One reasons following:  atomic vector x type t, every single element x scalar type t.  However, every element list x can virtually anything:  atomic object, another list, unevaluated expression, even dark magic like quote(expr =).  difficult make vectorized function object many unknowns.  Therefore, vast majority cases, one needs loop list elements.","code":"x <-list(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) x[1:2] <- 2:1"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa05_squarebrackets_modify.html","id":null,"dir":"Reference","previous_headings":"","what":"Regarding Modification — aaa05_squarebrackets_modify","title":"Regarding Modification — aaa05_squarebrackets_modify","text":"help page describes main modification semantics available 'squarebrackets'.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa05_squarebrackets_modify.html","id":"base-r-s-default-modification","dir":"Reference","previous_headings":"","what":"Base R's default modification","title":"Regarding Modification — aaa05_squarebrackets_modify","text":"average users, R's default copy--modify semantics fine.  benefits indexing arguments 'squarebrackets' can combined [<- operator, idx method.  result idx() method can used inside regular square-brackets operators.  example like :   thus allowing user benefit convenient index translations 'squarebrackets', whilst still using R's default copy--modification semantics (instead semantics provided 'squarebrackets').","code":"x <- array(...) my_indices <- idx(x, sub, dims) x[my_indices] <- value  y <- data.frame(...) rows <- idx(y, 1:10, 1, inv = TRUE) cols <- idx(y, c(\"a\", \"b\"), 2) y[rows, cols] <- value"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa05_squarebrackets_modify.html","id":"explicit-copy","dir":"Reference","previous_headings":"","what":"Explicit Copy","title":"Regarding Modification — aaa05_squarebrackets_modify","text":"'squarebrackets' provides sb_mod/sb2_mod method modify copy.  method always copies modification.  recursive objects, sb2_mod returns original object, modified subsets copied, thus preventing unnecessary usage memory.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa05_squarebrackets_modify.html","id":"pass-by-reference","dir":"Reference","previous_headings":"","what":"Pass-by-Reference","title":"Regarding Modification — aaa05_squarebrackets_modify","text":"'squarebrackets' provides sb_set/sb2_set slice_set methods modify reference, meaning copy made .  Pass--Reference fastest memory efficient.  also involved modification forms, requires thought.  See squarebrackets_PassByReference information.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa05_squarebrackets_modify.html","id":"replacement-and-transformation-in-atomic-objects","dir":"Reference","previous_headings":"","what":"Replacement and Transformation in Atomic Objects","title":"Regarding Modification — aaa05_squarebrackets_modify","text":"rp argument used replace values specified indices values specified rp. Using rp argument modification methods, corresponds something like following:   tf argument used transform values specified indices transformation function tf. Using tf argument corresponds something like following:   tf function returns object appropriate type size (tf pass--reference function).","code":"x[...] <- rp x[...] <- tf(x[...])"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa05_squarebrackets_modify.html","id":"replacement-and-transformation-in-lists","dir":"Reference","previous_headings":"","what":"Replacement and Transformation in Lists","title":"Regarding Modification — aaa05_squarebrackets_modify","text":"rp tf arguments work mostly way recursive objects.  slight differences. Argument rp  'squarebrackets' demands rp always provided list S3 methods recursive vectors, matrices, arrays (.e. lists).  prevent ambiguity respect replacement recycled distributed specified indices  (See Footnote 1 ). Argument tf  functions (base) 'R' vectorized atomic objects, lists  (see Footnote 2 ).  'squarebrackets' therefore apply transformation function tf via lapply, like :   methods recursive objects, tf argument accompanied .lapply argument.  default, .lapply = lapply.  user may supply custom lapply()-like function argument use instead.  example, perform parallel transformation, user may supply future.apply::future_lapply.  supplied function must use exact argument convention lapply, otherwise errors unexpected behaviour may occur.","code":"x[...] <- lapply(x[...], tf)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa05_squarebrackets_modify.html","id":"replacement-and-transformation-in-data-frame-like-objects","dir":"Reference","previous_headings":"","what":"Replacement and Transformation in data.frame-like Objects","title":"Regarding Modification — aaa05_squarebrackets_modify","text":"Replacement transformations data.frame-like objects bit flexible Lists. rp always demanded list data.frame-like objects, appropriate (example, replacing multiple columns, column list.)  rp given list, unclassed unnamed used replace values.  ensure consistency accross supported data.frame types.  Bear mind every column data.frame like element list;  .lapply used transformations across multiple columns.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa05_squarebrackets_modify.html","id":"recycling-and-coercion","dir":"Reference","previous_headings":"","what":"Recycling and Coercion","title":"Regarding Modification — aaa05_squarebrackets_modify","text":"Recycling allowed modification methods.  , example, length(rp) must equal length selected subset, equal 1.  using Pass--Reference semantics, user extra mindful auto-coercion rules.  See squarebrackets_coercion details.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa05_squarebrackets_modify.html","id":"footnotes","dir":"Reference","previous_headings":"","what":"Footnotes","title":"Regarding Modification — aaa05_squarebrackets_modify","text":"Footnote 1  Consider following replacement base 'R':   happen?  x[1] list(1:2) x[2] also list(1:2)?  x[1] list(2) x[2] list(1)?  turns latter happen; somewhat ambiguous code.  prevent ambiguity code, 'squarebrackets' demands rp always provided list. Footnote 2  functions (base) 'R' vectorized atomic objects, lists.  One reasons following:  atomic vector x type t, every single element x scalar type t.  However, every element list x can virtually anything:  atomic object, another list, unevaluated expression, even dark magic like quote(expr =).  difficult make vectorized function object many unknowns.  Therefore, vast majority cases, one needs loop list elements.","code":"x <-list(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) x[1:2] <- 2:1"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa05_squarebrackets_options.html","id":null,"dir":"Reference","previous_headings":"","what":"squarebrackets Options — aaa05_squarebrackets_options","title":"squarebrackets Options — aaa05_squarebrackets_options","text":"help page explains various global options can set 'squarebrackets' package, affects functionality.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa05_squarebrackets_options.html","id":"check-duplicates","dir":"Reference","previous_headings":"","what":"Check Duplicates","title":"squarebrackets Options — aaa05_squarebrackets_options","text":"sb_x/sb2_x method method providing duplicate indices actually make sense.  methods, make sense.  Giving duplicate indices usually break anything; however, replacing/transforming removing subsets, almost certainly intention provide duplicate indices.  Providing duplicate indices anyway might lead unexpected results.  Therefore, methods giving duplicate indices make sense, chkdup argument present.  argument controls whether method question checks duplicates (TRUE) (FALSE).  Setting chkdup = TRUE means method question check duplicate indices, give error finds .  Setting chkdup = FALSE disable checks, saves time computation power, thus efficient.  Since checking duplicates can expensive, set FALSE default.  default can changed squarebrackets.chkdup option.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa05_squarebrackets_options.html","id":"sticky","dir":"Reference","previous_headings":"","what":"Sticky","title":"squarebrackets Options — aaa05_squarebrackets_options","text":"slice_x slice_wo methods can already handle names, attributes specific mutable_atomic class, attributes specific factor class.  sticky = FALSE, arguably safest setting, slice_x slice_wo methods drop attributes.  setting sticky = TRUE, attributes except comment tsp preserved;  name-related attributes separate handled use.names argument.  key advantage , classes use static attributes (.e. classes use attributes change sub-setting), automatically supported sticky = TRUE, separate methods written slice_x slice_wo.  Attributes specific classes like difftime, Date, POSIXct, roman, hexmode, octmode, , use static attributes.  Instead setting sticky = TRUE sticky = FALSE, one can also specify classes use static attributes using current R session.  fact, 'squarebrackets' loaded (loaded, attaching necessary), squarebrackets.sticky option set follows:   default setting, sticky = TRUE  \"difftime\", \"Date\", \"POSIXct\", \"roman\", \"hexmode\", \"octmode\".  Also default setting, sticky = FALSE classes.  Note, , mutable_atomic factor already handled slice_x slice_wo, handling affected sticky argument/option.  reason slice_x slice_wo need sticky option, following.  Unlike sb_/sb2_ methods, slice_x slice_wo methods wrappers around [ [<- operators.  Therefore, [ - S3 methods highly specialized classes readily available slice_x slice_wo methods.  therefore, important class-specific attributes automatically preserved.  sticky option convenient way support large number classes, without write specific methods .  specialized classes use attributes change sub-setting, separate slice_x slice_wo methods need written.  Package authors welcome create method dispatches classes methods.  final note, name \"sticky\" inspired sticky::sticky.","code":"squarebrackets.sticky = c(    \"difftime\", \"Date\", \"POSIXct\", \"roman\", \"hexmode\", \"octmode\" )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa06_squarebrackets_method_dispatch.html","id":null,"dir":"Reference","previous_headings":"","what":"Method Dispatch of 'squarebrackets' — aaa06_squarebrackets_method_dispatch","title":"Method Dispatch of 'squarebrackets' — aaa06_squarebrackets_method_dispatch","text":"help page gives additional details regarding S3 method dispatch used 'squarebrackets'.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa06_squarebrackets_method_dispatch.html","id":"atomic-vs-recursive","dir":"Reference","previous_headings":"","what":"Atomic vs Recursive","title":"Method Dispatch of 'squarebrackets' — aaa06_squarebrackets_method_dispatch","text":"Atomic recursive objects quite different ways: homo- heterogeneous: atomic object can values one data type.  recursive objects can hold values combination data types. nesting: Recursive objects can nested, atomic objects nested. copy coercion effect: One can coerce copy subset recursive object, without copying rest object.  atomic objects, however, coercion copy operation coerces copies entire vector (ignoring attributes). vectorization: vectorized operations generally work atomic objects, whereas recursive objects often require loops apply-like functions. recursive subsets: Recursive objects distinguish \"regular\" subset operations (base R using [, [<-), recursive subset operations (base R using [[, [[<-).  See example sb2_rec method, red = TRUE argument sb2_x sb2_wo methods.  atomic objects, 2 meaningful difference (safe perhaps minor attribute handling). views: recursive objects, one can create view recursive subset.  Subset views exist atomic objects. main S3 methods perform subset operation object, come atomic (sb_) recursive (sb2_) form.  idx method operates indices object, operate object , distinction atomic recursive form.  split atomic recursive forms method dispatches done several reasons: many nuances keep track user atomic recursive objects.  splitting methods atomic recursive objects, user choose sb_ sb2_, 'squarebrackets' can handle rest user. giving atomic recursive separate methods, becomes syntactically clear consequences subset-operation:  entire object coerced copied? transformation function go lapply? operation affecting shallow subsets? etc. S3 classes, like array matrix classes, available atomic recursive forms.  S3 method dispatch distinguish atomic recursive objects, despite aforementioned differences 2.  'squarebrackets' uses separate method dispatch atomic recursive form. Package authors can create separate sub-set operation methods atomic recursive objects using 'squarebrackets'.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa06_squarebrackets_method_dispatch.html","id":"manual-dispatch","dir":"Reference","previous_headings":"","what":"Manual Dispatch","title":"Method Dispatch of 'squarebrackets' — aaa06_squarebrackets_method_dispatch","text":"'squarebrackets' package intentionally exports function S3 method dispatch system.  handy programming purposes.  example: one can explicitly alias specific dispatch method, one desires.  example like :   certain circumstances, might help code clear.","code":"array_x <- function(x, ...) {     if(is.atomic(x)) {      sb_x.array(x, ...)    }    else if(is.recursive(x)) {      sb2_x.array(x, ...)    }     }"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa06_squarebrackets_method_dispatch.html","id":"ellipsis","dir":"Reference","previous_headings":"","what":"Ellipsis","title":"Method Dispatch of 'squarebrackets' — aaa06_squarebrackets_method_dispatch","text":"Due S3 method dispatch system works 'R', generic methods ellipsis argument (...).  user's safety, 'squarebrackets' check user accidentally add arguments make sense method (like specifying inv argument calling sb_x).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa06_squarebrackets_options.html","id":null,"dir":"Reference","previous_headings":"","what":"squarebrackets Options — aaa06_squarebrackets_options","title":"squarebrackets Options — aaa06_squarebrackets_options","text":"help page explains various global options can set 'squarebrackets' package, affects functionality.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa06_squarebrackets_options.html","id":"check-duplicates","dir":"Reference","previous_headings":"","what":"Check Duplicates","title":"squarebrackets Options — aaa06_squarebrackets_options","text":"sb_x/sb2_x method method providing duplicate indices actually make sense.  methods, make sense.  Giving duplicate indices usually break anything; however, replacing/transforming removing subsets, almost certainly intention provide duplicate indices.  Providing duplicate indices anyway might lead unexpected results.  Therefore, methods giving duplicate indices make sense, chkdup argument present.  argument controls whether method question checks duplicates (TRUE) (FALSE).  Setting chkdup = TRUE means method question check duplicate indices, give error finds .  Setting chkdup = FALSE disable checks, saves time computation power, thus efficient.  Since checking duplicates can expensive, set FALSE default.  default can changed squarebrackets.chkdup option.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa06_squarebrackets_options.html","id":"sticky","dir":"Reference","previous_headings":"","what":"Sticky","title":"squarebrackets Options — aaa06_squarebrackets_options","text":"slice_x slice_wo methods can already handle names, attributes specific mutable_atomic class, attributes specific factor class.  sticky = FALSE, arguably safest setting, slice_x slice_wo methods drop attributes.  setting sticky = TRUE, attributes except comment tsp preserved;  name-related attributes separate handled use.names argument.  key advantage , classes use static attributes (.e. classes use attributes change sub-setting), automatically supported sticky = TRUE, separate methods written slice_x slice_wo.  Attributes specific classes like difftime, Date, POSIXct, roman, hexmode, octmode, , use static attributes.  Instead setting sticky = TRUE sticky = FALSE, one can also specify classes use static attributes using current R session.  fact, 'squarebrackets' loaded (loaded, attaching necessary), squarebrackets.sticky option set follows:   default setting, sticky = TRUE  \"difftime\", \"Date\", \"POSIXct\", \"roman\", \"hexmode\", \"octmode\".  Also default setting, sticky = FALSE classes.  Note, , mutable_atomic factor already handled slice_x slice_wo, handling affected sticky argument/option.  reason slice_x slice_wo need sticky option, following.  Unlike sb_/sb2_ methods, slice_x slice_wo methods wrappers around [ [<- operators.  Therefore, [ - S3 methods highly specialized classes readily available slice_x slice_wo methods.  therefore, important class-specific attributes automatically preserved.  sticky option convenient way support large number classes, without write specific methods .  specialized classes use attributes change sub-setting, separate slice_x slice_wo methods need written.  Package authors welcome create method dispatches classes methods.  final note, name \"sticky\" inspired sticky::sticky.","code":"squarebrackets.sticky = c(    \"difftime\", \"Date\", \"POSIXct\", \"roman\", \"hexmode\", \"octmode\" )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa07_squarebrackets_PassByReference.html","id":null,"dir":"Reference","previous_headings":"","what":"Regarding Modification By Reference — aaa07_squarebrackets_PassByReference","title":"Regarding Modification By Reference — aaa07_squarebrackets_PassByReference","text":"help page describes modification using \"pass--reference\" semantics handled 'squarebrackets' package.  help page explain basics pass--reference semantics, treated prior knowledge.  functions/methods 'squarebrackets' package word \"set\" name use pass--reference semantics.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa07_squarebrackets_PassByReference.html","id":"advantages-and-disadvantages","dir":"Reference","previous_headings":"","what":"Advantages and Disadvantages","title":"Regarding Modification By Reference — aaa07_squarebrackets_PassByReference","text":"main advantage pass--reference much less memory required modify objects, modification also generally faster.  several disadvantages.  First, coercion rules slightly different: see squarebrackets_coercion.  Second, 2 variables refer exactly object, changing one variable also changes ones.  .e. following code,   modifies just x, also y.  true even one variables locked (see bindingIsLocked).  .e. following code,   modifies x y without error, even though y locked constant.","code":"x <- y <- mutable_atomic(1:16) sb_set(x, i = 1:6, rp = 8) x <- mutable_atomic(1:16) y <- x lockBinding(\"y\", environment()) sb_set(x, i = 1:6, rp = 8)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa07_squarebrackets_PassByReference.html","id":"mutable-vs-immutable-classes","dir":"Reference","previous_headings":"","what":"Mutable vs Immutable Classes","title":"Regarding Modification By Reference — aaa07_squarebrackets_PassByReference","text":"exception environments, base R's S3 classes treated immutable:  Modifying object 'R' make copy object, something called 'copy--modify' semantics.  prominent mutable S3 class data.table class, mutable data.frame class, supported 'squarebrackets'.  Similarly, 'squarebrackets' adds class mutable atomic objects: mutable_atomic.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa07_squarebrackets_PassByReference.html","id":"material-vs-immaterial-objects","dir":"Reference","previous_headings":"","what":"Material vs Immaterial objects","title":"Regarding Modification By Reference — aaa07_squarebrackets_PassByReference","text":"objects 'R' material objects:  values object contains actually stored memory.  example, given x <- rnorm(1e6), x material object:  1 million values (decimal numbers, case) actually stored memory.  contrast, ActiveBindings immaterial:  objects , accessed, call function generate values fly, rather actually storing values.  Since immaterial objects actually store values memory, values obviously also changed memory.  Therefore, Pass--Reference semantics work immaterial objects.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa07_squarebrackets_PassByReference.html","id":"altrep","dir":"Reference","previous_headings":"","what":"ALTREP","title":"Regarding Modification By Reference — aaa07_squarebrackets_PassByReference","text":"mutable_atomic constructors (.e. mutable_atomic, .mutable_atomic, etc.) automatically materialize ALTREP objects, ensure consistent behaviour 'pass--reference' semantics.  data.table can ALTREP columns.  data.tables coerce column materialized column modified, even reference.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa07_squarebrackets_PassByReference.html","id":"mutability-rules-with-respect-to-recursive-objects","dir":"Reference","previous_headings":"","what":"Mutability Rules With Respect To Recursive Objects","title":"Regarding Modification By Reference — aaa07_squarebrackets_PassByReference","text":"Lists difficult objects contain elements, simply point  objects, one can access via list.  recursive object mutable class, subsets treated mutable, long part object.  hand, recursive object immutable class, recursive subsets retain original mutability. Example 1: Mutable data.tables  data.table mutable class.  columns data.table treated mutable;  requirement , instance, first change columns class mutable_atomic modify columns reference. Example 2: Immutable lists  regular list immutable class.  list immutable, recursive subsets list retain mutability.  list data.table objects, example, data.tables remain mutable.  Therefore, following pass--reference modification work without issue:   Notice code myref address x$, therefore copy x$.  Thus changing myref also changes x$.  words: myref called \"View\" x$.","code":"x <- list(  a = data.table::data.table(cola = 1:10, colb = letters[1:10]),  b = data.table::data.table(cola = 11:20, colb = letters[11:20]) ) myref <- x$a sb2_set(myref, col = \"cola\", tf = \\(x)x^2)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa07_squarebrackets_PassByReference.html","id":"input-variable","dir":"Reference","previous_headings":"","what":"Input Variable","title":"Regarding Modification By Reference — aaa07_squarebrackets_PassByReference","text":"Methods/functions perform -place modification reference works objects actually exist actual variable, similar functions style some_function(x, ...) <- value.  Thus things like following, sb_set(1:10, ...), sb2_set(x$, ...), sb_set(base::letters),  work.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa07_squarebrackets_PassByReference.html","id":"lock-binding","dir":"Reference","previous_headings":"","what":"Lock Binding","title":"Regarding Modification By Reference — aaa07_squarebrackets_PassByReference","text":"Mutable classes , name suggests, meant mutable.  Locking binding mutable object mostly fruitless (completely; see currentBindings function).  ensure object modified methods/functions 'squarebrackets', 2 things must true: object must immutable class. binding must locked (see lockBinding).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa07_squarebrackets_PassByReference.html","id":"protection","dir":"Reference","previous_headings":"","what":"Protection","title":"Regarding Modification By Reference — aaa07_squarebrackets_PassByReference","text":"Due properties described help page, 'squarebrackets' protects user something like following:   'squarebrackets' give error running code , : addresses baseenv() protected; immutable objects disallowed (create mutable object, create copy original, thus keeping original object safe modification reference); locked bindings disallowed.","code":"# letters = base::letters sb_set(letters, i = 1, rp = \"XXX\")"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa07_squarebrackets_PassByReference.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Regarding Modification By Reference — aaa07_squarebrackets_PassByReference","text":"","code":"# the following code demonstrates how locked bindings, # such as `base::letters`, # are being safe-guarded  x <- list(a = base::letters) myref <- x$a # view of a list address(myref) == address(base::letters) # TRUE: point to the same memory #> [1] TRUE bindingIsLocked(\"letters\", baseenv()) # base::letters is locked ... #> [1] TRUE bindingIsLocked(\"myref\", environment()) # ... but this pointer is not! #> [1] FALSE  if(requireNamespace(\"tinytest\")) {   tinytest::expect_error(     sb_set(myref, i = 1, rp = \"XXX\") # this still gives an error though ...   ) } #> Loading required namespace: tinytest #> ----- PASSED      : <--> #>  call| eval(expr, envir, enclos)   is.mutable_atomic(myref) # ... because it's not of class `mutable_atomic` #> [1] FALSE   x <- list(   a = as.mutable_atomic(base::letters) # `as.mutable_atomic()` makes a copy ) myref <- x$a # view of a list address(myref) == address(base::letters) # FALSE: it's a copy #> [1] FALSE sb_set(   myref, i = 1, rp = \"XXX\"  # modifies x, does NOT modify `base::letters` ) print(x) # x is modified #> $a #>  [1] \"XXX\" \"b\"   \"c\"   \"d\"   \"e\"   \"f\"   \"g\"   \"h\"   \"i\"   \"j\"   \"k\"   \"l\"   #> [13] \"m\"   \"n\"   \"o\"   \"p\"   \"q\"   \"r\"   \"s\"   \"t\"   \"u\"   \"v\"   \"w\"   \"x\"   #> [25] \"y\"   \"z\"   #> mutable_atomic  #> typeof:  character  #>  base::letters # but this still the same #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" #> [20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa08_squarebrackets_coercion.html","id":null,"dir":"Reference","previous_headings":"","what":"Auto-Coercion Rules for Mutable Objects — aaa08_squarebrackets_coercion","title":"Auto-Coercion Rules for Mutable Objects — aaa08_squarebrackets_coercion","text":"help page describes auto-coercion rules mutable classes, handled 'squarebrackets' package.  useful information users wish intend employ Pass--Reference semantics provided 'squarebrackets'.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa08_squarebrackets_coercion.html","id":"mutable-atomic","dir":"Reference","previous_headings":"","what":"mutable_atomic","title":"Auto-Coercion Rules for Mutable Objects — aaa08_squarebrackets_coercion","text":"Mutable atomic objects automatically coerced fit modified subset values, modifying copy, just like regular atomic classes.  example, replacing one multiple values integer vector (type int) decimal number (type dbl) coerce entire vector type dbl.  Replacing transforming subsets mutable atomic objects reference support coercion. Thus, example, following code,   gives c(rep(8, 6) 7:16) instead c(rep(8.5, 6), 7:16), x type integer, rp interpreted type integer also.","code":"x <- mutable_atomic(1:16) sb_set(x, i = 1:6, rp = 8.5) #> coercing replacement to integer print(x) #>  [1]  8  8  8  8  8  8  7  8  9 10 11 12 13 14 15 16 #> mutable_atomic  #> typeof:  integer"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa08_squarebrackets_coercion.html","id":"data-table-when-replacing-transforming-whole-columns","dir":"Reference","previous_headings":"","what":"data.table, when replacing/transforming whole columns","title":"Auto-Coercion Rules for Mutable Objects — aaa08_squarebrackets_coercion","text":"data.table actually list made mutable, column list. , replacing/transforming whole columns, row = NULL filter = NULL, allows completely changing type column.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa08_squarebrackets_coercion.html","id":"data-table-when-partially-replacing-transforming-columns","dir":"Reference","previous_headings":"","what":"data.table, when partially replacing/transforming columns","title":"Auto-Coercion Rules for Mutable Objects — aaa08_squarebrackets_coercion","text":"rows specified sb2_set method, thus whole columns parts columns replaced transformed, auto-coercion takes place.  .e.: replacing/transforming value integer (int) column become 1.5, coerce column decimal type (dbl); instead, replacement value 1.5 coerced integer 1.  sb2_mod method, however, allows coercion just like regular data.frame objects.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa08_squarebrackets_coercion.html","id":"views-of-lists","dir":"Reference","previous_headings":"","what":"Views of Lists","title":"Auto-Coercion Rules for Mutable Objects — aaa08_squarebrackets_coercion","text":"Regular lists treated immutable 'squarebrackets'.  remember list (potentially hierarchical) structure references objects.  Thus, even list treated mutable, subsets list mutable classes, mutable.  example, list data.table objects, data.tables mutable.  Therefore, following work:   Notice code myref copy x$, since address.  Thus changing myref also changes x$.  words: myref called \"view\" x$.  Notice also sb2_set(x$, ...) work, since sb_set/sb2_set requires actual variables, similar -place functions style `myfun()<-`.  auto-coercion rules Views Lists, depends entirely object .  Thus View data.table, coercion rules data.tables apply.  View mutable_atomic matrix, coercion rules mutable_atomic matrices apply, etc.","code":"x <- list(  a = data.table::data.table(cola = 1:10, colb = letters[1:10]),  b = data.table::data.table(cola = 11:20, colb = letters[11:20]) ) myref <- x$a sb2_set(myref, col = \"cola\", tf = \\(x)x^2)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa08_squarebrackets_coercion.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Auto-Coercion Rules for Mutable Objects — aaa08_squarebrackets_coercion","text":"","code":"# Coercion examples - mutable_atomic ====  x <- as.mutable_atomic(1:16) sb_set(x, i = 1:6, rp = 8.5) # 8.5 coerced to 8, because `x` is of type `integer` #> coercing replacement to integer print(x) #>  [1]  8  8  8  8  8  8  7  8  9 10 11 12 13 14 15 16 #> mutable_atomic  #> typeof:  integer   #############################################################################  # Coercion examples - data.table - whole columns ====  # sb_mod(): obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb2_mod(   obj, vars = is.numeric,   tf = sqrt # SAFE: row=NULL & filter = NULL, so coercion performed ) #>            a      b        c      d #>        <num> <char>    <num> <fctr> #>  1: 1.000000      a 3.316625      a #>  2: 1.414214      b 3.464102      b #>  3: 1.732051      c 3.605551      c #>  4: 2.000000      d 3.741657      d #>  5: 2.236068      e 3.872983      e #>  6: 2.449490      f 4.000000      f #>  7: 2.645751      g 4.123106      g #>  8: 2.828427      h 4.242641      h #>  9: 3.000000      i 4.358899      i #> 10: 3.162278      j 4.472136      j  # sb_set(): sb2_set(   obj, vars = is.numeric,   tf = sqrt # SAFE: row=NULL & filter = NULL, so coercion performed ) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 1.41 1.73 2 2.24 ... #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  3.32 3.46 3.61 3.74 3.87 ... #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>   #############################################################################   # Coercion examples - data.table - partial columns ====  # sb_mod(): obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>   sb2_mod(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # SAFE: coercion performed ) #>             a      b         c      d #>         <num> <char>     <num> <fctr> #>  1:  1.000000      a 11.000000      a #>  2:  1.414214      b  3.464102      b #>  3:  1.732051      c  3.605551      c #>  4:  2.000000      d  3.741657      d #>  5:  2.236068      e  3.872983      e #>  6:  2.449490      f  4.000000      f #>  7:  2.645751      g  4.123106      g #>  8:  8.000000      h 18.000000      h #>  9:  9.000000      i 19.000000      i #> 10: 10.000000      j 20.000000      j  # sb_set(): obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb2_set(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt   # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost ) #> Warning: 1.414214 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 1 named 'a') #> Warning: 3.464102 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 3 named 'c') print(obj) #>         a      b     c      d #>     <int> <char> <int> <fctr> #>  1:     1      a    11      a #>  2:     1      b     3      b #>  3:     1      c     3      c #>  4:     2      d     3      d #>  5:     2      e     3      e #>  6:     2      f     4      f #>  7:     2      g     4      g #>  8:     8      h    18      h #>  9:     9      i    19      i #> 10:    10      j    20      j  obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  dt_setcoe(obj, vars = is.numeric, v = as.numeric) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb2_set(obj,   filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # SAFE: coercion performed by dt_setcoe(); so no warnings )  print(obj) #>             a      b         c      d #>         <num> <char>     <num> <fctr> #>  1:  1.000000      a 11.000000      a #>  2:  1.414214      b  3.464102      b #>  3:  1.732051      c  3.605551      c #>  4:  2.000000      d  3.741657      d #>  5:  2.236068      e  3.872983      e #>  6:  2.449490      f  4.000000      f #>  7:  2.645751      g  4.123106      g #>  8:  8.000000      h 18.000000      h #>  9:  9.000000      i 19.000000      i #> 10: 10.000000      j 20.000000      j   #############################################################################  # View of List ====  x <- list(  a = data.table::data.table(cola = 1:10, colb = letters[1:10]),  b = data.table::data.table(cola = 11:20, colb = letters[11:20]) ) print(x) #> $a #>      cola   colb #>     <int> <char> #>  1:     1      a #>  2:     2      b #>  3:     3      c #>  4:     4      d #>  5:     5      e #>  6:     6      f #>  7:     7      g #>  8:     8      h #>  9:     9      i #> 10:    10      j #>  #> $b #>      cola   colb #>     <int> <char> #>  1:    11      k #>  2:    12      l #>  3:    13      m #>  4:    14      n #>  5:    15      o #>  6:    16      p #>  7:    17      q #>  8:    18      r #>  9:    19      s #> 10:    20      t #>  myref <- x$a address(myref) == address(x$a) # they are the same #> [1] TRUE sb2_set(myref, col = \"cola\", tf = \\(x)x^2) print(x) # notice x has been changed #> $a #>      cola   colb #>     <num> <char> #>  1:     1      a #>  2:     4      b #>  3:     9      c #>  4:    16      d #>  5:    25      e #>  6:    36      f #>  7:    49      g #>  8:    64      h #>  9:    81      i #> 10:   100      j #>  #> $b #>      cola   colb #>     <int> <char> #>  1:    11      k #>  2:    12      l #>  3:    13      m #>  4:    14      n #>  5:    15      o #>  6:    16      p #>  7:    17      q #>  8:    18      r #>  9:    19      s #> 10:    20      t #>"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa09_squarebrackets_inconveniences.html","id":null,"dir":"Reference","previous_headings":"","what":"Examples Where the Square Bracket Operators Are Less Convenient — aaa09_squarebrackets_inconveniences","title":"Examples Where the Square Bracket Operators Are Less Convenient — aaa09_squarebrackets_inconveniences","text":"help page shows examples square bracket operators ( [, [<-) less optimally convenient, methods provided 'squarebrackets' can helpful cases.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa09_squarebrackets_inconveniences.html","id":"arrays","dir":"Reference","previous_headings":"","what":"Arrays","title":"Examples Where the Square Bracket Operators Are Less Convenient — aaa09_squarebrackets_inconveniences","text":"order perform subset operations array x square brackets operator ([, [<-), one needs know many dimensions .  .e. x 3 dimensions, one use:   one use [ [<- operators, number dimensions x known -priori?  ’s impossible, still rather convoluted.  methods provided 'squarebrackets' use position-based arguments, work arbitrary dimensions without requiring prior knowledge;  see squarebrackets_indx_args details.","code":"x[i, j, k, drop = FALSE]  x[i, j, k] <- value"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa09_squarebrackets_inconveniences.html","id":"rule-sets-for-data-frame-like-objects","dir":"Reference","previous_headings":"","what":"Rule-sets for data.frame-like Objects","title":"Examples Where the Square Bracket Operators Are Less Convenient — aaa09_squarebrackets_inconveniences","text":"data.frame, tibble, data.table, tidytable classes inherit class “data.frame”.  Yet use different rules regarding usage square bracket operators.  Constantly switching rules annoying, makes one's code inconsistent.  methods provided 'squarebrackets' use sub-setting rules data.frame inherited classes, thus solving issue.  'squarebrackets' package attempts keep data.frame methods class agnostic possible, class agnostic functionality 'collapse' 'data.table' R-packages.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa09_squarebrackets_inconveniences.html","id":"long-vectors","dir":"Reference","previous_headings":"","what":"Long Vectors","title":"Examples Where the Square Bracket Operators Are Less Convenient — aaa09_squarebrackets_inconveniences","text":"Performing sub-set operations long vector x using [, like object, requires indexing vector.  indexing vector may need type double (since long vectors can longer 2^31 - 1), indexing vector may need large also.  can quite inefficient, one may need twice memory object .  'squarebrackets' provides slice_ methods, can perform sub-set operations large atomic vectors, without need indexing vector .  Note dimensional objects, arrays data.frame-like objects, less dire need slice_ method due dimensional indexing:  example, 1500 1500 1500 array already long vector (1500^3 > (2^31 - 1)), yet one need indexing vectors longer 1500 elements type double.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa09_squarebrackets_inconveniences.html","id":"annoying-sub-setting-by-names","dir":"Reference","previous_headings":"","what":"Annoying Sub-setting By Names","title":"Examples Where the Square Bracket Operators Are Less Convenient — aaa09_squarebrackets_inconveniences","text":"selecting names sub-setting, first occurrences names selected sub-set;  un-selecting/removing names sub-setting, syntax different selecting names.  methods provided 'squarebrackets' uses syntax selecting removing sub-sets.  Moreover, selecting/removing sub-sets names always selects/removes sub-sets given names, just first match.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa09_squarebrackets_inconveniences.html","id":"modification-semantics","dir":"Reference","previous_headings":"","what":"Modification Semantics","title":"Examples Where the Square Bracket Operators Are Less Convenient — aaa09_squarebrackets_inconveniences","text":"‘R’ adheres copy--modify semantics replacing values using [<-.  sometimes one like explicit control create copy, modify using pass--reference semantics.  'squarebrackets' package provides sb_mod/sb2_mod methods return copy object modified subsets, sb_set/sb2_set slice_set methods modify using pass--reference semantics.  idx method can used combination R's [<- operator R's default copy--modify semantics.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa09_squarebrackets_inconveniences.html","id":"regarding-other-packages","dir":"Reference","previous_headings":"","what":"Regarding Other Packages","title":"Examples Where the Square Bracket Operators Are Less Convenient — aaa09_squarebrackets_inconveniences","text":"packages solve issues.  using different packages solving different issues common theme (case: solving inconveniences square bracket operators) leads inconsistent code.  found R-package provides holistic approach providing alternative methods square brackets operators.  Thus, 'R' package born.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/bind.html","id":null,"dir":"Reference","previous_headings":"","what":"Dimensional Binding of Objects — bind","title":"Dimensional Binding of Objects — bind","text":"bind_implementations provide dimensional binding functionalities.  possible, bind_ functions return mutable classes.  following implementations available: bind_mat() binds dimensionless (atomic/recursive) vectors (atomic/recursive) matrices row- column-wise.  result atomic, returns mutable_atomic matrix; otherwise returns recursive matrix. bind_array() binds (atomic/recursive) arrays (atomic/recursive) matrices.  result atomic, returns mutable_atomic array; otherwise returns recursive array. bind_dt() binds data.tables data.frame-like objects.  Returns data.table.  Faster .call(cbind, ...) .call(rbind, ...) regular data.frame objects. Note naming convention binding implementations \"bind_\" followed resulting class (abbreviated).  .e. bind_mat returns matrix, can bind matrices vectors.  bind_array returns array, can bind arrays matrices.  bind_dt returns data.table, can bind data.tables, also data.frame-like objects.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/bind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dimensional Binding of Objects — bind","text":"","code":"bind_mat(arg.list, along, name_deparse = TRUE, comnames_from = 1L)  bind_array(   arg.list,   along,   name_along = TRUE,   comnames_from = 1L,   name_flat = FALSE )  bind_dt(arg.list, along, ...)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/bind.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dimensional Binding of Objects — bind","text":"arg.list list appropriate objects.  arg.list named, names used names dimension along output, far possible. along single integer, indicating dimension along bind dimensions.  .e. use along = 1 row-binding, along = 2 column-binding, etc.  arrays, additional flexibility available: Specifying along = 0 bind arrays new dimension first, making along new first dimension. Specifying along = n+1, n last available dimension, create additional dimension (n+1) bind arrays along new dimension. name_deparse Boolean, bind_mat().  Indicates dimension along named.  Uses naming method rbind/cbind . comnames_from either integer scalar NULL, bind_mat()  bind_array().  Indicates object arg.list used naming shared dimension.  NULL, communal names given.  example:  binding columns matrices, matrices share rownames.  Using comnames_from = 10 result bind_array() using rownames(arg.list[[10]]) rownames output. name_along Boolean, bind_array().  Indicates dimension along named. name_flat Boolean, bind_array().  Indicates flat indices named.  Note setting TRUE reduce performance considerably. ... arguments passed rbindlist.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/bind.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dimensional Binding of Objects — bind","text":"bound object.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/bind.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Dimensional Binding of Objects — bind","text":"bind_array() modified version fantastic abind::abind function Tony Plare & Richard Heiberger (2016), following ways: bind_array() primarily differs abind::abind can handle recursive arrays properly  (original abind::abind function unlist everything atomic arrays, ruining structure). unlike abind::abind, bind_array() binds (atomic/recursive) arrays matrices. bind_array()attempt convert things arrays arrays, give error instead.  saves computation time prevents unexpected results. bind_array() results atomic array, mutable_atomic array. bind_array() streamlined naming options. bind_mat() modified version rbind/cbind.  primary differences bind_mat() gives error fractional recycling attempted (like binding  1:3 1:10).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/bind.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Dimensional Binding of Objects — bind","text":"Plate T, Heiberger R (2016). abind: Combine Multidimensional Arrays. R package version 1.4-5, https://CRAN.R-project.org/package=abind.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/bind.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dimensional Binding of Objects — bind","text":"","code":"# bind_array ====  # here, atomic and recursive matrices are mixed, # resulting in a recursive matrix  # creating the arrays x <- c(   lapply(1:3, \\(x)sample(c(TRUE, FALSE, NA))),   lapply(1:3, \\(x)sample(1:10)),   lapply(1:3, \\(x)rnorm(10)),   lapply(1:3, \\(x)sample(letters)) ) x <- matrix(x, 4, 3, byrow = TRUE) dimnames(x) <- n(letters[1:4], LETTERS[1:3]) print(x) #>   A            B            C            #> a logical,3    logical,3    logical,3    #> b integer,10   integer,10   integer,10   #> c numeric,10   numeric,10   numeric,10   #> d character,26 character,26 character,26  y <- matrix(1:12, 4, 3) print(y) #>      [,1] [,2] [,3] #> [1,]    1    5    9 #> [2,]    2    6   10 #> [3,]    3    7   11 #> [4,]    4    8   12  # binding the arrays arg.list <- list(x = x, y = y) bind_array(arg.list, along = 0L) # binds on new dimension before first #> , , A #>  #>   a         b          c          d            #> x logical,3 integer,10 numeric,10 character,26 #> y 1         2          3          4            #>  #> , , B #>  #>   a         b          c          d            #> x logical,3 integer,10 numeric,10 character,26 #> y 5         6          7          8            #>  #> , , C #>  #>   a         b          c          d            #> x logical,3 integer,10 numeric,10 character,26 #> y 9         10         11         12           #>  bind_array(arg.list, along = 1L) # binds on first dimension #>     A            B            C            #> a   logical,3    logical,3    logical,3    #> b   integer,10   integer,10   integer,10   #> c   numeric,10   numeric,10   numeric,10   #> d   character,26 character,26 character,26 #> y.1 1            5            9            #> y.2 2            6            10           #> y.3 3            7            11           #> y.4 4            8            12           bind_array(arg.list, along = 2L) #>   A            B            C            y.1 y.2 y.3 #> a logical,3    logical,3    logical,3    1   5   9   #> b integer,10   integer,10   integer,10   2   6   10  #> c numeric,10   numeric,10   numeric,10   3   7   11  #> d character,26 character,26 character,26 4   8   12  bind_array(arg.list, along = 3L) # bind on new dimension after last #> , , x #>  #>   A            B            C            #> a logical,3    logical,3    logical,3    #> b integer,10   integer,10   integer,10   #> c numeric,10   numeric,10   numeric,10   #> d character,26 character,26 character,26 #>  #> , , y #>  #>   A B C  #> a 1 5 9  #> b 2 6 10 #> c 3 7 11 #> d 4 8 12 #>     ################################################################################  # bind_mat ====  # here, atomic and recursive matrices are mixed, # resulting in a recursive matrix  x <- c(   lapply(1:3, \\(x)sample(c(TRUE, FALSE, NA))),   lapply(1:3, \\(x)sample(1:10)),   lapply(1:3, \\(x)rnorm(10)),   lapply(1:3, \\(x)sample(letters)) ) x <- matrix(x, 4, 3, byrow = TRUE) dimnames(x) <- n(letters[1:4], LETTERS[1:3]) print(x) #>   A            B            C            #> a logical,3    logical,3    logical,3    #> b integer,10   integer,10   integer,10   #> c numeric,10   numeric,10   numeric,10   #> d character,26 character,26 character,26  y <- matrix(1:12, 4, 3) print(y) #>      [,1] [,2] [,3] #> [1,]    1    5    9 #> [2,]    2    6   10 #> [3,]    3    7   11 #> [4,]    4    8   12  bind_mat(n(x = x, y = y), 2L) #>   A            B            C                   #> a logical,3    logical,3    logical,3    1 5 9  #> b integer,10   integer,10   integer,10   2 6 10 #> c numeric,10   numeric,10   numeric,10   3 7 11 #> d character,26 character,26 character,26 4 8 12    ################################################################################  # bind_dt ====   x <- data.frame(a = 1:12, b = month.abb) # data.frame y <- data.table::data.table(a = 1:12, b = month.abb) # data.table  bind_dt(n(x = x, y = y), 2L) # column bind #>       x.a    x.b   y.a    y.b #>     <int> <char> <int> <char> #>  1:     1    Jan     1    Jan #>  2:     2    Feb     2    Feb #>  3:     3    Mar     3    Mar #>  4:     4    Apr     4    Apr #>  5:     5    May     5    May #>  6:     6    Jun     6    Jun #>  7:     7    Jul     7    Jul #>  8:     8    Aug     8    Aug #>  9:     9    Sep     9    Sep #> 10:    10    Oct    10    Oct #> 11:    11    Nov    11    Nov #> 12:    12    Dec    12    Dec  bind_dt(n(x = x, y = y), 1L) # row bind #>         a      b #>     <int> <char> #>  1:     1    Jan #>  2:     2    Feb #>  3:     3    Mar #>  4:     4    Apr #>  5:     5    May #>  6:     6    Jun #>  7:     7    Jul #>  8:     8    Aug #>  9:     9    Sep #> 10:    10    Oct #> 11:    11    Nov #> 12:    12    Dec #> 13:     1    Jan #> 14:     2    Feb #> 15:     3    Mar #> 16:     4    Apr #> 17:     5    May #> 18:     6    Jun #> 19:     7    Jul #> 20:     8    Aug #> 21:     9    Sep #> 22:    10    Oct #> 23:    11    Nov #> 24:    12    Dec #>         a      b"},{"path":"https://tony-aw.github.io/squarebrackets/reference/ci.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct Indices — ci_flat","title":"Construct Indices — ci_flat","text":"functions construct flat dimensional indices. ci_flat() constructs integer vector flat indices. ci_margin() constructs integer vector indices one particular dimension margin. ci_sub() constructs list integer subscripts. ci_df() ci_margin(), except specifically designed data.frame-like objects.  separate function, things like dimnames(x)[1] rownames(x) always return output certain data.frame-like objects.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/ci.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct Indices — ci_flat","text":"","code":"ci_flat(   x,   i,   inv = FALSE,   chkdup = FALSE,   uniquely_named = FALSE,   .abortcall = sys.call() )  ci_margin(   x,   slice,   margin,   inv = FALSE,   chkdup = FALSE,   uniquely_named = FALSE,   .abortcall = sys.call() )  ci_sub(   x,   sub,   dims,   inv = FALSE,   chkdup = FALSE,   uniquely_named = FALSE,   .abortcall = sys.call() )  ci_df(   x,   slice,   margin,   inv = FALSE,   chkdup = FALSE,   uniquely_named = FALSE,   .abortcall = sys.call() )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/ci.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct Indices — ci_flat","text":"x object indices meant. , slice, margin, sub, dims, inv See squarebrackets_indx_args. chkdup see squarebrackets_options. uniquely_named Boolean, indicating user knows -priori relevant names x unique.  set TRUE, speed may increase.  specifying TRUE relevant names unique result incorrect output. .abortcall environment error message passed .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/ci.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct Indices — ci_flat","text":"integer vector constructed indices.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/ci.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct Indices — ci_flat","text":"","code":"x <- matrix(1:25, 5, 5) colnames(x) <- c(\"a\", \"a\", \"b\", \"c\", \"d\") print(x) #>      a  a  b  c  d #> [1,] 1  6 11 16 21 #> [2,] 2  7 12 17 22 #> [3,] 3  8 13 18 23 #> [4,] 4  9 14 19 24 #> [5,] 5 10 15 20 25  bool <- sample(c(TRUE, FALSE), 5, TRUE) int <- 1:4 chr <- c(\"a\", \"a\") cplx <- 1:4 * -1i tci_bool(bool, nrow(x)) #> [1] 2 5 tci_int(int, ncol(x), inv = TRUE) #> [1] 5 tci_chr(chr, colnames(x)) #> [1] 1 2 1 2 tci_cplx(cplx, nrow(x)) #> [1] 5 4 3 2  ci_flat(x, 1:10 * -1i) #>  [1] 25 24 23 22 21 20 19 18 17 16 ci_margin(x, 1:4, 2) #> [1] 1 2 3 4 ci_sub(x, n(1:5 * -1i, 1:4), 1:2) #> [[1]] #> [1] 5 4 3 2 1 #>  #> [[2]] #> [1] 1 2 3 4 #>"},{"path":"https://tony-aw.github.io/squarebrackets/reference/class_mutable_atomic.html","id":null,"dir":"Reference","previous_headings":"","what":"Mutable Atomic Classes — class_mutable_atomic","title":"Mutable Atomic Classes — class_mutable_atomic","text":"mutable_atomic class mutable version atomic classes.  works exactly aspects regular atomic classes, one real difference:  'squarebrackets' methods functions perform modification reference (basically methods functions \"set\" name) accept mutable_atomic, accept regular atomic.  See squarebrackets_PassByReference details.  Like data.table, [<- performs R's default copy--modification semantics.  modification  reference, use sb_set.  Exposed functions (beside S3 methods): mutable_atomic(): create mutable_atomic object given data. couldb.mutable_atomic(): checks object become mutable_atomic.  objects can become mutable_atomic one following types: logical, integer, double, character, complex, raw. bit64::integer64 type also supported, since internally defined double. typecast.mutable_atomic() type-casts possibly reshapes (mutable) atomic object, returns mutable_atomic object.  preserve dimension names dimensions changed.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/class_mutable_atomic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mutable Atomic Classes — class_mutable_atomic","text":"","code":"mutable_atomic(data, names = NULL, dim = NULL, dimnames = NULL)  as.mutable_atomic(x, ...)  # S3 method for default as.mutable_atomic(x, ...)  is.mutable_atomic(x)  couldb.mutable_atomic(x)  typecast.mutable_atomic(x, type = typeof(x), dims = dim(x))  # S3 method for mutable_atomic c(..., use.names = TRUE)  # S3 method for mutable_atomic [(x, ...)  # S3 method for mutable_atomic [(x, ...) <- value  # S3 method for mutable_atomic format(x, ...)  # S3 method for mutable_atomic print(x, ...)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/class_mutable_atomic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mutable Atomic Classes — class_mutable_atomic","text":"data atomic vector giving data fill mutable_atomic object. names, dim, dimnames see setNames array. x atomic object. ... method dependent arguments. type string giving type; see typeof. dims integer vector, giving new dimensions. use.names Boolean, indicating names preserved. value see Extract.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/class_mutable_atomic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mutable Atomic Classes — class_mutable_atomic","text":"mutable_atomic(), .mutable_atomic(), typecast.mutable_atomic(): Returns mutable_atomic object.  .mutable_atomic(): Returns TRUE object mutable_atomic, returns FALSE otherwise.  couldb.mutable_atomic(): Returns TRUE object one following types: logical, integer, double, character, complex, raw. bit64::integer64 type also supported, since internally defined double. Returns FALSE otherwise.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/class_mutable_atomic.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"Mutable Atomic Classes — class_mutable_atomic","text":"Always use exported functions given 'squarebrackets' create mutable_atomic object, make necessary checks.  Circumventing checks may break things!","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/class_mutable_atomic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mutable Atomic Classes — class_mutable_atomic","text":"","code":"x <- mutable_atomic(   1:20, dim = c(5, 4), dimnames = list(letters[1:5], letters[1:4]) ) x #>   a  b  c  d #> a 1  6 11 16 #> b 2  7 12 17 #> c 3  8 13 18 #> d 4  9 14 19 #> e 5 10 15 20 #> mutable_atomic  #> typeof:  integer  typecast.mutable_atomic(x, \"character\") #>      [,1] [,2] [,3] [,4] #> [1,] \"1\"  \"6\"  \"11\" \"16\" #> [2,] \"2\"  \"7\"  \"12\" \"17\" #> [3,] \"3\"  \"8\"  \"13\" \"18\" #> [4,] \"4\"  \"9\"  \"14\" \"19\" #> [5,] \"5\"  \"10\" \"15\" \"20\" #> mutable_atomic  #> typeof:  character   x <- matrix(1:10, ncol = 2) x <- as.mutable_atomic(x) is.mutable_atomic(x) #> [1] TRUE print(x) #>      [,1] [,2] #> [1,]    1    6 #> [2,]    2    7 #> [3,]    3    8 #> [4,]    4    9 #> [5,]    5   10 #> mutable_atomic  #> typeof:  integer  x[, 1] #> [1] 1 2 3 4 5 #> mutable_atomic  #> typeof:  integer  x[] <- as.double(x) #> coercing type from `integer` to `double` print(x) #>      [,1] [,2] #> [1,]    1    6 #> [2,]    2    7 #> [3,]    3    8 #> [4,]    4    9 #> [5,]    5   10 #> mutable_atomic  #> typeof:  double  is.mutable_atomic(x) #> [1] TRUE"},{"path":"https://tony-aw.github.io/squarebrackets/reference/cp_seq.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct Parameters for a Sequence Based on Margins — cp_seq","title":"Construct Parameters for a Sequence Based on Margins — cp_seq","text":"cp_seq() returns list parameters construct sequence based margins object.  internally used idx_r function slice method.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/cp_seq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct Parameters for a Sequence Based on Margins — cp_seq","text":"","code":"cp_seq(x, m = 0L, from = NULL, to = NULL, by = 1L)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/cp_seq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct Parameters for a Sequence Based on Margins — cp_seq","text":"x object compute margin-based sequence parameters. m integer complex, giving margin(s).  non-dimensional objects flat indices, specify m = 0L. integer complex, length m length 1, specifying point. integer complex, length m length 1, specifying maximally allowed end value. integer, length m length 1, specifying step size.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/cp_seq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct Parameters for a Sequence Based on Margins — cp_seq","text":"list following elements:  $start: actual starting point sequence. simply translated regular numeric.  $end: actual ending point sequence. , even translated regular numeric. example, following code:   specifies = 10L. sequence actually end 10; ends 9. Therefore, cp_seq(x, m, 1, 10, 2) return end = 9, end = 10. allows user easily predict sequence given idx_r/slice actually end.  $: give , sign adjusted, needed.  $length.: actual vector lengths sequences , given translated parameters.","code":"seq(from = 1L, to = 10L, by = 2L) #> [1] 1 3 5 7 9"},{"path":"https://tony-aw.github.io/squarebrackets/reference/cp_seq.html","id":"arguments-details","dir":"Reference","previous_headings":"","what":"Arguments Details","title":"Construct Parameters for a Sequence Based on Margins — cp_seq","text":"Multiple dimensions  cp_seq function can construct sequence parameters needed multiple dimensions , specifying vector m.  lengths arguments recycled needed. Using  , specified, using construct following sequence:  positive, seq.int(1L, n, ).  negative, seq.int(n, 1L, ).  n maximum index (.e. length(x) dim(x)[m], depending situation). Using , ,  , , specified, stored abs(), sign  automatically adjusted ensure sensible sequence created.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/cp_seq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct Parameters for a Sequence Based on Margins — cp_seq","text":"","code":"x <- data.frame(   a = 1:10, b = letters[1:10], c = factor(letters[1:10]), d = -1:-10 ) print(x) #>     a b c   d #> 1   1 a a  -1 #> 2   2 b b  -2 #> 3   3 c c  -3 #> 4   4 d d  -4 #> 5   5 e e  -5 #> 6   6 f f  -6 #> 7   7 g g  -7 #> 8   8 h h  -8 #> 9   9 i i  -9 #> 10 10 j j -10 ind1 <- idx_r(x, 1, 2, 2* -1i) # rows 2:(nrow(x)-1) sb2_x(x, ind1) # extract the row range #>   a b c  d #> 1 2 b b -2 #> 2 3 c c -3 #> 3 4 d d -4 #> 4 5 e e -5 #> 5 6 f f -6 #> 6 7 g g -7 #> 7 8 h h -8 #> 8 9 i i -9  x <- array(1:125, c(5,5,5)) dims <- 1:3 sub <- idx_r(x, dims, 2, 2* -1i) # 2:(n-1) for every dimension sb_x(x, sub, dims) # same as x[ 2:4, 2:4, 2:4, drop = FALSE] #> , , 1 #>  #>      [,1] [,2] [,3] #> [1,]   32   37   42 #> [2,]   33   38   43 #> [3,]   34   39   44 #>  #> , , 2 #>  #>      [,1] [,2] [,3] #> [1,]   57   62   67 #> [2,]   58   63   68 #> [3,]   59   64   69 #>  #> , , 3 #>  #>      [,1] [,2] [,3] #> [1,]   82   87   92 #> [2,]   83   88   93 #> [3,]   84   89   94 #>   x <- letters x[idx_r(x, 0, 2, 2* -1i)] #>  [1] \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" \"t\" #> [20] \"u\" \"v\" \"w\" \"x\" \"y\""},{"path":"https://tony-aw.github.io/squarebrackets/reference/currentBindings.html","id":null,"dir":"Reference","previous_headings":"","what":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","text":"currentBindings(x, action = \"list\")  lists currently existing objects sharing address x, given environment. currentBindings(x, action = \"checklock\")  searches currently existing objects sharing address x, given environment, reports locked locked. currentBindings(x, action = \"lockbindings\")  searches currently existing objects sharing address x, given environment, locks using lockBinding.  See also squarebrackets_PassByReference information regarding relation locked bindings pass--reference modifications.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/currentBindings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","text":"","code":"currentBindings(x, action = \"list\", env = NULL)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/currentBindings.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","text":"x existing variable whose address use searching bindings. action single string, giving action perform.  Must one following: \"list\" (default). \"checklock\". \"lockbindings\". env environment look objects.  NULL (default), caller environment used.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/currentBindings.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","text":"currentBindings(x, action = \"list\"): Returns character vector.  currentBindings(x, action = \"checklock\"): Returns named logical vector. names give names bindings, associated value indicates whether binding locked (TRUE) locked (FALSE).  currentBindings(x, action = \"lockbindings\"): Returns VOID. just locks currently existing bindings. unlock bindings, remove objects (see rm).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/currentBindings.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","text":"lockBinding function locks binding object, preventing modification.  'R' also uses locked bindings prevent modification objects package namespaces.  pass--reference semantics 'squarebrackets' principle respect , disallows modification objects reference.  However, lockBinding lock address/pointer object, one particular binding object.  problematic; consider following example:   code, x y share address, thus pointing memory, yet y actually locked.  Since x locked, modifying x allowed.  since sb_set()/sb2_set() performs modification reference, y still modified, despite locked.  currentBindings() function allows user : find currently existing bindings caller environment sharing address x, locking bindings.","code":"x <- mutable_atomic(1:16) y <- x lockBinding(\"y\", environment()) sb_set(x, i = 1:6, rp = 8)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/currentBindings.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","text":"currentBindings() function locks currently existing bindings specified environment;  bindings created calling currentBindings() automatically locked.  Thus, every time user creates new binding object, user wishes locked, currentBindings() must called .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/currentBindings.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","text":"","code":"x <- as.mutable_atomic(1:10) y <- x lockBinding(\"y\", environment()) currentBindings(x) #> searching environment: <000002b93dd7d438> #> [1] \"x\" \"y\" currentBindings(x, \"checklock\") # only y is locked #> searching environment: <000002b93dd7d438> #>     x     y  #> FALSE  TRUE    # since only y is locked, we can still modify y through x by reference: sb_set(x, i = 1, rp = -1) #> coercing replacement to integer print(y) # modified! #>  [1] -1  2  3  4  5  6  7  8  9 10 #> mutable_atomic  #> typeof:  integer  rm(list= c(\"y\")) # clean up   # one can fix this by locking ALL bindings: y <- x currentBindings(x, \"lockbindings\") # lock all #> searching environment: <000002b93dd7d438> currentBindings(x, \"checklock\") # all bindings are locked, including y #> searching environment: <000002b93dd7d438> #>    x    y  #> TRUE TRUE  # the 'squarebrackets' package respects the lock of a binding, # provided all bindings of an address are locked; # so this will give an error, as it should:  if(requireNamespace(\"tinytest\")) {   tinytest::expect_error(     sb_set(x, i = 1, rp = -1),     pattern = \"object is locked\"   ) } #> ----- PASSED      : <--> #>  call| eval(expr, envir, enclos)   # creating a new variable will NOT automatically be locked: z <- y # new variable; will not be locked! currentBindings(x, \"checklock\") # z is not locked #> searching environment: <000002b93dd7d438> #>     x     y     z  #>  TRUE  TRUE FALSE  currentBindings(x, \"lockbindings\") # we must re-run this #> searching environment: <000002b93dd7d438> currentBindings(x, \"checklock\") # now z is also locked #> searching environment: <000002b93dd7d438> #>    x    y    z  #> TRUE TRUE TRUE   if(requireNamespace(\"tinytest\")) {   tinytest::expect_error( # now z is also protected     sb_set(z, i = 1, rp = -1),     pattern = \"object is locked\"   ) } #> ----- PASSED      : <--> #>  call| eval(expr, envir, enclos)    rm(list= c(\"x\", \"y\", \"z\")) # clean up"},{"path":"https://tony-aw.github.io/squarebrackets/reference/developer_ci.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct Indices — developer_ci","title":"Construct Indices — developer_ci","text":"functions construct flat dimensional indices. ci_flat() constructs integer vector flat indices. ci_margin() constructs integer vector indices one particular dimension margin. ci_sub() constructs list integer subscripts. ci_df() ci_margin(), except specifically designed data.frame-like objects.  separate function, things like dimnames(x)[1] rownames(x) always return output certain data.frame-like objects.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/developer_ci.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct Indices — developer_ci","text":"","code":"ci_flat(   x,   i,   inv = FALSE,   chkdup = FALSE,   uniquely_named = FALSE,   .abortcall = sys.call() )  ci_margin(   x,   slice,   margin,   inv = FALSE,   chkdup = FALSE,   uniquely_named = FALSE,   .abortcall = sys.call() )  ci_sub(   x,   sub,   dims,   inv = FALSE,   chkdup = FALSE,   uniquely_named = FALSE,   .abortcall = sys.call() )  ci_df(   x,   slice,   margin,   inv = FALSE,   chkdup = FALSE,   uniquely_named = FALSE,   .abortcall = sys.call() )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/developer_ci.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct Indices — developer_ci","text":"x object indices meant. , slice, margin, sub, dims, inv See squarebrackets_indx_args. chkdup see squarebrackets_options. uniquely_named Boolean, indicating user knows -priori relevant names x unique.  set TRUE, speed may increase.  specifying TRUE relevant names unique result incorrect output. .abortcall environment error message passed .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/developer_ci.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct Indices — developer_ci","text":"integer vector constructed indices.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/developer_ci.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct Indices — developer_ci","text":"","code":"x <- matrix(1:25, 5, 5) colnames(x) <- c(\"a\", \"a\", \"b\", \"c\", \"d\") print(x) #>      a  a  b  c  d #> [1,] 1  6 11 16 21 #> [2,] 2  7 12 17 22 #> [3,] 3  8 13 18 23 #> [4,] 4  9 14 19 24 #> [5,] 5 10 15 20 25  bool <- sample(c(TRUE, FALSE), 5, TRUE) int <- 1:4 chr <- c(\"a\", \"a\") cplx <- 1:4 * -1i tci_bool(bool, nrow(x)) #> [1] 2 5 tci_int(int, ncol(x), inv = TRUE) #> [1] 5 tci_chr(chr, colnames(x)) #> [1] 1 2 1 2 tci_cplx(cplx, nrow(x)) #> [1] 5 4 3 2  ci_flat(x, 1:10 * -1i) #>  [1] 25 24 23 22 21 20 19 18 17 16 ci_margin(x, 1:4, 2) #> [1] 1 2 3 4 ci_sub(x, n(1:5 * -1i, 1:4), 1:2) #> [[1]] #> [1] 5 4 3 2 1 #>  #> [[2]] #> [1] 1 2 3 4 #>"},{"path":"https://tony-aw.github.io/squarebrackets/reference/developer_tci.html","id":null,"dir":"Reference","previous_headings":"","what":"Type Cast Indices — developer_tci","title":"Type Cast Indices — developer_tci","text":"functions typecast indices proper integer indices.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/developer_tci.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Type Cast Indices — developer_tci","text":"","code":"tci_bool(indx, n, inv = FALSE, .abortcall = sys.call())  tci_int(indx, n, inv = FALSE, chkdup = FALSE, .abortcall = sys.call())  tci_chr(   indx,   nms,   inv = FALSE,   chkdup = FALSE,   uniquely_named = FALSE,   .abortcall = sys.call() )  tci_cplx(indx, n, inv = FALSE, chkdup = FALSE, .abortcall = sys.call())"},{"path":"https://tony-aw.github.io/squarebrackets/reference/developer_tci.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Type Cast Indices — developer_tci","text":"indx indices typecast n relevant size, typecasting integer logical indices.  Examples: target row indices, input nrow n. target flat indices, input length n. inv Boolean, indicating indices inverted.  See squarebrackets_indx_args. .abortcall environment error message passed . chkdup see squarebrackets_options. nms relevant names, typecasting character indices.  Examples: target row indices, input row names nms. target flat indices, input flat names nms. uniquely_named Boolean, indicating user knows -priori relevant names x unique.  set TRUE, speed may increase.  specifying TRUE relevant names unique result incorrect output.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/developer_tci.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Type Cast Indices — developer_tci","text":"integer vector type-cast indices.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/developer_tci.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Type Cast Indices — developer_tci","text":"","code":"x <- matrix(1:25, 5, 5) colnames(x) <- c(\"a\", \"a\", \"b\", \"c\", \"d\") print(x) #>      a  a  b  c  d #> [1,] 1  6 11 16 21 #> [2,] 2  7 12 17 22 #> [3,] 3  8 13 18 23 #> [4,] 4  9 14 19 24 #> [5,] 5 10 15 20 25  bool <- sample(c(TRUE, FALSE), 5, TRUE) int <- 1:4 chr <- c(\"a\", \"a\") cplx <- 1:4 * -1i tci_bool(bool, nrow(x)) #> [1] 3 4 tci_int(int, ncol(x), inv = TRUE) #> [1] 5 tci_chr(chr, colnames(x)) #> [1] 1 2 1 2 tci_cplx(cplx, nrow(x)) #> [1] 5 4 3 2  ci_flat(x, 1:10 * -1i) #>  [1] 25 24 23 22 21 20 19 18 17 16 ci_margin(x, 1:4, 2) #> [1] 1 2 3 4 ci_sub(x, n(1:5 * -1i, 1:4), 1:2) #> [[1]] #> [1] 5 4 3 2 1 #>  #> [[2]] #> [1] 1 2 3 4 #>"},{"path":"https://tony-aw.github.io/squarebrackets/reference/dt.html","id":null,"dir":"Reference","previous_headings":"","what":"Functional Forms of data.table Operations — dt","title":"Functional Forms of data.table Operations — dt","text":"Functional forms special data.table operations.  functions use Non-Standard Evaluation.  functions also benefit security measures 'squarebrackets' implements pass--reference semantics. dt_aggregate() aggregates data.table tidytable, returns aggregated copy. dt_setcoe() coercively transforms columns data.table tidytable using pass--reference semantics. dt_setrm() removes columns data.table tidytable using pass--reference semantics. dt_setadd(x, new) adds columns data.table/tidytable new data.table/tidytable x, thereby modifying x using pass--reference semantics. dt_setreorder() reorders rows /variables data.table using pass--reference semantics.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/dt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functional Forms of data.table Operations — dt","text":"","code":"dt_aggregate(x, SDcols = NULL, f, by, order_by = FALSE)  dt_setcoe(   x,   col = NULL,   vars = NULL,   v,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  dt_setrm(   x,   col = NULL,   vars = NULL,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  dt_setadd(x, new)  dt_setreorder(x, roworder = NULL, varorder = NULL)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/dt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functional Forms of data.table Operations — dt","text":"x data.table tidytable. SDcols atomic vector, giving columns aggregation function f() applied . f aggregation function atomic vector, giving grouping columns. order_by Boolean, indicating aggregated result ordered columns specified . col, vars see squarebrackets_indx_args.  Duplicates allowed. v coercive transformation function chkdup see squarebrackets_options. new data.frame-like object.  must column names already exist x. roworder integer vector length nrow(x), giving order rows re-order. Internally, numeric vector turned order using order, thus ensuring strict permutation 1:nrow(x). varorder integer character vector length ncol(x), giving new column order.  See data.table::setcolorder.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/dt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functional Forms of data.table Operations — dt","text":"dt_aggregate(): aggregated data.table object.  rest functions: Returns: VOID. functions modify object reference. use assignments like x <- dt_setcoe(x, ...). Since functions return void, just get NULL.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/dt.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Functional Forms of data.table Operations — dt","text":"dt_setreorder(x, roworder = roworder) internally creates new column reorder data.table , removes new column.  column name randomized, extra care given ensure overwrite existing columns.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/dt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functional Forms of data.table Operations — dt","text":"","code":"# dt_aggregate on sf-data.table ====  if(requireNamespace(\"sf\")) {   x <- sf::st_read(system.file(\"shape/nc.shp\", package = \"sf\"))   x <- data.table::as.data.table(x)      x$region <- ifelse(x$CNTY_ID <= 2000, 'high', 'low')   d.aggr <- dt_aggregate(     x, SDcols = \"geometry\", f= sf::st_union, by = \"region\"   )      head(d.aggr) } #> Loading required namespace: sf #> Reading layer `nc' from data source `D:\\Programs\\R-4.4.0\\library\\sf\\shape\\nc.shp' using driver `ESRI Shapefile' #> Simple feature collection with 100 features and 14 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 #> Geodetic CRS:  NAD27 #>    region                       geometry #>    <char>             <sfc_MULTIPOLYGON> #> 1:   high MULTIPOLYGON (((-75.78317 3... #> 2:    low MULTIPOLYGON (((-76.46926 3...    #############################################################################   # dt_setcoe ====  obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb2_set(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost ) #> Warning: 1.414214 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 1 named 'a') #> Warning: 3.464102 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 3 named 'c') str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 1 1 2 2 2 2 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 3 3 3 3 4 4 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) dt_setcoe(obj, vars = is.numeric, v = as.numeric) # integers are now numeric str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb2_set(obj,   filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # SAFE: coercion performed; so no warnings )  str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 1.41 1.73 2 2.24 ... #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  11 3.46 3.61 3.74 3.87 ... #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>    #############################################################################   # dt_setrm ====  obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  dt_setrm(obj, col = 1) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  3 variables: #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>   obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  dt_setrm(obj, vars = is.numeric) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  2 variables: #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>    #############################################################################   # dt_setadd ====  obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) new <- data.table::data.table(   e = sample(c(TRUE, FALSE), 10, TRUE),   f = sample(c(TRUE, FALSE), 10, TRUE) ) dt_setadd(obj, new) print(obj) #>         a      b     c      d      e      f #>     <int> <char> <int> <fctr> <lgcl> <lgcl> #>  1:     1      a    11      a  FALSE  FALSE #>  2:     2      b    12      b  FALSE   TRUE #>  3:     3      c    13      c  FALSE  FALSE #>  4:     4      d    14      d  FALSE  FALSE #>  5:     5      e    15      e   TRUE   TRUE #>  6:     6      f    16      f  FALSE  FALSE #>  7:     7      g    17      g  FALSE  FALSE #>  8:     8      h    18      h   TRUE   TRUE #>  9:     9      i    19      i   TRUE  FALSE #> 10:    10      j    20      j  FALSE  FALSE    #############################################################################   # dt_setreorder====  n <- 1e4 obj <- data.table::data.table(   a = 1L:n, b = n:1L, c = as.double(1:n), d = as.double(n:1) ) dt_setreorder(obj, roworder = n:1) head(obj) #>        a     b     c     d #>    <int> <int> <num> <num> #> 1: 10000     1 10000     1 #> 2:  9999     2  9999     2 #> 3:  9998     3  9998     3 #> 4:  9997     4  9997     4 #> 5:  9996     5  9996     5 #> 6:  9995     6  9995     6 dt_setreorder(obj, varorder = ncol(obj):1) head(obj) #>        d     c     b     a #>    <num> <num> <int> <int> #> 1:     1 10000     1 10000 #> 2:     2  9999     2  9999 #> 3:     3  9998     3  9998 #> 4:     4  9997     4  9997 #> 5:     5  9996     5  9996 #> 6:     6  9995     6  9995"},{"path":"https://tony-aw.github.io/squarebrackets/reference/exported_uilities.html","id":null,"dir":"Reference","previous_headings":"","what":"Exported Utilities — indx_x","title":"Exported Utilities — indx_x","text":"Exported utilities.  Usually user need functions.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/exported_uilities.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exported Utilities — indx_x","text":"","code":"indx_x(i, x, xnames, xsize)  indx_wo(i, x, xnames, xsize)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/exported_uilities.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exported Utilities — indx_x","text":"See squarebrackets_indx_args. x vector, vector-like object, factor, data.frame, data.frame-like object, list. xnames names dimension names xsize length dimension size","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/exported_uilities.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exported Utilities — indx_x","text":"subsetted object.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/exported_uilities.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Exported Utilities — indx_x","text":"","code":"x <- 1:10 names(x) <- letters[1:10] indx_x(1:5, x, names(x), length(x)) #> [1] 1 2 3 4 5 indx_wo(1:5, x, names(x), length(x)) #> [1]  6  7  8  9 10"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx1.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert/Translate Indices (for Copy-On-Modify Substitution) — idx","title":"Convert/Translate Indices (for Copy-On-Modify Substitution) — idx","text":"idx() method converts indices.  type output depends type input index arguments given: idx(x, = , ...) converts linear indices strictly positive integer vector linear indices. idx(x, sub = sub, dims = dims, ...) converts dimensional indices strictly positive integer vector linear indices. idx(x, slice = slice, margin = margin, ...) converts indices one dimension strictly positive integer vector indices specific dimension. Vectors (atomic recursive) index argument .  Data.frame-like objects slice, margin index argument pair.  Arrays (atomic recursive) sub, dims index argument pair, well arguments slice, margin.  result idx() method can used inside regular square-brackets operators.  example like :   thus allowing user benefit convenient index translations 'squarebrackets', whilst still using R's default copy--modification semantics (instead semantics provided 'squarebrackets').","code":"x <- array(...) my_sub2ind <- idx(x, sub, dims) x[my_sub2ind] <- value  y <- data.frame(...) rows <- idx(y, 1:10, 1, inv = TRUE) cols <- idx(y, c(\"a\", \"b\"), 2) y[rows, cols] <- value"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert/Translate Indices (for Copy-On-Modify Substitution) — idx","text":"","code":"idx(x, ...)  # S3 method for default idx(x, i, inv = FALSE, ..., chkdup = getOption(\"squarebrackets.chkdup\", FALSE))  # S3 method for array idx(   x,   sub = NULL,   dims = 1:ndims(x),   slice = NULL,   margin = NULL,   i = NULL,   inv = FALSE,   ...,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # S3 method for data.frame idx(   x,   slice,   margin,   inv = FALSE,   ...,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx1.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert/Translate Indices (for Copy-On-Modify Substitution) — idx","text":"x vector, matrix, array, data.frame; atomic recursive objects supported. ... see squarebrackets_method_dispatch. , sub, dims, margin, slice, inv See squarebrackets_indx_args.  Duplicates allowed. chkdup see squarebrackets_options.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx1.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert/Translate Indices (for Copy-On-Modify Substitution) — idx","text":"idx(x, = , ...) idx(x, sub = sub, dims = dims, ...): strictly positive integer vector flat indices.  idx(x, margin = margin, slice = slice, ...): strictly positive integer vector indices dimension specified margin.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx1.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert/Translate Indices (for Copy-On-Modify Substitution) — idx","text":"","code":"# atomic ====  x <- 1:10 x[idx(x, \\(x)x>5)] <- -5 print(x) #>  [1]  1  2  3  4  5 -5 -5 -5 -5 -5  x <- array(1:27, dim = c(3,3,3)) x[idx(x, n(1:2, 1:2), c(1,3))] <- -10 print(x) #> , , 1 #>  #>      [,1] [,2] [,3] #> [1,]  -10  -10  -10 #> [2,]  -10  -10  -10 #> [3,]    3    6    9 #>  #> , , 2 #>  #>      [,1] [,2] [,3] #> [1,]  -10  -10  -10 #> [2,]  -10  -10  -10 #> [3,]   12   15   18 #>  #> , , 3 #>  #>      [,1] [,2] [,3] #> [1,]   19   22   25 #> [2,]   20   23   26 #> [3,]   21   24   27 #>    ################################################################################   # recursive ====  x <- as.list(1:10) x[idx(x, \\(x)x>5)] <- -5 print(x) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 3 #>  #> [[4]] #> [1] 4 #>  #> [[5]] #> [1] 5 #>  #> [[6]] #> [1] -5 #>  #> [[7]] #> [1] -5 #>  #> [[8]] #> [1] -5 #>  #> [[9]] #> [1] -5 #>  #> [[10]] #> [1] -5 #>   x <- array(as.list(1:27), dim = c(3,3,3)) x[idx(x, n(1:2, 1:2), c(1,3))] <- -10 print(x) #> , , 1 #>  #>      [,1] [,2] [,3] #> [1,] -10  -10  -10  #> [2,] -10  -10  -10  #> [3,] 3    6    9    #>  #> , , 2 #>  #>      [,1] [,2] [,3] #> [1,] -10  -10  -10  #> [2,] -10  -10  -10  #> [3,] 12   15   18   #>  #> , , 3 #>  #>      [,1] [,2] [,3] #> [1,] 19   22   25   #> [2,] 20   23   26   #> [3,] 21   24   27   #>    x <- data.frame(   a = sample(c(TRUE, FALSE, NA), 10, TRUE),   b = 1:10,   c = rnorm(10),   d = letters[1:10],   e = factor(letters[11:20]) ) rows <- idx(x, 1:5, 1, inv = TRUE) cols <- idx(x, c(\"b\", \"a\"), 2) x[rows, cols] <- NA print(x) #>        a  b          c d e #> 1  FALSE  1  0.3720032 a k #> 2  FALSE  2 -0.6098583 b l #> 3  FALSE  3  1.0439389 c m #> 4   TRUE  4 -0.3027063 d n #> 5   TRUE  5  1.4172813 e o #> 6     NA NA -0.8671011 f p #> 7     NA NA -2.2181411 g q #> 8     NA NA -0.2753020 h r #> 9     NA NA  0.3766451 i s #> 10    NA NA  0.9721363 j t"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_by.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Grouped Indices — idx_by","title":"Compute Grouped Indices — idx_by","text":"Given: sub-set function f; object x margin m; grouping factor grp; idx_by() function takes indices per group grp.  result idx_by() can supplied indexing arguments (see squarebrackets_indx_args) perform grouped subset operations.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_by.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Grouped Indices — idx_by","text":"","code":"idx_by(x, m, f, grp, parallel = FALSE, mc.cores = 1L)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_by.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Grouped Indices — idx_by","text":"x object compute indices. m single non-negative integer giving margin compute indices.  flat indices non-dimensional objects, use m = 0L. f subset function applied per group indices.  m == 0L, indices defined setNames(1:length(x), names(x)).  m > 0L, indices defined setNames(1:dim(x)[m], dimnames(x)[[m]]).  function must produce character integer vector output.  example, subset last element per group, specify: f = last grp factor giving groups. parallel, mc.cores see .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_by.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Grouped Indices — idx_by","text":"vector indices.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_by.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Grouped Indices — idx_by","text":"","code":"# vectors ==== (a <- 1:20) #>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 (grp <- factor(rep(letters[1:5], each = 4))) #>  [1] a a a a b b b b c c c c d d d d e e e e #> Levels: a b c d e  # get the last element of `a` for each group in `grp`: i <- idx_by(a, 0L, last, grp) sb_x(cbind(a, grp), i, 1L) #>       a grp #> [1,]  4   1 #> [2,]  8   2 #> [3,] 12   3 #> [4,] 16   4 #> [5,] 20   5   # data.frame ==== x <- data.frame(   a = sample(1:20),   b = letters[1:20],   group = factor(rep(letters[1:5], each = 4)) ) print(x) #>     a b group #> 1   7 a     a #> 2  14 b     a #> 3  10 c     a #> 4  18 d     a #> 5  15 e     b #> 6   2 f     b #> 7   5 g     b #> 8   6 h     b #> 9  17 i     c #> 10 20 j     c #> 11 13 k     c #> 12  3 l     c #> 13  4 m     d #> 14  9 n     d #> 15 12 o     d #> 16  8 p     d #> 17 16 q     e #> 18 11 r     e #> 19  1 s     e #> 20 19 t     e # get the first row for each group in data.frame `x`: row <- idx_by(x, 1, first, x$group) sb2_x(x, row) #>    a b group #> 1  7 a     a #> 2 15 e     b #> 3 17 i     c #> 4  4 m     d #> 5 16 q     e # get the first row for each group for which a > 10: x2 <- sb2_x(x, filter = ~ a > 10) row <- na.omit(idx_by(x2, 1, first, x2$group)) sb2_x(x2, row) #>    a b group #> 1 14 b     a #> 2 15 e     b #> 3 17 i     c #> 4 12 o     d #> 5 16 q     e"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_ord.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Ordered Indices — idx_ord_v","title":"Compute Ordered Indices — idx_ord_v","text":"Computes ordered indices. Similar order, except user must supply vector, list equal-length vectors, data.frame matrix (row-wise column-wise supported), input.  vector x, idx_ord_v(x) equivalent order(x).  data.frame list equal-length vectors x, p columns/elements, idx_ord_df(x) equivalent order(x[[1]], ..., x[[p]]).  matrix (array) x p rows, idx_ord_m(x, margin = 1) equivalent order(x[1, ], ..., x[p, ], ...).  matrix (array) x p columns, idx_ord_m(x, margin = 2) equivalent order(x[, 1], ..., x[, p], ...).  Note merely convenience functions, actually slightly slower order (except idx_ord_v()), due additional functionality.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_ord.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Ordered Indices — idx_ord_v","text":"","code":"idx_ord_v(   x,   na.last = TRUE,   decr = FALSE,   method = c(\"auto\", \"shell\", \"radix\") )  idx_ord_m(   x,   margin,   na.last = TRUE,   decr = FALSE,   method = c(\"auto\", \"shell\", \"radix\") )  idx_ord_df(   x,   na.last = TRUE,   decr = FALSE,   method = c(\"auto\", \"shell\", \"radix\") )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_ord.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Ordered Indices — idx_ord_v","text":"x vector, data.frame, array na.last, method see order sort. decr see argument decreasing order margin margin cut matrix/array vectors.  .e. margin = 1L cut x individual rows, apply order rows.  margin = 2L cut x columns, etc.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_ord.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Ordered Indices — idx_ord_v","text":"See order.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_ord.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Ordered Indices — idx_ord_v","text":"","code":"x <- sample(1:10) order(x) #>  [1]  3  6  4  5  8 10  7  9  1  2 idx_ord_v(x) #>  [1]  3  6  4  5  8 10  7  9  1  2 idx_ord_m(rbind(x, x), 1) #>  [1]  3  6  4  5  8 10  7  9  1  2 idx_ord_m(cbind(x, x), 2) #>  [1]  3  6  4  5  8 10  7  9  1  2 idx_ord_df(data.frame(x, x)) #>  [1]  3  6  4  5  8 10  7  9  1  2"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_r.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Integer Index Range — idx_r","title":"Compute Integer Index Range — idx_r","text":"idx_r() computes integer index range(s).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_r.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Integer Index Range — idx_r","text":"","code":"idx_r(x, m = 0L, from = NULL, to = NULL, by = 1L)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_r.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Integer Index Range — idx_r","text":"x object compute subset indices. m, , , see cp_seq.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_r.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Integer Index Range — idx_r","text":"length(m) == 1L: vector numeric indices.  length(m) > 1L: list length m, containing numeric vectors indices.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_r.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Integer Index Range — idx_r","text":"","code":"x <- data.frame(   a = 1:10, b = letters[1:10], c = factor(letters[1:10]), d = -1:-10 ) print(x) #>     a b c   d #> 1   1 a a  -1 #> 2   2 b b  -2 #> 3   3 c c  -3 #> 4   4 d d  -4 #> 5   5 e e  -5 #> 6   6 f f  -6 #> 7   7 g g  -7 #> 8   8 h h  -8 #> 9   9 i i  -9 #> 10 10 j j -10 ind1 <- idx_r(x, 1, 2, 2* -1i) # rows 2:(nrow(x)-1) sb2_x(x, ind1) # extract the row range #>   a b c  d #> 1 2 b b -2 #> 2 3 c c -3 #> 3 4 d d -4 #> 4 5 e e -5 #> 5 6 f f -6 #> 6 7 g g -7 #> 7 8 h h -8 #> 8 9 i i -9  x <- array(1:125, c(5,5,5)) dims <- 1:3 sub <- idx_r(x, dims, 2, 2* -1i) # 2:(n-1) for every dimension sb_x(x, sub, dims) # same as x[ 2:4, 2:4, 2:4, drop = FALSE] #> , , 1 #>  #>      [,1] [,2] [,3] #> [1,]   32   37   42 #> [2,]   33   38   43 #> [3,]   34   39   44 #>  #> , , 2 #>  #>      [,1] [,2] [,3] #> [1,]   57   62   67 #> [2,]   58   63   68 #> [3,]   59   64   69 #>  #> , , 3 #>  #>      [,1] [,2] [,3] #> [1,]   82   87   92 #> [2,]   83   88   93 #> [3,]   84   89   94 #>   x <- letters x[idx_r(x, 0, 2, 2* -1i)] #>  [1] \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" \"t\" #> [20] \"u\" \"v\" \"w\" \"x\" \"y\""},{"path":"https://tony-aw.github.io/squarebrackets/reference/lst.html","id":null,"dir":"Reference","previous_headings":"","what":"Unnest Tree-like List into a Recursive Matrix or Flattened Recursive Vector — lst","title":"Unnest Tree-like List into a Recursive Matrix or Flattened Recursive Vector — lst","text":"[[, [[<-, sb2_rec, sb2_recin, can perform recursive subset operations nested list.  recursive subset operations operate single element.  Performing recursive subset operations multiple elements vectorized, requires (potentially slow) loop.  lst_untree() function takes nested tree-like list, turns recursive matrix (matrix list-elements), allowing vectorized subset operations performed nested list. lst_untree() can also simply flatten list, making non-nested list.  See Examples section understand list arranged named.  lst_nlists() counts total number recursive list-elements inside list.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/lst.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unnest Tree-like List into a Recursive Matrix or Flattened Recursive Vector — lst","text":"","code":"lst_nlists(x)  lst_untree(x, margin, use.names = TRUE)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/lst.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Unnest Tree-like List into a Recursive Matrix or Flattened Recursive Vector — lst","text":"x tree-like nested list. margin single integer, indicating result arranged: margin = 0 produces simple flattened recursive vector (.e. list) without dimensions. margin = 1 produces recursive matrix (.e. matrix list-elements),  length(x) rows n columns,  n = sapply(x, lst_nlists) |> max().  Empty elements filled list(NULL). margin = 2 produces recursive matrix (.e. matrix list-elements),  length(x) columns n rows,  n = sapply(x, lst_nlists) |> max().  Empty elements filled list(NULL). use.names Boolean, indicating result named.  See section \"use.names\" information.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/lst.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Unnest Tree-like List into a Recursive Matrix or Flattened Recursive Vector — lst","text":"lst_untree(): non-nested (dimensional) list. Note margin = 1 margin = 2, lst_untree() returns recursive matrix (.e. recursive array 2 dimensions), data.frame. turn nested list data.frame instead, one option use: rrapply(x, = \"melt\")    lst_nlists(): single integer, giving total number recursive list-elements given list.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/lst.html","id":"use-names","dir":"Reference","previous_headings":"","what":"use.names","title":"Unnest Tree-like List into a Recursive Matrix or Flattened Recursive Vector — lst","text":"margin = 0 use.names = TRUE  margin = 0 use.names = TRUE, every element flattened list named.  Names nested elements, x[[\"\"]][[\"B\"]][[\"C\"]], become \".B.C\", behaviour rapply function (lst_untree() calls internally).  therefore advised use dots (\".\") list names, use underscores (\"_\") instead, calling lst_untree().  See rrapply::rrapply function renaming (forms transforming) recursive subsets lists. margin = 1 use.names = TRUE  margin == 1 use.names = TRUE, rows resulting recursive matrix equal names(x), recursive names assigned. margin = 2 use.names = TRUE  margin == 2 use.names = TRUE, columns resulting recursive matrix equal names(x), recursive names assigned. use.names = FALSE  use.names = FALSE, result names assigned .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/lst.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Unnest Tree-like List into a Recursive Matrix or Flattened Recursive Vector — lst","text":"","code":"# show-casing how the list-elements are arranged and named ====  x <- list(   A = list(     A = list(A = \"AAA\", B = \"AAB\"),     A = list(A  = \"AA2A\", B = \"AA2B\"),     B = list(A = \"ABA\", B = \"ABB\"),     C = letters   ),   Y = list(     Z = list(Z = \"YZZ\", Y = \"YZY\"),     Y = list(Z = \"YYZ\", Y = \"YYY\"),     X = \"YX\"   ) )   # un-tree column-wise: sapply(x, lst_nlists) |> max() # number of rows `y` will have #> [1] 7 y <- lst_untree(x, margin = 2L, use.names = TRUE) dim(y) #> [1] 7 2 print(y) #>      A            Y     #> [1,] \"AAA\"        \"YZZ\" #> [2,] \"AAB\"        \"YZY\" #> [3,] \"AA2A\"       \"YYZ\" #> [4,] \"AA2B\"       \"YYY\" #> [5,] \"ABA\"        \"YX\"  #> [6,] \"ABB\"        NULL  #> [7,] character,26 NULL  sb2_x(y, n(1:3, 1:2), 1:ndims(y)) # vectorized selection of multiple recursive elements #>      A      Y     #> [1,] \"AAA\"  \"YZZ\" #> [2,] \"AAB\"  \"YZY\" #> [3,] \"AA2A\" \"YYZ\"   # un-tree row-wise: sapply(x, lst_nlists) |> max() # number of columns `y` will have #> [1] 7 y <- lst_untree(x, margin = 1L, use.names = TRUE) dim(y) #> [1] 2 7 print(y) #>   [,1]  [,2]  [,3]   [,4]   [,5]  [,6]  [,7]         #> A \"AAA\" \"AAB\" \"AA2A\" \"AA2B\" \"ABA\" \"ABB\" character,26 #> Y \"YZZ\" \"YZY\" \"YYZ\"  \"YYY\"  \"YX\"  NULL  NULL         sb2_x(y, n(1:2, 1:3), 1:ndims(y))  # vectorized selection of multiple recursive elements #>   [,1]  [,2]  [,3]   #> A \"AAA\" \"AAB\" \"AA2A\" #> Y \"YZZ\" \"YZY\" \"YYZ\"    # simple flattened list: y <- lst_untree(x, margin = 0, use.names = TRUE) print(y) #> $A.A.A #> [1] \"AAA\" #>  #> $A.A.B #> [1] \"AAB\" #>  #> $A.A.A #> [1] \"AA2A\" #>  #> $A.A.B #> [1] \"AA2B\" #>  #> $A.B.A #> [1] \"ABA\" #>  #> $A.B.B #> [1] \"ABB\" #>  #> $A.C #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" #> [20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\" #>  #> $Y.Z.Z #> [1] \"YZZ\" #>  #> $Y.Z.Y #> [1] \"YZY\" #>  #> $Y.Y.Z #> [1] \"YYZ\" #>  #> $Y.Y.Y #> [1] \"YYY\" #>  #> $Y.X #> [1] \"YX\" #>  y[[\"Y.Z.Y\"]] #> [1] \"YZY\" x[[c(\"Y\", \"Z\", \"Y\")]] # equivalent in the original list #> [1] \"YZY\"   ################################################################################  # showcasing that only list-elements are recursively flattened ==== # i.e. atomic vectors in recursive subsets remain atomic  x <- lapply(1:10, \\(x)list(sample(letters), sample(1:10)))  sapply(x, lst_nlists) |> max() #> [1] 2 y <- lst_untree(x, margin = 1) dim(y) #> [1] 10  2 print(y) #>       [,1]         [,2]       #>  [1,] character,26 integer,10 #>  [2,] character,26 integer,10 #>  [3,] character,26 integer,10 #>  [4,] character,26 integer,10 #>  [5,] character,26 integer,10 #>  [6,] character,26 integer,10 #>  [7,] character,26 integer,10 #>  [8,] character,26 integer,10 #>  [9,] character,26 integer,10 #> [10,] character,26 integer,10  lst_untree(x, margin = 1) #>       [,1]         [,2]       #>  [1,] character,26 integer,10 #>  [2,] character,26 integer,10 #>  [3,] character,26 integer,10 #>  [4,] character,26 integer,10 #>  [5,] character,26 integer,10 #>  [6,] character,26 integer,10 #>  [7,] character,26 integer,10 #>  [8,] character,26 integer,10 #>  [9,] character,26 integer,10 #> [10,] character,26 integer,10   ################################################################################  # showcasing vectorized sub-setting ==== x <- lapply(1:10, \\(x) list(   list(sample(letters[1:10]), sample(LETTERS[1:10])),   list(sample(month.abb), sample(month.name)),   list(sample(1:10), rnorm(10)) )) y <- lst_untree(x, 1)  # getting the first recursive elements in the second level/depth in base R: for(i in seq_along(x)) {   x[[c(i, c(1L, 1L))]] |> print() # for-loop, slow } #>  [1] \"d\" \"h\" \"j\" \"e\" \"i\" \"c\" \"a\" \"g\" \"b\" \"f\" #>  [1] \"j\" \"i\" \"f\" \"d\" \"b\" \"a\" \"e\" \"g\" \"h\" \"c\" #>  [1] \"a\" \"b\" \"j\" \"c\" \"f\" \"h\" \"i\" \"d\" \"g\" \"e\" #>  [1] \"g\" \"j\" \"i\" \"f\" \"e\" \"b\" \"d\" \"h\" \"c\" \"a\" #>  [1] \"h\" \"g\" \"f\" \"c\" \"d\" \"i\" \"a\" \"j\" \"b\" \"e\" #>  [1] \"g\" \"f\" \"b\" \"i\" \"a\" \"c\" \"d\" \"e\" \"j\" \"h\" #>  [1] \"e\" \"d\" \"c\" \"a\" \"f\" \"b\" \"g\" \"h\" \"i\" \"j\" #>  [1] \"h\" \"i\" \"f\" \"c\" \"a\" \"e\" \"d\" \"j\" \"g\" \"b\" #>  [1] \"h\" \"a\" \"d\" \"i\" \"g\" \"e\" \"b\" \"j\" \"c\" \"f\" #>  [1] \"e\" \"d\" \"i\" \"b\" \"a\" \"c\" \"j\" \"h\" \"g\" \"f\"  # the same, but vectorized using the untree'd list: sb2_x(y, n(1:nrow(y), 1L), 1:ndims(y)) |> drop() |> print() # vectorized, fast #> [[1]] #>  [1] \"d\" \"h\" \"j\" \"e\" \"i\" \"c\" \"a\" \"g\" \"b\" \"f\" #>  #> [[2]] #>  [1] \"j\" \"i\" \"f\" \"d\" \"b\" \"a\" \"e\" \"g\" \"h\" \"c\" #>  #> [[3]] #>  [1] \"a\" \"b\" \"j\" \"c\" \"f\" \"h\" \"i\" \"d\" \"g\" \"e\" #>  #> [[4]] #>  [1] \"g\" \"j\" \"i\" \"f\" \"e\" \"b\" \"d\" \"h\" \"c\" \"a\" #>  #> [[5]] #>  [1] \"h\" \"g\" \"f\" \"c\" \"d\" \"i\" \"a\" \"j\" \"b\" \"e\" #>  #> [[6]] #>  [1] \"g\" \"f\" \"b\" \"i\" \"a\" \"c\" \"d\" \"e\" \"j\" \"h\" #>  #> [[7]] #>  [1] \"e\" \"d\" \"c\" \"a\" \"f\" \"b\" \"g\" \"h\" \"i\" \"j\" #>  #> [[8]] #>  [1] \"h\" \"i\" \"f\" \"c\" \"a\" \"e\" \"d\" \"j\" \"g\" \"b\" #>  #> [[9]] #>  [1] \"h\" \"a\" \"d\" \"i\" \"g\" \"e\" \"b\" \"j\" \"c\" \"f\" #>  #> [[10]] #>  [1] \"e\" \"d\" \"i\" \"b\" \"a\" \"c\" \"j\" \"h\" \"g\" \"f\" #>"},{"path":"https://tony-aw.github.io/squarebrackets/reference/match_all.html","id":null,"dir":"Reference","previous_headings":"","what":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","title":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","text":"Find indices vector haystack equal vector needles, taking account order vectors, duplicate values. match_all() essentially much efficient version :   Like lapply(needles, \\() (haystack == )), NAs ignored. match_all() internally calls collapse::fmatch collapse::gsplit.  Core code based suggestion Sebastian Kranz (author 'collapse' package).","code":"lapply(needles, \\(i) which(haystack == i))"},{"path":"https://tony-aw.github.io/squarebrackets/reference/match_all.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","text":"","code":"match_all(needles, haystack, unlist = TRUE)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/match_all.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","text":"needles, haystack vectors type. needles contain NA/NaN.  Long vectors supported. unlist Boolean, indicating result single unnamed integer vector (TRUE, default), named list integer vectors (FALSE).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/match_all.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","text":"integer vector, list integer vectors. list, element list corresponds value needles. needles /haystack empty, haystack fully NA, match_all() returns empty integer vector (unlist = TRUE), empty list (unlist = FALSE).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/match_all.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","text":"","code":"n <- 200 haystack <- sample(letters, n, TRUE) needles <- sample(letters, n/2, TRUE) indices1 <- match_all(needles, haystack) head(indices1) #> [1]  26  32  71 108 113 116"},{"path":"https://tony-aw.github.io/squarebrackets/reference/ma_setv.html","id":null,"dir":"Reference","previous_headings":"","what":"Find and Replace Present Values in mutable_atomic Objects By Reference — ma_setv","title":"Find and Replace Present Values in mutable_atomic Objects By Reference — ma_setv","text":"ma_setv(x, v rp) function performs equivalent x[(x == v)] <- rp  using pass--reference semantics.  faster using sb_set(x, = (x == v), rp = rp).  Inspired collapse::setv, written 'C++' 'Rcpp', additional safety checks.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/ma_setv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find and Replace Present Values in mutable_atomic Objects By Reference — ma_setv","text":"","code":"ma_setv(x, v, rp, invert = FALSE, NA.safety = TRUE)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/ma_setv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find and Replace Present Values in mutable_atomic Objects By Reference — ma_setv","text":"x mutable_atomic variable. v non-missing (NA NaN) atomic scalar find. rp atomic scalar giving replacement value. invert Boolean.  FALSE (default), equivalent x[(x == v()] <- rp performed;  TRUE, equivalent x[(x != v)] <- rp performed instead. NA.safety Boolean.  just like , NA NaN results x==v ignored, thus NA.safety TRUE default.  However, known x contains NAs NaNs, setting NA.safety FALSE increase performance bit.  NOTE: Setting NA.safety = FALSE x contain NAs NaNs, may result unexpected behaviour.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/ma_setv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find and Replace Present Values in mutable_atomic Objects By Reference — ma_setv","text":"Returns: VOID. function modifies object reference. use assignment like x <- ma_setv(x, ...). Since function returns void, just get NULL.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/ma_setv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find and Replace Present Values in mutable_atomic Objects By Reference — ma_setv","text":"","code":"x <- mutable_atomic(c(1:20, NA, NaN)) print(x) #>  [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19 #> [20]  20  NA NaN #> mutable_atomic  #> typeof:  double  ma_setv(x, 2, 100) print(x) #>  [1]   1 100   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19 #> [20]  20  NA NaN #> mutable_atomic  #> typeof:  double"},{"path":"https://tony-aw.github.io/squarebrackets/reference/ndims.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Number of Dimensions — ndims","title":"Get Number of Dimensions — ndims","text":"ndims(x) short-hand length(dim(x)).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/ndims.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Number of Dimensions — ndims","text":"","code":"ndims(x)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/ndims.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Number of Dimensions — ndims","text":"x object get number dimensions .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/ndims.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Number of Dimensions — ndims","text":"integer, giving number dimensions x . vectors, gives 0L.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/ndims.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Number of Dimensions — ndims","text":"","code":"x <- 1:10 ndims(x) #> [1] 0 obj <- array(1:64, c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  ndims(obj) #> [1] 3"},{"path":"https://tony-aw.github.io/squarebrackets/reference/nest.html","id":null,"dir":"Reference","previous_headings":"","what":"Nest — n","title":"Nest — n","text":"c() function concatenates vectors lists vector (possible) else list.  analogy function, n() function nests objects list (atomic vector, atomic vectors nested).  short-hand version list function.  handy lists often needed 'squarebrackets', especially arrays.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/nest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nest — n","text":"","code":"n()"},{"path":"https://tony-aw.github.io/squarebrackets/reference/nest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nest — n","text":"list.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/nest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Nest — n","text":"","code":"obj <- array(1:64, c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  sb_x(obj, n(1:3, 1:2), c(1,3)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #>  # above is equivalent to obj[1:3, , 1:2, drop = FALSE]"},{"path":"https://tony-aw.github.io/squarebrackets/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. data.table address, copy, first, last","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb2_rec.html","id":null,"dir":"Reference","previous_headings":"","what":"Access, Replace, Transform, Delete, or Extend Recursive Subsets — sb2_rec","title":"Access, Replace, Transform, Delete, or Extend Recursive Subsets — sb2_rec","text":"sb2_rec() sb2_recin() methods essentially convenient wrappers around [[ [[<-, respectively.  Unlike [[ [[<-, actually S3 methods, package authors can create additional method dispatches. sb2_rec() access recursive subsets lists. sb2_recin() can following things: replace transform recursive subsets list, using R's default Copy--Modify semantics, specifying rp tf argument, respectively. delete recursive subset list, using R's default Copy--Modify semantics, specifying argument rp = NULL. extending list additional recursive elements, using R's default Copy--Modify semantics.  done specifying --bounds index argument rec, entering new values argument rp.  Note adding surface level elements dimensional list delete dimension attributes list.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb2_rec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Access, Replace, Transform, Delete, or Extend Recursive Subsets — sb2_rec","text":"","code":"sb2_rec(x, ...)  # S3 method for default sb2_rec(x, rec, ...)  sb2_recin(x, ...)  # S3 method for default sb2_recin(x, rec, ..., rp, tf)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb2_rec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Access, Replace, Transform, Delete, or Extend Recursive Subsets — sb2_rec","text":"x list, list-like object. ... see squarebrackets_method_dispatch. rec strictly positive integer vector character vector, length p, sb2_rec(x, rec) equivalent x[[ rec[1] ]]...[[ rec[p] ]], providing final indexing results list.  certain subset level nested list, multiple subsets name exist, first one selected performing recursive indexing name, since recursive indexing can select single element. rp optional, allows multiple functionalities: simplest case, performs x[[rec]] <- rp, using R's default semantics.  Since replacement recursive subset, rp necessarily list ; rp can type object. Specifying rp = NULL delete (recursive) subset sb(x, rec).  specify actual NULL instead deleting subset, use rp = list(NULL). rec integer, specifies --bounds subset, sb2_recin() add value rp list.  empty positions filled NA. rec character, specifies non-existing name, sb2_recin() add value rp list new element end. tf optional function. specified, performs x[[rec]] <- tf(x[[rec]]), using R's default Copy--Modify semantics.  support extending list like argument rp.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb2_rec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Access, Replace, Transform, Delete, or Extend Recursive Subsets — sb2_rec","text":"sb2_rec(): Returns recursive subset.  sb2_recin(..., rp = rp): Returns VOID, replaces, adds, deletes specified recursive subset, using R's default Copy--Modify semantics.  sb2_recin(..., tf = tf): Returns VOID, transforms specified recursive subset, using R's default Copy--Modify semantics.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb2_rec.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Access, Replace, Transform, Delete, or Extend Recursive Subsets — sb2_rec","text":"Since recursive objects references objects, extending list deleting element list copy entire list, contrast atomic vectors.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb2_rec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Access, Replace, Transform, Delete, or Extend Recursive Subsets — sb2_rec","text":"","code":"lst <- list(   A = list(     A = list(A = \"AAA\", B = \"AAB\"),     A = list(A  = \"AA2A\", B = \"AA2B\"),     B = list(A = \"ABA\", B = \"ABB\")   ),   B = list(     A = list(A = \"BAA\", B = \"BAB\"),     B = list(A = \"BBA\", B = \"BBB\")   ) )  #############################################################################  # access recursive subsets ====  sb2_rec(lst, c(1,2,2)) # this gives \"AA2B\" #> [1] \"AA2B\" sb2_rec(lst, c(\"A\", \"B\", \"B\")) # this gives \"ABB\" #> [1] \"ABB\" sb2_rec(lst, c(2,2,1)) # this gives \"BBA\" #> [1] \"BBA\" sb2_rec(lst, c(\"B\", \"B\", \"A\")) # this gives \"BBA\" #> [1] \"BBA\"   #############################################################################  # replace recursive subset with R's default in-place semantics ====  # replace \"AAB\" using R's default in-place semantics: sb2_recin(   lst, c(\"A\", \"A\", \"B\"),   rp = \"THIS IS REPLACED WITH IN-PLACE SEMANTICS\" ) print(lst) #> $A #> $A$A #> $A$A$A #> [1] \"AAA\" #>  #> $A$A$B #> [1] \"THIS IS REPLACED WITH IN-PLACE SEMANTICS\" #>  #>  #> $A$A #> $A$A$A #> [1] \"AA2A\" #>  #> $A$A$B #> [1] \"AA2B\" #>  #>  #> $A$B #> $A$B$A #> [1] \"ABA\" #>  #> $A$B$B #> [1] \"ABB\" #>  #>  #>  #> $B #> $B$A #> $B$A$A #> [1] \"BAA\" #>  #> $B$A$B #> [1] \"BAB\" #>  #>  #> $B$B #> $B$B$A #> [1] \"BBA\" #>  #> $B$B$B #> [1] \"BBB\" #>  #>  #>     #############################################################################  # replace shallow subsets with R's default in-place semantics ====  for(i in c(\"A\", \"B\")) sb2_recin(lst, i, rp = \"AND THEN THERE WERE NONE\")  print(lst) #> $A #> [1] \"AND THEN THERE WERE NONE\" #>  #> $B #> [1] \"AND THEN THERE WERE NONE\" #>    #############################################################################  # Modify View of List By Reference ====  x <- list(  a = data.table::data.table(cola = 1:10, colb = letters[1:10]),  b = data.table::data.table(cola = 11:20, colb = letters[11:20]) ) print(x) #> $a #>      cola   colb #>     <int> <char> #>  1:     1      a #>  2:     2      b #>  3:     3      c #>  4:     4      d #>  5:     5      e #>  6:     6      f #>  7:     7      g #>  8:     8      h #>  9:     9      i #> 10:    10      j #>  #> $b #>      cola   colb #>     <int> <char> #>  1:    11      k #>  2:    12      l #>  3:    13      m #>  4:    14      n #>  5:    15      o #>  6:    16      p #>  7:    17      q #>  8:    18      r #>  9:    19      s #> 10:    20      t #>  myref <- sb2_rec(x, \"a\") address(myref) == address(x$a) # they are the same #> [1] TRUE sb2_set(myref, col = \"cola\", tf = \\(x)x^2) print(x) # notice x has been changed #> $a #>      cola   colb #>     <num> <char> #>  1:     1      a #>  2:     4      b #>  3:     9      c #>  4:    16      d #>  5:    25      e #>  6:    36      f #>  7:    49      g #>  8:    64      h #>  9:    81      i #> 10:   100      j #>  #> $b #>      cola   colb #>     <int> <char> #>  1:    11      k #>  2:    12      l #>  3:    13      m #>  4:    14      n #>  5:    15      o #>  6:    16      p #>  7:    17      q #>  8:    18      r #>  9:    19      s #> 10:    20      t #>"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":null,"dir":"Reference","previous_headings":"","what":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"S3 Method return copy object modified subsets.  Use sb_mod(x, ...) x atomic object; returns full copy.  Use sb2_mod(x, ...) x recursive object (.e. list data.frame-like); returns partial copy.  modifying subsets using R's default copy--modification semantics, see idx.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"","code":"sb_mod(x, ...)  # S3 method for default sb_mod(   x,   i = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # S3 method for array sb_mod(   x,   sub = NULL,   dims = 1:ndims(x),   i = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  sb2_mod(x, ...)  # S3 method for default sb2_mod(   x,   i = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE),   .lapply = lapply )  # S3 method for array sb2_mod(   x,   sub = NULL,   dims = 1:ndims(x),   i = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE),   .lapply = lapply )  # S3 method for data.frame sb2_mod(   x,   row = NULL,   col = NULL,   filter = NULL,   vars = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE),   .lapply = lapply )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"x see squarebrackets_supported_structures. ... see squarebrackets_method_dispatch. , row, col, sub, dims, filter, vars, inv See squarebrackets_indx_args.  empty index selection returns original object unchanged. rp, tf, .lapply see squarebrackets_modify. chkdup see squarebrackets_options.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"copy object replaced/transformed values.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"Transform Replace  Specifying argument tf transform subset.  Specifying rp replace subset.  One specify tf rp. either one set .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"","code":"# atomic objects ====  obj <- matrix(1:16, ncol = 4) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 rp <- -1:-9 sb_mod(obj, 1:3, 1:ndims(obj), rp = rp) #>       a  b  c  a #> [1,] -1 -4 -7 13 #> [2,] -2 -5 -8 14 #> [3,] -3 -6 -9 15 #> [4,]  4  8 12 16 # above is equivalent to  obj[1:3, 1:3] <- -1:-9; obj sb_mod(obj, i = \\(x)x<=5, rp = -1:-5) #>       a  b  c  a #> [1,] -1 -5  9 13 #> [2,] -2  6 10 14 #> [3,] -3  7 11 15 #> [4,] -4  8 12 16 # above is equivalent to  obj[obj <= 5] <- -1:-5; obj sb_mod(obj, \"a\", 2L, rp = -1:-8) #>       a b  c  a #> [1,] -1 5  9 -5 #> [2,] -2 6 10 -6 #> [3,] -3 7 11 -7 #> [4,] -4 8 12 -8 # above is equivalent to  obj[, which(colnames(obj) %in% \"a\")] <- -1:-8; obj sb_mod(obj, 1:3, 1:ndims(obj),tf = \\(x) -x) #>       a  b   c  a #> [1,] -1 -5  -9 13 #> [2,] -2 -6 -10 14 #> [3,] -3 -7 -11 15 #> [4,]  4  8  12 16 # above is equivalent to  obj[1:3, 1:3] <- (-1 * obj[1:3, 1:3]); obj sb_mod(obj, i = \\(x)x<=5, tf = \\(x) -x) #>       a  b  c  a #> [1,] -1 -5  9 13 #> [2,] -2  6 10 14 #> [3,] -3  7 11 15 #> [4,] -4  8 12 16 # above is equivalent to  obj[obj <= 5] <- (-1 * obj[obj <= 5]); obj  obj <- array(1:64, c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  sb_mod(obj, n(1:3, 1:2), c(1,3), rp = -1:-24) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   -1   -4   -7  -10 #> [2,]   -2   -5   -8  -11 #> [3,]   -3   -6   -9  -12 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]  -13  -16  -19  -22 #> [2,]  -14  -17  -20  -23 #> [3,]  -15  -18  -21  -24 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  # above is equivalent to obj[1:3, , 1:2] <- -1:-24 sb_mod(obj, i = \\(x)x <= 5, rp = -1:-5) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   -1   -5    9   13 #> [2,]   -2    6   10   14 #> [3,]   -3    7   11   15 #> [4,]   -4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  # above is equivalent to obj[obj <= 5] <- -1:-5  #############################################################################   # lists ====  obj <- list(a = 1:10, b = letters[1:11], c = 11:20) print(obj) #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  sb2_mod(obj, \"a\", rp = list(1L)) #> $a #> [1] 1 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  # above is equivalent to  obj[[\"a\"]] <- 1L; obj sb2_mod(obj, is.numeric, rp = list(-1:-10, -11:-20)) #> $a #>  [1]  -1  -2  -3  -4  -5  -6  -7  -8  -9 -10 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] -11 -12 -13 -14 -15 -16 -17 -18 -19 -20 #>  # above is equivalent to  obj[which(sapply(obj, is.numeric))] <- list(-1:-10, -11:-20); obj  obj <- rbind(   lapply(1:4, \\(x)sample(c(TRUE, FALSE, NA))),   lapply(1:4, \\(x)sample(1:10)),   lapply(1:4, \\(x)rnorm(10)),   lapply(1:4, \\(x)sample(letters)) ) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a            b            c            a            #> [1,] logical,3    logical,3    logical,3    logical,3    #> [2,] integer,10   integer,10   integer,10   integer,10   #> [3,] numeric,10   numeric,10   numeric,10   numeric,10   #> [4,] character,26 character,26 character,26 character,26 sb2_mod(obj, 1:3, 1:ndims(obj),rp = n(-1)) #>      a            b            c            a            #> [1,] -1           -1           -1           logical,3    #> [2,] -1           -1           -1           integer,10   #> [3,] -1           -1           -1           numeric,10   #> [4,] character,26 character,26 character,26 character,26 # above is equivalent to obj[1:3, 1:3] <- list(-1) sb2_mod(obj, i = is.numeric, rp = n(-1)) #>      a            b            c            a            #> [1,] logical,3    logical,3    logical,3    logical,3    #> [2,] -1           -1           -1           -1           #> [3,] -1           -1           -1           -1           #> [4,] character,26 character,26 character,26 character,26 # above is equivalent to obj[sapply(obj, is.numeric)] <- list(-1) sb2_mod(obj, \"a\", 2L, rp = n(-1)) #>      a  b            c            a  #> [1,] -1 logical,3    logical,3    -1 #> [2,] -1 integer,10   integer,10   -1 #> [3,] -1 numeric,10   numeric,10   -1 #> [4,] -1 character,26 character,26 -1 # above is equivalent to # obj[, lapply(c(\"a\", \"a\"), \\(i) which(colnames(obj) == i)) |> unlist()] <- list(-1)   obj <- array(as.list(1:64), c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 1    5    9    13   #> [2,] 2    6    10   14   #> [3,] 3    7    11   15   #> [4,] 4    8    12   16   #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 17   21   25   29   #> [2,] 18   22   26   30   #> [3,] 19   23   27   31   #> [4,] 20   24   28   32   #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 33   37   41   45   #> [2,] 34   38   42   46   #> [3,] 35   39   43   47   #> [4,] 36   40   44   48   #>  sb2_mod(obj, n(1:3, 1:2), c(1,3), rp = as.list(-1:-24)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,] -1   -4   -7   -10  #> [2,] -2   -5   -8   -11  #> [3,] -3   -6   -9   -12  #> [4,] 4    8    12   16   #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,] -13  -16  -19  -22  #> [2,] -14  -17  -20  -23  #> [3,] -15  -18  -21  -24  #> [4,] 20   24   28   32   #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 33   37   41   45   #> [2,] 34   38   42   46   #> [3,] 35   39   43   47   #> [4,] 36   40   44   48   #>  # above is equivalent to obj[1:3, , 1:2] <- as.list(-1:-24) sb2_mod(obj, i = \\(x) x <= 5, rp = as.list(-1:-5)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,] -1   -5   9    13   #> [2,] -2   6    10   14   #> [3,] -3   7    11   15   #> [4,] -4   8    12   16   #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 17   21   25   29   #> [2,] 18   22   26   30   #> [3,] 19   23   27   31   #> [4,] 20   24   28   32   #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 33   37   41   45   #> [2,] 34   38   42   46   #> [3,] 35   39   43   47   #> [4,] 36   40   44   48   #>  # above is equivalent to obj[sapply(onj, \\(x) x <= 5)] <- as.list(-1:-5)   #############################################################################  # data.frame-like objects  - whole columns ====  obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 sb2_mod(   obj, vars = is.numeric,   tf = sqrt ) #>           a b        c d #> 1  1.000000 a 3.316625 a #> 2  1.414214 b 3.464102 b #> 3  1.732051 c 3.605551 c #> 4  2.000000 d 3.741657 d #> 5  2.236068 e 3.872983 e #> 6  2.449490 f 4.000000 f #> 7  2.645751 g 4.123106 g #> 8  2.828427 h 4.242641 h #> 9  3.000000 i 4.358899 i #> 10 3.162278 j 4.472136 j  #############################################################################  # data.frame-like objects  - partial columns ====  obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10  sb2_mod(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt )  #>            a b         c d #> 1   1.000000 a 11.000000 a #> 2   1.414214 b  3.464102 b #> 3   1.732051 c  3.605551 c #> 4   2.000000 d  3.741657 d #> 5   2.236068 e  3.872983 e #> 6   2.449490 f  4.000000 f #> 7   2.645751 g  4.123106 g #> 8   8.000000 h 18.000000 h #> 9   9.000000 i 19.000000 i #> 10 10.000000 j 20.000000 j sb2_mod(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt )  #>            a b         c d #> 1   1.000000 a 11.000000 a #> 2   1.414214 b  3.464102 b #> 3   1.732051 c  3.605551 c #> 4   2.000000 d  3.741657 d #> 5   2.236068 e  3.872983 e #> 6   2.449490 f  4.000000 f #> 7   2.645751 g  4.123106 g #> 8   8.000000 h 18.000000 h #> 9   9.000000 i 19.000000 i #> 10 10.000000 j 20.000000 j sb2_mod(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt )  #>            a b         c d #> 1   1.000000 a 11.000000 a #> 2   1.414214 b  3.464102 b #> 3   1.732051 c  3.605551 c #> 4   2.000000 d  3.741657 d #> 5   2.236068 e  3.872983 e #> 6   2.449490 f  4.000000 f #> 7   2.645751 g  4.123106 g #> 8   8.000000 h 18.000000 h #> 9   9.000000 i 19.000000 i #> 10 10.000000 j 20.000000 j"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":null,"dir":"Reference","previous_headings":"","what":"Method to Modify Subsets of a Mutable Object By Reference — sb_set","title":"Method to Modify Subsets of a Mutable Object By Reference — sb_set","text":"S3 Method replace transform subset supported mutable object using pass--reference semantics  Use sb_set(x, ...) x atomic object (.e. mutable_atomic).  Use sb2_set(x, ...) x recursive object (.e. data.table).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method to Modify Subsets of a Mutable Object By Reference — sb_set","text":"","code":"sb_set(x, ...)  # S3 method for default sb_set(   x,   i = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # S3 method for array sb_set(   x,   sub = NULL,   dims = 1:ndims(x),   i = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  sb2_set(x, ...)  # S3 method for default sb2_set(x, ...)  # S3 method for data.table sb2_set(   x,   row = NULL,   col = NULL,   filter = NULL,   vars = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE),   .lapply = lapply )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method to Modify Subsets of a Mutable Object By Reference — sb_set","text":"x variable belonging one supported mutable classes. ... see squarebrackets_method_dispatch. , row, col, sub, dims, filter, vars, inv See squarebrackets_indx_args.  empty index selection leaves original object unchanged. rp, tf, .lapply see squarebrackets_modify. chkdup see squarebrackets_options.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Method to Modify Subsets of a Mutable Object By Reference — sb_set","text":"Returns: VOID. method modifies object reference. use assignments like x <- sb_set(x, ...). Since function returns void, just get NULL.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Method to Modify Subsets of a Mutable Object By Reference — sb_set","text":"Transform Replace  Specifying argument tf transform subset. Specifying rp replace subset. One specify tf rp. either one set .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Method to Modify Subsets of a Mutable Object By Reference — sb_set","text":"","code":"# mutable_atomic objects ====  gen_mat <- function() {   obj <- as.mutable_atomic(matrix(1:16, ncol = 4))   colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\")   return(obj) }  obj <- obj2 <- gen_mat() print(obj) #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutable_atomic  #> typeof:  integer   sb_set(obj, 1:3, 1:ndims(obj), rp = -1:-9) print(obj2) #>       a  b  c  a #> [1,] -1 -4 -7 13 #> [2,] -2 -5 -8 14 #> [3,] -3 -6 -9 15 #> [4,]  4  8 12 16 #> mutable_atomic  #> typeof:  integer  # above is like x[1:3, 1:3] <- -1:-9, but using pass-by-reference  obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutable_atomic  #> typeof:  integer   sb_set(obj, i = \\(x) x <= 5, rp = -1:-5) print(obj2) #>       a  b  c  a #> [1,] -1 -5  9 13 #> [2,] -2  6 10 14 #> [3,] -3  7 11 15 #> [4,] -4  8 12 16 #> mutable_atomic  #> typeof:  integer  # above is like x[x <= 5] <- -1:-5, but using pass-by-reference  obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutable_atomic  #> typeof:  integer   sb_set(obj, \"a\", 2L, rp = cbind(-1:-4, -5:-8)) print(obj2) #>       a b  c  a #> [1,] -1 5  9 -5 #> [2,] -2 6 10 -6 #> [3,] -3 7 11 -7 #> [4,] -4 8 12 -8 #> mutable_atomic  #> typeof:  integer  # above is like x[, \"a\"] <- cbind(-1:-4, -5:-8), but using pass-by-reference  obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutable_atomic  #> typeof:  integer   sb_set(obj, 1:3, 1:ndims(obj), tf = \\(x) -x) print(obj2) #>       a  b   c  a #> [1,] -1 -5  -9 13 #> [2,] -2 -6 -10 14 #> [3,] -3 -7 -11 15 #> [4,]  4  8  12 16 #> mutable_atomic  #> typeof:  integer  # above is like x[1:3, 1:3] <- -1 * x[1:3, 1:3], but using pass-by-reference  obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutable_atomic  #> typeof:  integer   sb_set(obj, i = \\(x) x <= 5, tf = \\(x) -x) print(obj2) #>       a  b  c  a #> [1,] -1 -5  9 13 #> [2,] -2  6 10 14 #> [3,] -3  7 11 15 #> [4,] -4  8 12 16 #> mutable_atomic  #> typeof:  integer  # above is like x[x <= 5] <- -1 * x[x <= 5], but using pass-by-reference  obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutable_atomic  #> typeof:  integer   sb_set(obj, \"a\", 2L, tf = \\(x) -x) obj2 #>       a b  c   a #> [1,] -1 5  9 -13 #> [2,] -2 6 10 -14 #> [3,] -3 7 11 -15 #> [4,] -4 8 12 -16 #> mutable_atomic  #> typeof:  integer  # above is like x[, \"a\"] <- -1 * x[, \"a\"], but using pass-by-reference   gen_array <- function() {   as.mutable_atomic(array(1:64, c(4,4,3))) } obj <- obj2 <- gen_array() obj #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  #> mutable_atomic  #> typeof:  integer   sb_set(obj, n(1:3, 1:2, c(1, 3)), 1:3, rp = -1:-12) print(obj2) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   -1   -4    9   13 #> [2,]   -2   -5   10   14 #> [3,]   -3   -6   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   -7  -10   41   45 #> [2,]   -8  -11   42   46 #> [3,]   -9  -12   43   47 #> [4,]   36   40   44   48 #>  #> mutable_atomic  #> typeof:  integer  # above is like x[1:3, , 1:2] <- -1:-12, but using pass-by-reference   obj <- obj2 <- gen_array() obj #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  #> mutable_atomic  #> typeof:  integer  sb_set(obj, i = \\(x)x <= 5, rp = -1:-5) print(obj2) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   -1   -5    9   13 #> [2,]   -2    6   10   14 #> [3,]   -3    7   11   15 #> [4,]   -4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  #> mutable_atomic  #> typeof:  integer  # above is like x[x <= 5] <- -1:-5, but using pass-by-reference    #############################################################################  # data.table ====  obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb2_set(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost ) #> Warning: 1.414214 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 1 named 'a') #> Warning: 3.464102 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 3 named 'c') print(obj) #>         a      b     c      d #>     <int> <char> <int> <fctr> #>  1:     1      a    11      a #>  2:     1      b     3      b #>  3:     1      c     3      c #>  4:     2      d     3      d #>  5:     2      e     3      e #>  6:     2      f     4      f #>  7:     2      g     4      g #>  8:     8      h    18      h #>  9:     9      i    19      i #> 10:    10      j    20      j  obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) dt_setcoe(obj, vars = is.numeric, v = as.numeric) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb2_set(obj,   filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # SAFE: coercion performed by dt_setcoe(); so no warnings )  print(obj) #>             a      b         c      d #>         <num> <char>     <num> <fctr> #>  1:  1.000000      a 11.000000      a #>  2:  1.414214      b  3.464102      b #>  3:  1.732051      c  3.605551      c #>  4:  2.000000      d  3.741657      d #>  5:  2.236068      e  3.872983      e #>  6:  2.449490      f  4.000000      f #>  7:  2.645751      g  4.123106      g #>  8:  8.000000      h 18.000000      h #>  9:  9.000000      i 19.000000      i #> 10: 10.000000      j 20.000000      j  obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb2_set(   obj, vars = is.numeric,   tf = sqrt # SAFE: row=NULL & filter = NULL, so coercion performed ) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 1.41 1.73 2 2.24 ... #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  3.32 3.46 3.61 3.74 3.87 ... #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_setRename.html","id":null,"dir":"Reference","previous_headings":"","what":"Safely Change the Names of a Mutable Object By Reference — sb_setRename","title":"Safely Change the Names of a Mutable Object By Reference — sb_setRename","text":"Functions rename supported mutable object using pass--reference semantics: sb_setFlatnames() renames (flat) names mutable_atomic object. sb_setDimnames() renames dimension names mutable_atomic object. sb2_setVarnames() renames variable names data.table object.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_setRename.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Safely Change the Names of a Mutable Object By Reference — sb_setRename","text":"","code":"sb_setFlatnames(x, i = NULL, newnames, ...)  sb_setDimnames(x, m, newdimnames, ...)  sb2_setVarnames(x, old, new, skip_absent = FALSE, ...)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_setRename.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Safely Change the Names of a Mutable Object By Reference — sb_setRename","text":"x variable belonging one supported mutable classes. logical, numeric, character, imaginary indices, indicating flatnames changed.  = NULL, names completely replaced. newnames Atomic character vector giving new names.  Specifying NULL remove names. ... see squarebrackets_method_dispatch. m integer vector giving margin(s) change names (m = 1L rows, m = 2L columns, etc.). newdimnames list length m.  first element list corresponds margin m[1], second element m[2], .  components list can either NULL, character vector length corresponding dimension.  Instead list, simply NULL can specified, remove dimnames completely. old old column names new new column names, order old skip_absent Skip items old missing (.e. absent) names(x).  Default FALSE halts error missing.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_setRename.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Safely Change the Names of a Mutable Object By Reference — sb_setRename","text":"Returns: VOID. method modifies object reference. use assignment like names(x) <- sb_setRename(x, ...). Since function returns void, just get NULL.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_setRename.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Safely Change the Names of a Mutable Object By Reference — sb_setRename","text":"","code":"# mutable atomic vector ==== x <- y <- mutable_atomic(1:10, names = letters[1:10]) print(x) #>  a  b  c  d  e  f  g  h  i  j  #>  1  2  3  4  5  6  7  8  9 10  #> mutable_atomic  #> typeof:  integer  sb_setFlatnames(x, newnames = rev(letters[1:10])) print(y) #>  j  i  h  g  f  e  d  c  b  a  #>  1  2  3  4  5  6  7  8  9 10  #> mutable_atomic  #> typeof:  integer   x <- y <- mutable_atomic(1:10, names = letters[1:10]) print(x) #>  a  b  c  d  e  f  g  h  i  j  #>  1  2  3  4  5  6  7  8  9 10  #> mutable_atomic  #> typeof:  integer  sb_setFlatnames(x, 1L, \"XXX\") print(y) #> XXX   b   c   d   e   f   g   h   i   j  #>   1   2   3   4   5   6   7   8   9  10  #> mutable_atomic  #> typeof:  integer   ################################################################################   # mutable atomic matrix ==== x <- mutable_atomic(   1:20, dim = c(5, 4), dimnames = n(letters[1:5], letters[1:4]) ) print(x) #>   a  b  c  d #> a 1  6 11 16 #> b 2  7 12 17 #> c 3  8 13 18 #> d 4  9 14 19 #> e 5 10 15 20 #> mutable_atomic  #> typeof:  integer  sb_setDimnames(   x,   1:2,   lapply(dimnames(x), rev) ) print(x) #>   d  c  b  a #> e 1  6 11 16 #> d 2  7 12 17 #> c 3  8 13 18 #> b 4  9 14 19 #> a 5 10 15 20 #> mutable_atomic  #> typeof:  integer     ################################################################################    # data.table ====  x <- data.table::data.table(   a = 1:20,   b = letters[1:20] ) print(x) #>         a      b #>     <int> <char> #>  1:     1      a #>  2:     2      b #>  3:     3      c #>  4:     4      d #>  5:     5      e #>  6:     6      f #>  7:     7      g #>  8:     8      h #>  9:     9      i #> 10:    10      j #> 11:    11      k #> 12:    12      l #> 13:    13      m #> 14:    14      n #> 15:    15      o #> 16:    16      p #> 17:    17      q #> 18:    18      r #> 19:    19      s #> 20:    20      t #>         a      b sb2_setVarnames(x, old = names(x), new = rev(names(x))) print(x) #>         b      a #>     <int> <char> #>  1:     1      a #>  2:     2      b #>  3:     3      c #>  4:     4      d #>  5:     5      e #>  6:     6      f #>  7:     7      g #>  8:     8      h #>  9:     9      i #> 10:    10      j #> 11:    11      k #> 12:    12      l #> 13:    13      m #> 14:    14      n #> 15:    15      o #> 16:    16      p #> 17:    17      q #> 18:    18      r #> 19:    19      s #> 20:    20      t #>         b      a"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_wo.html","id":null,"dir":"Reference","previous_headings":"","what":"Method to Return Object Without Specified Subset — sb_wo","title":"Method to Return Object Without Specified Subset — sb_wo","text":"S3 Method return object without specified subset. sb_wo()/ sb2_wo() essentially inverse sb_x/sb2_x.  Use sb_wo(x, ...) x atomic object.  Use sb2_wo(x, ...) x recursive object (.e. list data.frame-like).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_wo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method to Return Object Without Specified Subset — sb_wo","text":"","code":"sb_wo(x, ...)  # S3 method for default sb_wo(x, i = NULL, ..., chkdup = getOption(\"squarebrackets.chkdup\", FALSE))  # S3 method for array sb_wo(   x,   sub = NULL,   dims = 1:ndims(x),   i = NULL,   ...,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  sb2_wo(x, ...)  # S3 method for default sb2_wo(   x,   i = NULL,   red = FALSE,   ...,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # S3 method for array sb2_wo(   x,   sub = NULL,   dims = 1:ndims(x),   i = NULL,   red = FALSE,   ...,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # S3 method for data.frame sb2_wo(   x,   row = NULL,   col = NULL,   filter = NULL,   vars = NULL,   ...,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_wo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method to Return Object Without Specified Subset — sb_wo","text":"x see squarebrackets_supported_structures. ... see squarebrackets_method_dispatch. , row, col, sub, dims, filter, vars See squarebrackets_indx_args.  empty index selection results nothing removed, entire object returned. chkdup see squarebrackets_options. red Boolean, recursive objects , indicating result reduced.  red = TRUE, selecting single element give simplified result, like using [[]].  red = FALSE, list always returned regardless number elements.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_wo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Method to Return Object Without Specified Subset — sb_wo","text":"copy sub-setted object.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_wo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Method to Return Object Without Specified Subset — sb_wo","text":"","code":"# atomic objects ====  obj <- matrix(1:16, ncol = 4) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 sb_wo(obj, 1:3, 1:ndims(obj)) #>       a #> [1,] 16 # above is equivalent to  obj[-1:-3, -1:-3, drop = FALSE] sb_wo(obj, i = \\(x) x > 5) #> [1] 1 2 3 4 5 # above is equivalent to  obj[!obj > 5] sb_wo(obj, \"a\", 2L) #>      b  c #> [1,] 5  9 #> [2,] 6 10 #> [3,] 7 11 #> [4,] 8 12 # above is equivalent to  obj[, which(!colnames(obj) %in% \"a\")]  obj <- array(1:64, c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  sb_wo(obj, n(1, c(1, 3)), c(1, 3)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   18   22   26   30 #> [2,]   19   23   27   31 #> [3,]   20   24   28   32 #>  # above is equivalent to obj[-1, , c(-1, -3), drop = FALSE] sb_wo(obj, i = \\(x)x > 5) #> [1] 1 2 3 4 5 # above is equivalent to obj[!obj > 5]    #############################################################################   # lists ====  obj <- list(a = 1:10, b = letters[1:11], c = 11:20) print(obj) #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  sb2_wo(obj, \"a\") #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  # above is equivalent to obj[which(!names(obj) %in% \"a\")] sb2_wo(obj, 1) # obj[-1] #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  sb2_wo(obj, 1:2) #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  # above is equivalent to obj[seq_len(length(obj))[-1:-2]] sb2_wo(obj, is.numeric, red = TRUE) #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" # above is equivalent to obj[[!sapply(obj, is.numeric)]] IF this returns a single element obj <- list(a = 1:10, b = letters[1:11], c = letters) sb2_wo(obj, is.numeric) #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" #> [20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\" #>  # above is equivalent to obj[!sapply(obj, is.numeric)] # this time singular brackets? # for recusive indexing, see sb2_rec()   obj <- rbind(   lapply(1:4, \\(x)sample(c(TRUE, FALSE, NA))),   lapply(1:4, \\(x)sample(1:10)),   lapply(1:4, \\(x)rnorm(10)),   lapply(1:4, \\(x)sample(letters)) ) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a            b            c            a            #> [1,] logical,3    logical,3    logical,3    logical,3    #> [2,] integer,10   integer,10   integer,10   integer,10   #> [3,] numeric,10   numeric,10   numeric,10   numeric,10   #> [4,] character,26 character,26 character,26 character,26 sb2_wo(obj, 1:3, 1:ndims(obj)) #>      a            #> [1,] character,26 # above is equivalent to obj[1:3, 1:3, drop = FALSE] sb2_wo(obj, i = is.numeric) #> [[1]] #> [1] FALSE  TRUE    NA #>  #> [[2]] #>  [1] \"o\" \"f\" \"j\" \"v\" \"q\" \"e\" \"l\" \"w\" \"t\" \"m\" \"s\" \"d\" \"u\" \"k\" \"x\" \"y\" \"n\" \"c\" \"h\" #> [20] \"g\" \"z\" \"b\" \"i\" \"a\" \"p\" \"r\" #>  #> [[3]] #> [1] FALSE    NA  TRUE #>  #> [[4]] #>  [1] \"e\" \"q\" \"d\" \"b\" \"v\" \"f\" \"y\" \"w\" \"a\" \"c\" \"j\" \"z\" \"s\" \"g\" \"i\" \"p\" \"o\" \"r\" \"h\" #> [20] \"n\" \"m\" \"u\" \"x\" \"t\" \"l\" \"k\" #>  #> [[5]] #> [1]  TRUE FALSE    NA #>  #> [[6]] #>  [1] \"c\" \"p\" \"e\" \"q\" \"o\" \"z\" \"l\" \"j\" \"f\" \"y\" \"b\" \"k\" \"r\" \"a\" \"s\" \"n\" \"h\" \"t\" \"w\" #> [20] \"i\" \"u\" \"d\" \"g\" \"x\" \"v\" \"m\" #>  #> [[7]] #> [1]  TRUE    NA FALSE #>  #> [[8]] #>  [1] \"i\" \"s\" \"p\" \"c\" \"e\" \"g\" \"x\" \"d\" \"o\" \"j\" \"r\" \"q\" \"u\" \"l\" \"b\" \"k\" \"m\" \"f\" \"h\" #> [20] \"n\" \"y\" \"t\" \"v\" \"z\" \"a\" \"w\" #>  # above is equivalent to obj[sapply(obj, is.numeric)] sb2_wo(obj, c(\"a\", \"a\"), 2L) #>      b            c            #> [1,] logical,3    logical,3    #> [2,] integer,10   integer,10   #> [3,] numeric,10   numeric,10   #> [4,] character,26 character,26 # above is equivalent to obj[, lapply(c(\"a\", \"a\"), \\(i) which(colnames(obj) == i)) |> unlist()]  obj <- array(as.list(1:64), c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 1    5    9    13   #> [2,] 2    6    10   14   #> [3,] 3    7    11   15   #> [4,] 4    8    12   16   #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 17   21   25   29   #> [2,] 18   22   26   30   #> [3,] 19   23   27   31   #> [4,] 20   24   28   32   #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 33   37   41   45   #> [2,] 34   38   42   46   #> [3,] 35   39   43   47   #> [4,] 36   40   44   48   #>  sb2_wo(obj, n(1, c(1, 3)), c(1, 3)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 18   22   26   30   #> [2,] 19   23   27   31   #> [3,] 20   24   28   32   #>  # above is equivalent to obj[-1, , c(-1, -3), drop = FALSE] sb2_wo(obj, i = \\(x)x>5) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 3 #>  #> [[4]] #> [1] 4 #>  #> [[5]] #> [1] 5 #>  # above is equivalent to obj[!sapply(obj, \\(x) x > 5)]    #############################################################################  # data.frame-like objects ====  obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) print(obj) #>     a b  c d #> 1   1 a 11 a #> 2   2 b 12 b #> 3   3 c 13 c #> 4   4 d 14 d #> 5   5 e 15 e #> 6   6 f 16 f #> 7   7 g 17 g #> 8   8 h 18 h #> 9   9 i 19 i #> 10 10 j 20 j sb2_wo(obj, 1:3, 1:3) #>   d #> 1 d #> 2 e #> 3 f #> 4 g #> 5 h #> 6 i #> 7 j # above is equivalent to obj[-1:-3, -1:-3, drop = FALSE] sb2_wo(obj, filter = ~ (a > 5) & (c < 19), vars = is.numeric) #>   b d #> 1 a a #> 2 b b #> 3 c c #> 4 d d #> 5 e e #> 6 i i #> 7 j j"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_x.html","id":null,"dir":"Reference","previous_headings":"","what":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","title":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","text":"S3 Method extract, exchange, duplicate (.e. repeat x times) subsets object.  Use sb_x(x, ...) x atomic object.  Use sb2_x(x, ...) x recursive object (.e. list data.frame-like).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_x.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","text":"","code":"sb_x(x, ...)  # S3 method for default sb_x(x, i = NULL, ...)  # S3 method for array sb_x(x, sub = NULL, dims = 1:ndims(x), i = NULL, ...)  sb2_x(x, ...)  # S3 method for default sb2_x(x, i = NULL, red = FALSE, ...)  # S3 method for array sb2_x(x, sub = NULL, dims = 1:ndims(x), i = NULL, red = FALSE, ...)  # S3 method for data.frame sb2_x(x, row = NULL, col = NULL, filter = NULL, vars = NULL, ...)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_x.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","text":"x see squarebrackets_supported_structures. ... see squarebrackets_method_dispatch. , row, col, sub, dims, filter, vars See squarebrackets_indx_args.  Duplicates allowed, resulting duplicated indices.  empty index selection results empty object length 0. red Boolean, recursive objects , indicating result reduced.  red = TRUE, selecting single element give simplified result, like using [[]].  red = FALSE, list always returned regardless number elements.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_x.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","text":"Returns copy sub-setted object.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_x.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","text":"","code":"# atomic objects ====  obj <- matrix(1:16, ncol = 4) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 sb_x(obj, 1:3, 1:ndims(obj)) #>      a b  c #> [1,] 1 5  9 #> [2,] 2 6 10 #> [3,] 3 7 11 # above is equivalent to obj[1:3, 1:3, drop = FALSE] sb_x(obj, i = \\(x)x>5) #>  [1]  6  7  8  9 10 11 12 13 14 15 16 # above is equivalent to obj[obj > 5] sb_x(obj, c(\"a\", \"a\"), 2L) #>      a  a a  a #> [1,] 1 13 1 13 #> [2,] 2 14 2 14 #> [3,] 3 15 3 15 #> [4,] 4 16 4 16 # above is equivalent to obj[, lapply(c(\"a\", \"a\"), \\(i) which(colnames(obj) == i)) |> unlist()]  obj <- array(1:64, c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  sb_x(obj, n(1:3, 1:2), c(1,3)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #>  # above is equivalent to obj[1:3, , 1:2, drop = FALSE] sb_x(obj, i = \\(x)x > 5) #>  [1]  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #> [26] 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 # above is equivalent to obj[obj > 5]   #############################################################################   # lists ====  obj <- list(a = 1:10, b = letters[1:11], c = 11:20) print(obj) #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  sb2_x(obj, 1) # obj[1] #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  sb2_x(obj, 1, red = TRUE) # obj[[1]] #>  [1]  1  2  3  4  5  6  7  8  9 10 sb2_x(obj, 1:2) # obj[1:2] #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  sb2_x(obj, is.numeric) # obj[sapply(obj, is.numeric)] #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  # for recursive subsets, see sb2_rec()   obj <- rbind(   lapply(1:4, \\(x)sample(c(TRUE, FALSE, NA))),   lapply(1:4, \\(x)sample(1:10)),   lapply(1:4, \\(x)rnorm(10)),   lapply(1:4, \\(x)sample(letters)) ) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a            b            c            a            #> [1,] logical,3    logical,3    logical,3    logical,3    #> [2,] integer,10   integer,10   integer,10   integer,10   #> [3,] numeric,10   numeric,10   numeric,10   numeric,10   #> [4,] character,26 character,26 character,26 character,26 sb2_x(obj, 1:3, 1:ndims(obj)) #>      a          b          c          #> [1,] logical,3  logical,3  logical,3  #> [2,] integer,10 integer,10 integer,10 #> [3,] numeric,10 numeric,10 numeric,10 # above is equivalent to obj[1:3, 1:3, drop = FALSE] sb2_x(obj, i = is.numeric) #> [[1]] #>  [1]  6 10  3  8  9  5  1  2  4  7 #>  #> [[2]] #>  [1]  0.5068670  0.4600684  1.4843919  0.8819632 -0.5367022  1.2855537 #>  [7]  0.5878485 -1.3084820  0.3167263  1.1941583 #>  #> [[3]] #>  [1]  2  8  3  4  5  1  6  7 10  9 #>  #> [[4]] #>  [1]  0.9130571 -0.7867530 -0.4109297  0.4763737  0.1859159 -1.3247163 #>  [7]  1.1723711  0.2314928  0.4830719 -0.5353196 #>  #> [[5]] #>  [1]  7  8  5  4 10  3  1  2  9  6 #>  #> [[6]] #>  [1]  1.37813582 -1.30267167  0.63485754  0.99965516 -0.33774895 -0.08603361 #>  [7] -1.71881758 -0.92912157  0.81367605  0.52641355 #>  #> [[7]] #>  [1]  7  2  1  8  9  3  4 10  6  5 #>  #> [[8]] #>  [1]  1.0119574  0.8313798  0.4151341 -0.6612571  0.5488113 -0.5393678 #>  [7] -0.1713184 -0.7667346 -0.6065748  1.6473128 #>  # above is equivalent to obj[sapply(obj, is.numeric)] sb2_x(obj, c(\"a\", \"a\"), 2L) #>      a            a            a            a            #> [1,] logical,3    logical,3    logical,3    logical,3    #> [2,] integer,10   integer,10   integer,10   integer,10   #> [3,] numeric,10   numeric,10   numeric,10   numeric,10   #> [4,] character,26 character,26 character,26 character,26 # above is equivalent to obj[, lapply(c(\"a\", \"a\"), \\(i) which(colnames(obj) == i)) |> unlist()]  obj <- array(as.list(1:64), c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 1    5    9    13   #> [2,] 2    6    10   14   #> [3,] 3    7    11   15   #> [4,] 4    8    12   16   #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 17   21   25   29   #> [2,] 18   22   26   30   #> [3,] 19   23   27   31   #> [4,] 20   24   28   32   #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 33   37   41   45   #> [2,] 34   38   42   46   #> [3,] 35   39   43   47   #> [4,] 36   40   44   48   #>  sb2_x(obj, n(1:3, 1:2), c(1,3)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 1    5    9    13   #> [2,] 2    6    10   14   #> [3,] 3    7    11   15   #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 17   21   25   29   #> [2,] 18   22   26   30   #> [3,] 19   23   27   31   #>  # above is equivalent to obj[1:3, , 1:2, drop = FALSE] sb2_x(obj, i = \\(x)x > 5) #> [[1]] #> [1] 6 #>  #> [[2]] #> [1] 7 #>  #> [[3]] #> [1] 8 #>  #> [[4]] #> [1] 9 #>  #> [[5]] #> [1] 10 #>  #> [[6]] #> [1] 11 #>  #> [[7]] #> [1] 12 #>  #> [[8]] #> [1] 13 #>  #> [[9]] #> [1] 14 #>  #> [[10]] #> [1] 15 #>  #> [[11]] #> [1] 16 #>  #> [[12]] #> [1] 17 #>  #> [[13]] #> [1] 18 #>  #> [[14]] #> [1] 19 #>  #> [[15]] #> [1] 20 #>  #> [[16]] #> [1] 21 #>  #> [[17]] #> [1] 22 #>  #> [[18]] #> [1] 23 #>  #> [[19]] #> [1] 24 #>  #> [[20]] #> [1] 25 #>  #> [[21]] #> [1] 26 #>  #> [[22]] #> [1] 27 #>  #> [[23]] #> [1] 28 #>  #> [[24]] #> [1] 29 #>  #> [[25]] #> [1] 30 #>  #> [[26]] #> [1] 31 #>  #> [[27]] #> [1] 32 #>  #> [[28]] #> [1] 33 #>  #> [[29]] #> [1] 34 #>  #> [[30]] #> [1] 35 #>  #> [[31]] #> [1] 36 #>  #> [[32]] #> [1] 37 #>  #> [[33]] #> [1] 38 #>  #> [[34]] #> [1] 39 #>  #> [[35]] #> [1] 40 #>  #> [[36]] #> [1] 41 #>  #> [[37]] #> [1] 42 #>  #> [[38]] #> [1] 43 #>  #> [[39]] #> [1] 44 #>  #> [[40]] #> [1] 45 #>  #> [[41]] #> [1] 46 #>  #> [[42]] #> [1] 47 #>  #> [[43]] #> [1] 48 #>  # above is equivalent to obj[sapply(obj, \\(x) x > 5)]  #############################################################################  # data.frame-like objects ====  obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) print(obj) #>     a b  c d #> 1   1 a 11 a #> 2   2 b 12 b #> 3   3 c 13 c #> 4   4 d 14 d #> 5   5 e 15 e #> 6   6 f 16 f #> 7   7 g 17 g #> 8   8 h 18 h #> 9   9 i 19 i #> 10 10 j 20 j sb2_x(obj, 1:3, 1:3) # obj[1:3, 1:3, drop = FALSE] #>   a b  c #> 1 1 a 11 #> 2 2 b 12 #> 3 3 c 13 sb2_x(obj, filter = ~ (a > 5) & (c < 19), vars = is.numeric) #>   a  c #> 1 6 16 #> 2 7 17 #> 3 8 18"},{"path":"https://tony-aw.github.io/squarebrackets/reference/setapply.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply Functions Over mutable_atomic Matrix Margins By Reference — setapply","title":"Apply Functions Over mutable_atomic Matrix Margins By Reference — setapply","text":"setapply() function applies functions rows columns mutable_atomic matrix, pass--reference semantics.  every iteration, copy single row column (depending margin) made, function applied copy, original row/column replaced modified copy pass--reference semantics.  setapply() bit faster uses less memory apply.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/setapply.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply Functions Over mutable_atomic Matrix Margins By Reference — setapply","text":"","code":"setapply(x, MARGIN, FUN)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/setapply.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply Functions Over mutable_atomic Matrix Margins By Reference — setapply","text":"x mutable_atomic matrix. Arrays supported. MARGIN single integer scalar, giving subscript apply function . 1 indicates rows, 2 indicates columns. FUN function applied.  function must return vector type x, appropriate length (.e. length ncol(x) MARGIN == 1 length nrow(x) MARGIN == 2).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/setapply.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply Functions Over mutable_atomic Matrix Margins By Reference — setapply","text":"Returns: VOID. function modifies object reference. use assignment like x <- setapply(x, ...). Since function returns void, just get NULL.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/setapply.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply Functions Over mutable_atomic Matrix Margins By Reference — setapply","text":"","code":"# re-order elements matrix by reference ==== x <- mutable_atomic(1:20, dim = c(5,4)) print(x) #>      [,1] [,2] [,3] [,4] #> [1,]    1    6   11   16 #> [2,]    2    7   12   17 #> [3,]    3    8   13   18 #> [4,]    4    9   14   19 #> [5,]    5   10   15   20 #> mutable_atomic  #> typeof:  integer  setapply(x, 1, FUN = \\(x)x[c(4,1,3,2)]) print(x) #>      [,1] [,2] [,3] [,4] #> [1,]   16    1   11    6 #> [2,]   17    2   12    7 #> [3,]   18    3   13    8 #> [4,]   19    4   14    9 #> [5,]   20    5   15   10 #> mutable_atomic  #> typeof:  integer    # sort elements of matrix by reference ==== x <- mutable_atomic(20:1, dim = c(5,4)) print(x) #>      [,1] [,2] [,3] [,4] #> [1,]   20   15   10    5 #> [2,]   19   14    9    4 #> [3,]   18   13    8    3 #> [4,]   17   12    7    2 #> [5,]   16   11    6    1 #> mutable_atomic  #> typeof:  integer  setapply(x, 2, FUN = sort) print(x) #>      [,1] [,2] [,3] [,4] #> [1,]   16   11    6    1 #> [2,]   17   12    7    2 #> [3,]   18   13    8    3 #> [4,]   19   14    9    4 #> [5,]   20   15   10    5 #> mutable_atomic  #> typeof:  integer"},{"path":"https://tony-aw.github.io/squarebrackets/reference/slice.html","id":null,"dir":"Reference","previous_headings":"","what":"Efficient Sequence-based Subset Methods on (Long) Vectors — slice","title":"Efficient Sequence-based Subset Methods on (Long) Vectors — slice","text":"slice_ - methods similar sb_ - methods, except require indexing vector, designed memory efficiency.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/slice.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Efficient Sequence-based Subset Methods on (Long) Vectors — slice","text":"","code":"slice_x(x, ...)  # S3 method for default slice_x(   x,   from = NULL,   to = NULL,   by = 1L,   ...,   use.names = TRUE,   sticky = getOption(\"squarebrackets.sticky\", FALSE) )  slice_wo(x, ...)  # S3 method for default slice_wo(   x,   from = NULL,   to = NULL,   by = 1L,   ...,   use.names = TRUE,   sticky = getOption(\"squarebrackets.sticky\", FALSE) )  slice_set(x, ...)  # S3 method for default slice_set(x, from = NULL, to = NULL, by = 1L, inv = FALSE, ..., rp, tf)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/slice.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Efficient Sequence-based Subset Methods on (Long) Vectors — slice","text":"x atomic object.  slice_set must mutable_atomic variable. ... see squarebrackets_method_dispatch. , , see cp_seq. use.names Boolean, indicating flat names preserved.  Note , since slice operates flat indices , dimensions dimnames always dropped. sticky see squarebrackets_options. inv Boolean, indicating whether invert sequence.  TRUE, slice_set() apply replacement/transformation elements vector, except elements specified sequence. rp, tf see squarebrackets_modify.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/slice.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Efficient Sequence-based Subset Methods on (Long) Vectors — slice","text":"Similar sb_ methods.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/slice.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Efficient Sequence-based Subset Methods on (Long) Vectors — slice","text":"","code":"x <- mutable_atomic(1:1e7)  # extract: slice_x(x, 1, 10) #>  [1]  1  2  3  4  5  6  7  8  9 10 #> mutable_atomic  #> typeof:  integer   # reverse: slice_x(x, -1i, 1) |> head() #> [1] 10000000  9999999  9999998  9999997  9999996  9999995 #> mutable_atomic  #> typeof:  integer   # remove: slice_wo(x, 1, -11i) # all elements except the last 10 #>  [1]  9999991  9999992  9999993  9999994  9999995  9999996  9999997  9999998 #>  [9]  9999999 10000000 #> mutable_atomic  #> typeof:  integer   # replace every other element: x <- mutable_atomic(1:1e7) slice_set(x, 2, -1i, 2, rp = -1) #> coercing replacement to integer head(x) #> [1]  1 -1  3 -1  5 -1 #> mutable_atomic  #> typeof:  integer   # replace all elements except the first element: x <- mutable_atomic(1:1e7) slice_set(x, 1, 1, inv = TRUE, rp = -1) #> coercing replacement to integer head(x) #> [1]  1 -1 -1 -1 -1 -1 #> mutable_atomic  #> typeof:  integer"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"functions convert list integer subscripts integer matrix coordinates, integer matrix coordinates integer vector flat indices, vice-versa.  Inspired sub2ind function 'MatLab'. sub2coord() converts list integer subscripts integer matrix coordinates. coord2ind() converts integer matrix coordinates integer vector flat indices. ind2coord() converts integer vector flat indices integer matrix coordinates. coord2sub() converts integer matrix coordinates list integer subscripts;  performs simple (one might even say naive) conversion. sub2ind() faster memory efficient version coord2ind(sub2coord(sub, x.dims), x.dims)  (especially 8 dimensions). functions written memory-efficient.  coord2ind() thus opposite arrayInd, ind2coord merely convenient wrapper around arrayInd.  Note equivalent sub2ind function 'MatLab' actually coord2ind() function .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"","code":"sub2coord(sub, x.dim)  coord2sub(coord)  coord2ind(coord, x.dim, checks = TRUE)  ind2coord(ind, x.dim)  sub2ind(sub, x.dim, checks = TRUE)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"sub list integer subscripts.  first element list corresponds first dimension (rows), second element second dimensions (columns), etc.  length sub must equal length x.dim.  One give empty subscript; instead fill something like seq_len(dim(x)[margin]).  NOTE: coord2sub() function support duplicate subscripts. x.dim integer vector giving dimensions array question. .e. dim(x). coord integer matrix, giving coordinate indices (subscripts) convert.  row index, column dimension.  first columns corresponds first dimension, second column second dimensions, etc.  number columns coord must equal length x.dim. checks Boolean, indicating arguments checks performed.  Defaults TRUE.  Can set FALSE minor speed improvements. ind integer vector, giving flat position indices convert.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"sub2coord() ind2coord(): Returns integer matrix coordinates (properties described argument coord).  coord2ind(): Returns numeric vector flat indices (properties described argument ind).  coord2sub(): Returns list integer subscripts (properties described argument sub)  sub2ind(): Returns integer vector flat indices(prod(x.dim) < (2^31 - 1)), numeric vector flat indices (prod(x.dim) >= (2^31 - 1)).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"functions specifically designed duplicate indices per-sé.  efficiency, check duplicate indices either.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"","code":"x.dim <- c(10, 10, 3) x.len <- prod(x.dim) x <- array(1:x.len, x.dim) sub <- list(c(4, 3), c(3, 2), c(2, 3)) coord <- sub2coord(sub, x.dim) print(coord) #>      [,1] [,2] [,3] #> [1,]    4    3    2 #> [2,]    3    3    2 #> [3,]    4    2    2 #> [4,]    3    2    2 #> [5,]    4    3    3 #> [6,]    3    3    3 #> [7,]    4    2    3 #> [8,]    3    2    3 ind <- coord2ind(coord, x.dim) print(ind) #> [1] 124 123 114 113 224 223 214 213 all(x[ind] == c(x[c(4, 3), c(3, 2), c(2, 3)])) # TRUE #> [1] TRUE coord2 <- ind2coord(ind, x.dim) print(coord) #>      [,1] [,2] [,3] #> [1,]    4    3    2 #> [2,]    3    3    2 #> [3,]    4    2    2 #> [4,]    3    2    2 #> [5,]    4    3    3 #> [6,]    3    3    3 #> [7,]    4    2    3 #> [8,]    3    2    3 all(coord == coord2) # TRUE #> [1] TRUE sub2 <- coord2sub(coord2) sapply(1:3, \\(i) sub2[[i]] == sub[[i]]) |> all() # TRUE #> [1] TRUE"},{"path":"https://tony-aw.github.io/squarebrackets/reference/tci.html","id":null,"dir":"Reference","previous_headings":"","what":"Type Cast Indices — tci_bool","title":"Type Cast Indices — tci_bool","text":"functions typecast indices proper integer indices.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/tci.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Type Cast Indices — tci_bool","text":"","code":"tci_bool(indx, n, inv = FALSE, .abortcall = sys.call())  tci_int(indx, n, inv = FALSE, chkdup = FALSE, .abortcall = sys.call())  tci_chr(   indx,   nms,   inv = FALSE,   chkdup = FALSE,   uniquely_named = FALSE,   .abortcall = sys.call() )  tci_cplx(indx, n, inv = FALSE, chkdup = FALSE, .abortcall = sys.call())"},{"path":"https://tony-aw.github.io/squarebrackets/reference/tci.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Type Cast Indices — tci_bool","text":"indx indices typecast n relevant size, typecasting integer logical indices.  Examples: target row indices, input nrow n. target flat indices, input length n. inv Boolean, indicating indices inverted.  See squarebrackets_indx_args. .abortcall environment error message passed . chkdup see squarebrackets_options. nms relevant names, typecasting character indices.  Examples: target row indices, input row names nms. target flat indices, input flat names nms. uniquely_named Boolean, indicating user knows -priori relevant names x unique.  set TRUE, speed may increase.  specifying TRUE relevant names unique result incorrect output.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/tci.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Type Cast Indices — tci_bool","text":"integer vector type-cast indices.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/tci.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Type Cast Indices — tci_bool","text":"","code":"x <- matrix(1:25, 5, 5) colnames(x) <- c(\"a\", \"a\", \"b\", \"c\", \"d\") print(x) #>      a  a  b  c  d #> [1,] 1  6 11 16 21 #> [2,] 2  7 12 17 22 #> [3,] 3  8 13 18 23 #> [4,] 4  9 14 19 24 #> [5,] 5 10 15 20 25  bool <- sample(c(TRUE, FALSE), 5, TRUE) int <- 1:4 chr <- c(\"a\", \"a\") cplx <- 1:4 * -1i tci_bool(bool, nrow(x)) #> [1] 1 2 5 tci_int(int, ncol(x), inv = TRUE) #> [1] 5 tci_chr(chr, colnames(x)) #> [1] 1 2 1 2 tci_cplx(cplx, nrow(x)) #> [1] 5 4 3 2  ci_flat(x, 1:10 * -1i) #>  [1] 25 24 23 22 21 20 19 18 17 16 ci_margin(x, 1:4, 2) #> [1] 1 2 3 4 ci_sub(x, n(1:5 * -1i, 1:4), 1:2) #> [[1]] #> [1] 5 4 3 2 1 #>  #> [[2]] #> [1] 1 2 3 4 #>"}]
