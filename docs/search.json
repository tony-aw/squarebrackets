[{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Benchmarks - sb_x","text":"Due many checks conversions performed squarebrackets:: functions, make sub-setting programmatically beginner friendly, functions almost necessarily slower base R’s [-like operators. However, considerable effort made keep speed loss minimum. Generally, speed loss indeed negligible, cases even speed improvement (thanks heavy lifting performed ‘collapse’ package). benchmarks give one idea speed loss. just examples; speed determined great number factors.  ","code":"library(bench) library(ggplot2) library(patchwork)"},{"path":[]},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"matrix","dir":"Articles","previous_headings":"Atomic objects","what":"Matrix","title":"Benchmarks - sb_x","text":" ","code":"n <- 5e3 x.mat <- matrix(seq_len(n*n), ncol = n) colnames(x.mat) <- sample(c(letters, NA), n, TRUE) sel.rows <- 1:100 sel.cols <- rep(sample(letters[1:13]), 10) bm.sb_x.matrix <- bench::mark(   \"squarebrackets\" = sb_x.matrix(x.mat, sel.rows, sel.cols),   \"base R\" = x.mat[sel.rows, lapply(sel.cols, \\(i) which(colnames(x.mat) == i)) |> unlist(), drop = FALSE],   min_iterations = 500 ) bm.sb_x.matrix summary(bm.sb_x.matrix) #> # A tibble: 2 × 6 #>   expression          min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>     <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 squarebrackets   4.99ms   5.56ms      177.    9.82MB     28.3 #> 2 base R           7.81ms    8.9ms      111.   14.67MB     16.6"},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"array-3d","dir":"Articles","previous_headings":"Atomic objects","what":"Array (3D)","title":"Benchmarks - sb_x","text":" ","code":"x.dims <- c(5000, 2000, 4) x.3d <- array(1:prod(x.dims), x.dims) sel.rows <- 1:900 sel.lyrs <- c(TRUE, FALSE, TRUE, FALSE) bm.sb_x.3d <- bench::mark(   \"squarebrackets\" =  sb_x.array(x.3d, rcl = n(sel.rows, NULL, sel.lyrs)),   \"base R + abind\" = abind::asub(x.3d, idx = list(sel.rows, sel.lyrs), dims = c(1,3)),   min_iterations = 500 ) summary(bm.sb_x.3d) #> # A tibble: 2 × 6 #>   expression          min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>     <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 squarebrackets   9.64ms   10.6ms      94.1    13.7MB     7.52 #> 2 base R + abind    9.7ms   10.7ms      92.8    13.7MB     6.56"},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"plot","dir":"Articles","previous_headings":"Atomic objects","what":"Plot","title":"Benchmarks - sb_x","text":" ","code":"#> Loading required namespace: tidyr"},{"path":[]},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"data-frame","dir":"Articles","previous_headings":"Data.frame-like objects","what":"data.frame","title":"Benchmarks - sb_x","text":" ","code":"n <- 1e5 chrmat <- matrix(   sample(letters, n*400, replace = TRUE), ncol = 400 ) intmat <- matrix(   seq.int(n*400), ncol = 400 ) x <- cbind(chrmat, intmat) |> as.data.frame() rm(list = c(\"chrmat\", \"intmat\")) colnames(x) <- make.names(colnames(x), unique = TRUE) sel.cols <- rep(sample(names(x), 10), 4) sel.rows <- 1:1000 bm.sb_x.df <- bench::mark(   \"squarebrackets\" = sb_x.data.frame(x, sel.rows, sel.cols),   \"collapse::ss\" = collapse::ss(x, sel.rows, match(sel.cols, names(x))),   \"base R\" = x[sel.rows, match(sel.cols, names(x)), drop = FALSE],   min_iterations = 1e4 ) summary(bm.sb_x.df) #> # A tibble: 2 × 6 #>   expression          min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>     <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 squarebrackets    124µs    193µs     4466.     441KB     8.95 #> 2 base R            345µs    879µs     1052.     362KB     2.11"},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"data-table","dir":"Articles","previous_headings":"Data.frame-like objects","what":"data.table","title":"Benchmarks - sb_x","text":" ","code":"x <- as.data.table(x) tempfun <- function(x, i, j) {   x <- collapse::ss(x, i, j, check = TRUE)   names(x) <- make.names(names(x), unique = TRUE)   return(x) } bm.sb_x.dt <- bench::mark(   \"squarebrackets\" = sb_x.data.frame(x, sel.rows, sel.cols),   \"data.table + collapse\" = tempfun(x, sel.rows, match(sel.cols, names(x))),   min_iterations = 1e4 ) summary(bm.sb_x.dt) #> # A tibble: 2 × 6 #>   expression                 min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>            <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 squarebrackets           112µs    125µs     7610.     324KB     4.57 #> 2 data.table + collapse    106µs    124µs     5508.     339KB     0"},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"plot-1","dir":"Articles","previous_headings":"Data.frame-like objects","what":"plot","title":"Benchmarks - sb_x","text":" ","code":""},{"path":"https://tony-aw.github.io/squarebrackets/articles/Extra_Examples.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Additional Examples","text":"function documentation ‘squarebrackets’ package rich examples. article adds additional examples focussed combining ‘squarebrackets’ packages.  ","code":""},{"path":"https://tony-aw.github.io/squarebrackets/articles/Extra_Examples.html","id":"aggregate-sf-data-table","dir":"Articles","previous_headings":"","what":"Aggregate sf-data.table","title":"Additional Examples","text":"‘sf’ package adds data.frames/data.tables spatial features. example, functionality ‘squarebrackets’ used ‘sf’ class data.table. plot created (using ‘ggplot2’, ‘ggh4x’, ‘tinycodet’) aggregation region spatial data.table:   ","code":"library(ggplot2) library(ggh4x) library(tinycodet) #> Warning: package 'tinycodet' was built under R version 4.3.3 #> Run `?tinycodet::tinycodet` to open the introduction help page of 'tinycodet'. import_as(~dt., \"data.table\") #> Importing packages and registering methods... #> Done #> You can now access the functions using `dt.$` #> For conflicts report, packages order, and other attributes, run `attr.import(dt.)` x <- sf::st_read(system.file(\"shape/nc.shp\", package = \"sf\")) #> Reading layer `nc' from data source `D:\\Programs\\R-4.3.2\\library\\sf\\shape\\nc.shp' using driver `ESRI Shapefile' #> Simple feature collection with 100 features and 14 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 #> Geodetic CRS:  NAD27 x <- dt.$as.data.table(x)  x$region <- ifelse(x$CNTY_ID <= 2000, 'high', 'low') plotdat <- dt_aggregate(   x, SDcols = \"geometry\", f = sf::st_union, by = \"region\" ) geometry <- form(~geometry) fill <- form(~region) fct <- form(~region) ggplot(plotdat, aes_pro(geometry = geometry, fill = fill)) +    facet_wrap2(fct, nrow = 2) +   geom_sf()"},{"path":"https://tony-aw.github.io/squarebrackets/articles/Extra_Examples.html","id":"re-order-an-array-like-a-rubiks-cube","dir":"Articles","previous_headings":"","what":"Re-order an array like a Rubik’s cube","title":"Additional Examples","text":"%row~% %col~% operators ‘tinycodet’ can quickly re-order elements row column independently rows columns. One can combine operators sb_ methods ‘squarebrackets’ re-order matrix slices array, like re-ordering panels Rubik’s cube. using sb_set() one can even reference better memory efficiency - exactly done . Let’s first create mutable array: Now let’s numerically sort every column slices array reference: Now, let’s see successful: Yes, column layer independently sorted numerically. One can thing character array; note time use stringi::stri_rank() determining proper order: : successful.    ","code":"x <- mutable_atomic(sample(1:27), dim = c(3,3,3)) print(x) #> , , 1 #>  #>      [,1] [,2] [,3] #> [1,]   10   14    6 #> [2,]    9    4   18 #> [3,]   16    7    1 #>  #> , , 2 #>  #>      [,1] [,2] [,3] #> [1,]   21   22   20 #> [2,]    3   25   19 #> [3,]   23   11   12 #>  #> , , 3 #>  #>      [,1] [,2] [,3] #> [1,]    5   13   24 #> [2,]    8   17   26 #> [3,]   27    2   15 #>  #> mutable_atomic  #> typeof:  integer library(tinycodet)  for(i in 1:3) {   y <- sb_x(x, n(i), 3) |> drop()   rp <- y %col~% y   sb_set(x, n(i), 3, rp = rp) } print(x) #> , , 1 #>  #>      [,1] [,2] [,3] #> [1,]    9    4    1 #> [2,]   10    7    6 #> [3,]   16   14   18 #>  #> , , 2 #>  #>      [,1] [,2] [,3] #> [1,]    3   11   12 #> [2,]   21   22   19 #> [3,]   23   25   20 #>  #> , , 3 #>  #>      [,1] [,2] [,3] #> [1,]    5    2   15 #> [2,]    8   13   24 #> [3,]   27   17   26 #>  #> mutable_atomic  #> typeof:  integer x <- mutable_atomic(sample(c(letters, 1e3)), dim = c(3,3,3)) print(x) #> , , 1 #>  #>      [,1] [,2]   [,3] #> [1,] \"g\"  \"1000\" \"w\"  #> [2,] \"s\"  \"c\"    \"r\"  #> [3,] \"l\"  \"p\"    \"x\"  #>  #> , , 2 #>  #>      [,1] [,2] [,3] #> [1,] \"n\"  \"b\"  \"u\"  #> [2,] \"a\"  \"v\"  \"i\"  #> [3,] \"j\"  \"e\"  \"y\"  #>  #> , , 3 #>  #>      [,1] [,2] [,3] #> [1,] \"q\"  \"k\"  \"z\"  #> [2,] \"m\"  \"t\"  \"h\"  #> [3,] \"f\"  \"d\"  \"o\"  #>  #> mutable_atomic  #> typeof:  character for(i in 1:3) {   y <- sb_x(x, n(i), 3) |> drop()   rp <- y %col~% stringi::stri_rank(y)   sb_set(x, n(i), 3, rp = rp) } print(x) #> , , 1 #>  #>      [,1] [,2]   [,3] #> [1,] \"g\"  \"1000\" \"r\"  #> [2,] \"l\"  \"c\"    \"w\"  #> [3,] \"s\"  \"p\"    \"x\"  #>  #> , , 2 #>  #>      [,1] [,2] [,3] #> [1,] \"a\"  \"b\"  \"i\"  #> [2,] \"j\"  \"e\"  \"u\"  #> [3,] \"n\"  \"v\"  \"y\"  #>  #> , , 3 #>  #>      [,1] [,2] [,3] #> [1,] \"f\"  \"d\"  \"h\"  #> [2,] \"m\"  \"k\"  \"o\"  #> [3,] \"q\"  \"t\"  \"z\"  #>  #> mutable_atomic  #> typeof:  character"},{"path":"https://tony-aw.github.io/squarebrackets/articles/Extra_Examples.html","id":"mutate-column-of-data-table","dir":"Articles","previous_headings":"","what":"Mutate column of data.table","title":"Additional Examples","text":"can mutate column data.table reference, combining ‘squarebrackets’ tinycodet::with_pro(), follows:  ","code":"x <- sf::st_read(system.file(\"shape/nc.shp\", package = \"sf\")) #> Reading layer `nc' from data source `D:\\Programs\\R-4.3.2\\library\\sf\\shape\\nc.shp' using driver `ESRI Shapefile' #> Simple feature collection with 100 features and 14 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 #> Geodetic CRS:  NAD27 x <- dt.$as.data.table(x)  myform <- form(~ PERIMETER / AREA) x$newcolumn <- 1:nrow(x) mutated <- dt.$as.data.table(with_pro(x, myform)) sb_set(x, col = \"newcolumn\", rp = mutated) summary(x) #>       AREA          PERIMETER         CNTY_         CNTY_ID     #>  Min.   :0.0420   Min.   :0.999   Min.   :1825   Min.   :1825   #>  1st Qu.:0.0910   1st Qu.:1.324   1st Qu.:1902   1st Qu.:1902   #>  Median :0.1205   Median :1.609   Median :1982   Median :1982   #>  Mean   :0.1263   Mean   :1.673   Mean   :1986   Mean   :1986   #>  3rd Qu.:0.1542   3rd Qu.:1.859   3rd Qu.:2067   3rd Qu.:2067   #>  Max.   :0.2410   Max.   :3.640   Max.   :2241   Max.   :2241   #>      NAME               FIPS               FIPSNO         CRESS_ID      #>  Length:100         Length:100         Min.   :37001   Min.   :  1.00   #>  Class :character   Class :character   1st Qu.:37051   1st Qu.: 25.75   #>  Mode  :character   Mode  :character   Median :37100   Median : 50.50   #>                                        Mean   :37100   Mean   : 50.50   #>                                        3rd Qu.:37150   3rd Qu.: 75.25   #>                                        Max.   :37199   Max.   :100.00   #>      BIR74           SID74          NWBIR74           BIR79       #>  Min.   :  248   Min.   : 0.00   Min.   :   1.0   Min.   :  319   #>  1st Qu.: 1077   1st Qu.: 2.00   1st Qu.: 190.0   1st Qu.: 1336   #>  Median : 2180   Median : 4.00   Median : 697.5   Median : 2636   #>  Mean   : 3300   Mean   : 6.67   Mean   :1050.8   Mean   : 4224   #>  3rd Qu.: 3936   3rd Qu.: 8.25   3rd Qu.:1168.5   3rd Qu.: 4889   #>  Max.   :21588   Max.   :44.00   Max.   :8027.0   Max.   :30757   #>      SID79          NWBIR79                 geometry     newcolumn     #>  Min.   : 0.00   Min.   :    3.0   MULTIPOLYGON :100   Min.   : 8.35   #>  1st Qu.: 2.00   1st Qu.:  250.5   epsg:4267    :  0   1st Qu.:11.62   #>  Median : 5.00   Median :  874.5   +proj=long...:  0   Median :13.32   #>  Mean   : 8.36   Mean   : 1352.8                       Mean   :14.49   #>  3rd Qu.:10.25   3rd Qu.: 1406.8                       3rd Qu.:16.11   #>  Max.   :57.00   Max.   :11631.0                       Max.   :42.40"},{"path":"https://tony-aw.github.io/squarebrackets/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Tony Wilkes. Author, maintainer, copyright holder.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Wilkes T (2024). squarebrackets: Methods Alternative Square Brackets Operators. R package version 0.0.0.9, https://tony-aw.github.io/squarebrackets/, https://github.com/tony-aw/squarebrackets/.","code":"@Manual{,   title = {squarebrackets: Methods as an Alternative to the Square Brackets Operators},   author = {Tony Wilkes},   year = {2024},   note = {R package version 0.0.0.9, https://tony-aw.github.io/squarebrackets/},   url = {https://github.com/tony-aw/squarebrackets/}, }"},{"path":"https://tony-aw.github.io/squarebrackets/index.html","id":"squarebrackets","dir":"","previous_headings":"","what":"Methods as an Alternative to the Square Brackets Operators","title":"Methods as an Alternative to the Square Brackets Operators","text":"squarebrackets: Methods Alternative Square Brackets Operators  ","code":""},{"path":"https://tony-aw.github.io/squarebrackets/index.html","id":"introduction","dir":"","previous_headings":"","what":"Introduction","title":"Methods as an Alternative to the Square Brackets Operators","text":"‘squarebrackets’ package provides methods used situation regular square brackets ([) inconvenient. examples given situations [ inconvenient, ‘squarebrackets’ helps situations.   Suppose array x. order perform subset operations x [, need know many dimensions . .e. x 3 dimensions, one use x[, j, k, drop = FALSE] x[, j, k] <- value. don’t know -priori number dimensions x . ? ’s impossible [, still rather convoluted. ‘squarebrackets’ package solves providing methods use name-based arguments, instead position based arguments.   data.frame, tibble, data.table, tidytable objects, inherit class “data.frame”, use slightly different rules regarding usage [. Especially data.table different rules. Constantly switching rules annoying, makes code look inconsistent. ‘squarebrackets’ package solves , using methods consistent across classes data.frame, tibble, data.table, tidytable, direct extensions (sf-data.table class).   ‘R’ adheres copy--modification semantics replacing values using [<-. Usually fine. sometimes one like explicit control create copy, modify using pass--reference semantics. ‘squarebrackets’ package provides 2 methods explicit semantics: sb_mod() modification deep copies, sb_set() modification pass--reference semantics.   Now, get started see ?squarebrackets_help  ","code":""},{"path":"https://tony-aw.github.io/squarebrackets/index.html","id":"installing--loading","dir":"","previous_headings":"","what":"Installing & Loading","title":"Methods as an Alternative to the Square Brackets Operators","text":"One can install ‘squarebrackets’ GitHub like : Special care taken make sure function names clear, function names unlikely conflict core R, recommended R packages, rstudioapi package, major packages fastverse. one can attach package - thus exposing functions namespace - using: user wish expose specific functions ‘squarebrackets’ within specific environment, like within specific function, one can use following:  ","code":"remotes::install_github(\"https://github.com/tony-aw/squarebrackets\") library(squarebrackets) tinycodet::import_LL(\"squarebrackets\", selection = ... )"},{"path":"https://tony-aw.github.io/squarebrackets/index.html","id":"changelog-experimental-versions","dir":"","previous_headings":"","what":"Changelog (EXPERIMENTAL VERSIONS)","title":"Methods as an Alternative to the Square Brackets Operators","text":"First GitHub upload - Package much experimental.  ","code":""},{"path":"https://tony-aw.github.io/squarebrackets/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 Tony Wilkes Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa0_squarebrackets.html","id":null,"dir":"Reference","previous_headings":"","what":"squarebrackets: Methods as an Alternative to the Square Brackets Operators — aaa0_squarebrackets","title":"squarebrackets: Methods as an Alternative to the Square Brackets Operators — aaa0_squarebrackets","text":"squarebrackets: Methods Alternative Square Brackets Operators","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa0_squarebrackets.html","id":"motivation","dir":"Reference","previous_headings":"","what":"Motivation","title":"squarebrackets: Methods as an Alternative to the Square Brackets Operators — aaa0_squarebrackets","text":"","code":"Among programming languages, 'R' has perhaps one of the most flexible and comprehensive sub-setting functionality. But with flexibility often comes confusion, and (apparent) inconsistencies. And 'R' is no exception.  This becomes quite apparent when one reads (online) documents, such as \"The R Inferno\" by Patrick Burns, and \"Frustration: One Year With R\" by Reece Goding. These documents point out many inconsistencies, and sub-setting related inconsistencies make up a good portion of these documents.  Subset-related R packages to \"fix\" such issues do exist. But they usually focus almost exclusively on one class (usually data.frame-like objects), and packages focussing on different classes use different APIs. Moreover, these packages are not always programmatically friendly, (for example, they often employ quite a bit of non-standard evaluation).  Thus, this R package was born.  Although this package was somewhat made for people who are new to 'R' (especially when coming from another programming language), and found themselves confused, I trust this package will be useful, even for those who are quite experienced in 'R'."},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa0_squarebrackets.html","id":"goal-amp-properties","dir":"Reference","previous_headings":"","what":"Goal & Properties","title":"squarebrackets: Methods as an Alternative to the Square Brackets Operators — aaa0_squarebrackets","text":"Goal 'squarebrackets' package replace square-brackets operators per-sé (see Extract), provide alternative sub-setting methods functions, used situations square-brackets operators inconvenient.  (hopefully) easier sub-setting methods functions following properties: Programmatically friendly: Name-based arguments instead position-based arguments. Unlike base [, required know number dimensions array -priori, perform subset-operations object. Missing arguments can filled NULL, instead using dark magic like base::quote(expr =    ). Non-standard evaluation. Functions pipe-friendly. (silent) vector recycling. Extracting removing subsets uses syntax. Class consistent: sub-setting multi-dimensional objects specifying dimensions (.e. rows, columns, ...) use drop = FALSE. matrix , matrix . functions deliver results data.frames, data.tables, tibbles, tidytables. longer one re-learn different brackets-based sub-setting rules different types data.frame-like objects. Powered subclass agnostic 'C'-code 'collapse' 'data.table'. Explicit copy semantics: Sub-set operations change memory allocations, always return modified copy object. sub-set operations just change values -place (similar [<- [[<- methods) user can choose method modifies object reference, choose method returns deep copy. Careful handling names attributes: Sub-setting object index names returns indices name, just first. Data.frame-like objects (see supported classes ) forced unique column names. Attributes data.frame-like objects (see supported classes ) always preserved sub-setting. object types, user can specify whether preserve Attributes, use R's [ attribute behaviour (.e. drop attributes). ensure compatibility R-packages create attribute behaviour sub-setting. Concise function argument names. Performance aware:  Despite many checks performed, functions kept reasonably speedy, use 'Rcpp', 'collapse', 'data.table' R-packages. heavy lifting package done 'collapse' package.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa0_squarebrackets.html","id":"supported-classes","dir":"Reference","previous_headings":"","what":"Supported  Classes","title":"squarebrackets: Methods as an Alternative to the Square Brackets Operators — aaa0_squarebrackets","text":"'squarebrackets' supports S3 classes, primarily use square brackets sub-setting (hence name package).  Supported immutable classes: atomic, factor, list, data.frame (including tibble sf-data.frame).  Supported  mutable classes: mutable_atomic, data.table (including tidytable sf-data.table).  support mutable list-like classes, various collections classes 'collections' package, fastmap class 'fastmap' package, sub-setting method primarily based square-brackets.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa0_squarebrackets.html","id":"methods-and-functions","dir":"Reference","previous_headings":"","what":"Methods and Functions","title":"squarebrackets: Methods as an Alternative to the Square Brackets Operators — aaa0_squarebrackets","text":"main focus following generic S3 methods: sb_x: extract, exchange, duplicate subsets. sb_rm: un-select/remove subsets. sb_set: modify (transform replace) subsets mutable object using Pass Reference semantics. sb_mod: return copy object modified (transformed replaced) subsets. sb_coe: coerce transform whole object, recursive subset object. sb_before, sb_after: insert new values index along dimension object. sb_rec: accesses recursive subsets lists. sb_currentBindings: list currently existing bindings share share address input variable. Additional specialized sub-setting functions provided: setapply: apply functions mutable matrix margins using Pass Reference semantics. sb_str: extract replace subset characters single string (single character treated single element). sb_a: extract multiple attributes object. dt_-functions data.table-specific [-operations. finally, couple helper functions creating ranges, sequences, indices (often needed sub-setting) provided: n: Nested version c, short-hand list. Computing indices: idx_by compute grouped indices. idx_ord_-functions compute ordered indices. match_all: Find matches, one vector another, taking account order duplicate values vectors. Computing sequences: seq_rec recursive sequence generator (example generate Fibonacci sequence). seq_names create range indices specified starting ending name. seq_mlen create multiple sequences given lengths . sub2coord, coord2ind: Convert subscripts (array indices) coordinates, coordinates flat indices, vice-versa.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa0_squarebrackets.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"squarebrackets: Methods as an Alternative to the Square Brackets Operators — aaa0_squarebrackets","text":"badges shown documentation R-package made using services : https://shields.io/","code":""},{"path":[]},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa0_squarebrackets.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"squarebrackets: Methods as an Alternative to the Square Brackets Operators — aaa0_squarebrackets","text":"Maintainer: Tony Wilkes tony_a_wilkes@outlook.com (ORCID)","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa1_squarebrackets_immutable_classes.html","id":null,"dir":"Reference","previous_headings":"","what":"Supported Immutable S3 Classes, With Auto-Coercion Rules — aaa1_squarebrackets_immutable_classes","title":"Supported Immutable S3 Classes, With Auto-Coercion Rules — aaa1_squarebrackets_immutable_classes","text":"sb_ generic methods support following categories S3 classes: atomic classes (vector, matrix, array); factor; list; data.frame (classes inherit data.frame, like tibble, sf-data.frame sf-tibble)","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa1_squarebrackets_immutable_classes.html","id":"auto-coercion-rules","dir":"Reference","previous_headings":"","what":"Auto-Coercion Rules","title":"Supported Immutable S3 Classes, With Auto-Coercion Rules — aaa1_squarebrackets_immutable_classes","text":"Atomic  Atomic objects automatically coerced fit modified subset values, modifying copy.  example, replacing one multiple values integer vector (type int) decimal number (type dbl) coerce entire vector type dbl. Factor  Factors accept values part levels, thus support coercion modification. mechanism changing factors reference .  Replacing value new value part levels, result replacement value NA. List  Lists allow complete change elements, since lists merely pointers.  example, following code performs full coercion:   However, recursive subset list list, follows coercion rules whatever class recursive subset .  example following code:   transforms recursive subsets according - case - atomic auto-coercion rules. Data.frames replacing/transforming whole columns  data.frame actually list, column list. , replacing/transforming whole columns, row = NULL filter = NULL, allows completely changing type column.  Note coercion columns needs arguments row = NULL filter = NULL sb_mod sb_set methods; auto-coercion take place specifying something like row = 1:nrow(x) (see next section). Data.frames, partially replacing/transforming columns  rows specified sb_mod sb_set methods, thus whole columns parts columns replaced transformed, auto-coercion takes place.  .e.: replacing/transforming value integer (int) column become 1.5, coerce column decimal type (dbl); instead, replacement value 1.5 coerced integer 1.  coe argument sb_mod method allows user enforce coercion, even subsets columns replaced/transformed instead whole columns.  Specifically, coe arguments allows user specify coercive function applied entirety every column specified col vars; columns outside subset affected.  coercion function , course, applied replacement (rp) transformation (tf()).","code":"x <- list(factor(letters), factor(letters)) sb_mod(x, 1, rp = list(1)) x <- list(1:10, 1:10) sb_rec(x, 1, rp = \"a\") # coerces to character"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa1_squarebrackets_immutable_classes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Supported Immutable S3 Classes, With Auto-Coercion Rules — aaa1_squarebrackets_immutable_classes","text":"","code":"# Coercion examples - lists ==== x <- list(factor(letters), factor(letters)) print(x) #> [[1]] #>  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z #> Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z #>  #> [[2]] #>  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z #> Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z #>  sb_mod(x, 1, rp = list(1)) # first element fully changed. #> [[1]] #> [1] 1 #>  #> [[2]] #>  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z #> Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z #>   x <- list(1:10, 1:10) print(x) #> [[1]] #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> [[2]] #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  sb_rec(x, 1, rp = \"a\") # coerces first element to character print(x) #> [[1]] #> [1] \"a\" #>  #> [[2]] #>  [1]  1  2  3  4  5  6  7  8  9 10 #>    #############################################################################   # Coercion examples - data.frame-like - whole columns ====  obj <- data.frame(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 sb_mod(   obj, vars = is.numeric,   tf = sqrt # SAFE: row=NULL & filter = NULL, so coercion performed ) #>           a b        c d #> 1  1.000000 a 3.316625 a #> 2  1.414214 b 3.464102 b #> 3  1.732051 c 3.605551 c #> 4  2.000000 d 3.741657 d #> 5  2.236068 e 3.872983 e #> 6  2.449490 f 4.000000 f #> 7  2.645751 g 4.123106 g #> 8  2.828427 h 4.242641 h #> 9  3.000000 i 4.358899 i #> 10 3.162278 j 4.472136 j  #############################################################################   # Coercion examples - data.frame-like - partial columns ====  # sb_mod(): obj <- data.frame(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10  sb_mod(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost ) #> Warning: 1.414214 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 1 named 'a') #> Warning: 3.464102 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 3 named 'c') #>     a b  c d #> 1   1 a 11 a #> 2   1 b  3 b #> 3   1 c  3 c #> 4   2 d  3 d #> 5   2 e  3 e #> 6   2 f  4 f #> 7   2 g  4 g #> 8   8 h 18 h #> 9   9 i 19 i #> 10 10 j 20 j sb_mod(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   coe = as.double, tf = sqrt # SAFE: coercion performed ) #>            a b         c d #> 1   1.000000 a 11.000000 a #> 2   1.414214 b  3.464102 b #> 3   1.732051 c  3.605551 c #> 4   2.000000 d  3.741657 d #> 5   2.236068 e  3.872983 e #> 6   2.449490 f  4.000000 f #> 7   2.645751 g  4.123106 g #> 8   8.000000 h 18.000000 h #> 9   9.000000 i 19.000000 i #> 10 10.000000 j 20.000000 j"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa2_squarebrackets_mutable_classes.html","id":null,"dir":"Reference","previous_headings":"","what":"Supported Mutable S3 classes, With Auto-Coercion Rules — aaa2_squarebrackets_mutable_classes","title":"Supported Mutable S3 classes, With Auto-Coercion Rules — aaa2_squarebrackets_mutable_classes","text":"sb_ generic methods support following Mutable S3 classes: mutable_atomic (vector class supports dimension, thus also matrices arrays); data.table (classes inherit data.table, like tidytable sf-data.table); Views Lists: Though lists treated immutable, lists can contain mutable objects, modification reference mutable views lists support 'squarebrackets'. mutable version list class , example, various collections classes 'collections' package, fastmap class 'fastmap' package; use sub-setting method based square brackets operators, thus covered package.  Environments also covered package.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa2_squarebrackets_mutable_classes.html","id":"auto-coercion-rules","dir":"Reference","previous_headings":"","what":"Auto-Coercion Rules","title":"Supported Mutable S3 classes, With Auto-Coercion Rules — aaa2_squarebrackets_mutable_classes","text":"Coercion Semantics  mutable classes support \"copy--modify\" semantics like immutable classes, - unlike immutable classes - also support \"pass--reference\" semantics.  sb_mod method modify subsets object deep copy.  sb_set method dt_setcoe function modify subsets object reference.  2 copy semantics - \"pass reference\" \"modify copy\" - slightly different auto-coercion rules.  explained section.  Note sb_before sb_after methods usually allow coercion classes. mutable_atomic  Mutable atomic objects automatically coerced fit modified subset values, modifying copy, just like regular atomic classes.  example, replacing one multiple values integer vector (type int) decimal number (type dbl) coerce entire vector type dbl.  Replacing transforming subsets mutable atomic objects reference support coercion. Thus, example, following code,   gives c(rep(8, 6) 7:16) instead c(rep(8.5, 6), 7:16), x type integer, rp interpreted type integer also. data.table, replacing/transforming whole columns  data.table actually list made mutable, column list. , replacing/transforming whole columns, row = NULL filter = NULL, allows completely changing type column.  Note coercion columns needs arguments row = NULL filter = NULL sb_mod sb_set methods; auto-coercion take place specifying something like row = 1:nrow(x) (see next section). data.table, partially replacing/transforming columns  rows specified sb_mod sb_set methods, thus whole columns parts columns replaced transformed, auto-coercion takes place.  .e.: replacing/transforming value integer (int) column become 1.5, coerce column decimal type (dbl); instead, replacement value 1.5 coerced integer 1.  coe argument sb_mod method allows user enforce coercion, even subsets columns replaced/transformed instead whole columns.  Specifically, coe arguments allows user specify coercive function applied entirety every column specified col vars; columns outside subset affected.  coercion function , course, applied replacement (rp) transformation (tf()). Views Lists  Regular lists treated mutable objects 'squarebrackets'.  However, lists actually really objects, merely (potentially hierarchical) structure pointers.  Thus, even list treated mutable, subsets list mutable classes, mutable.  example, list data.table objects, data.tables mutable.  Therefore, following work:   Notice code mypointer copy x$, since address.  Thus changing mypointer also changes x$.  words: mypointer called \"view\" x$.  Notice also sb_set(x$, ...) work, since sb_set() requires actual variables, similar -place functions style `myfun()<-`.  auto-coercion rules Views Lists, depends entirely object .  Thus list subset data.table, mutable matrix, coercion rules data.tables apply.  list subset data.table, coercion rules mutable matrices apply., etc.","code":"x <- 1:16 sb_set(x, i = 1:6, rp = 8.5) x x <- list(  a = data.table(cola = 1:10, colb = letters[1:10]),  b = data.table(cola = 11:20, colb = letters[11:20]) ) mypointer <- x$a sb_set(mypointer, col = \"cola\", tf = \\(x)x^2)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa2_squarebrackets_mutable_classes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Supported Mutable S3 classes, With Auto-Coercion Rules — aaa2_squarebrackets_mutable_classes","text":"","code":"# Coercion examples - mutable_atomic ====  x <- as.mutable_atomic(1:16) sb_set(x, i = 1:6, rp = 8.5) # 8.5 coerced to 8, because `x` is of type `integer` #> Warning: Type of R (double) is larger than X (integer) and thus coerced. This incurs loss of information, such as digits of real numbers being truncated upon coercion to integer. To avoid this, make sure X has a larger type than R: character > double > integer > logical. print(x) #>  [1]  8  8  8  8  8  8  7  8  9 10 11 12 13 14 15 16 #> mutable_atomic  #> typeof:  integer   #############################################################################  # Coercion examples - data.table - whole columns ====  # sb_mod(): obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb_mod(   obj, vars = is.numeric,   tf = sqrt # SAFE: row=NULL & filter = NULL, so coercion performed ) #>            a      b        c      d #>        <num> <char>    <num> <fctr> #>  1: 1.000000      a 3.316625      a #>  2: 1.414214      b 3.464102      b #>  3: 1.732051      c 3.605551      c #>  4: 2.000000      d 3.741657      d #>  5: 2.236068      e 3.872983      e #>  6: 2.449490      f 4.000000      f #>  7: 2.645751      g 4.123106      g #>  8: 2.828427      h 4.242641      h #>  9: 3.000000      i 4.358899      i #> 10: 3.162278      j 4.472136      j  # sb_set(): sb_set(   obj, vars = is.numeric,   tf = sqrt # SAFE: row=NULL & filter = NULL, so coercion performed ) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 1.41 1.73 2 2.24 ... #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  3.32 3.46 3.61 3.74 3.87 ... #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>   #############################################################################   # Coercion examples - data.table - partial columns ====  # sb_mod(): obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>   sb_mod(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt   # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost )  #> Warning: 1.414214 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 1 named 'a') #> Warning: 3.464102 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 3 named 'c') #>         a      b     c      d #>     <int> <char> <int> <fctr> #>  1:     1      a    11      a #>  2:     1      b     3      b #>  3:     1      c     3      c #>  4:     2      d     3      d #>  5:     2      e     3      e #>  6:     2      f     4      f #>  7:     2      g     4      g #>  8:     8      h    18      h #>  9:     9      i    19      i #> 10:    10      j    20      j sb_mod(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   coe = as.double, tf = sqrt # SAFE: coercion performed ) #>             a      b         c      d #>         <num> <char>     <num> <fctr> #>  1:  1.000000      a 11.000000      a #>  2:  1.414214      b  3.464102      b #>  3:  1.732051      c  3.605551      c #>  4:  2.000000      d  3.741657      d #>  5:  2.236068      e  3.872983      e #>  6:  2.449490      f  4.000000      f #>  7:  2.645751      g  4.123106      g #>  8:  8.000000      h 18.000000      h #>  9:  9.000000      i 19.000000      i #> 10: 10.000000      j 20.000000      j  # sb_set(): obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb_set(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt   # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost ) #> Warning: 1.414214 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 1 named 'a') #> Warning: 3.464102 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 3 named 'c') print(obj) #>         a      b     c      d #>     <int> <char> <int> <fctr> #>  1:     1      a    11      a #>  2:     1      b     3      b #>  3:     1      c     3      c #>  4:     2      d     3      d #>  5:     2      e     3      e #>  6:     2      f     4      f #>  7:     2      g     4      g #>  8:     8      h    18      h #>  9:     9      i    19      i #> 10:    10      j    20      j  obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  obj <- sb_coe(obj, vars = is.numeric, v = as.numeric) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb_set(obj,   filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # SAFE: coercion performed by sb_coe(); so no warnings )  print(obj) #>             a      b         c      d #>         <num> <char>     <num> <fctr> #>  1:  1.000000      a 11.000000      a #>  2:  1.414214      b  3.464102      b #>  3:  1.732051      c  3.605551      c #>  4:  2.000000      d  3.741657      d #>  5:  2.236068      e  3.872983      e #>  6:  2.449490      f  4.000000      f #>  7:  2.645751      g  4.123106      g #>  8:  8.000000      h 18.000000      h #>  9:  9.000000      i 19.000000      i #> 10: 10.000000      j 20.000000      j  #############################################################################  # View of List ====  x <- list(  a = data.table::data.table(cola = 1:10, colb = letters[1:10]),  b = data.table::data.table(cola = 11:20, colb = letters[11:20]) ) print(x) #> $a #>      cola   colb #>     <int> <char> #>  1:     1      a #>  2:     2      b #>  3:     3      c #>  4:     4      d #>  5:     5      e #>  6:     6      f #>  7:     7      g #>  8:     8      h #>  9:     9      i #> 10:    10      j #>  #> $b #>      cola   colb #>     <int> <char> #>  1:    11      k #>  2:    12      l #>  3:    13      m #>  4:    14      n #>  5:    15      o #>  6:    16      p #>  7:    17      q #>  8:    18      r #>  9:    19      s #> 10:    20      t #>  mypointer <- x$a address(mypointer) == address(x$a) # they are the same #> [1] TRUE sb_set(mypointer, col = \"cola\", tf = \\(x)x^2) print(x) # notice x has been changed #> $a #>      cola   colb #>     <num> <char> #>  1:     1      a #>  2:     4      b #>  3:     9      c #>  4:    16      d #>  5:    25      e #>  6:    36      f #>  7:    49      g #>  8:    64      h #>  9:    81      i #> 10:   100      j #>  #> $b #>      cola   colb #>     <int> <char> #>  1:    11      k #>  2:    12      l #>  3:    13      m #>  4:    14      n #>  5:    15      o #>  6:    16      p #>  7:    17      q #>  8:    18      r #>  9:    19      s #> 10:    20      t #>"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":null,"dir":"Reference","previous_headings":"","what":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"6 types arguments can used generic methods 'squarebrackets' specify indices perform operations : : specify flat (.e. dimensionless) indices. row, col: specify rows /columns tabular objects. idx, dims: specify indices arbitrary dimensions arrays. rcl: specify rows (first dimension), columns (second dimension), layers (third dimension), arrays exactly 3 dimensions. lvl: specify levels, factors . filter, vars: specify rows /columns specifically data.frame-like objects. help page, x refers object sub-setted.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"argument-i","dir":"Reference","previous_headings":"","what":"Argument i","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"following can specified argument : NULL, multi-dimensional objects factors, specifying arguments (.e. dimensional indices factor levels.) vector length 0, case indices selected operation (.e. empty selection). strictly positive integer vector indices. logical vector (without NAs!), length x, giving indices select operation. character vector index names.  object multiple indices given name, corresponding indices selected operation. function takes input x, returns logical vector, giving element indices select operation.  atomic objects, interpreted (x).  lists, interpreted lapply(x, ). Using arguments corresponds something like following:   brief explanation relationship flat indices (), dimension indices (row, col, etc.), see Details section sub2ind.","code":"sb_x(x, i = i) # ==> x[i]"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"arguments-row-col","dir":"Reference","previous_headings":"","what":"Arguments row, col","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"following can specified arguments row / col: NULL (default), corresponds missing argument, results indices dimension selected operation. vector length 0, case indices selected operation (.e. empty selection). strictly positive integer vector dimension indices select operation. logical vector (without NAs!) length corresponding dimension size, giving indices dimension select operation. character vector index names.  object multiple indices given name, corresponding indices selected operation. NOTE: arguments row col ignored specified. Using row, col arguments corresponds something like following:","code":"sb_x(x, row = row, col = col) # ==> x[row, col, drop = FALSE]"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"arguments-idx-dims","dir":"Reference","previous_headings":"","what":"Arguments idx, dims","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"idx must list indices. dims must integer vector length idx, giving dimensions indices given idx correspond .  elements idx follow rules rules row col, EXCEPT one fill NULL.  NOTE: arguments idx dims ignored specified.  keep syntax short, user can use n function instead list() specify idx.  Using idx, dims arguments, corresponds something like following, using example 4-dimensional array:","code":"sb_x(x, n(1:10, 1:5), c(1, 3)) # ==> x[1:10, , 1:5, , drop = FALSE]"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"arguments-rcl","dir":"Reference","previous_headings":"","what":"Arguments rcl","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"rcl argument applicable arrays exactly 3 dimensions.  user knows -priori array 3 dimensions, using rcl efficient using idx, dims arguments.  rcl argument must list exactly 3 elements, first element giving indices first dimension (rows), second element giving indices second dimension (columns), third element giving indices third last dimension (layers); thus rcl stands \"rows, columns, layers\" (.e. 3 dimensions 3-dimensional array).  aforementioned 3 elements list rcl, following can specified: NULL, corresponds missing argument, results indices dimension selected operation. vector length 0, case indices selected operation (.e. empty selection). strictly positive integer vector dimension indices select operation. logical vector (without NAs!) length corresponding dimension size, giving indices dimension select operation. character vector index names.  object multiple indices given name, corresponding indices selected operation. default rcl list simply NULL, used specifying arguments (either idx, dims ).  keep syntax short, user can use n function instead list() specify rcl.  Using rcl argument corresponds something like following:","code":"sb_x(x, rcl = n(NULL, 1:10, 1:5)) # ==> x[, 1:10, 1:5, drop = FALSE]"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"argument-lvl","dir":"Reference","previous_headings":"","what":"Argument lvl","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"argument, names levels x can given, selecting corresponding indices operation.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"arguments-filter-vars","dir":"Reference","previous_headings":"","what":"Arguments filter, vars","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"filter must one-sided formula single logical expression using column names data.frame, giving condition observation/row indices selected operation.  example, perform operation rows column height > 2 column sex != \"female\", specify following formula:   formula linked environment, variables found data set searched environment.  See also tinycodet::form conveniently creating formulas without environments, thus reducing possibility memory leaks. vars must function returns logical vector, giving column indices select operation.  example, select numeric columns, specify vars = .numeric.","code":"~ (height > 2) & (sex != \"female\")"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"duplicates-for-names-integers-and-levels-","dir":"Reference","previous_headings":"","what":"Duplicates (for Names, Integers, and Levels)","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"Generally speaking, duplicate names, integers, levels allowed index selection.  exception sb_x method, method can used duplicating indices.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"out-of-bounds-integers-and-unknown-names-levels","dir":"Reference","previous_headings":"","what":"Out-of-Bounds Integers and Unknown Names/Levels","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"Integers bounds always give error.  Specifying unknown names/levels considered form zero-length indexing.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"disallowed-combinations-of-index-arguments","dir":"Reference","previous_headings":"","what":"Disallowed Combinations of Index Arguments","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"One specify  indexing arguments simultaneously; either , arguments.  arguments  evaluated following order: Argument Argument lvl (factors) argument rcl (3-dimensional arrays) rest indexing arguments. One specify row filter simultaneously. either one . Similarly, one specify col vars simultaneously.  cases holds one set specified, set ignored.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"drop","dir":"Reference","previous_headings":"","what":"Drop","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"Sub-setting generic methods 'squarebrackets' R-package using dimensional arguments (row, col, lyr, idx, dims, filter, vars) always use drop = FALSE.  drop potentially redundant (.e. single level) dimensions, use drop function, like :","code":"sb_x(x, row = row, col = col) |> drop() # ==> x[row, col, drop = TRUE]"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"first-last-and-shuffle","dir":"Reference","previous_headings":"","what":"First, Last, and Shuffle","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"indices counted forward. .e. 1 first element, last.  One can use last function get last N indices.  One can use first function get first N indices.  shuffle elements indices, use sample function.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa4_squarebrackets_duplicates.html","id":null,"dir":"Reference","previous_headings":"","what":"On Duplicates — aaa4_squarebrackets_duplicates","title":"On Duplicates — aaa4_squarebrackets_duplicates","text":"sb_x method method providing duplicate indices actually make sense.  methods, make sense.  Giving duplicate indices usually break anything; however, replacing/transforming removing subsets, almost certainly intention provide duplicate indices.  Providing duplicate indices anyway might lead unexpected results.  Therefore, methods giving duplicate indices make sense, chkdup argument present.  argument controls whether method question checks duplicates (TRUE) (FALSE).  default, chkdup = TRUE, means method question check duplicate indices, give error finds .  Setting chkdup = FALSE disable checks, saves time computation power, thus efficient.  Checking duplicates, expensive, sake user-friendliness, default chkdup = TRUE.  optimal performance, please set chkdup = FALSE.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa5_squarebrackets_PassByReference.html","id":null,"dir":"Reference","previous_headings":"","what":"Regarding Modification By Reference — aaa5_squarebrackets_PassByReference","title":"Regarding Modification By Reference — aaa5_squarebrackets_PassByReference","text":"help page describes modification using \"pass--reference\" semantics handled 'squarebrackets' package.  main advantage pass--reference much less memory required modify objects.  least 2 things taken consideration modifying object reference.  First, coercion rules slightly different: see squarebrackets_mutable_classes.  Second, 2 variables refer exactly object, changing one variable also changes ones.  .e. following code,   modifies just x, also y.  true even one variables locked (see bindingIsLocked).  .e. following code,   modifies x y without error, even though y locked constant.","code":"x <- y <- 1:16 sb_set(x, i = 1:6, rp = 8) tinycodet::import_LL(\"tinycodet\", \"%<-c%\") x <- 1:16 y %<-c% x sb_set(x, i = 1:6, rp = 8)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa5_squarebrackets_PassByReference.html","id":"mutable-vs-immutable-types","dir":"Reference","previous_headings":"","what":"Mutable vs Immutable types","title":"Regarding Modification By Reference — aaa5_squarebrackets_PassByReference","text":"exception environments, base R's data types treated immutable:  Modifying object 'R' make copy object, something called 'copy--modify' semantics.  However, almost base R's datatypes can modified reference, R's 'C' API, 'C++' code (like via 'Rcpp'), thus treating objects mutable, even though \"supposed\" mutable.  Modifying base 'R' object reference can problematic.  Since 'R', also R-packages, treat objects immutable, modifying -mutable may produce undesired results.  prevent issue described , 'squarebrackets' supports pass--reference semantics objects actually supposed mutable.  relation restriction, 'squarebrackets' adds new class objects, mutable_atomic, simply atomic objects permission modified reference.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa5_squarebrackets_PassByReference.html","id":"lock-binding","dir":"Reference","previous_headings":"","what":"Lock Binding","title":"Regarding Modification By Reference — aaa5_squarebrackets_PassByReference","text":"lockBinding function locks binding object, preventing modification.  'R' also uses locked bindings prevent modification objects package namespaces.  pass--reference semantics 'squarebrackets' principle respect , disallows modification objects reference.  However, lockBinding lock address/pointer object, one particular binding object.  problematic; consider following example:   code, x y share address, thus pointing memory, yet y actually locked.  Since x locked, modifying x allowed.  since sb_set() performs modification reference, y STILL modified, despite locked.  remedy issue explained , 'squarebrackets' provides sb_currentBindings method.  method can multiple things. One look address object x, find currently existing bindings caller environment sharing address x, locking bindings.  Warning:  sb_currentBindings method locks currently existing bindings caller environment;  bindings created calling sb_currentBindings automatically locked.  Thus, every time user creates new binding object, user wishes locked, sb_currentBindings must called .","code":"tinycodet::import_LL(\"tinycodet\", \"%<-c%\") x <- 1:16 y %<-c% x sb_set(x, i = 1:6, rp = 8)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa5_squarebrackets_PassByReference.html","id":"protected-addresses","dir":"Reference","previous_headings":"","what":"Protected Addresses","title":"Regarding Modification By Reference — aaa5_squarebrackets_PassByReference","text":"prevent accidental pass--reference modification objects base environment, addresses exported objects base environment (baseenv) stored option squarebrackets.protected whenever 'squarebrackets' loaded, either directly indirectly.  Needless say, user never touch option.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa5_squarebrackets_PassByReference.html","id":"input-variable","dir":"Reference","previous_headings":"","what":"Input Variable","title":"Regarding Modification By Reference — aaa5_squarebrackets_PassByReference","text":"Methods/functions perform -place modification reference can thought similar functions style some_function(x, ...) <- value, sense variable must actually exist actual variable.  Thus things like following, sb_set(1:10, ...), sb_set(x$, ...), sb_set(base::letters), work.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa5_squarebrackets_PassByReference.html","id":"views-of-lists","dir":"Reference","previous_headings":"","what":"Views of Lists","title":"Regarding Modification By Reference — aaa5_squarebrackets_PassByReference","text":"Regular lists treated mutable objects 'squarebrackets'.  However, lists actually really objects, merely (potentially hierarchical) structure pointers.  Thus, even list treated mutable, subsets list mutable classes, mutable.  example, list data.table objects, data.tables mutable.  Therefore, following work:   Notice code mypointer copy x$, since address.  Thus changing mypointer also changes x$.  words: mypointer called \"view\" x$.","code":"x <- list(  a = data.table(cola = 1:10, colb = letters[1:10]),  b = data.table(cola = 11:20, colb = letters[11:20]) ) mypointer <- x$a sb_set(mypointer, col = \"cola\", tf = \\(x)x^2)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa5_squarebrackets_PassByReference.html","id":"protection","dir":"Reference","previous_headings":"","what":"Protection","title":"Regarding Modification By Reference — aaa5_squarebrackets_PassByReference","text":"Due properties given help page far, something like following work:   work : base objects disallowed; immutable objects disallowed (create mutable object, create copy original, thus keeping original object safe modification reference); locked bindings disallowed. Despite checks made package, user never actively try modify locked protected object reference, defeat purpose locking object.","code":"# letters = base::letters sb_set(letters, i = 1, rp = \"XXX\")"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa5_squarebrackets_PassByReference.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Regarding Modification By Reference — aaa5_squarebrackets_PassByReference","text":"","code":"# the following code demonstrates how locked bindings, # such as `base::letters`, # are being safe-guarded  x <- list(a = base::letters) mypointer <- x$a # view of a list address(mypointer) == address(base::letters) # TRUE: point to the same memory #> [1] TRUE bindingIsLocked(\"letters\", baseenv()) # base::letters is locked ... #> [1] TRUE bindingIsLocked(\"mypointer\", environment()) # ... but this pointer is not! #> [1] FALSE  if(requireNamespace(\"tinytest\")) {   tinytest::expect_error(     sb_set(mypointer, i = 1, rp = \"XXX\") # this still gives an error though ...   ) } #> Loading required namespace: tinytest #> ----- PASSED      : <--> #>  call| eval(expr, envir, enclos)   is.mutable_atomic(mypointer) # ... because it's not of class `mutable_atomic` #> [1] FALSE   x <- list(   a = as.mutable_atomic(base::letters) # `as.mutable_atomic()` makes a copy ) mypointer <- x$a # view of a list address(mypointer) == address(base::letters) # FALSE: it's a copy #> [1] FALSE sb_set(   mypointer, i = 1, rp = \"XXX\"  # modifies x, does NOT modify `base::letters` ) print(x) # x is modified #> $a #>  [1] \"XXX\" \"b\"   \"c\"   \"d\"   \"e\"   \"f\"   \"g\"   \"h\"   \"i\"   \"j\"   \"k\"   \"l\"   #> [13] \"m\"   \"n\"   \"o\"   \"p\"   \"q\"   \"r\"   \"s\"   \"t\"   \"u\"   \"v\"   \"w\"   \"x\"   #> [25] \"y\"   \"z\"   #> mutable_atomic  #> typeof:  character  #>  base::letters # but this still the same #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" #> [20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"  # Word of warning: # the safe-guard in 'squarebrackets' is good, but definitely not perfect. # Do not actively try to break things; you might actually succeed."},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa6_squarebrackets_technical.html","id":null,"dir":"Reference","previous_headings":"","what":"Additional Technical Details — aaa6_squarebrackets_technical","title":"Additional Technical Details — aaa6_squarebrackets_technical","text":"Atomic  atomic vector basic class type.  Matrices Arrays just atomic vectors dimension attributes.  elements atomic vector class must atomic type (\"logical\", \"integer\", \"numeric\", \"complex\", \"character\" \"raw\").  Therefore, sb_coe method coerce entirety atomic vector, just subset . Factor  Factors property can store values defined \"levels\" attribute; values allowed, thus result NAs.  Thus sb_mod coerce replacement values factors! quite different atomic vector classes, can store infinite variety values (provided atomic type).  Due properties, sb_set() method factors. List  Lists recursive objects (.e. can nested), actually store values rather store reference objects.  Therefore sb_rec method can used access recursive subsets list, matter deep/low hierarchy list. Data.frame-like  data.frame-like objects quite different previously named classes.  different data.frame-like classes also differ quite bit - especially terms sub-setting.  'squarebrackets' R-package attempts keep data.frame methods class agnostic possible, class agnostic functionality 'collapse' 'data.table' R-packages.  3 things cause important oddities data.frame-like classes treated differently classes: Whole-columns auto-coerced replaced/transformed sb_mod(), partial columns auto-coerced. sb_x sb_rm methods always automatically conserve attributes (though names adjusted accordingly, course), never stripped, unlike classes. Giving data.frame-like object non-unique column names sb_-methods returns error. Also, duplicating columns sb_x automatically adjust column names make unique.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/class_mutable_atomic.html","id":null,"dir":"Reference","previous_headings":"","what":"Mutable Atomic Classes — class_mutable_atomic","title":"Mutable Atomic Classes — class_mutable_atomic","text":"mutable_atomic class mutable version atomic classes.  works exactly aspects regular atomic classes, one real difference: sb_set accepts mutable_atomic, accept regular atomic.  See squarebrackets_PassByReference details.  Like data.table, [<- performs R's default copy--modification semantics.  modification  reference, use sb_set.  .mutable_atomic() function checks object atomic.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/class_mutable_atomic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mutable Atomic Classes — class_mutable_atomic","text":"","code":"mutable_atomic(data, names = NULL, dim = NULL, dimnames = NULL)  as.mutable_atomic(x, ...)  is.mutable_atomic(x)  # S3 method for mutable_atomic [(x, ...)  # S3 method for mutable_atomic [(x, ...) <- value  # S3 method for mutable_atomic format(x, ...)  # S3 method for mutable_atomic print(x, ...)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/class_mutable_atomic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mutable Atomic Classes — class_mutable_atomic","text":"data atomic vector giving data fill mutable_atomic object. names, dim, dimnames see setNames array. x atomic object. ... method dependent arguments. value see Extract.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/class_mutable_atomic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mutable Atomic Classes — class_mutable_atomic","text":".mutable_atomic converts atomic object (vector, matrix, array) object, additional class \"mutable_atomic\", additional attribute \"typeof\".  .mutable_atomic returns TRUE object atomic, class \"mutable_atomic\", correctly set attribute \"typeof\"; .mutable_atomic returns FALSE otherwise.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/class_mutable_atomic.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"Mutable Atomic Classes — class_mutable_atomic","text":"Always use mutable_atomic() .mutable_atomic create mutable object.  attempt manually create mutable atomic object tweaking attributes: mutable_atomic() .mutable_atomic make necessary checks functions, sb_set, spend computation time perform checks also.  Circumventing checks may break things.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/class_mutable_atomic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mutable Atomic Classes — class_mutable_atomic","text":"","code":"x <- mutable_atomic(   1:20, dim = c(5, 4), dimnames = list(letters[1:5], letters[1:4]) ) x #>   a  b  c  d #> a 1  6 11 16 #> b 2  7 12 17 #> c 3  8 13 18 #> d 4  9 14 19 #> e 5 10 15 20 #> mutable_atomic  #> typeof:  integer   x <- matrix(1:10, ncol = 2) x <- as.mutable_atomic(x) is.mutable_atomic(x) #> [1] TRUE print(x) #>      [,1] [,2] #> [1,]    1    6 #> [2,]    2    7 #> [3,]    3    8 #> [4,]    4    9 #> [5,]    5   10 #> mutable_atomic  #> typeof:  integer  x[, 1] #> [1] 1 2 3 4 5 #> mutable_atomic  #> typeof:  integer  x[] <- as.double(x) # notifies the user a copy is being made #> copying on modification; for modification by reference, use `sb_set()` print(x) # \"typeof\" attribute adjusted accordingly, and class still present #>      [,1] [,2] #> [1,]    1    6 #> [2,]    2    7 #> [3,]    3    8 #> [4,]    4    9 #> [5,]    5   10 #> mutable_atomic  #> typeof:  double"},{"path":"https://tony-aw.github.io/squarebrackets/reference/dt.html","id":null,"dir":"Reference","previous_headings":"","what":"Functional forms of data.table Operations (also work on tidytables) — dt","title":"Functional forms of data.table Operations (also work on tidytables) — dt","text":"Functional forms special data.table operations - programmatically friendly (Non-Standard Evaluation). dt_aggregate() aggregates data.table tidytable, returns aggregated copy. dt_setcoe() coercively transforms columns data.table tidytable using pass--reference semantics.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/dt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functional forms of data.table Operations (also work on tidytables) — dt","text":"","code":"dt_aggregate(x, SDcols = NULL, f, by, order_by = FALSE)  dt_setcoe(x, col = NULL, vars = NULL, f, chkdup = TRUE)  dt_setrm(x, col = NULL, vars = NULL, chkdup = TRUE)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/dt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functional forms of data.table Operations (also work on tidytables) — dt","text":"x data.table tidytable. SDcols atomic vector, giving columns aggregation function f() applied . f aggregation function atomic vector, giving grouping columns. order_by logical (TRUE FALSE), indicating aggregated result ordered columns specified . col, vars columns select coercion; see squarebrackets_indx_args.  Duplicates allowed. chkdup see squarebrackets_duplicates.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/dt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functional forms of data.table Operations (also work on tidytables) — dt","text":"dt_aggregate(): aggregated data.table object.  rest functions: Returns: VOID. functions modify object reference. use assignment like x <- dt_setcoe(x, ...). Since functions return void, just get NULL.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/dt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functional forms of data.table Operations (also work on tidytables) — dt","text":"","code":"requireNamespace(\"sf\")   # dt_aggregate on sf-data.table ====  x <- sf::st_read(system.file(\"shape/nc.shp\", package = \"sf\")) #> Reading layer `nc' from data source `D:\\Programs\\R-4.3.2\\library\\sf\\shape\\nc.shp' using driver `ESRI Shapefile' #> Simple feature collection with 100 features and 14 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 #> Geodetic CRS:  NAD27 x <- data.table::as.data.table(x)  x$region <- ifelse(x$CNTY_ID <= 2000, 'high', 'low') d.aggr <- dt_aggregate(   x, SDcols = \"geometry\", f= sf::st_union, by = \"region\" )  head(d.aggr) #>    region                       geometry #>    <char>             <sfc_MULTIPOLYGON> #> 1:   high MULTIPOLYGON (((-75.78317 3... #> 2:    low MULTIPOLYGON (((-76.46926 3...   #############################################################################   # dt_setcoe ====  obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb_set(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost ) #> Warning: 1.414214 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 1 named 'a') #> Warning: 3.464102 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 3 named 'c') str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 1 1 2 2 2 2 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 3 3 3 3 4 4 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) dt_setcoe(obj, vars = is.numeric, f = as.numeric) # integers are now numeric str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb_set(obj,   filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # SAFE: coercion performed; so no warnings )  str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 1.41 1.73 2 2.24 ... #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  11 3.46 3.61 3.74 3.87 ... #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>     #############################################################################   # dt_setrm ====  obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  dt_setrm(obj, col = 1) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  3 variables: #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>   obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  dt_setrm(obj, vars = is.numeric) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  2 variables: #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>"},{"path":"https://tony-aw.github.io/squarebrackets/reference/exported_uilities.html","id":null,"dir":"Reference","previous_headings":"","what":"Exported Utilities — indx_x","title":"Exported Utilities — indx_x","text":"Exported utilities","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/exported_uilities.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exported Utilities — indx_x","text":"","code":"indx_x(i, x, xnames, xsize)  indx_rm(i, x, xnames, xsize)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/exported_uilities.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exported Utilities — indx_x","text":"See squarebrackets_indx_args. x vector, vector-like object, factor, data.frame, data.frame-like object, list. xnames names dimension names xsize length dimension size","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/exported_uilities.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exported Utilities — indx_x","text":"subsetted object.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/exported_uilities.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Exported Utilities — indx_x","text":"","code":"x <- 1:10 names(x) <- letters[1:10] indx_x(1:5, x, names(x), length(x)) #> [1] 1 2 3 4 5 indx_rm(1:5, x, names(x), length(x)) #> [1]  6  7  8  9 10"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_by.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Grouped Indices — idx_by","title":"Compute Grouped Indices — idx_by","text":"Given: sub-set function f; complete range indices r object x; grouping factor grp; idx_by() function takes indices f(r) per group grp.  result idx_by() can supplied indexing arguments (see squarebrackets_indx_args) : sb_x, sb_rm, sb_mod, sb_set, sb_coe,  perform grouped subset operations.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_by.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Grouped Indices — idx_by","text":"","code":"idx_by(f, r, grp, parallel = FALSE, mc.cores = 1L)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_by.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Grouped Indices — idx_by","text":"f subset function applied per group r.  function must accept character integer vector input, produce character integer vector output.  example, subset last element per group, specify: f = last r integer character vector, giving complete range indices object.  example: colnames(x), 1:nrow(x), etc. grp factor giving groups. Make sure order corresponds r, otherwise makes sense. parallel, mc.cores see .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_by.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Grouped Indices — idx_by","text":"vector indices type r.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_by.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Grouped Indices — idx_by","text":"","code":"# vectors ==== (a <- 1:20) #>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 (grp <- factor(rep(letters[1:5], each = 4))) #>  [1] a a a a b b b b c c c c d d d d e e e e #> Levels: a b c d e  # get the last element of `a` for each group in `grp`: i <- idx_by(last, seq_along(a), grp) sb_x(cbind(a, grp), row = i) #>       a grp #> [1,]  4   1 #> [2,]  8   2 #> [3,] 12   3 #> [4,] 16   4 #> [5,] 20   5   # data.frame ==== x <- data.frame(   a = sample(1:20),   b = letters[1:20],   group = factor(rep(letters[1:5], each = 4)) ) print(x) #>     a b group #> 1   6 a     a #> 2  17 b     a #> 3  18 c     a #> 4  16 d     a #> 5   3 e     b #> 6   1 f     b #> 7  14 g     b #> 8  15 h     b #> 9   4 i     c #> 10 10 j     c #> 11 13 k     c #> 12 19 l     c #> 13  2 m     d #> 14  7 n     d #> 15  9 o     d #> 16  5 p     d #> 17 11 q     e #> 18 20 r     e #> 19 12 s     e #> 20  8 t     e # get the first row for each group in data.frame `x`: row <- idx_by(first, 1:nrow(x), x$group) sb_x(x, row) #>    a b group #> 1  6 a     a #> 2  3 e     b #> 3  4 i     c #> 4  2 m     d #> 5 11 q     e # get the first row for each group for which a > 10: x2 <- sb_x(x, filter = ~ a > 10) row <- na.omit(idx_by(first, 1:nrow(x2), x2$group)) sb_x(x2, row) #>    a b group #> 1 17 b     a #> 2 14 g     b #> 3 13 k     c #> 4 11 q     e"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_ord.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Ordered Indices — idx_ord_v","title":"Compute Ordered Indices — idx_ord_v","text":"Computes ordered indices. Similar order, except user must supply vector, list equal-length vectors, data.frame matrix (row-wise column-wise supported), input.  vector x, idx_ord_v(x) equivalent order(x).  data.frame list equal-length vectors x, p columns/elements, idx_ord_df(x) equivalent order(x[[1]], ..., x[[p]]).  matrix (array) x p rows, idx_ord_m(x, margin = 1) equivalent order(x[1, ], ..., x[p, ], ...).  matrix (array) x p columns, idx_ord_m(x, margin = 2) equivalent order(x[, 1], ..., x[, p], ...).  Note merely convenience functions, actually slightly slower order (except idx_ord_v()), due additional functionality.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_ord.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Ordered Indices — idx_ord_v","text":"","code":"idx_ord_v(   x,   na.last = TRUE,   decr = FALSE,   method = c(\"auto\", \"shell\", \"radix\") )  idx_ord_m(   x,   margin,   na.last = TRUE,   decr = FALSE,   method = c(\"auto\", \"shell\", \"radix\") )  idx_ord_df(   x,   na.last = TRUE,   decr = FALSE,   method = c(\"auto\", \"shell\", \"radix\") )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_ord.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Ordered Indices — idx_ord_v","text":"x vector, data.frame, array na.last, method see order sort. decr see argument decreasing order margin margin cut matrix/array vectors.  .e. margin = 1 cut x individual rows, apply order rows.  margin = 2 cut x columns, etc.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_ord.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Ordered Indices — idx_ord_v","text":"See order.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_ord.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Ordered Indices — idx_ord_v","text":"","code":"x <- sample(1:10) order(x) #>  [1]  8  7  9  6  1  2  4  3 10  5 idx_ord_v(x) #>  [1]  8  7  9  6  1  2  4  3 10  5 idx_ord_m(rbind(x, x), 1) #>  [1]  8  7  9  6  1  2  4  3 10  5 idx_ord_m(cbind(x, x), 2) #>  [1]  8  7  9  6  1  2  4  3 10  5 idx_ord_df(data.frame(x, x)) #>  [1]  8  7  9  6  1  2  4  3 10  5"},{"path":"https://tony-aw.github.io/squarebrackets/reference/match_all.html","id":null,"dir":"Reference","previous_headings":"","what":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","title":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","text":"Find indices vector haystack equal vector needles, taking account order vectors, duplicate values.  essentially much efficient version :   Like lapply(needles, \\() (haystack == )), NAs ignored.  Core code based suggestion Sebastian Kranz (author 'collapse' package).","code":"lapply(needles, \\(i) which(haystack == i))"},{"path":"https://tony-aw.github.io/squarebrackets/reference/match_all.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","text":"","code":"match_all(needles, haystack, unlist = TRUE)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/match_all.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","text":"needles, haystack vectors unlist logical, indicating result vector (TRUE, default), list (FALSE).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/match_all.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","text":"integer vector, list integer vector. list, element list corresponds value needles. needles /haystack /empty fully NA, match_all() returns empty integer vector (unlist = TRUe), empty list (unlist = FALSE).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/match_all.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","text":"","code":"n <- 200 haystack <- sample(letters, n, TRUE) needles <- sample(letters, n/2, TRUE) indices1 <- match_all(needles, haystack) head(indices1) #> [1]  18  47  86 144  41  43"},{"path":"https://tony-aw.github.io/squarebrackets/reference/nest.html","id":null,"dir":"Reference","previous_headings":"","what":"Nest — n","title":"Nest — n","text":"c() function concatenates vectors lists vector (possible) else list.  analogy function, n() function nests objects list (atomic vector, atomic vectors nested).  short-hand version list function.  handy lists often needed 'squarebrackets', especially arrays.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/nest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nest — n","text":"","code":"n()"},{"path":"https://tony-aw.github.io/squarebrackets/reference/nest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nest — n","text":"list.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/nest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Nest — n","text":"","code":"obj <- array(1:64, c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  sb_x(obj, n(1:3, 1:2), c(1,3)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #>  # above is equivalent to obj[1:3, , 1:2, drop = FALSE]"},{"path":"https://tony-aw.github.io/squarebrackets/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. data.table address, copy, first, last","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_coe.html","id":null,"dir":"Reference","previous_headings":"","what":"Method to Coerce and Transform (Recursive Subsets of) an Object — sb_coe","title":"Method to Coerce and Transform (Recursive Subsets of) an Object — sb_coe","text":"S3 Method completely transform (recursive subsets ) object explicit coercion.  Given coercing function v(), following can stated method. (1) atomic objects (vectors, matrices, arrays), method equivalent :   (2) factors, method equivalent :   (3) lists, one multiple elements specified argument , method equivalent :   (4) data.frame-like objects, one multiple columns specified argument col, method equivalent :   Note x data.table, one can coercively transform columns reference (memory efficient), using dt_setcoe.","code":"x[] <- v(x) x <- v(x) \\(x, i) { x[i] <- lapply(x[i], v); return(x) } collapse::ftransformv(x, col, v)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_coe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method to Coerce and Transform (Recursive Subsets of) an Object — sb_coe","text":"","code":"sb_coe(x, ...)  # S3 method for default sb_coe(x, v, ...)  # S3 method for factor sb_coe(x, v, ...)  # S3 method for list sb_coe(x, i, v, ...)  # S3 method for data.frame sb_coe(x, col = NULL, vars = NULL, v, ...)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_coe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method to Coerce and Transform (Recursive Subsets of) an Object — sb_coe","text":"x see squarebrackets_immutable_classes squarebrackets_mutable_classes. ... arguments passed methods. v coercive transformation function use. , col, vars See squarebrackets_indx_args.  empty index selection returns original object unchanged.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_coe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Method to Coerce and Transform (Recursive Subsets of) an Object — sb_coe","text":"copy coercively transformed object.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_coe.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Method to Coerce and Transform (Recursive Subsets of) an Object — sb_coe","text":"replacing values reference, (recursive subset ) object never coerced, requires making deep copy; instead, replacement value coerced.  example:  Using sb_set() replacing/transform one values integer type (int) mutable_atomic object / data.table column, become 1.5, coerce object column decimal type (dbl); instead, replacement 1.5 coerced integer 1.  reason, sb_coe() method can used coercively transform object replacing transforming values reference.  See also Examples section .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_coe.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Method to Coerce and Transform (Recursive Subsets of) an Object — sb_coe","text":"","code":"obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb_set(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost ) #> Warning: 1.414214 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 1 named 'a') #> Warning: 3.464102 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 3 named 'c') print(obj) #>         a      b     c      d #>     <int> <char> <int> <fctr> #>  1:     1      a    11      a #>  2:     1      b     3      b #>  3:     1      c     3      c #>  4:     2      d     3      d #>  5:     2      e     3      e #>  6:     2      f     4      f #>  7:     2      g     4      g #>  8:     8      h    18      h #>  9:     9      i    19      i #> 10:    10      j    20      j obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) obj <- sb_coe(obj, vars = is.numeric, v = as.numeric) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb_set(obj,   filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # SAFE: coercion performed; so no warnings )  print(obj) #>             a      b         c      d #>         <num> <char>     <num> <fctr> #>  1:  1.000000      a 11.000000      a #>  2:  1.414214      b  3.464102      b #>  3:  1.732051      c  3.605551      c #>  4:  2.000000      d  3.741657      d #>  5:  2.236068      e  3.872983      e #>  6:  2.449490      f  4.000000      f #>  7:  2.645751      g  4.123106      g #>  8:  8.000000      h 18.000000      h #>  9:  9.000000      i 19.000000      i #> 10: 10.000000      j 20.000000      j"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_currentBindings.html","id":null,"dir":"Reference","previous_headings":"","what":"List or Lock All Currently Existing Bindings Pointing To Same Address — sb_currentBindings","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — sb_currentBindings","text":"sb_currentBindings(x, action = \"list\")  lists currently existing objects sharing address x, given environment. sb_currentBindings(x, action = \"checklock\")  searches currently existing objects sharing address x, given environment, reports locked locked. sb_currentBindings(x, action = \"lockbindings\")  searches currently existing objects sharing address x, given environment, locks using lockBinding.  See also squarebrackets_PassByReference information regarding relation locked bindings pass--reference modifications.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_currentBindings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — sb_currentBindings","text":"","code":"sb_currentBindings(x, action = \"list\", env = NULL)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_currentBindings.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — sb_currentBindings","text":"x existing variable whose address use searching bindings. action single string, giving action perform.  Must one following: \"list\" (default). \"checklock\". \"lockbindings\". env environment look objects.  NULL (default), caller environment used.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_currentBindings.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — sb_currentBindings","text":"sb_currentBindings(x, action = \"list\"): Returns character vector.  sb_currentBindings(x, action = \"checklock\"): Returns named logical vector. names give names bindings, associated value indicates whether binding locked (TRUE) locked (FALSE).  sb_currentBindings(x, action = \"lockbindings\"): Returns VOID. just locks currently existing bindings. unlock bindings, remove objects (see rm).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_currentBindings.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — sb_currentBindings","text":"","code":"x <- as.mutable_atomic(1:10) y <- x lockBinding(\"y\", environment()) sb_currentBindings(x) #> searching environment: <000001bd32dfb0d8> #> [1] \"x\" \"y\" sb_currentBindings(x, \"checklock\") # only y is locked #> searching environment: <000001bd32dfb0d8> #>     x     y  #> FALSE  TRUE    # since only y is locked, we can still modify y through x by reference: sb_set(x, i = 1, rp = -1) print(y) # modified! #>  [1] -1  2  3  4  5  6  7  8  9 10 #> mutable_atomic  #> typeof:  integer  rm(list= c(\"y\")) # clean up   # one can fix this by locking ALL bindings: y <- x sb_currentBindings(x, \"lockbindings\") # lock all #> searching environment: <000001bd32dfb0d8> sb_currentBindings(x, \"checklock\") # all bindings are locked, including y #> searching environment: <000001bd32dfb0d8> #>    x    y  #> TRUE TRUE  # the 'squarebrackets' package respects the lock of a binding, # provided all bindings of an address are locked; # so this will give an error, as it should:  if(requireNamespace(\"tinytest\")) {   tinytest::expect_error(     sb_set(x, i = 1, rp = -1),     pattern = \"object is locked\"   ) } #> ----- PASSED      : <--> #>  call| eval(expr, envir, enclos)   # creating a new variable will NOT automatically be locked: z <- y # new variable; will not be locked! sb_currentBindings(x, \"checklock\") # z is not locked #> searching environment: <000001bd32dfb0d8> #>     x     y     z  #>  TRUE  TRUE FALSE  sb_currentBindings(x, \"lockbindings\") # we must re-run this #> searching environment: <000001bd32dfb0d8> sb_currentBindings(x, \"checklock\") # now z is also locked #> searching environment: <000001bd32dfb0d8> #>    x    y    z  #> TRUE TRUE TRUE   if(requireNamespace(\"tinytest\")) {   tinytest::expect_error( # now z is also protected     sb_set(z, i = 1, rp = -1),     pattern = \"object is locked\"   ) } #> ----- PASSED      : <--> #>  call| eval(expr, envir, enclos)    rm(list= c(\"x\", \"y\", \"z\")) # clean up"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_in.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods to Insert New Values Before or After an Index Along a Dimension — sb_before","title":"Methods to Insert New Values Before or After an Index Along a Dimension — sb_before","text":"sb_before() method inserts new values position along dimension.  sb_after() method inserts new values position along dimension.  functions use modified version abind::abind (see reference ).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_in.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods to Insert New Values Before or After an Index Along a Dimension — sb_before","text":"","code":"sb_before(x, ...)  sb_after(x, ...)  # S3 method for default sb_before(x, new, pos = 1, .attr = NULL, ...)  # S3 method for default sb_after(x, new, pos = length(x), .attr = NULL, ...)  # S3 method for array sb_before(x, new, margin, pos = 1, .attr = NULL, ...)  # S3 method for array sb_after(x, new, margin, pos = dim(x)[margin], .attr = NULL, ...)  # S3 method for factor sb_before(x, new, pos = 1, .attr = NULL, ...)  # S3 method for factor sb_after(x, new, pos = length(x), .attr = NULL, ...)  # S3 method for list sb_before(x, new, pos = 1, .attr = NULL, ...)  # S3 method for list sb_after(x, new, pos = length(x), .attr = NULL, ...)  # S3 method for data.frame sb_before(x, new, margin, pos = 1, .attr = NULL, ...)  # S3 method for data.frame sb_after(x, new, margin, pos = collapse::fdim(x)[margin], .attr = NULL, ...)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_in.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods to Insert New Values Before or After an Index Along a Dimension — sb_before","text":"x see squarebrackets_immutable_classes squarebrackets_mutable_classes. ... arguments passed methods. new new value(s). type object depends x: atomic objects, new can atomic object. However, one wished added values new named, ensure new type object x. example: use matrix column names new appending/inserting columns matrix x. factors, new must factor. lists, new must (possible named) list. data.frame-like objects, new must data.frame. pos strictly positive single integer scalar (duplicates), giving position along dimension (specified margin), new values added. .attr list, giving additional potentially missing attributes added returned object.  default, concatenation strips attributes, since attributes x new may equal even compatible.  attr argument, attributes merged object can specified.  attributes actually missing insertion added, thus preventing overwriting existing attributes like names.  One may, example, specify .attr = sb_a(x) .attr = sb_a(new).  NULL (default), attributes added post-insert.  speed important, NULL best option (attributes preserved). margin single scalar, giving dimension along add new values.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_in.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Methods to Insert New Values Before or After an Index Along a Dimension — sb_before","text":"Returns copy appended object.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_in.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Methods to Insert New Values Before or After an Index Along a Dimension — sb_before","text":"Plate T, Heiberger R (2016). abind: Combine Multidimensional Arrays. R package version 1.4-5, https://CRAN.R-project.org/package=abind.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_in.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Methods to Insert New Values Before or After an Index Along a Dimension — sb_before","text":"","code":"# atomic objects ====  x <- matrix(1:20 , ncol = 4) print(x) #>      [,1] [,2] [,3] [,4] #> [1,]    1    6   11   16 #> [2,]    2    7   12   17 #> [3,]    3    8   13   18 #> [4,]    4    9   14   19 #> [5,]    5   10   15   20 new <- -1 * x sb_before(x, new, 1) #>       [,1] [,2] [,3] [,4] #>  [1,]   -1   -6  -11  -16 #>  [2,]   -2   -7  -12  -17 #>  [3,]   -3   -8  -13  -18 #>  [4,]   -4   -9  -14  -19 #>  [5,]   -5  -10  -15  -20 #>  [6,]    1    6   11   16 #>  [7,]    2    7   12   17 #>  [8,]    3    8   13   18 #>  [9,]    4    9   14   19 #> [10,]    5   10   15   20 sb_before(x, new, 2) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> [1,]   -1   -6  -11  -16    1    6   11   16 #> [2,]   -2   -7  -12  -17    2    7   12   17 #> [3,]   -3   -8  -13  -18    3    8   13   18 #> [4,]   -4   -9  -14  -19    4    9   14   19 #> [5,]   -5  -10  -15  -20    5   10   15   20 sb_after(x, new, 1) #>       [,1] [,2] [,3] [,4] #>  [1,]    1    6   11   16 #>  [2,]    2    7   12   17 #>  [3,]    3    8   13   18 #>  [4,]    4    9   14   19 #>  [5,]    5   10   15   20 #>  [6,]   -1   -6  -11  -16 #>  [7,]   -2   -7  -12  -17 #>  [8,]   -3   -8  -13  -18 #>  [9,]   -4   -9  -14  -19 #> [10,]   -5  -10  -15  -20 sb_after(x, new, 2) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> [1,]    1    6   11   16   -1   -6  -11  -16 #> [2,]    2    7   12   17   -2   -7  -12  -17 #> [3,]    3    8   13   18   -3   -8  -13  -18 #> [4,]    4    9   14   19   -4   -9  -14  -19 #> [5,]    5   10   15   20   -5  -10  -15  -20  #############################################################################   # factors ====  x <- factor(letters) new <- factor(\"foo\") sb_before(x, new) #>  [1] foo a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   #> [20] s   t   u   v   w   x   y   z   #> Levels: foo a b c d e f g h i j k l m n o p q r s t u v w x y z sb_after(x, new) #>  [1] a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   #> [20] t   u   v   w   x   y   z   foo #> Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z foo   #############################################################################   # lists ====  x <- as.list(1:5) new <- lapply(x, \\(x)x*-1) print(x) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 3 #>  #> [[4]] #> [1] 4 #>  #> [[5]] #> [1] 5 #>  sb_before(x, new) #> [[1]] #> [1] -1 #>  #> [[2]] #> [1] -2 #>  #> [[3]] #> [1] -3 #>  #> [[4]] #> [1] -4 #>  #> [[5]] #> [1] -5 #>  #> [[6]] #> [1] 1 #>  #> [[7]] #> [1] 2 #>  #> [[8]] #> [1] 3 #>  #> [[9]] #> [1] 4 #>  #> [[10]] #> [1] 5 #>  sb_after(x, new) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 3 #>  #> [[4]] #> [1] 4 #>  #> [[5]] #> [1] 5 #>  #> [[6]] #> [1] -1 #>  #> [[7]] #> [1] -2 #>  #> [[8]] #> [1] -3 #>  #> [[9]] #> [1] -4 #>  #> [[10]] #> [1] -5 #>    #############################################################################   # data.frame-like objects ====  x <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) new <- data.frame(e = 101:110) sb_before(x, new, 2) #>      e  a b  c d #> 1  101  1 a 11 a #> 2  102  2 b 12 b #> 3  103  3 c 13 c #> 4  104  4 d 14 d #> 5  105  5 e 15 e #> 6  106  6 f 16 f #> 7  107  7 g 17 g #> 8  108  8 h 18 h #> 9  109  9 i 19 i #> 10 110 10 j 20 j sb_after(x, new, 2) #>     a b  c d   e #> 1   1 a 11 a 101 #> 2   2 b 12 b 102 #> 3   3 c 13 c 103 #> 4   4 d 14 d 104 #> 5   5 e 15 e 105 #> 6   6 f 16 f 106 #> 7   7 g 17 g 107 #> 8   8 h 18 h 108 #> 9   9 i 19 i 109 #> 10 10 j 20 j 110 new <- x[1,] sb_before(x, new, 1) #>     a b  c d #> 1   1 a 11 a #> 2   1 a 11 a #> 3   2 b 12 b #> 4   3 c 13 c #> 5   4 d 14 d #> 6   5 e 15 e #> 7   6 f 16 f #> 8   7 g 17 g #> 9   8 h 18 h #> 10  9 i 19 i #> 11 10 j 20 j sb_after(x, new, 1) #>     a b  c d #> 1   1 a 11 a #> 2   2 b 12 b #> 3   3 c 13 c #> 4   4 d 14 d #> 5   5 e 15 e #> 6   6 f 16 f #> 7   7 g 17 g #> 8   8 h 18 h #> 9   9 i 19 i #> 10 10 j 20 j #> 11  1 a 11 a"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":null,"dir":"Reference","previous_headings":"","what":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"S3 Method return copy object modified subsets.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"","code":"sb_mod(x, ...)  # S3 method for default sb_mod(x, i, ..., rp, tf, chkdup = TRUE)  # S3 method for matrix sb_mod(x, row = NULL, col = NULL, i = NULL, ..., rp, tf, chkdup = TRUE)  # S3 method for array sb_mod(   x,   idx = NULL,   dims = NULL,   rcl = NULL,   i = NULL,   ...,   rp,   tf,   chkdup = TRUE )  # S3 method for factor sb_mod(x, i = NULL, lvl = NULL, ..., rp, chkdup = TRUE)  # S3 method for list sb_mod(x, i, ..., rp, tf, chkdup = TRUE, .lapply = lapply)  # S3 method for data.frame sb_mod(   x,   row = NULL,   col = NULL,   filter = NULL,   vars = NULL,   coe = NULL,   ...,   rp,   tf,   chkdup = TRUE,   .lapply = lapply )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"x see squarebrackets_immutable_classes squarebrackets_mutable_classes. ... arguments passed methods. , lvl, row, col, idx, dims, rcl, filter, vars See squarebrackets_indx_args.  empty index selection returns original object unchanged. rp object somewhat type selected subset x, length selected subset x length 1. tf transformation function. chkdup see squarebrackets_duplicates. .lapply sb_mod() default uses lapply lists dapply data.frame-like objects compute tf() every list element data.frame column.  user may supply custom lapply()/dapply()-like function argument use instead.  example, perform parallel transformation, user may supply future.apply::future_lapply.  supplied function must use exact argument convention lapply, otherwise errors unexpected behaviour may occur. coe data.frame-like objects, sb_mod() can coerce whole columns, subsets columns.  automatically coerce column types row filter also specified.  Therefore, user can specify coercion function, applied entirety every column specified col vars; columns outside subset affected.  coercion function , course, applied replacement (rp) transformation (tf()).  default, coe = NULL means columns coercively transformed.  See also sb_coe.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"copy object replaced/transformed values.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"Transform Replace  Specifying argument tf transform subset.  Specifying rp replace subset.  One specify tf rp. either one set .  Note tf argument available factors: intentional.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"","code":"# atomic objects ====  obj <- matrix(1:16, ncol = 4) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 rp <- -1:-9 sb_mod(obj, 1:3, 1:3, rp = rp) #>       a  b  c  a #> [1,] -1 -4 -7 13 #> [2,] -2 -5 -8 14 #> [3,] -3 -6 -9 15 #> [4,]  4  8 12 16 # above is equivalent to  obj[1:3, 1:3] <- -1:-9; obj sb_mod(obj, i = \\(x)x<=5, rp = -1:-5) #>       a  b  c  a #> [1,] -1 -5  9 13 #> [2,] -2  6 10 14 #> [3,] -3  7 11 15 #> [4,] -4  8 12 16 # above is equivalent to  obj[obj <= 5] <- -1:-5; obj sb_mod(obj, col = \"a\", rp = -1:-8) #>       a b  c  a #> [1,] -1 5  9 -5 #> [2,] -2 6 10 -6 #> [3,] -3 7 11 -7 #> [4,] -4 8 12 -8 # above is equivalent to  obj[, which(colnames(obj) %in% \"a\")] <- -1:-8; obj sb_mod(obj, 1:3, 1:3, tf = \\(x) -x) #>       a  b   c  a #> [1,] -1 -5  -9 13 #> [2,] -2 -6 -10 14 #> [3,] -3 -7 -11 15 #> [4,]  4  8  12 16 # above is equivalent to  obj[1:3, 1:3] <- (-1 * obj[1:3, 1:3]); obj sb_mod(obj, i = \\(x)x<=5, tf = \\(x) -x) #>       a  b  c  a #> [1,] -1 -5  9 13 #> [2,] -2  6 10 14 #> [3,] -3  7 11 15 #> [4,] -4  8 12 16 # above is equivalent to  obj[obj <= 5] <- (-1 * obj[obj <= 5]); obj  obj <- matrix(1:16, ncol = 4) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 sb_mod(obj, 1:3, 1:3, tf = \\(x) -x) #>       a  b   c  a #> [1,] -1 -5  -9 13 #> [2,] -2 -6 -10 14 #> [3,] -3 -7 -11 15 #> [4,]  4  8  12 16 # above is equivalent to  obj[1:3, 1:3] <- -1 * obj[1:3, 1:3] sb_mod(obj, i = \\(x)x<=5, tf = \\(x) -x) #>       a  b  c  a #> [1,] -1 -5  9 13 #> [2,] -2  6 10 14 #> [3,] -3  7 11 15 #> [4,] -4  8 12 16 # above is equivalent to  obj[obj <= 5] <- -1:-5; obj sb_mod(obj, col = \"a\", tf = \\(x) -x) #>       a b  c   a #> [1,] -1 5  9 -13 #> [2,] -2 6 10 -14 #> [3,] -3 7 11 -15 #> [4,] -4 8 12 -16 # above is equivalent to  obj[, which(colnames(obj) %in% \"a\")] <- -1:-8; obj  obj <- array(1:64, c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  sb_mod(obj, list(1:3, 1:2), c(1,3), rp = -1:-24) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   -1   -4   -7  -10 #> [2,]   -2   -5   -8  -11 #> [3,]   -3   -6   -9  -12 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]  -13  -16  -19  -22 #> [2,]  -14  -17  -20  -23 #> [3,]  -15  -18  -21  -24 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  # above is equivalent to obj[1:3, , 1:2] <- -1:-24 sb_mod(obj, i = \\(x)x<=5, rp = -1:-5) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   -1   -5    9   13 #> [2,]   -2    6   10   14 #> [3,]   -3    7   11   15 #> [4,]   -4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  # above is equivalent to obj[obj <= 5] <- -1:-5  #############################################################################   # lists ====  obj <- list(a = 1:10, b = letters[1:11], c = 11:20) print(obj) #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  sb_mod(obj, \"a\", rp = list(1L)) #> $a #> [1] 1 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  # above is equivalent to  obj[[\"a\"]] <- 1L; obj sb_mod(obj, is.numeric, rp = list(-1:-10, -11:-20)) #> $a #>  [1]  -1  -2  -3  -4  -5  -6  -7  -8  -9 -10 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] -11 -12 -13 -14 -15 -16 -17 -18 -19 -20 #>  # above is equivalent to  obj[which(sapply(obj, is.numeric))] <- list(-1:-10, -11:-20); obj  #############################################################################   # data.frame-like objects ==== obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10  sb_mod(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost )  #> Warning: 1.414214 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 1 named 'a') #> Warning: 3.464102 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 3 named 'c') #>     a b  c d #> 1   1 a 11 a #> 2   1 b  3 b #> 3   1 c  3 c #> 4   2 d  3 d #> 5   2 e  3 e #> 6   2 f  4 f #> 7   2 g  4 g #> 8   8 h 18 h #> 9   9 i 19 i #> 10 10 j 20 j sb_mod(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   coe = as.double, tf = sqrt # SAFE: coercion performed )  #>            a b         c d #> 1   1.000000 a 11.000000 a #> 2   1.414214 b  3.464102 b #> 3   1.732051 c  3.605551 c #> 4   2.000000 d  3.741657 d #> 5   2.236068 e  3.872983 e #> 6   2.449490 f  4.000000 f #> 7   2.645751 g  4.123106 g #> 8   8.000000 h 18.000000 h #> 9   9.000000 i 19.000000 i #> 10 10.000000 j 20.000000 j  obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 sb_mod(   obj, vars = is.numeric,   tf = sqrt # SAFE: row=NULL & filter = NULL, so coercion performed ) #>           a b        c d #> 1  1.000000 a 3.316625 a #> 2  1.414214 b 3.464102 b #> 3  1.732051 c 3.605551 c #> 4  2.000000 d 3.741657 d #> 5  2.236068 e 3.872983 e #> 6  2.449490 f 4.000000 f #> 7  2.645751 g 4.123106 g #> 8  2.828427 h 4.242641 h #> 9  3.000000 i 4.358899 i #> 10 3.162278 j 4.472136 j"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_rec.html","id":null,"dir":"Reference","previous_headings":"","what":"Access Recursive Subsets — sb_rec","title":"Access Recursive Subsets — sb_rec","text":"sb_rec() method allows user access recursive subsets lists.  sb_rec() method also allows replacing transforming recursive subset list, using R's default -place semantics, specifying rp argument.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_rec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Access Recursive Subsets — sb_rec","text":"","code":"sb_rec(lst, rec, rp)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_rec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Access Recursive Subsets — sb_rec","text":"lst list, list-like object. rec vector length p, lst[[rec]] equivalent lst[[ rec[1] ]]...[[ rec[p] ]], providing final indexing results list.  certain subset level nested list, multiple subsets name exist, first one selected performing recursive indexing name, due recursive nature type subsetting. rp optional. specified, performs lst[[rec]] <- rp, using R's default -place semantics.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_rec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Access Recursive Subsets — sb_rec","text":"rp specified: Returns recursive subset. rp specified: Returns nothing, replaces recursive subset rp, using R's default -place semantics.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_rec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Access Recursive Subsets — sb_rec","text":"","code":"lst <- list(   A = list(     A = list(A = \"AAA\", B = \"AAB\"),     A = list(A  = \"AA2A\", B = \"AA2B\"),     B = list(A = \"ABA\", B = \"ABB\")   ),   B = list(     A = list(A = \"BAA\", B = \"BAB\"),     B = list(A = \"BBA\", B = \"BBB\")   ) )  #############################################################################  # access recursive subsets ====  sb_rec(lst, c(1,2,2)) # this gives \"AA2B\" #> [1] \"AA2B\" sb_rec(lst, c(\"A\", \"B\", \"B\")) # this gives \"ABB\" #> [1] \"ABB\" sb_rec(lst, c(2,2,1)) # this gives \"BBA\" #> [1] \"BBA\" sb_rec(lst, c(\"B\", \"B\", \"A\")) # this gives \"BBA\" #> [1] \"BBA\"   #############################################################################  # replace with R's default in-place semantics ====  # replace \"AAB\" using R's default in-place semantics: sb_rec(   lst, c(\"A\", \"A\", \"B\"),   rp = \"THIS IS REPLACED WITH IN-PLACE SEMANTICS\" ) print(lst) #> $A #> $A$A #> $A$A$A #> [1] \"AAA\" #>  #> $A$A$B #> [1] \"THIS IS REPLACED WITH IN-PLACE SEMANTICS\" #>  #>  #> $A$A #> $A$A$A #> [1] \"AA2A\" #>  #> $A$A$B #> [1] \"AA2B\" #>  #>  #> $A$B #> $A$B$A #> [1] \"ABA\" #>  #> $A$B$B #> [1] \"ABB\" #>  #>  #>  #> $B #> $B$A #> $B$A$A #> [1] \"BAA\" #>  #> $B$A$B #> [1] \"BAB\" #>  #>  #> $B$B #> $B$B$A #> [1] \"BBA\" #>  #> $B$B$B #> [1] \"BBB\" #>  #>  #>    #############################################################################  # Modify View of List By Reference ====  x <- list(  a = data.table::data.table(cola = 1:10, colb = letters[1:10]),  b = data.table::data.table(cola = 11:20, colb = letters[11:20]) ) print(x) #> $a #>      cola   colb #>     <int> <char> #>  1:     1      a #>  2:     2      b #>  3:     3      c #>  4:     4      d #>  5:     5      e #>  6:     6      f #>  7:     7      g #>  8:     8      h #>  9:     9      i #> 10:    10      j #>  #> $b #>      cola   colb #>     <int> <char> #>  1:    11      k #>  2:    12      l #>  3:    13      m #>  4:    14      n #>  5:    15      o #>  6:    16      p #>  7:    17      q #>  8:    18      r #>  9:    19      s #> 10:    20      t #>  mypointer <- sb_rec(x, \"a\") address(mypointer) == address(x$a) # they are the same #> [1] TRUE sb_set(mypointer, col = \"cola\", tf = \\(x)x^2) print(x) # notice x has been changed #> $a #>      cola   colb #>     <num> <char> #>  1:     1      a #>  2:     4      b #>  3:     9      c #>  4:    16      d #>  5:    25      e #>  6:    36      f #>  7:    49      g #>  8:    64      h #>  9:    81      i #> 10:   100      j #>  #> $b #>      cola   colb #>     <int> <char> #>  1:    11      k #>  2:    12      l #>  3:    13      m #>  4:    14      n #>  5:    15      o #>  6:    16      p #>  7:    17      q #>  8:    18      r #>  9:    19      s #> 10:    20      t #>"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_rm.html","id":null,"dir":"Reference","previous_headings":"","what":"Method to Un-Select/Remove Subsets of an Object — sb_rm","title":"Method to Un-Select/Remove Subsets of an Object — sb_rm","text":"S3 Method un-select/remove subsets object.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_rm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method to Un-Select/Remove Subsets of an Object — sb_rm","text":"","code":"sb_rm(x, ...)  # S3 method for default sb_rm(x, i, ..., rat = FALSE, chkdup = TRUE)  # S3 method for matrix sb_rm(x, row = NULL, col = NULL, i = NULL, ..., rat = FALSE, chkdup = TRUE)  # S3 method for array sb_rm(   x,   idx = NULL,   dims = NULL,   rcl = NULL,   i = NULL,   ...,   rat = FALSE,   chkdup = TRUE )  # S3 method for factor sb_rm(x, i = NULL, lvl = NULL, drop = FALSE, ..., rat = FALSE, chkdup = TRUE)  # S3 method for list sb_rm(x, i, drop = FALSE, ..., rat = FALSE, chkdup = TRUE)  # S3 method for data.frame sb_rm(   x,   row = NULL,   col = NULL,   filter = NULL,   vars = NULL,   ...,   chkdup = TRUE )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_rm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method to Un-Select/Remove Subsets of an Object — sb_rm","text":"x see squarebrackets_immutable_classes squarebrackets_mutable_classes. ... arguments passed methods. , lvl, row, col, idx, dims, rcl, filter, vars See squarebrackets_indx_args.  empty index selection results nothing removed, entire object returned. rat TRUE FALSE, indicating attributes returned sub-setted object.  See Details section info. chkdup see squarebrackets_duplicates. drop logical. factors: drop = TRUE, unused levels dropped, drop = FALSE dropped. lists: drop = TRUE, selecting single element give simplified result, like using [[]]. drop = FALSE, list always returned regardless number elements.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_rm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Method to Un-Select/Remove Subsets of an Object — sb_rm","text":"copy sub-setted object.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_rm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Method to Un-Select/Remove Subsets of an Object — sb_rm","text":"One rat argument  [ - methods strip () attributes.  rat = FALSE, chkdup = TRUE, default behaviour preserved, compatibility special classes. fastest option.  rat = TRUE, attributes x missing sub-setting re-assigned x. Already existing attributes sub-setting overwritten.  rat argument data.frame-like object: attributes always preserved.  NOTE: following situations, rat argument ignored, attributes necessarily dropped: x list, drop = TRUE, single element selected. x matrix array, sub-setting done argument.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_rm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Method to Un-Select/Remove Subsets of an Object — sb_rm","text":"","code":"# atomic objects ====  obj <- matrix(1:16, ncol = 4) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 sb_rm(obj, 1:3, 1:3) #>       a #> [1,] 16 # above is equivalent to  obj[-1:-3, -1:-3, drop = FALSE] sb_rm(obj, i = \\(x)x>5) #> [1] 1 2 3 4 5 # above is equivalent to  obj[!obj > 5] sb_rm(obj, col = \"a\") #>      b  c #> [1,] 5  9 #> [2,] 6 10 #> [3,] 7 11 #> [4,] 8 12 # above is equivalent to  obj[, which(!colnames(obj) %in% \"a\")]  obj <- array(1:64, c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  sb_rm(obj, n(1, c(1, 3)), c(1, 3)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   18   22   26   30 #> [2,]   19   23   27   31 #> [3,]   20   24   28   32 #>  sb_rm(obj, rcl = n(1, NULL, c(1, 3))) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   18   22   26   30 #> [2,]   19   23   27   31 #> [3,]   20   24   28   32 #>  # above 2 lines are equivalent to obj[-1, c(-1, -3), drop = FALSE] sb_rm(obj, i = \\(x)x>5) #> [1] 1 2 3 4 5 # above is equivalent to obj[!obj > 5]  #############################################################################   # lists ====  obj <- list(a = 1:10, b = letters[1:11], c = 11:20) print(obj) #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  sb_rm(obj, \"a\") #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  # above is equivalent to obj[which(!names(obj) %in% \"a\")] sb_rm(obj, 1) # obj[-1] #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  sb_rm(obj, 1:2) #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  # above is equivalent to obj[seq_len(length(obj))[-1:-2]] sb_rm(obj, is.numeric, drop = TRUE) #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" # above is equivalent to obj[[!sapply(obj, is.numeric)]] IF this returns a single element obj <- list(a = 1:10, b = letters[1:11], c = letters) sb_rm(obj, is.numeric) #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" #> [20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\" #>  # above is equivalent to obj[!sapply(obj, is.numeric)] # this time singular brackets? # for recusive indexing, see sb_rec()  #############################################################################   # factors ====  obj <- factor(rep(letters[1:5], 2)) sb_rm(obj, lvl = \"a\") #> [1] b c d e b c d e #> Levels: a b c d e # above is equivalent to obj[which(!obj %in% \"a\")]  #############################################################################   # data.frame-like objects ====  obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) print(obj) #>     a b  c d #> 1   1 a 11 a #> 2   2 b 12 b #> 3   3 c 13 c #> 4   4 d 14 d #> 5   5 e 15 e #> 6   6 f 16 f #> 7   7 g 17 g #> 8   8 h 18 h #> 9   9 i 19 i #> 10 10 j 20 j sb_rm(obj, 1:3, 1:3) #>   d #> 1 d #> 2 e #> 3 f #> 4 g #> 5 h #> 6 i #> 7 j # above is equivalent to obj[-1:-3, -1:-3, drop = FALSE] sb_rm(obj, filter = ~ (a > 5) & (c < 19), vars = is.numeric) #>   b d #> 1 a a #> 2 b b #> 3 c c #> 4 d d #> 5 e e #> 6 i i #> 7 j j"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":null,"dir":"Reference","previous_headings":"","what":"Method to Modify Subsets of a Mutable Object By Reference — sb_set","title":"Method to Modify Subsets of a Mutable Object By Reference — sb_set","text":"S3 Method replace transform subset supported mutable object using pass--reference semantics.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method to Modify Subsets of a Mutable Object By Reference — sb_set","text":"","code":"sb_set(x, ...)  # S3 method for default sb_set(x, i, ..., rp, tf, chkdup = TRUE)  # S3 method for matrix sb_set(x, row = NULL, col = NULL, i = NULL, ..., rp, tf, chkdup = TRUE)  # S3 method for array sb_set(   x,   idx = NULL,   dims = NULL,   rcl = NULL,   i = NULL,   ...,   rp,   tf,   chkdup = TRUE )  # S3 method for data.table sb_set(   x,   row = NULL,   col = NULL,   filter = NULL,   vars = NULL,   ...,   rp,   tf,   chkdup = TRUE,   .lapply = lapply )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method to Modify Subsets of a Mutable Object By Reference — sb_set","text":"x variable belonging one supported mutable classes. ... arguments passed methods. , row, col, idx, dims, rcl, filter, vars See squarebrackets_indx_args.  empty index selection returns original object unchanged. rp object somewhat type selected subset x, length selected subset x length 1. tf transformation function. chkdup see squarebrackets_duplicates. .lapply sb_set() default uses lapply lists dapply data.frame-like objects compute tf() every list element data.frame column.  user may supply custom lapply()/dapply()-like function argument use instead.  example, perform parallel transformation, user may supply future.apply::future_lapply.  supplied function must use exact argument convention lapply, otherwise errors unexpected behaviour may occur.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Method to Modify Subsets of a Mutable Object By Reference — sb_set","text":"Returns: VOID. method modifies object reference. use assignment like x <- sb_set(x, ...). Since function returns void, just get NULL.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Method to Modify Subsets of a Mutable Object By Reference — sb_set","text":"Transform Replace  Specifying argument tf transform subset. Specifying rp replace subset. One specify tf rp. either one set .  Note sb_set() method factors: intentional.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Method to Modify Subsets of a Mutable Object By Reference — sb_set","text":"","code":"# mutable_atomic objects ====  gen_mat <- function() {   obj <- as.mutable_atomic(matrix(1:16, ncol = 4))   colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\")   return(obj) }  obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutable_atomic  #> typeof:  integer  sb_set(obj, 1:3, 1:3, rp = -1:-9) obj2 #>       a  b  c  a #> [1,] -1 -4 -7 13 #> [2,] -2 -5 -8 14 #> [3,] -3 -6 -9 15 #> [4,]  4  8 12 16 #> mutable_atomic  #> typeof:  integer  obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutable_atomic  #> typeof:  integer  sb_set(obj, i = \\(x)x<=5, rp = -1:-5) obj2 #>       a  b  c  a #> [1,] -1 -5  9 13 #> [2,] -2  6 10 14 #> [3,] -3  7 11 15 #> [4,] -4  8 12 16 #> mutable_atomic  #> typeof:  integer  obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutable_atomic  #> typeof:  integer  sb_set(obj, col = \"a\", rp = cbind(-1:-4, -5:-8)) obj2 #>       a b  c  a #> [1,] -1 5  9 -5 #> [2,] -2 6 10 -6 #> [3,] -3 7 11 -7 #> [4,] -4 8 12 -8 #> mutable_atomic  #> typeof:  integer   obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutable_atomic  #> typeof:  integer  sb_set(obj, 1:3, 1:3, tf = \\(x) -x) obj2 #>       a  b   c  a #> [1,] -1 -5  -9 13 #> [2,] -2 -6 -10 14 #> [3,] -3 -7 -11 15 #> [4,]  4  8  12 16 #> mutable_atomic  #> typeof:  integer  obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutable_atomic  #> typeof:  integer  sb_set(obj, i = \\(x)x<=5, tf = \\(x) -x) obj2 #>       a  b  c  a #> [1,] -1 -5  9 13 #> [2,] -2  6 10 14 #> [3,] -3  7 11 15 #> [4,] -4  8 12 16 #> mutable_atomic  #> typeof:  integer  obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutable_atomic  #> typeof:  integer  sb_set(obj, col = \"a\", tf = \\(x) -x) obj2 #>       a b  c   a #> [1,] -1 5  9 -13 #> [2,] -2 6 10 -14 #> [3,] -3 7 11 -15 #> [4,] -4 8 12 -16 #> mutable_atomic  #> typeof:  integer    gen_array <- function() {   as.mutable_atomic(array(1:64, c(4,4,3))) } obj <- gen_array() obj #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  #> mutable_atomic  #> typeof:  integer  sb_set(obj, list(1:3, 1:2, c(1, 3)), 1:3, rp = -1:-12) obj #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   -1   -4    9   13 #> [2,]   -2   -5   10   14 #> [3,]   -3   -6   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   -7  -10   41   45 #> [2,]   -8  -11   42   46 #> [3,]   -9  -12   43   47 #> [4,]   36   40   44   48 #>  #> mutable_atomic  #> typeof:  integer  obj <- gen_array() obj #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  #> mutable_atomic  #> typeof:  integer  sb_set(obj, i = \\(x)x<=5, rp = -1:-5) obj #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   -1   -5    9   13 #> [2,]   -2    6   10   14 #> [3,]   -3    7   11   15 #> [4,]   -4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  #> mutable_atomic  #> typeof:  integer    #############################################################################  # data.table ====  obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb_set(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost ) #> Warning: 1.414214 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 1 named 'a') #> Warning: 3.464102 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 3 named 'c') print(obj) #>         a      b     c      d #>     <int> <char> <int> <fctr> #>  1:     1      a    11      a #>  2:     1      b     3      b #>  3:     1      c     3      c #>  4:     2      d     3      d #>  5:     2      e     3      e #>  6:     2      f     4      f #>  7:     2      g     4      g #>  8:     8      h    18      h #>  9:     9      i    19      i #> 10:    10      j    20      j  obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) obj <- sb_coe(obj, vars = is.numeric, v = as.numeric) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb_set(obj,   filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # SAFE: coercion performed by sb_coe(); so no warnings )  print(obj) #>             a      b         c      d #>         <num> <char>     <num> <fctr> #>  1:  1.000000      a 11.000000      a #>  2:  1.414214      b  3.464102      b #>  3:  1.732051      c  3.605551      c #>  4:  2.000000      d  3.741657      d #>  5:  2.236068      e  3.872983      e #>  6:  2.449490      f  4.000000      f #>  7:  2.645751      g  4.123106      g #>  8:  8.000000      h 18.000000      h #>  9:  9.000000      i 19.000000      i #> 10: 10.000000      j 20.000000      j  obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb_set(   obj, vars = is.numeric,   tf = sqrt # SAFE: row=NULL & filter = NULL, so coercion performed ) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 1.41 1.73 2 2.24 ... #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  3.32 3.46 3.61 3.74 3.87 ... #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_special.html","id":null,"dir":"Reference","previous_headings":"","what":"Specialized Sub-setting Functions — sb_special","title":"Specialized Sub-setting Functions — sb_special","text":"sb_a() function subsets extracts one attributes object.  sb_str() function subsets characters single string, replace subset characters single string subsets characters another string. cases, single string treated iterable vector, single character string single element. sb_str() function considerably faster equivalent operation base 'R' even 'stringi'.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_special.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specialized Sub-setting Functions — sb_special","text":"","code":"sb_str(str, ind, rp.str, rp.ind)  sb_a(x, a = NULL)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_special.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specialized Sub-setting Functions — sb_special","text":"str single string. ind integer vector, giving positions string subset. rp.str, rp.ind similar str ind, respectively.  specified, sb_str() perform something like str[ind]  treating str iterable vector.  specified, sb_str() perform something like str[ind] <- rp.str[rp.ind]  treating str rp.str iterable vectors. x object character vector attribute names. NULL (default), attributes returned.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_special.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Specialized Sub-setting Functions — sb_special","text":"sub-setted object.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_special.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Specialized Sub-setting Functions — sb_special","text":"","code":"x <- matrix(1:10, ncol = 2) colnames(x) <- c(\"a\", \"b\") attr(x, \"test\") <- \"test\" sb_a(x, \"test\") #> $test #> [1] \"test\" #>  sb_a(x) #> $dim #> [1] 5 2 #>  #> $dimnames #> $dimnames[[1]] #> NULL #>  #> $dimnames[[2]] #> [1] \"a\" \"b\" #>  #>  #> $test #> [1] \"test\" #>    x <- \"hello\" sb_str(x, 5:1) # this gives \"olleh\" #> [1] \"olleh\" sb_str(x, c(1:5, 5)) # this gives \"helloo\" #> [1] \"helloo\" sb_str(x, c(2:5)) # this gives \"ello\" #> [1] \"ello\" sb_str(x, seq(1, 5, by = 2)) # this gives \"hlo\" #> [1] \"hlo\" sb_str(x, 1:4, \"world\", 1:4) # this gives \"worlo\" #> [1] \"worlo\""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_x.html","id":null,"dir":"Reference","previous_headings":"","what":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","title":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","text":"S3 Method extract, exchange, duplicate (.e. replicate indices x times) indices object.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_x.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","text":"","code":"sb_x(x, ...)  # S3 method for default sb_x(x, i, ..., rat = FALSE)  # S3 method for matrix sb_x(x, row = NULL, col = NULL, i = NULL, ..., rat = FALSE)  # S3 method for array sb_x(x, idx = NULL, dims = NULL, rcl = NULL, i = NULL, ..., rat = FALSE)  # S3 method for factor sb_x(x, i = NULL, lvl = NULL, drop = FALSE, ..., rat = FALSE)  # S3 method for list sb_x(x, i, drop = FALSE, ..., rat = FALSE)  # S3 method for data.frame sb_x(x, row = NULL, col = NULL, filter = NULL, vars = NULL, ...)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_x.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","text":"x see squarebrackets_immutable_classes squarebrackets_mutable_classes. ... arguments passed methods. , lvl, row, col, idx, dims, rcl, filter, vars See squarebrackets_indx_args.  Duplicates allowed, resulting duplicated indices.  empty index selection results empty object length 0. rat logical, indicating attributes returned sub-setted object. See Details section info. drop logical. factors: drop = TRUE, unused levels dropped, drop = FALSE dropped. lists: drop = TRUE, selecting single element give simplified result, like using [[]]. drop = FALSE, list always returned regardless number elements.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_x.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","text":"Returns copy sub-setted object.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_x.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","text":"One rat argument  [ - methods strip () attributes.  rat = FALSE, default behaviour preserved, compatibility special classes. fastest option.  rat = TRUE, attributes x missing sub-setting re-assigned x. Already existing attributes sub-setting overwritten.  rat argument data.frame-like object: attributes always preserved.  NOTE: following situations, rat argument ignored, attributes necessarily dropped: x list, drop = TRUE, single element selected. x matrix array, sub-setting done argument.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_x.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","text":"","code":"# atomic objects ====  obj <- matrix(1:16, ncol = 4) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 sb_x(obj, 1:3, 1:3) #>      a b  c #> [1,] 1 5  9 #> [2,] 2 6 10 #> [3,] 3 7 11 # above is equivalent to obj[1:3, 1:3, drop = FALSE] sb_x(obj, i = \\(x)x>5) #>  [1]  6  7  8  9 10 11 12 13 14 15 16 # above is equivalent to obj[obj > 5] sb_x(obj, col = c(\"a\", \"a\")) #>      a  a a  a #> [1,] 1 13 1 13 #> [2,] 2 14 2 14 #> [3,] 3 15 3 15 #> [4,] 4 16 4 16 # above is equivalent to obj[, lapply(c(\"a\", \"a\"), \\(i) which(colnames(obj) == i)) |> unlist()]  obj <- array(1:64, c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  sb_x(obj, n(1:3, 1:2), c(1,3)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #>  sb_x(obj, rcl = n(1:3, NULL, 1:2)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #>  # above 2 lines are equivalent to obj[1:3, , 1:2, drop = FALSE] sb_x(obj, i = \\(x)x>5) #>  [1]  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #> [26] 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 # above is equivalent to obj[obj > 5]  #############################################################################   # lists ====  obj <- list(a = 1:10, b = letters[1:11], c = 11:20) print(obj) #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  sb_x(obj, 1) # obj[1] #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  sb_x(obj, 1, drop = TRUE) # obj[[1]] #>  [1]  1  2  3  4  5  6  7  8  9 10 sb_x(obj, 1:2) # obj[1:2] #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  sb_x(obj, is.numeric) # obj[sapply(obj, is.numeric)] #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  # for recursive indexing, see sb_rec()  #############################################################################   # factors ====  obj <- factor(rep(letters[1:5], 2)) sb_x(obj, lvl = c(\"a\", \"a\")) #> [1] a a a a #> Levels: a b c d e # above is equivalent to obj[lapply(c(\"a\", \"a\"), \\(i) which(obj == i)) |> unlist()]  #############################################################################   # data.frame-like objects ====  obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) print(obj) #>     a b  c d #> 1   1 a 11 a #> 2   2 b 12 b #> 3   3 c 13 c #> 4   4 d 14 d #> 5   5 e 15 e #> 6   6 f 16 f #> 7   7 g 17 g #> 8   8 h 18 h #> 9   9 i 19 i #> 10 10 j 20 j sb_x(obj, 1:3, 1:3) # obj[1:3, 1:3, drop = FALSE] #>   a b  c #> 1 1 a 11 #> 2 2 b 12 #> 3 3 c 13 sb_x(obj, filter = ~ (a > 5) & (c < 19), vars = is.numeric) #>   a  c #> 1 6 16 #> 2 7 17 #> 3 8 18"},{"path":"https://tony-aw.github.io/squarebrackets/reference/seq_mlen.html","id":null,"dir":"Reference","previous_headings":"","what":"Multiple seq_len — seq_mlen","title":"Multiple seq_len — seq_mlen","text":"Create multiple sequences certain lengths .  vectorized version lapply(x, seq_len).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/seq_mlen.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multiple seq_len — seq_mlen","text":"","code":"seq_mlen(x)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/seq_mlen.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multiple seq_len — seq_mlen","text":"x integer vector giving lengths.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/seq_mlen.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multiple seq_len — seq_mlen","text":"list length(x) elements, element result seq_len.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/seq_mlen.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multiple seq_len — seq_mlen","text":"","code":"seq_mlen(c(10, 10, 3)) #> [[1]] #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> [[2]] #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> [[3]] #> [1] 1 2 3 #>"},{"path":"https://tony-aw.github.io/squarebrackets/reference/seq_names.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Integer Sequence From a Range of Names — seq_names","title":"Generate Integer Sequence From a Range of Names — seq_names","text":"Generate integer sequence range names.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/seq_names.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Integer Sequence From a Range of Names — seq_names","text":"","code":"seq_names(names, start, end, inv = FALSE)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/seq_names.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Integer Sequence From a Range of Names — seq_names","text":"names character vector names.  Duplicate names, empty names, character vector length zero allowed. start name giving starting index sequence end name giving ending index sequence inv logical, TRUE, indices names EXCEPT names specified sequence given.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/seq_names.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Integer Sequence From a Range of Names — seq_names","text":"integer vector.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/seq_names.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Integer Sequence From a Range of Names — seq_names","text":"","code":"x <- data.frame(   a = 1:10, b = letters[1:10], c = factor(letters[1:10]), d = -1:-10 ) ind <- seq_names(colnames(x), \"b\", \"d\") sb_x(x, col = ind) #>    b c   d #> 1  a a  -1 #> 2  b b  -2 #> 3  c c  -3 #> 4  d d  -4 #> 5  e e  -5 #> 6  f f  -6 #> 7  g g  -7 #> 8  h h  -8 #> 9  i i  -9 #> 10 j j -10"},{"path":"https://tony-aw.github.io/squarebrackets/reference/seq_rec.html","id":null,"dir":"Reference","previous_headings":"","what":"Recursive Sequence Generator — seq_rec","title":"Recursive Sequence Generator — seq_rec","text":"recursive sequence generator. function essentially highly generalized version Fibonacci sequence generator. One can change initial values, window size, even window function used.  function assumes following sequence generated: sequence consists real numbers (.e. class integer class double). window size iterations. window function iterations. sequence grows vector length n achieved.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/seq_rec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Recursive Sequence Generator — seq_rec","text":"","code":"seq_rec(inits = c(0, 1), n = 10L, f = sum)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/seq_rec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Recursive Sequence Generator — seq_rec","text":"inits numeric (double integer) vector giving initial values.  numbers allowed, even negative /fractional numbers.  Note numbers given must give valid results passed function f().  IMPORTANT: length inits determines window size w.  regular Fibonacci, inits = 0:1, course means window size w = 2. n single integer, giving size numeric vector generate.  NOTE: must hold n larger equal window size w.  window size equal w = length(inits). f function used last w numbers generate next number sequence iteration.  must function takes input numeric vector, returns single numeric value.  regular Fibonacci sequence, either: f = sum,  (since window size 2) f = \\(x) x[2] + x[1]","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/seq_rec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Recursive Sequence Generator — seq_rec","text":"sequence numbers.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/seq_rec.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Recursive Sequence Generator — seq_rec","text":"default values arguments give first 10 numbers regular Fibonacci sequence.  See examples several number series created function.  function written C++ using Rcpp better performance.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/seq_rec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Recursive Sequence Generator — seq_rec","text":"","code":"seq_rec() # by default gives Fibonacci numbers #>  [1]  0  1  1  2  3  5  8 13 21 34 seq_rec(0:3, 10L, sum) # a weird shifted version of Fibonacci #>  [1]   0   1   2   3   6  12  23  44  85 164 seq_rec(inits = 2:1) # Lucas numbers #>  [1]  2  1  3  4  7 11 18 29 47 76 c(1, seq_rec(c(1, 2), f = prod)) # Multiplicative Fibonacci #>  [1]           1           1           2           2           4           8 #>  [7]          32         256        8192     2097152 17179869184 seq_rec(f = \\(x) 2 * x[2] + x[1]) # Pell numbers #>  [1]   0   1   2   5  12  29  70 169 408 985 seq_rec(inits = c(1, 0), f = \\(x) 2 * x[1]) # see https://oeis.org/A077957 #>  [1]  1  0  2  0  4  0  8  0 16  0 seq_rec(f = \\(x) x[2] + 2 * x[1]) # Jacobsthal numbers #>  [1]   0   1   1   3   5  11  21  43  85 171 seq_rec(c(1, 1, 1), f = \\(x) x[1] + x[2]) # Padovan sequence #>  [1] 1 1 1 2 2 3 4 5 7 9 seq_rec(c(3, 0, 2), f = \\(x) x[1] + x[2]) # Perrin numbers #>  [1]  3  0  2  3  2  5  5  7 10 12 seq_rec(c(0, 1, 3), f = \\(x) 3 * x[3] - 3 * x[2] + x[1]) # Triangular numbers #>  [1]  0  1  3  6 10 15 21 28 36 45"},{"path":"https://tony-aw.github.io/squarebrackets/reference/setapply.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply Functions Over Mutable Atomic Matrix Margins By Reference — setapply","title":"Apply Functions Over Mutable Atomic Matrix Margins By Reference — setapply","text":"setapply() function applies functions rows columns mutable_atomic matrix, pass--reference semantics.  every iteration, copy single row column (depending margin) made, function applied copy, original row/column replaced modified copy pass--reference semantics.  setapply() speed apply.  However, setapply() uses much less memory apply.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/setapply.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply Functions Over Mutable Atomic Matrix Margins By Reference — setapply","text":"","code":"setapply(x, MARGIN, FUN)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/setapply.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply Functions Over Mutable Atomic Matrix Margins By Reference — setapply","text":"x mutable_atomic matrix. Arrays supported. MARGIN single integer scalar, giving subscript apply function . 1 indicates rows, 2 indicates columns. FUN function applied.  case (infix) operators, function name must backquoted quoted.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/setapply.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply Functions Over Mutable Atomic Matrix Margins By Reference — setapply","text":"Returns: VOID. function modifies object reference. use assignment like x <- setapply(x, ...). Since function returns void, just get NULL.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/setapply.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply Functions Over Mutable Atomic Matrix Margins By Reference — setapply","text":"","code":"# re-order elements matrix by reference ==== x <- mutable_atomic(1:20, dim = c(5,4)) print(x) #>      [,1] [,2] [,3] [,4] #> [1,]    1    6   11   16 #> [2,]    2    7   12   17 #> [3,]    3    8   13   18 #> [4,]    4    9   14   19 #> [5,]    5   10   15   20 #> mutable_atomic  #> typeof:  integer  setapply(x, 1, FUN = \\(x)x[c(4,1,3,2)]) print(x) #>      [,1] [,2] [,3] [,4] #> [1,]   16    1   11    6 #> [2,]   17    2   12    7 #> [3,]   18    3   13    8 #> [4,]   19    4   14    9 #> [5,]   20    5   15   10 #> mutable_atomic  #> typeof:  integer    # sort elements of matrix by reference ==== x <- mutable_atomic(20:1, dim = c(5,4)) print(x) #>      [,1] [,2] [,3] [,4] #> [1,]   20   15   10    5 #> [2,]   19   14    9    4 #> [3,]   18   13    8    3 #> [4,]   17   12    7    2 #> [5,]   16   11    6    1 #> mutable_atomic  #> typeof:  integer  setapply(x, 2, FUN = sort) print(x) #>      [,1] [,2] [,3] [,4] #> [1,]   16   11    6    1 #> [2,]   17   12    7    2 #> [3,]   18   13    8    3 #> [4,]   19   14    9    4 #> [5,]   20   15   10    5 #> mutable_atomic  #> typeof:  integer"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"functions convert list integer subscripts integer matrix coordinates, integer matrix coordinates integer vector flat indices, vice-versa.  Inspired sub2ind function 'MatLab'. sub2coord() converts list integer subscripts integer matrix coordinates. coord2ind() converts integer matrix coordinates integer vector flat indices. ind2coord() converts integer vector flat indices integer matrix coordinates. coord2sub() converts integer matrix coordinates list integer subscripts. sub2ind() faster memory efficient version coord2ind(sub2coord(sub, x.dims), x.dims) (especially 5 dimensions).  Note coord2sub() function performs simple (one might even say naive) conversion.  functions written memory-efficient.  coord2ind() thus opposite arrayInd, ind2coord merely convenient wrapper around arrayInd.  Note equivalent sub2ind function 'MatLab' actually coord2ind() function .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"","code":"sub2coord(sub, x.dim)  coord2sub(coord)  coord2ind(coord, x.dim, checks = TRUE)  ind2coord(ind, x.dim)  sub2ind(sub, x.dim, checks = TRUE)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"sub list integer subscripts.  first element list corresponds first dimension (rows), second element second dimensions (columns), etc.  length sub must equal length x.dim.  One give empty subscript; instead fill something like seq_len(dim(x)[margin]).  NOTE: coord2sub() function support duplicate subscripts. x.dim integer vector giving dimensions array question. .e. dim(x). coord integer matrix, giving coordinate indices (subscripts) convert.  row index, column dimension.  first columns corresponds first dimension, second column second dimensions, etc.  number columns coord must equal length x.dim. checks logical, indicating arguments checks performed.  Defaults TRUE. Can set FALSE minor speed improvements, recommended. ind integer vector, giving flat position indices convert.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"sub2coord() ind2coord(): Returns integer matrix coordinates (properties described argument coord).  coord2ind(): Returns integer vector flat indices (properties described argument ind).  coord2sub(): Returns list integer subscripts (properties described argument sub)","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"S3 classes 'R' use standard Linear Algebraic convention, academic fields like Mathematics Statistics, following sense: vectors column vectors (.e. vertically aligned vectors); index counting starts 1; rows first dimension/subscript, columns second dimension/subscript, etc. Thus, orientation flat indices , example, 4 4 matrix, follows:   subscript [1,2] refers first row second column. 4 4 matrix, subscript [1,2] corresponds flat index 5.  functions described thus follow also convention.","code":"[,1] [,2] [,3] [,4]  [1,]    1    5    9   13  [2,]    2    6   10   14  [3,]    3    7   11   15  [4,]    4    8   12   16"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"functions support duplicate indices.  efficiency, check duplicate indices either.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"","code":"x.dim <- c(10, 10, 3) x.len <- prod(x.dim) x <- array(1:x.len, x.dim) sub <- list(c(4, 3), c(3, 2), c(2, 3)) coord <- sub2coord(sub, x.dim) print(coord) #>      [,1] [,2] [,3] #> [1,]    4    3    2 #> [2,]    3    3    2 #> [3,]    4    2    2 #> [4,]    3    2    2 #> [5,]    4    3    3 #> [6,]    3    3    3 #> [7,]    4    2    3 #> [8,]    3    2    3 ind <- coord2ind(coord, x.dim) print(ind) #> [1] 124 123 114 113 224 223 214 213 all(x[ind] == c(x[c(4, 3), c(3, 2), c(2, 3)])) # TRUE #> [1] TRUE coord2 <- ind2coord(ind, x.dim) print(coord) #>      [,1] [,2] [,3] #> [1,]    4    3    2 #> [2,]    3    3    2 #> [3,]    4    2    2 #> [4,]    3    2    2 #> [5,]    4    3    3 #> [6,]    3    3    3 #> [7,]    4    2    3 #> [8,]    3    2    3 all(coord == coord2) # TRUE #> [1] TRUE sub2 <- coord2sub(coord2) sapply(1:3, \\(i) sub2[[i]] == sub[[i]]) |> all() # TRUE #> [1] TRUE"}]
