[{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Benchmarks - sb_x","text":"Due many checks conversions performed squarebrackets:: functions, make sub-setting programmatically beginner friendly, functions almost necessarily slower base R’s [-like operators. However, considerable effort made keep speed loss minimum. Generally, speed loss indeed negligible, cases even speed improvement (thanks heavy lifting performed ‘collapse’ package). benchmarks give one idea speed loss. just examples; speed determined great number factors.  ","code":"library(bench) library(ggplot2) library(patchwork)"},{"path":[]},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"matrix","dir":"Articles","previous_headings":"Atomic objects","what":"Matrix","title":"Benchmarks - sb_x","text":" ","code":"n <- 5e3 x.mat <- matrix(seq_len(n*n), ncol = n) colnames(x.mat) <- sample(c(letters, NA), n, TRUE) sel.rows <- 1:100 sel.cols <- rep(sample(letters[1:13]), 10) bm.sb_x.matrix <- bench::mark(   \"sb_x\" = sb_x(x.mat, sel.rows, sel.cols),   \"base R\" = x.mat[sel.rows, lapply(sel.cols, \\(i) which(colnames(x.mat) == i)) |> unlist(), drop = FALSE],   min_iterations = 500 ) bm.sb_x.matrix summary(bm.sb_x.matrix) #> # A tibble: 2 × 6 #>   expression          min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>     <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 squarebrackets   4.99ms   5.56ms      177.    9.82MB     28.3 #> 2 base R           7.81ms    8.9ms      111.   14.67MB     16.6"},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"array-3d","dir":"Articles","previous_headings":"Atomic objects","what":"Array (3D)","title":"Benchmarks - sb_x","text":" ","code":"x.dims <- c(5000, 2000, 4) x.3d <- array(1:prod(x.dims), x.dims) sel.rows <- 1:900 sel.lyrs <- c(TRUE, FALSE, TRUE, FALSE) bm.sb_x.3d <- bench::mark(   \"squarebrackets\" =  sb_x(x.3d, n(sel.rows, sel.lyrs), c(1,3)),   \"base R + abind\" = abind::asub(x.3d, idx = list(sel.rows, sel.lyrs), dims = c(1,3)),   min_iterations = 500 ) summary(bm.sb_x.3d) #> # A tibble: 2 × 6 #>   expression          min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>     <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 squarebrackets   9.64ms   10.6ms      94.1    13.7MB     7.52 #> 2 base R + abind    9.7ms   10.7ms      92.8    13.7MB     6.56"},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"plot","dir":"Articles","previous_headings":"Atomic objects","what":"Plot","title":"Benchmarks - sb_x","text":" ","code":"#> Loading required namespace: tidyr"},{"path":[]},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"data-frame","dir":"Articles","previous_headings":"Data.frame-like objects","what":"data.frame","title":"Benchmarks - sb_x","text":" ","code":"n <- 1e5 chrmat <- matrix(   sample(letters, n*400, replace = TRUE), ncol = 400 ) intmat <- matrix(   seq.int(n*400), ncol = 400 ) x <- cbind(chrmat, intmat) |> as.data.frame() rm(list = c(\"chrmat\", \"intmat\")) colnames(x) <- make.names(colnames(x), unique = TRUE) sel.cols <- rep(sample(names(x), 10), 4) sel.rows <- 1:1000 bm.sb_x.df <- bench::mark(   \"squarebrackets\" = sb2_x(x, sel.rows, sel.cols),   \"collapse::ss\" = collapse::ss(x, sel.rows, match(sel.cols, names(x))),   \"base R\" = x[sel.rows, match(sel.cols, names(x)), drop = FALSE],   min_iterations = 1e4 ) summary(bm.sb_x.df) #> # A tibble: 2 × 6 #>   expression          min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>     <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 squarebrackets    124µs    193µs     4466.     441KB     8.95 #> 2 base R            345µs    879µs     1052.     362KB     2.11"},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"data-table","dir":"Articles","previous_headings":"Data.frame-like objects","what":"data.table","title":"Benchmarks - sb_x","text":" ","code":"x <- as.data.table(x) tempfun <- function(x, i, j) {   x <- collapse::ss(x, i, j, check = TRUE)   names(x) <- make.names(names(x), unique = TRUE)   return(x) } bm.sb_x.dt <- bench::mark(   \"squarebrackets\" = sb2_x(x, sel.rows, sel.cols),   \"data.table + collapse\" = tempfun(x, sel.rows, match(sel.cols, names(x))),   min_iterations = 1e4 ) summary(bm.sb_x.dt) #> # A tibble: 2 × 6 #>   expression                 min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>            <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 squarebrackets           112µs    125µs     7610.     324KB     4.57 #> 2 data.table + collapse    106µs    124µs     5508.     339KB     0"},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"plot-1","dir":"Articles","previous_headings":"Data.frame-like objects","what":"plot","title":"Benchmarks - sb_x","text":" ","code":""},{"path":"https://tony-aw.github.io/squarebrackets/articles/b_benchmarks_tf.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Benchmarks - transform operations","text":"Base R’s [<-, [[<-, $<- methods perform -place modification subsets objects using “copy--modify” semantics. ‘squarebrackets’ R-package provides 2 alternative semantics modification: “pass--reference” sb_set() method, “deep-copy” sb_mod() method. Moreover, base ‘R’ provides direct replacement , ‘squarebrackets’ provides replacement (rp argument) transformation (tf argument) mechanics. Thus, ‘squarebrackets’ base R really directly comparable terms benchmarking. Nonetheless, tried keep comparisons somewhat fair. sb_set() method generally several times (2 5 times) faster base R’s -place modification, generally uses half memory. sb_mod() method generally fast base R’s -place modification, uses amount memory. benchmarks give one idea speed loss. just examples; speed determined great number factors. keep comparisons classes fair, objects approximately 1e7 elements.  ","code":"library(bench) library(ggplot2) library(patchwork) library(tinycodet) #> Run `?tinycodet::tinycodet` to open the introduction help page of 'tinycodet'. plotfun <- function(title1, bm1, title2, bm2) {    plotdat1 <- bm1 |> tidyr::unnest(cols = c(\"time\", \"gc\", \"mem_alloc\"))   plotdat1$expression <- paste(     plotdat1$expression,     \"\\n (\", as.character(plotdat1$mem_alloc), \")\"   )   p1 <- ggplot(plotdat1, aes_pro(x = ~ time, y = ~ expression, color = ~ gc)) +   ggbeeswarm::geom_quasirandom() + ggtitle(title1)    plotdat2 <- bm2 |> tidyr::unnest(cols = c(\"time\", \"gc\", \"mem_alloc\"))   plotdat2$expression <- paste(     plotdat2$expression,     \"\\n (\", as.character(plotdat2$mem_alloc), \")\"   )   p2 <- ggplot(plotdat2, aes_pro(x = ~ time, y = ~ expression, color = ~ gc)) +   ggbeeswarm::geom_quasirandom() + ggtitle(title2)    combined <- p1 + p2 & theme(legend.position = \"bottom\")   combined + plot_layout(guides = \"collect\") }"},{"path":[]},{"path":"https://tony-aw.github.io/squarebrackets/articles/b_benchmarks_tf.html","id":"matrix","dir":"Articles","previous_headings":"Atomic objects","what":"Matrix","title":"Benchmarks - transform operations","text":" ","code":"n <- 3162 # approx sqrt(1e7) x.mat <- matrix(seq_len(n*n), ncol = n) x.mat2 <- as.mutable_atomic(x.mat) colnames(x.mat) <- sample(c(letters, LETTERS, NA), n, TRUE) sel.rows <- 1:1000 sel.cols <- 1:1000 basefun <- function(x, rows, cols, tf) {   x[rows, cols] <- tf(x[rows, cols])   return(x) } tf <- function(x) { return(-1 * x) } bm.sb_tf.matrix <- bench::mark(   \"base [<-\" =  basefun(x.mat, sel.rows, sel.cols, tf = tf),   \"sb_set\" = sb_set(x.mat2, sel.rows, sel.cols, tf = tf),   \"sb_mod\" = sb_mod(x.mat, sel.rows, sel.cols, tf = tf),   check = FALSE,   min_iterations = 500 ) bm.sb_tf.matrix summary(bm.sb_tf.matrix) #> # A tibble: 3 × 6 #>   expression      min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 base [<-    23.86ms  29.02ms      33.9    87.7MB     46.4 #> 2 sb_set       4.83ms   6.07ms     165.     15.4MB     14.7 #> 3 sb_mod      24.82ms  29.69ms      32.5    87.8MB     29.5"},{"path":"https://tony-aw.github.io/squarebrackets/articles/b_benchmarks_tf.html","id":"array-3d","dir":"Articles","previous_headings":"Atomic objects","what":"Array (3D)","title":"Benchmarks - transform operations","text":" ","code":"x.dims <- c(1900, 1900, 3) # leads to approx 1e7 elements x.3d <- array(1:prod(x.dims), x.dims) x.3d2 <- as.mutable_atomic(x.3d) sel.rows <- 1:900 sel.lyrs <- c(TRUE, FALSE, TRUE) basefun <- function(x, rows, lyrs, tf) {   x[rows, , lyrs] <- tf(x[rows, , lyrs])   return(x) } tf <- function(x) { return(-1 * x) } bm.sb_tf.3d <- bench::mark(   \"base [<-\" = basefun(x.3d, sel.rows, sel.lyrs, tf = tf ),   \"sb_set\" =  sb_set(x.3d2, n(sel.rows, sel.lyrs), c(1,3), tf = tf),   \"sb_mod\" = sb_mod(x.3d, n(sel.rows, sel.lyrs), c(1, 3), tf = tf),   check = FALSE,   min_iterations = 500 ) summary(bm.sb_tf.3d) #> # A tibble: 3 × 6 #>   expression      min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 base [<-     48.5ms     52ms      19.0   121.8MB     44.8 #> 2 sb_set       22.2ms   26.9ms      37.1    52.3MB     10.9 #> 3 sb_mod       45.5ms   52.9ms      18.8   121.8MB     21.9"},{"path":"https://tony-aw.github.io/squarebrackets/articles/b_benchmarks_tf.html","id":"plot","dir":"Articles","previous_headings":"Atomic objects","what":"Plot","title":"Benchmarks - transform operations","text":" ","code":"#> Warning: The `trans` argument of `continuous_scale()` is deprecated as of ggplot2 3.5.0. #> ℹ Please use the `transform` argument instead. #> This warning is displayed once every 8 hours. #> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was #> generated. #> Orientation inferred to be along y-axis; override with #> `position_quasirandom(orientation = 'x')` #> Orientation inferred to be along y-axis; override with #> `position_quasirandom(orientation = 'x')`"},{"path":"https://tony-aw.github.io/squarebrackets/articles/b_benchmarks_tf.html","id":"data-frame-like","dir":"Articles","previous_headings":"","what":"Data.frame-like","title":"Benchmarks - transform operations","text":"    ","code":"n <- 1e5 ncol <- 200 # times 2 chrmat <- matrix(   sample(letters, n*ncol, replace = TRUE), ncol = ncol ) intmat <- matrix(   seq.int(n*ncol), ncol = ncol ) x <- cbind(chrmat, intmat) |> as.data.frame() colnames(x) <- make.names(colnames(x), unique = TRUE) x2 <- data.table::as.data.table(x) rm(list = c(\"chrmat\", \"intmat\"))  sel.rows <- 1:1000 basefun <- function(x, rows, tf) {   x[rows, sapply(x, is.numeric)] <- lapply(x[rows, sapply(x, is.numeric)], tf)   return(x) } bm.sb_tf.df <- bench::mark(   \"base [<-\" = basefun(x, sel.rows, tf = \\(x) -1 * x),   \"sb_set\" = sb2_set.data.table(     x2, rows = sel.rows, vars = is.numeric, tf = \\(x) -1 * x   ),   \"sb_mod\" = sb2_mod.data.frame(     x, rows = sel.rows, vars = is.numeric, tf = \\(x) -1 * x, coe = TRUE   ),   check = FALSE,   min_iterations = 500 ) summary(bm.sb_tf.df) #> # A tibble: 3 × 6 #>   expression      min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 base [<-    237.9µs    307µs     3060.    62.3KB     12.3 #> 2 sb_set       84.3µs    122µs     7339.   932.8KB      0   #> 3 sb_mod      100.5µs    131µs     7400.    46.7KB      0 #> Orientation inferred to be along y-axis; override with #> `position_quasirandom(orientation = 'x')`"},{"path":"https://tony-aw.github.io/squarebrackets/articles/c_benchmarks_lst.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Benchmarks - Vectorized Recursive Subset Operations On Nested Lists","text":"Operating recursive sub-sets nested lists requires [[ [[<- operators. operators can select single subset . Thus, operating multiple recursive sub-sets requires -loop, thus vectorized. lst_untree() function unnests tree-like nested list recursive matrix, way recursive sub-set operations can performed vectorized manner. benchmarks operating original list, list transformed lst_untree().   ","code":"x <- lapply(1:1000, \\(x) list(   list(sample(letters), sample(LETTERS)),   list(sample(month.abb), sample(month.name)),   list(sample(1:100), rnorm(100)) )) y <- lst_untree(x, 1)  foo <- bench::mark(   original = for(i in seq_along(x)) {x[[c(i, c(1,2))]]},   \"untree'd\" = sb2_x(n(seq_len(nrow(y)), 2), 1:2),   check = FALSE,   min_iterations = 1000 ) summary(foo) #> # A tibble: 2 × 6 #>   expression      min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 original     1.09ms   1.27ms      766.    38.4KB     17.2 #> 2 untree'd      7.6µs      9µs   102420.    77.6KB     20.5 ggplot2::autoplot(foo) #> Loading required namespace: tidyr"},{"path":"https://tony-aw.github.io/squarebrackets/articles/Extra_Examples.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Additional Examples","text":"function documentation ‘squarebrackets’ package rich examples. article adds additional examples focussed combining ‘squarebrackets’ packages.  ","code":""},{"path":"https://tony-aw.github.io/squarebrackets/articles/Extra_Examples.html","id":"aggregate-sf-data-table","dir":"Articles","previous_headings":"","what":"Aggregate sf-data.table","title":"Additional Examples","text":"‘sf’ package adds data.frames/data.tables spatial features. example, functionality ‘squarebrackets’ used ‘sf’ class data.table. plot created (using ‘ggplot2’, ‘ggh4x’, ‘tinycodet’) aggregation region spatial data.table:   ","code":"library(ggplot2) library(ggh4x) library(tinycodet) #> Run `?tinycodet::tinycodet` to open the introduction help page of 'tinycodet'. import_as(~dt., \"data.table\") #> Importing packages and registering methods... #> Done #> You can now access the functions using `dt.$` #> For conflicts report, packages order, and other attributes, run `attr.import(dt.)` x <- sf::st_read(system.file(\"shape/nc.shp\", package = \"sf\")) #> Reading layer `nc' from data source `D:\\Programs\\R-4.4.0\\library\\sf\\shape\\nc.shp' using driver `ESRI Shapefile' #> Simple feature collection with 100 features and 14 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 #> Geodetic CRS:  NAD27 x <- dt.$as.data.table(x)  x$region <- ifelse(x$CNTY_ID <= 2000, 'high', 'low') plotdat <- dt_aggregate(   x, SDcols = \"geometry\", f = sf::st_union, by = \"region\" ) geometry <- ~geometry fill <- ~region fct <- ~region ggplot(plotdat, aes_pro(geometry = geometry, fill = fill)) +    facet_wrap2(fct, nrow = 2) +   geom_sf()"},{"path":"https://tony-aw.github.io/squarebrackets/articles/Extra_Examples.html","id":"re-order-an-array-like-a-rubiks-cube","dir":"Articles","previous_headings":"","what":"Re-order an array like a Rubik’s cube","title":"Additional Examples","text":"%row~% %col~% operators ‘tinycodet’ can quickly re-order elements row column independently rows columns. One can combine operators sb_ methods ‘squarebrackets’ re-order matrix slices array, like re-ordering panels Rubik’s cube. using sb_set() one can even reference better memory efficiency - exactly done . Let’s first create mutable array: Now let’s numerically sort every column slices array reference: Now, let’s see successful: Yes, column layer independently sorted numerically. One can thing character array; note time use stringi::stri_rank() determining proper order: : successful.    ","code":"x <- mutable_atomic(sample(1:27), dim = c(3,3,3)) print(x) #> , , 1 #>  #>      [,1] [,2] [,3] #> [1,]   13    5   22 #> [2,]   23    6    4 #> [3,]   12   15   26 #>  #> , , 2 #>  #>      [,1] [,2] [,3] #> [1,]    9   21    2 #> [2,]   24    8    7 #> [3,]   17   27   16 #>  #> , , 3 #>  #>      [,1] [,2] [,3] #> [1,]   10   25   19 #> [2,]   20   14    1 #> [3,]   18   11    3 #>  #> mutable_atomic  #> typeof:  integer library(tinycodet)  for(i in 1:3) {   y <- sb_x(x, n(i), 3) |> drop()   rp <- y %col~% y   sb_set(x, n(i), 3, rp = rp) } print(x) #> , , 1 #>  #>      [,1] [,2] [,3] #> [1,]   12    5    4 #> [2,]   13    6   22 #> [3,]   23   15   26 #>  #> , , 2 #>  #>      [,1] [,2] [,3] #> [1,]    9    8    2 #> [2,]   17   21    7 #> [3,]   24   27   16 #>  #> , , 3 #>  #>      [,1] [,2] [,3] #> [1,]   10   11    1 #> [2,]   18   14    3 #> [3,]   20   25   19 #>  #> mutable_atomic  #> typeof:  integer x <- mutable_atomic(sample(c(letters, 1e3)), dim = c(3,3,3)) print(x) #> , , 1 #>  #>      [,1] [,2] [,3] #> [1,] \"v\"  \"u\"  \"j\"  #> [2,] \"k\"  \"f\"  \"b\"  #> [3,] \"g\"  \"i\"  \"q\"  #>  #> , , 2 #>  #>      [,1] [,2] [,3]   #> [1,] \"a\"  \"c\"  \"1000\" #> [2,] \"w\"  \"n\"  \"p\"    #> [3,] \"t\"  \"r\"  \"e\"    #>  #> , , 3 #>  #>      [,1] [,2] [,3] #> [1,] \"h\"  \"o\"  \"s\"  #> [2,] \"m\"  \"y\"  \"z\"  #> [3,] \"d\"  \"x\"  \"l\"  #>  #> mutable_atomic  #> typeof:  character for(i in 1:3) {   y <- sb_x(x, n(i), 3) |> drop()   rp <- y %col~% stringi::stri_rank(y)   sb_set(x, n(i), 3, rp = rp) } print(x) #> , , 1 #>  #>      [,1] [,2] [,3] #> [1,] \"g\"  \"f\"  \"b\"  #> [2,] \"k\"  \"i\"  \"j\"  #> [3,] \"v\"  \"u\"  \"q\"  #>  #> , , 2 #>  #>      [,1] [,2] [,3]   #> [1,] \"a\"  \"c\"  \"1000\" #> [2,] \"t\"  \"n\"  \"e\"    #> [3,] \"w\"  \"r\"  \"p\"    #>  #> , , 3 #>  #>      [,1] [,2] [,3] #> [1,] \"d\"  \"o\"  \"l\"  #> [2,] \"h\"  \"x\"  \"s\"  #> [3,] \"m\"  \"y\"  \"z\"  #>  #> mutable_atomic  #> typeof:  character"},{"path":"https://tony-aw.github.io/squarebrackets/articles/Extra_Examples.html","id":"mutate-column-of-data-table","dir":"Articles","previous_headings":"","what":"Mutate column of data.table","title":"Additional Examples","text":"can mutate column data.table reference, combining ‘squarebrackets’ tinycodet::with_pro(), follows:  ","code":"x <- sf::st_read(system.file(\"shape/nc.shp\", package = \"sf\")) #> Reading layer `nc' from data source `D:\\Programs\\R-4.4.0\\library\\sf\\shape\\nc.shp' using driver `ESRI Shapefile' #> Simple feature collection with 100 features and 14 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 #> Geodetic CRS:  NAD27 x <- dt.$as.data.table(x)  myform <- ~ PERIMETER / AREA x$newcolumn <- 1:nrow(x) mutated <- dt.$as.data.table(with_pro(x, myform)) sb2_set(x, col = \"newcolumn\", rp = mutated) summary(x) #>       AREA          PERIMETER         CNTY_         CNTY_ID     #>  Min.   :0.0420   Min.   :0.999   Min.   :1825   Min.   :1825   #>  1st Qu.:0.0910   1st Qu.:1.324   1st Qu.:1902   1st Qu.:1902   #>  Median :0.1205   Median :1.609   Median :1982   Median :1982   #>  Mean   :0.1263   Mean   :1.673   Mean   :1986   Mean   :1986   #>  3rd Qu.:0.1542   3rd Qu.:1.859   3rd Qu.:2067   3rd Qu.:2067   #>  Max.   :0.2410   Max.   :3.640   Max.   :2241   Max.   :2241   #>      NAME               FIPS               FIPSNO         CRESS_ID      #>  Length:100         Length:100         Min.   :37001   Min.   :  1.00   #>  Class :character   Class :character   1st Qu.:37051   1st Qu.: 25.75   #>  Mode  :character   Mode  :character   Median :37100   Median : 50.50   #>                                        Mean   :37100   Mean   : 50.50   #>                                        3rd Qu.:37150   3rd Qu.: 75.25   #>                                        Max.   :37199   Max.   :100.00   #>      BIR74           SID74          NWBIR74           BIR79       #>  Min.   :  248   Min.   : 0.00   Min.   :   1.0   Min.   :  319   #>  1st Qu.: 1077   1st Qu.: 2.00   1st Qu.: 190.0   1st Qu.: 1336   #>  Median : 2180   Median : 4.00   Median : 697.5   Median : 2636   #>  Mean   : 3300   Mean   : 6.67   Mean   :1050.8   Mean   : 4224   #>  3rd Qu.: 3936   3rd Qu.: 8.25   3rd Qu.:1168.5   3rd Qu.: 4889   #>  Max.   :21588   Max.   :44.00   Max.   :8027.0   Max.   :30757   #>      SID79          NWBIR79                 geometry     newcolumn     #>  Min.   : 0.00   Min.   :    3.0   MULTIPOLYGON :100   Min.   : 8.35   #>  1st Qu.: 2.00   1st Qu.:  250.5   epsg:4267    :  0   1st Qu.:11.62   #>  Median : 5.00   Median :  874.5   +proj=long...:  0   Median :13.32   #>  Mean   : 8.36   Mean   : 1352.8                       Mean   :14.49   #>  3rd Qu.:10.25   3rd Qu.: 1406.8                       3rd Qu.:16.11   #>  Max.   :57.00   Max.   :11631.0                       Max.   :42.40"},{"path":"https://tony-aw.github.io/squarebrackets/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Tony Wilkes. Author, maintainer, copyright holder.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Wilkes T (2024). squarebrackets: Subset Methods Alternatives Square Brackets Operators Programming. R package version 0.0.0.9, https://tony-aw.github.io/squarebrackets/, https://github.com/tony-aw/squarebrackets/.","code":"@Manual{,   title = {squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming},   author = {Tony Wilkes},   year = {2024},   note = {R package version 0.0.0.9, https://tony-aw.github.io/squarebrackets/},   url = {https://github.com/tony-aw/squarebrackets/}, }"},{"path":"https://tony-aw.github.io/squarebrackets/index.html","id":"squarebrackets","dir":"","previous_headings":"","what":"Subset Methods as Alternatives to the Square Brackets Operators for Programming","title":"Subset Methods as Alternatives to the Square Brackets Operators for Programming","text":"squarebrackets: Subset Methods Alternatives Square Brackets Operators Programming","code":""},{"path":"https://tony-aw.github.io/squarebrackets/index.html","id":"description","dir":"","previous_headings":"","what":"Description","title":"Subset Methods as Alternatives to the Square Brackets Operators for Programming","text":"Provides subset methods (supporting atomic recursive S3 classes) may convenient alternatives [ [<- operators, whilst maintaining similar performance. nice properties methods include, limited , following: [ [<- operators use different rule-sets different data.frame-like types (data.frames, tibbles, data.tables, tidytables, etc.). ‘squarebrackets’ methods use rule-sets different data.frame-like types. Performing dimensional subset operations array using [ [<-, requires -priori knowledge number dimensions array . ‘squarebrackets’ methods work arbitrary dimensions without requiring prior knowledge. selecting names [ [<- operators, first occurrence names selected case duplicate names. ‘squarebrackets’ methods always perform names case duplicates, just first. [[ [[<- operators allow operating recursive subset nested list. operate single recursive subset, vectorized multiple recursive subsets nested list . ‘squarebrackets’ provides way reshape nested list 2D recursive array lists, thereby allowing vectorized operations recursive subsets nested list. [<- operator supports copy--modify semantics classes. ‘squarebrackets’ methods provides explicit pass--reference pass--value semantics, whilst still respecting things like binding-locks mutability rules. ‘squarebrackets’ supports index-less sub-set operations, faster memory efficient sub-set operations using [ [<- operators.  ","code":""},{"path":"https://tony-aw.github.io/squarebrackets/index.html","id":"get-started","dir":"","previous_headings":"","what":"Get Started","title":"Subset Methods as Alternatives to the Square Brackets Operators for Programming","text":"get started see ?squarebrackets_help  ","code":""},{"path":"https://tony-aw.github.io/squarebrackets/index.html","id":"installing--loading","dir":"","previous_headings":"","what":"Installing & Loading","title":"Subset Methods as Alternatives to the Square Brackets Operators for Programming","text":"One can install ‘squarebrackets’ GitHub like : Special care taken make sure function names clear, function names unlikely conflict core R, recommended R packages, rstudioapi package, major packages fastverse. one can attach package - thus exposing functions namespace - using: user wish expose specific functions ‘squarebrackets’ within current/local environment, one can use following:  ","code":"remotes::install_github(\"https://github.com/tony-aw/squarebrackets\") library(squarebrackets) tinycodet::import_LL(\"squarebrackets\", selection = ... )"},{"path":"https://tony-aw.github.io/squarebrackets/index.html","id":"changelog-experimental-versions","dir":"","previous_headings":"","what":"Changelog (EXPERIMENTAL VERSIONS)","title":"Subset Methods as Alternatives to the Square Brackets Operators for Programming","text":"10 March 2024: First GitHub upload - Package much experimental. 12 March 2024: Changed introduction help page bit, added dt_setadd(), added tests dt_ - functions. slightly 50,000 tests now. 15 March 2024: Added sb_setRename() method, added tests method also. 16 March 2024: Fixed bug “rcpp_set_rowcol” source code. Tweaked documentation bit. Improved tests bit. 17 March 2024: Added tests, tweaked documentation bit. 19 March 2024: methods/functions support mutable_atomic type “complex”; now fixed. Added support mutable_atomic type “raw”. Added tests atomic type handling. Added functions ma_setv(), couldb.mutable_atomic(). Added options “sb.rat” “sb.chkdup”; argument chkdup now also set FALSE default. Added badges documentation. 20 March 2024: user can now also specify coe = TRUE sb_mod.data.frame(). 24 March 2024: Methods now split methods non-recursive objects (sb_), methods recursive objects (sb2_). 26 March 2024: Replaced seq_rec() seq_rec2(). 27 March 2024: Added dt_setreorder(), added tests also. ‘abind’ now dependency, ‘abind’ based code removed, redundant. 29 March 2024: Added sb2_before.array() sb2_after.array(), added tests also. Added tests data.frame-like coercion types. Tweaked documentation bit. 30 March 2024: Removed separate NA checks, redundant. Fixed linguistic mistakes documentation. 1 April 2024: Removed sb_coe() kept sb2_coe(). Added inv argument sb_mod()/sb2_mod(), sb_set()/sb2_set(), sb2_coe(), added tests . Added idx1() Copy--Modification Substitution, added tests idx1() also.Fixed bug character subset ordering sb/sb2_mod/set/coe - generic methods. Fixed bug introduction message. Added even tests. Added idx1_dim(), added tests also. 5 April 2024: Replaced idx1/idx0 idx(). 18 May 2024: Added tests idx() method (need add ). Fixed export pattern expressions Namespace file. Adjusted documentation. 26 May 2024: Removed sb2_coe(), redundant. 6 June 2024: Removed sb(2)_before/methods favour new bind_/bind2_ implementations. Added lst_ functions. Added options help page. 30 June 2024: Re-written internal code arrays. Added support backward indexing via Complex Vector indices. Added tests. Replaced seq_names() new far flexible idx_r() function. 31 August 2024: Made tests efficient. Removed separate method dispatch factors, using default atomic vector method dispatch sufficient factors. 7 September 2024: Incorporated ALTREP functionality package. 15 September 2024: Replaced drop argument red avoid confusion base R’s drop mechanic. Small performance improvements sub2ind() sb_set.array(). 26 September 2024: Overhauled indexing complex vectors work. 28 September 2024: Split sb(2)_setRename() sb_setFlatnames(), sb_setDimnames(), sb2_setVarnames(). 10 October 2024: sb_mod() now makes partial copies data.frame-like objects instead whole copies, memory efficiency. Also removed old sb_str() sb_a() functions. Renamed ci_seq() cp_seq() (preparation next update). 19 October 2024: Removed renaming methods (sb_setRename), seq_rec2(). Added slcseq()  ","code":""},{"path":"https://tony-aw.github.io/squarebrackets/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 Tony Wilkes Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa0_squarebrackets_help.html","id":null,"dir":"Reference","previous_headings":"","what":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa0_squarebrackets_help","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa0_squarebrackets_help","text":"squarebrackets: Subset Methods Alternatives Square Brackets Operators Programming","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa0_squarebrackets_help.html","id":"goal-amp-properties","dir":"Reference","previous_headings":"","what":"Goal & Properties","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa0_squarebrackets_help","text":"Among programming languages, 'R' perhaps one flexible comprehensive sub-setting functionality, provided square brackets operators ([, [<-).  situations square brackets operators occasionally less optimally convenient  (see squarebrackets_inconveniences).  Goal 'squarebrackets' package replace square-brackets operators, provide alternative sub-setting methods functions, used situations square bracket operators inconvenient.  alternative sub-setting methods functions following properties: Programmatically friendly: Unlike base [, required know number dimensions array -priori, perform subset-operations array. Missing arguments can filled NULL, instead using dark magic like base::quote(expr =    ). Non-standard evaluation. Functions pipe-friendly. (silent) vector recycling. Extracting removing subsets uses syntax. Class consistent: sub-setting multi-dimensional objects specifying dimensions (.e. rows, columns, ...) use drop = FALSE.  matrix , matrix . methods deliver results data.frames, data.tables, tibbles, tidytables.  longer one re-learn different brackets-based sub-setting rules different types data.frame-like objects.  Powered subclass agnostic 'C'-code 'collapse' 'data.table'. Explicit copy semantics: Sub-set operations change memory allocations, always return modified (partial) copy object. sub-set operations just change values -place (similar [<- [[<- methods) user can choose method modifies object reference, choose method returns (partial) copy. Careful handling names: Sub-setting object index names returns matches given names, just first. Data.frame-like objects (see supported classes ) forced unique column names. Sub-setting arrays using x[indx1, indx2, etc.] drop names(x).  methods 'squarebrackets' drop names(x). Concise function argument names. Performance aware:  Despite many checks performed, functions kept reasonably speedy, use 'Rcpp', 'collapse', 'data.table' R-packages.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa0_squarebrackets_help.html","id":"supported-classes","dir":"Reference","previous_headings":"","what":"Supported Classes","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa0_squarebrackets_help","text":"'squarebrackets' supports S3 classes, primarily use square brackets sub-setting (hence name package).  Supported immutable classes: atomic, list, data.frame (including tibble, sf-data.frame, sf-tibble).  Supported  mutable classes: mutable_atomic, data.table (including tidytable, sf-data.table, sf-tidytable).  , course, lot classes supported 'squarebrackets'.  notably, key-value stores - environments, various 'collections' classes 'collections' package - supported.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa0_squarebrackets_help.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa0_squarebrackets_help","text":"main focus package generic methods dimensional binding implementations.  Generic methods atomic objects start sb_.  Generic methods recursive objects (list, data.frame, etc.) start sb2_.  binding implementations atomic dimensional objects (atomic arrays) start bind_.  binding implementations recursive dimensional objects (recursive arrays, data.frames) start bind2_.  also somewhat separate idx method, works recursive non-recursive objects.  finally slcseq_ methods, (currently) work atomic vectors.  sb_x, sb2_x: extract, exchange, duplicate subsets. sb_rm,  sb2_rm: un-select/remove subsets. sb2_rec: access recursive subsets lists. slcseq_x, slcseq_rm: efficiently extract remove subset (long) vector.  idx: translate given indices/subscripts, purpose copy--modify substitution. sb2_recin: replace, transform, remove, add recursive subsets list, R's default Copy--Modify semantics. sb_mod, sb2_mod: return (partial) copy object modified (transformed replaced) subsets. sb_set, sb2_set: modify (transform replace) subsets mutable object using pass--reference semantics. slcseq_set: efficiently modify (long) vector subset using pass--reference semantics.  bind_, bind2_:  implementations binding dimensional objects. cp_seq: construct parameters margin-based sequences.  actually method, can used predict exact sequence lay-, like used slcseq_ methods. example, use sb_rm() remove subsets atomic arrays, use sb2_rm() remove subsets recursive arrays.  See squarebrackets_method_dispatch information 'squarebrackets' uses S3 Method dispatch.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa0_squarebrackets_help.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa0_squarebrackets_help","text":"Additional specialized sub-setting functions provided: lst_untree: unnest tree-like nested list recursive array, make vectorized sub-setting recursive subsets list easier. dt_-functions programmatically perform data.table-specific [-operations, security measures provided 'squarebrackets' package. setapply: apply functions mutable matrix margins using pass--reference semantics. ma_setv: Find & Replace values mutable_atomic objects using pass--reference semantics.  considerably faster memory efficient using sb_set . couple helper functions creating ranges, sequences, indices (often needed sub-setting) provided: currentBindings: list lock currently existing bindings share share address input variable. n: Nested version c, short-hand list. sub2coord, coord2ind: Convert subscripts (array indices) coordinates, coordinates flat indices, vice-versa. match_all: Find matches, one vector another, taking account order duplicate values vectors. Computing indices: idx_r compute integer index range. idx_by compute grouped indices. idx_ord_-functions compute ordered indices.  finally developer functions constructing indices.  also used internally 'squarebrackets', package authors can use create additional sb_/sb2_ S3 methods, even entirely new subset-related functions. tci_ functions, type-casting indices. ci_ functions, constructing indices. indx_x indx_rm, testing methods.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa0_squarebrackets_help.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa0_squarebrackets_help","text":"badges shown documentation R-package made using services : https://shields.io/","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa0_squarebrackets_help.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators for Programming — aaa0_squarebrackets_help","text":"Maintainer: Tony Wilkes tony_a_wilkes@outlook.com (ORCID)","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa1_squarebrackets_immutable_classes.html","id":null,"dir":"Reference","previous_headings":"","what":"Supported Immutable S3 Classes, With Auto-Coercion Rules — aaa1_squarebrackets_immutable_classes","title":"Supported Immutable S3 Classes, With Auto-Coercion Rules — aaa1_squarebrackets_immutable_classes","text":"sb_ generic methods support following immutable S3 classes: base atomic vector classes  (atomic vectors, matrices, arrays). classes derived atomic vectors  (factors, date, POSIXct, etc.).  'squarebrackets' treats classes regular atomic vectors. base list classes  (recursive vectors, matrices, arrays)  (note lists merely pointers objects, objects may different class may even mutable). data.frame  (including classes tibble, sf-data.frame sf-tibble). Note \"immutable\" mean modify .  simply means modification leads copy made.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa1_squarebrackets_immutable_classes.html","id":"auto-coercion-rules","dir":"Reference","previous_headings":"","what":"Auto-Coercion Rules","title":"Supported Immutable S3 Classes, With Auto-Coercion Rules — aaa1_squarebrackets_immutable_classes","text":"Atomic  Atomic objects automatically coerced fit modified subset values, modifying copy.  example, replacing one multiple values integer vector (type int) decimal number (type dbl) coerce entire vector type dbl. Derived Atomic  Factors, datetime, POSIXct derived atomic vectors, attributes special methods make behave differently.  Depending behaviour, may may allow coercion.  Factors, example, accept values part levels, thus support coercion modification.  highly specialized packages handle objects derived atomic objects.  example 'forcats' package handling factors, 'anytime' package handle ddate-time objects. List  Lists allow complete change elements, since lists merely pointers.  example, following code performs full coercion:   However, recursive subset list list, follows coercion rules whatever class recursive subset .  example following code:   transforms recursive subsets according - case - atomic auto-coercion rules. Data.frames replacing/transforming whole columns  data.frame actually list, column list. , replacing/transforming whole columns, row = NULL filter = NULL, allows completely changing type column.  Note coercion columns needs arguments row = NULL filter = NULL sb_mod sb_set methods; auto-coercion take place specifying something like row = 1:nrow(x) (see next section). Data.frames, partially replacing/transforming columns  rows specified sb_mod sb_set methods, thus whole columns parts columns replaced transformed, auto-coercion takes place.  .e.: replacing/transforming value integer (int) column become 1.5, coerce column decimal type (dbl); instead, replacement value 1.5 coerced integer 1.  coe argument sb_mod method allows user enforce coercion, even subsets columns replaced/transformed instead whole columns.  Specifically, coe arguments allows user specify coercive function applied entirety every column specified col vars; columns outside subset affected.  coercion function , course, applied replacement (rp) transformation (tf()).","code":"x <- list(factor(letters), factor(letters)) sb_mod(x, 1, rp = list(1)) x <- list(1:10, 1:10) sb_rec(x, 1, rp = \"a\") # coerces to character"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa1_squarebrackets_immutable_classes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Supported Immutable S3 Classes, With Auto-Coercion Rules — aaa1_squarebrackets_immutable_classes","text":"","code":"# Coercion examples - lists ==== x <- list(factor(letters), factor(letters)) print(x) #> [[1]] #>  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z #> Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z #>  #> [[2]] #>  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z #> Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z #>  sb2_mod(x, 1, rp = list(1)) # first element fully changed. #> [[1]] #> [1] 1 #>  #> [[2]] #>  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z #> Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z #>   x <- list(1:10, 1:10) print(x) #> [[1]] #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> [[2]] #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  sb2_recin(x, 1, rp = \"a\") # coerces first element to character print(x) #> [[1]] #> [1] \"a\" #>  #> [[2]] #>  [1]  1  2  3  4  5  6  7  8  9 10 #>    #############################################################################   # Coercion examples - data.frame-like - whole columns ====  obj <- data.frame(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 sb2_mod(   obj, vars = is.numeric,   tf = sqrt # SAFE: row=NULL & filter = NULL, so coercion performed ) #>           a b        c d #> 1  1.000000 a 3.316625 a #> 2  1.414214 b 3.464102 b #> 3  1.732051 c 3.605551 c #> 4  2.000000 d 3.741657 d #> 5  2.236068 e 3.872983 e #> 6  2.449490 f 4.000000 f #> 7  2.645751 g 4.123106 g #> 8  2.828427 h 4.242641 h #> 9  3.000000 i 4.358899 i #> 10 3.162278 j 4.472136 j  #############################################################################   # Coercion examples - data.frame-like - partial columns ====  # sb_mod(): obj <- data.frame(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10  sb2_mod(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost ) #> Warning: 1.414214 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 1 named 'a') #> Warning: 3.464102 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 3 named 'c') #>     a b  c d #> 1   1 a 11 a #> 2   1 b  3 b #> 3   1 c  3 c #> 4   2 d  3 d #> 5   2 e  3 e #> 6   2 f  4 f #> 7   2 g  4 g #> 8   8 h 18 h #> 9   9 i 19 i #> 10 10 j 20 j sb2_mod(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   coe = as.double, tf = sqrt # SAFE: coercion performed ) #>            a b         c d #> 1   1.000000 a 11.000000 a #> 2   1.414214 b  3.464102 b #> 3   1.732051 c  3.605551 c #> 4   2.000000 d  3.741657 d #> 5   2.236068 e  3.872983 e #> 6   2.449490 f  4.000000 f #> 7   2.645751 g  4.123106 g #> 8   8.000000 h 18.000000 h #> 9   9.000000 i 19.000000 i #> 10 10.000000 j 20.000000 j"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa2_squarebrackets_mutable_classes.html","id":null,"dir":"Reference","previous_headings":"","what":"Supported Mutable S3 Classes, With Auto-Coercion Rules — aaa2_squarebrackets_mutable_classes","title":"Supported Mutable S3 Classes, With Auto-Coercion Rules — aaa2_squarebrackets_mutable_classes","text":"sb_ generic methods support following Mutable S3 classes: mutable_atomic (vector class supports dimension, thus also matrices arrays); data.table (including classes tidytable sf-data.table); Views Lists: Though lists treated immutable, lists can contain mutable objects, modification reference mutable views lists support 'squarebrackets'. mutable version list class environment class, various key-value storage classes available packages, 'collapse' package.  Key-value storage classes generally use square brackets primary sub-setting method, thus covered package.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa2_squarebrackets_mutable_classes.html","id":"auto-coercion-rules","dir":"Reference","previous_headings":"","what":"Auto-Coercion Rules","title":"Supported Mutable S3 Classes, With Auto-Coercion Rules — aaa2_squarebrackets_mutable_classes","text":"Coercion Semantics  mutable classes support \"copy--modify\" semantics like immutable classes, - unlike immutable classes - also support \"pass--reference\" semantics.  sb_mod method modify subsets object (partial) copy.  sb_set method dt_setcoe function modify subsets object reference.  2 copy semantics - \"pass reference\" \"modify copy\" - slightly different auto-coercion rules.  explained section. mutable_atomic  Mutable atomic objects automatically coerced fit modified subset values, modifying copy, just like regular atomic classes.  example, replacing one multiple values integer vector (type int) decimal number (type dbl) coerce entire vector type dbl.  Replacing transforming subsets mutable atomic objects reference support coercion. Thus, example, following code,   gives c(rep(8, 6) 7:16) instead c(rep(8.5, 6), 7:16), x type integer, rp interpreted type integer also. data.table, replacing/transforming whole columns  data.table actually list made mutable, column list. , replacing/transforming whole columns, row = NULL filter = NULL, allows completely changing type column.  Note coercion columns needs arguments row = NULL filter = NULL sb_mod sb_set methods; auto-coercion take place specifying something like row = 1:nrow(x) (see next section). data.table, partially replacing/transforming columns  rows specified sb_mod sb_set methods, thus whole columns parts columns replaced transformed, auto-coercion takes place.  .e.: replacing/transforming value integer (int) column become 1.5, coerce column decimal type (dbl); instead, replacement value 1.5 coerced integer 1.  coe argument sb_mod method allows user enforce coercion, even subsets columns replaced/transformed instead whole columns.  Specifically, coe arguments allows user specify coercive function applied entirety every column specified col vars; columns outside subset affected.  coercion function , course, applied replacement (rp) transformation (tf()). Views Lists  Regular lists treated mutable objects 'squarebrackets'.  However, lists actually really objects, merely (potentially hierarchical) structure pointers.  Thus, even list treated mutable, subsets list mutable classes, mutable.  example, list data.table objects, data.tables mutable.  Therefore, following work:   Notice code mypointer copy x$, since address.  Thus changing mypointer also changes x$.  words: mypointer called \"view\" x$.  Notice also sb_set(x$, ...) work, since sb_set() requires actual variables, similar -place functions style `myfun()<-`.  auto-coercion rules Views Lists, depends entirely object .  Thus View data.table, coercion rules data.tables apply.  View mutable_atomic matrix, coercion rules mutable_atomic matrices apply, etc.","code":"x <- 1:16 sb_set(x, i = 1:6, rp = 8.5) x x <- list(  a = data.table(cola = 1:10, colb = letters[1:10]),  b = data.table(cola = 11:20, colb = letters[11:20]) ) mypointer <- x$a sb_set(mypointer, col = \"cola\", tf = \\(x)x^2)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa2_squarebrackets_mutable_classes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Supported Mutable S3 Classes, With Auto-Coercion Rules — aaa2_squarebrackets_mutable_classes","text":"","code":"# Coercion examples - mutable_atomic ====  x <- as.mutable_atomic(1:16) sb_set(x, i = 1:6, rp = 8.5) # 8.5 coerced to 8, because `x` is of type `integer` #> coercing `rp` to integer print(x) #>  [1]  8  8  8  8  8  8  7  8  9 10 11 12 13 14 15 16 #> mutable_atomic  #> typeof:  integer   #############################################################################  # Coercion examples - data.table - whole columns ====  # sb_mod(): obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb2_mod(   obj, vars = is.numeric,   tf = sqrt # SAFE: row=NULL & filter = NULL, so coercion performed ) #>            a      b        c      d #>        <num> <char>    <num> <fctr> #>  1: 1.000000      a 3.316625      a #>  2: 1.414214      b 3.464102      b #>  3: 1.732051      c 3.605551      c #>  4: 2.000000      d 3.741657      d #>  5: 2.236068      e 3.872983      e #>  6: 2.449490      f 4.000000      f #>  7: 2.645751      g 4.123106      g #>  8: 2.828427      h 4.242641      h #>  9: 3.000000      i 4.358899      i #> 10: 3.162278      j 4.472136      j  # sb_set(): sb2_set(   obj, vars = is.numeric,   tf = sqrt # SAFE: row=NULL & filter = NULL, so coercion performed ) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 1.41 1.73 2 2.24 ... #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  3.32 3.46 3.61 3.74 3.87 ... #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>   #############################################################################   # Coercion examples - data.table - partial columns ====  # sb_mod(): obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>   sb2_mod(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt   # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost )  #> Warning: 1.414214 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 1 named 'a') #> Warning: 3.464102 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 3 named 'c') #>         a      b     c      d #>     <int> <char> <int> <fctr> #>  1:     1      a    11      a #>  2:     1      b     3      b #>  3:     1      c     3      c #>  4:     2      d     3      d #>  5:     2      e     3      e #>  6:     2      f     4      f #>  7:     2      g     4      g #>  8:     8      h    18      h #>  9:     9      i    19      i #> 10:    10      j    20      j sb2_mod(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   coe = as.double, tf = sqrt # SAFE: coercion performed ) #>             a      b         c      d #>         <num> <char>     <num> <fctr> #>  1:  1.000000      a 11.000000      a #>  2:  1.414214      b  3.464102      b #>  3:  1.732051      c  3.605551      c #>  4:  2.000000      d  3.741657      d #>  5:  2.236068      e  3.872983      e #>  6:  2.449490      f  4.000000      f #>  7:  2.645751      g  4.123106      g #>  8:  8.000000      h 18.000000      h #>  9:  9.000000      i 19.000000      i #> 10: 10.000000      j 20.000000      j  # sb_set(): obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb2_set(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt   # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost ) #> Warning: 1.414214 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 1 named 'a') #> Warning: 3.464102 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 3 named 'c') print(obj) #>         a      b     c      d #>     <int> <char> <int> <fctr> #>  1:     1      a    11      a #>  2:     1      b     3      b #>  3:     1      c     3      c #>  4:     2      d     3      d #>  5:     2      e     3      e #>  6:     2      f     4      f #>  7:     2      g     4      g #>  8:     8      h    18      h #>  9:     9      i    19      i #> 10:    10      j    20      j  obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  dt_setcoe(obj, vars = is.numeric, v = as.numeric) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb2_set(obj,   filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # SAFE: coercion performed by dt_setcoe(); so no warnings )  print(obj) #>             a      b         c      d #>         <num> <char>     <num> <fctr> #>  1:  1.000000      a 11.000000      a #>  2:  1.414214      b  3.464102      b #>  3:  1.732051      c  3.605551      c #>  4:  2.000000      d  3.741657      d #>  5:  2.236068      e  3.872983      e #>  6:  2.449490      f  4.000000      f #>  7:  2.645751      g  4.123106      g #>  8:  8.000000      h 18.000000      h #>  9:  9.000000      i 19.000000      i #> 10: 10.000000      j 20.000000      j   #############################################################################  # View of List ====  x <- list(  a = data.table::data.table(cola = 1:10, colb = letters[1:10]),  b = data.table::data.table(cola = 11:20, colb = letters[11:20]) ) print(x) #> $a #>      cola   colb #>     <int> <char> #>  1:     1      a #>  2:     2      b #>  3:     3      c #>  4:     4      d #>  5:     5      e #>  6:     6      f #>  7:     7      g #>  8:     8      h #>  9:     9      i #> 10:    10      j #>  #> $b #>      cola   colb #>     <int> <char> #>  1:    11      k #>  2:    12      l #>  3:    13      m #>  4:    14      n #>  5:    15      o #>  6:    16      p #>  7:    17      q #>  8:    18      r #>  9:    19      s #> 10:    20      t #>  mypointer <- x$a address(mypointer) == address(x$a) # they are the same #> [1] TRUE sb2_set(mypointer, col = \"cola\", tf = \\(x)x^2) print(x) # notice x has been changed #> $a #>      cola   colb #>     <num> <char> #>  1:     1      a #>  2:     4      b #>  3:     9      c #>  4:    16      d #>  5:    25      e #>  6:    36      f #>  7:    49      g #>  8:    64      h #>  9:    81      i #> 10:   100      j #>  #> $b #>      cola   colb #>     <int> <char> #>  1:    11      k #>  2:    12      l #>  3:    13      m #>  4:    14      n #>  5:    15      o #>  6:    16      p #>  7:    17      q #>  8:    18      r #>  9:    19      s #> 10:    20      t #>"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":null,"dir":"Reference","previous_headings":"","what":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"6 types arguments can used generic methods 'squarebrackets' specify indices perform operations : : specify flat (.e. dimensionless) indices. row, col: specify rows /columns tabular objects. sub, dims: specify indices arbitrary dimensions arrays. filter, vars: specify rows /columns specifically data.frame-like objects. margin, slice: specify indices one particular dimension. help page x refers object subset operations performed.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"fundamentals","dir":"Reference","previous_headings":"","what":"Fundamentals","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"Base 'R' supports indexing logical, integer, character vectors.  'squarebrackets' suppports also (albeit improvements), also supports additional methods indexing. Whole numbers  Whole numbers basic form index selection.  forms indexing 'squarebrackets' internally translated integer (double > (2^31 - 1)) indexing first, ensuring consistency.  Indexing integer/numeric indices 'squarebrackets' works base 'R', except negative values allowed. Logical  Selecting indices logical vector 'squarebrackets' works base 'R', except recycling allowed.  Thus logical vector must correct length (.e. length(x) dim(x)[L], depending situation). Characters  selecting indices using character vector, base 'R' selects first matches names.  'squarebrackets', however, selects matches.  Character indices internally translated integer indices using match_all. Imaginary Numbers  complex vector y structured y = + b *  Re(y) returns , Im(y) returns b.  squarebrackets' includes support indexing imaginary numbers (Im(y)) complex vectors.  Indexing imaginary numbers generalization indexing regular integers.  works follows:  Imaginary numbers positive integers, like 1:10 * 1i, work regular integers.  Imaginary numbers negative integers, like 1:10 * -1i, index counting backwards (.e. end), integer indices computed n + Im(y) + 1L.  n maximum possible integer (.e. length(x), dim(x)[L], depending situation), Im(y) negative.  Note Imaginary part complex vector used (Im(y));  Real part (Re(y)) ignored.  See results following code example:   Thus complex vectors allow user choose counting beginning, like regular integers, counting end.  follows detailed descriptions common arguments 'squarebrackets' used select indices.","code":"x <- 1:30 # vector of 30 elements  sb_x(x, 1:10 * 1i) # extract first 10 elements #>  [1]  1  2  3  4  5  6  7  8  9 10  sb_x(x, 1:10 * -1i) # extract last 10 elements #>  [1] 30 29 28 27 26 25 24 23 22 21  sb_x(x, 10:1 * -1i) # last 10 elements, in tail()-like order #>  [1] 21 22 23 24 25 26 27 28 29 30"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"argument-i","dir":"Reference","previous_headings":"","what":"Argument i","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"following can specified argument : NULL, corresponds missing argument. vector length 0, case indices selected operation (.e. empty selection). strictly positive whole numbers vector indices. complex vector, explained start help page. logical vector, length x, giving indices select operation. character vector index names.  object multiple indices given name, corresponding indices selected operation. function takes input x, returns logical vector, giving element indices select operation.  atomic objects, interpreted (x).  recursive objects, interpreted lapply(x, ). Using arguments corresponds something like following:","code":"sb_x(x, i = i) # ==> x[i]"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"arguments-row-col","dir":"Reference","previous_headings":"","what":"Arguments row, col","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"following can specified arguments row / col: NULL (default), corresponds missing argument. vector length 0, case indices selected operation (.e. empty selection). strictly positive whole numbers vector dimension indices select operation. complex vector, explained start help page. logical vector length corresponding dimension size, giving indices dimension select operation. character vector index names.  dimension multiple indices given name, corresponding indices selected operation. NOTE: arguments row col ignored specified. Using row, col arguments corresponds something like following:","code":"sb_x(x, row = row, col = col) # ==> x[row, col, drop = FALSE]"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"argument-pair-sub-dims","dir":"Reference","previous_headings":"","what":"Argument Pair sub, dims","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"sub, dims argument pair inspired abind::asub function 'abind' package (see reference ). dims must integer vector length sub, giving dimensions select indices (.e. dims specifies \"non-missing\" index margins). sub must list subscripts, length dims. element sub can following: vector length 0, case indices selected operation (.e. empty selection). strictly positive whole numbers vector dimension indices select operation. complex vector, explained start help page. logical vector length corresponding dimension size, giving indices dimension select operation. character vector index names.  dimension multiple indices given name, corresponding indices selected operation. Note also following: dims single integer, one can specify sub atomic vector specified types, instead list length 1. stated, dims specifies index margins non-missing.  dims - thus also sub - length 0, taken \"index margins missing\". keep syntax short, user can use n function instead list() specify sub.  Using sub, dims arguments, corresponds something like following, using example extracting subsets 4-dimensional array:   brief explanation relationship flat indices (), dimensional subscripts (sub, dims), see Details section sub2ind.","code":"sb_x(x, n(1:10, 1:5), c(1, 3)) # ==> x[1:10, , 1:5, , drop = FALSE]"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"arguments-filter-vars","dir":"Reference","previous_headings":"","what":"Arguments filter, vars","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"filter must one-sided formula single logical expression using column names data.frame, giving condition observation/row indices selected operation.  example, perform operation rows column height > 2 column sex != \"female\", specify following formula:   formula linked environment, variables found data set searched environment. vars must function returns logical vector, giving column indices select operation.  example, select numeric columns, specify vars = .numeric.","code":"~ (height > 2) & (sex != \"female\")"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"argument-pair-margin-slice","dir":"Reference","previous_headings":"","what":"Argument Pair margin, slice","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"Relevant idx method.  margin argument specifies dimension argument slice used.  .e. margin = 1, slice selects rows;  margin = 2, slice selects columns;  etc.  slice argument can following: strictly positive whole numbers vector dimension indices select operation. complex vector, explained start help page. logical vector length corresponding dimension size, giving dimension indices select operation. character vector index names.  dimension multiple indices given name, corresponding indices selected operation. One also give vector length 0 slice;  Argument slice used idx method , result idx meant used inside regular [ [<- operators.  Thus result zero-length index specification depends rule-set [.class(x) [<-.class(x).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"argument-inv","dir":"Reference","previous_headings":"","what":"Argument inv","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"Relevant sb_mod/sb2_mod, sb_set/sb2_set, idx methods.  default, inv = FALSE, translates indices like normally.  inv = TRUE, inverse indices taken.  Consider, example, atomic matrix x;  using sb_mod(x, col = 1:2, tf = tf) corresponds something like following:   using sb_mod(x, col = 1:2, inv = TRUE, tf = tf) corresponds something like following:   NOTE  order user gives indices inv = TRUE generally matter.  order indices appear original object x maintained, just like base 'R'.  Therefore, replacing multiple values order replacement matters, better keep inv = FALSE, default.  replacement single value transformation function, inv = TRUE can used without considering ordering.","code":"x[, 1:2] <- tf(x[, 1:2]) x x[, -1:-2] <- tf(x[, -1:-2]) x"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"all-null-indices","dir":"Reference","previous_headings":"","what":"All NULL indices","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"NULL indexing arguments corresponds missing argument.  Thus, sb_x sb_rm, using NULL indexing arguments corresponds something like following:   Similarly, sb_mod sb_set, using NULL corresponds something like following:   true even inv = TRUE /red = TRUE.","code":"x[] x[] <- rp # for replacement x[] <- tf(x) # for transformation"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"out-of-bounds-integers-non-existing-names-levels-and-nas","dir":"Reference","previous_headings":"","what":"Out-of-Bounds Integers, Non-Existing Names/Levels, and NAs","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"Integer indices bounds (including NaN NA_integer_) always give error. Specifying non-existing names/levels (including NA_character_) indices considered form zero-length indexing. Logical indices translated internally integers using , NAs ignored.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"disallowed-combinations-of-index-arguments","dir":"Reference","previous_headings":"","what":"Disallowed Combinations of Index Arguments","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"One specify  indexing arguments simultaneously; either , arguments.  One specify row filter simultaneously; either one .  One specify col vars simultaneously; either one .  One specify sub, dims pair slice, margin pair simultaneously; either one pair pair.  cases holds one set specified, set ignored.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"drop","dir":"Reference","previous_headings":"","what":"Drop","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"Sub-setting generic methods 'squarebrackets' R-package using dimensional arguments (row, col, lyr, sub, dims, filter, vars) always use drop = FALSE.  drop potentially redundant (.e. single level) dimensions, use drop function, like :","code":"sb_x(x, row = row, col = col) |> drop() # ==> x[row, col, drop = TRUE]"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"regarding-performance","dir":"Reference","previous_headings":"","what":"Regarding Performance","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"Integer indices logical indices fastest.  Indexing names levels (.e. character vectors) slowest.  Thus performance important, use integer logical indices.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"Plate T, Heiberger R (2016). abind: Combine Multidimensional Arrays. R package version 1.4-5, https://CRAN.R-project.org/package=abind.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa4_squarebrackets_method_dispatch.html","id":null,"dir":"Reference","previous_headings":"","what":"Method Dispatch of 'squarebrackets' — aaa4_squarebrackets_method_dispatch","title":"Method Dispatch of 'squarebrackets' — aaa4_squarebrackets_method_dispatch","text":"help page gives additional details regarding S3 method dispatch used 'squarebrackets'.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa4_squarebrackets_method_dispatch.html","id":"atomic-vs-recursive","dir":"Reference","previous_headings":"","what":"Atomic vs Recursive","title":"Method Dispatch of 'squarebrackets' — aaa4_squarebrackets_method_dispatch","text":"exception idx method, main generic methods available 2 forms:  Atomic form (sb_), Recursive Form (sb2_).  S3 classes available atomic recursive forms.  example, array S3 class matrix S3 class (inherits \"array\" S3 class) atomic form, recursive form.  recursive form arrays matrices sometimes referred \"dimensional list\".  Atomic recursive objects quite different ways: homo- heterogeneous: atomic object homogeneous, can contain one data-type (logical, integer, double, character, complex, raw).  contrast, recursive objects heterogeneous, can combination data-types. copy semantics: copying atomic data (almost) always performs deep copy (though statement comes technical caveats).  since recursive objects pointers data, copies recursive objects often shallow copies. vectorization: vectorized operations generally work atomic objects, whereas recursive objects often require loops apply-like functions.  especially relevant transforming subsets. recursive subsets: Recursive objects distinguish \"regular\" subset operations (base R using [, [<-), recursive subset operations (base R using [[, [[<-).  forms, atomic objects give atomic objects.  recursive objects, 2 subset operations significantly different. views: Recursive objects weird pointers objects.  allow extracted subsets views pointers (see squarebrackets_mutable_classes information use \"views\" recursive objects).  Atomic objects now allow subset views. S3 method dispatch system built-method separate dispatches recursive atomic objects.  Hence, given , 'squarebrackets' package separate methods recursive atomic objects.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa4_squarebrackets_method_dispatch.html","id":"manual-dispatch","dir":"Reference","previous_headings":"","what":"Manual Dispatch","title":"Method Dispatch of 'squarebrackets' — aaa4_squarebrackets_method_dispatch","text":"'squarebrackets' package intentionally exports function S3 method dispatch system.  handy programming purposes.  example: atomic matrices atomic arrays dispatch.  Thus, looping though matrices arrays extract elements, may easier treat arrays (remember matrices inherit arrays).  Thus one can use sb_x.array() ensure \"array\" method used, instead \"matrix\" method.  Another advantage one can alias specific dispatch method, one desires.  .e.: array2_x <- sb2_x.array.  certain circumstances, may help code clear.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa4_squarebrackets_method_dispatch.html","id":"ellipsis","dir":"Reference","previous_headings":"","what":"Ellipsis","title":"Method Dispatch of 'squarebrackets' — aaa4_squarebrackets_method_dispatch","text":"Due S3 method dispatch system works 'R', generic methods ellipsis argument (...).  user's safety, 'squarebrackets' check user accidentally add arguments make sense method (like specifying inv argument calling sb_x).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa4_squarebrackets_options.html","id":null,"dir":"Reference","previous_headings":"","what":"squarebrackets Options — aaa4_squarebrackets_options","title":"squarebrackets Options — aaa4_squarebrackets_options","text":"help page explains various global options can set 'squarebrackets' package, affects functionality.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa4_squarebrackets_options.html","id":"check-duplicates","dir":"Reference","previous_headings":"","what":"Check Duplicates","title":"squarebrackets Options — aaa4_squarebrackets_options","text":"sb_x method method providing duplicate indices actually make sense.  methods, make sense.  Giving duplicate indices usually break anything; however, replacing/transforming removing subsets, almost certainly intention provide duplicate indices.  Providing duplicate indices anyway might lead unexpected results.  Therefore, methods giving duplicate indices make sense, chkdup argument present.  argument controls whether method question checks duplicates (TRUE) (FALSE).  Setting chkdup = TRUE means method question check duplicate indices, give error finds .  Setting chkdup = FALSE disable checks, saves time computation power, thus efficient.  Since checking duplicates can expensive, set FALSE default.  default can changed squarebrackets.chkdup option.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa4_squarebrackets_options.html","id":"mutable-atomic-messages","dir":"Reference","previous_headings":"","what":"Mutable Atomic Messages","title":"squarebrackets Options — aaa4_squarebrackets_options","text":"[<-.mutable_atomic method notifies user copy--modification.  user find annoying, user can disable messages setting squarebrackets.ma_messages FALSE.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa5_squarebrackets_method_dispatch.html","id":null,"dir":"Reference","previous_headings":"","what":"Method Dispatch of 'squarebrackets' — aaa5_squarebrackets_method_dispatch","title":"Method Dispatch of 'squarebrackets' — aaa5_squarebrackets_method_dispatch","text":"help page gives additional details regarding S3 method dispatch used 'squarebrackets'.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa5_squarebrackets_method_dispatch.html","id":"atomic-vs-recursive","dir":"Reference","previous_headings":"","what":"Atomic vs Recursive","title":"Method Dispatch of 'squarebrackets' — aaa5_squarebrackets_method_dispatch","text":"exception idx method, main generic methods available 2 forms:  Atomic form (sb_), Recursive Form (sb2_).  S3 classes available atomic recursive forms.  example, array S3 class matrix S3 class (inherits \"array\" S3 class) atomic form, recursive form.  recursive form arrays matrices sometimes referred \"dimensional list\".  Atomic recursive objects quite different ways: homo- heterogeneous: atomic object homogeneous, can contain one data-type (logical, integer, double, character, complex, raw).  contrast, recursive objects heterogeneous, can combination data-types. copy semantics: copying atomic data (almost) always performs deep copy (though statement comes technical caveats).  since recursive objects pointers data, copies recursive objects often shallow copies. vectorization: vectorized operations generally work atomic objects, whereas recursive objects often require loops apply-like functions.  especially relevant transforming subsets. recursive subsets: Recursive objects distinguish \"regular\" subset operations (base R using [, [<-), recursive subset operations (base R using [[, [[<-).  forms, atomic objects give atomic objects.  recursive objects, 2 subset operations significantly different. views: Recursive objects weird pointers objects.  allow extracted subsets views pointers (see squarebrackets_mutable_classes information use \"views\" recursive objects).  Atomic objects now allow subset views. S3 method dispatch system built-method separate dispatches recursive atomic objects.  Hence, given , 'squarebrackets' package separate methods recursive atomic objects.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa5_squarebrackets_method_dispatch.html","id":"manual-dispatch","dir":"Reference","previous_headings":"","what":"Manual Dispatch","title":"Method Dispatch of 'squarebrackets' — aaa5_squarebrackets_method_dispatch","text":"'squarebrackets' package intentionally exports function S3 method dispatch system.  handy programming purposes.  example: atomic matrices atomic arrays dispatch.  Thus, looping though matrices arrays extract elements, may easier treat arrays (remember matrices inherit arrays).  Thus one can use sb_x.array() ensure \"array\" method used, instead \"matrix\" method.  Another advantage one can alias specific dispatch method, one desires.  .e.: array2_x <- sb2_x.array.  certain circumstances, may help code clear.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa5_squarebrackets_method_dispatch.html","id":"ellipsis","dir":"Reference","previous_headings":"","what":"Ellipsis","title":"Method Dispatch of 'squarebrackets' — aaa5_squarebrackets_method_dispatch","text":"Due S3 method dispatch system works 'R', generic methods ellipsis argument (...).  user's safety, 'squarebrackets' check user accidentally add arguments make sense method (like specifying inv argument calling sb_x).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa5_squarebrackets_modify.html","id":null,"dir":"Reference","previous_headings":"","what":"Regarding Modification — aaa5_squarebrackets_modify","title":"Regarding Modification — aaa5_squarebrackets_modify","text":"help page describes main modification semantics available 'squarebrackets'.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa5_squarebrackets_modify.html","id":"base-r-s-default-modification","dir":"Reference","previous_headings":"","what":"Base R's default modification","title":"Regarding Modification — aaa5_squarebrackets_modify","text":"average users, R's default copy--modify semantics fine.  benefits indexing arguments 'squarebrackets' can combined [<- operator, idx method.  result idx() method can used inside regular square-brackets operators.  example like :   thus allowing user benefit convenient index translations 'squarebrackets', whilst still using R's default copy--modification semantics (instead semantics provided 'squarebrackets').","code":"x <- array(...) my_indices <- idx(x, sub, dims) x[my_indices] <- value  y <- data.frame(...) rows <- idx(y, 1:10, 1, inv = TRUE) cols <- idx(y, c(\"a\", \"b\"), 2) y[rows, cols] <- value"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa5_squarebrackets_modify.html","id":"explicit-copy","dir":"Reference","previous_headings":"","what":"Explicit Copy","title":"Regarding Modification — aaa5_squarebrackets_modify","text":"'squarebrackets' provides sb_mod method modify copy.  method always copies modification.  recursive objects, sb_mod returns original object, modified subsets copied, thus preventing unnecessary usage memory.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa5_squarebrackets_modify.html","id":"pass-by-reference","dir":"Reference","previous_headings":"","what":"Pass-by-Reference","title":"Regarding Modification — aaa5_squarebrackets_modify","text":"'squarebrackets' provides sb_set method modify reference, meaning copy made .  Pass--Reference fastest memory efficient.  also involved modification forms, requires thought.  See squarebrackets_PassByReference information.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa5_squarebrackets_modify.html","id":"arguments-rp-tf-lapply","dir":"Reference","previous_headings":"","what":"Arguments rp, tf, .lapply","title":"Regarding Modification — aaa5_squarebrackets_modify","text":"Using rp argument modification methods, corresponds something like following:   Using tf argument (.lapply argument, recursive objects) modification methods, corresponds something like following:   tf function returns object appropriate type size (tf pass--reference function).  recursive objects, tf accompanied .lapply argument.  default, .lapply = lapply.  user may supply custom lapply()-like function argument use instead.  example, perform parallel transformation, user may supply future.apply::future_lapply.  supplied function must use exact argument convention lapply, otherwise errors unexpected behaviour may occur.","code":"x[...] <- rp x[...] <- tf(x[...]) # for atomic objects x[...] <- .lapply(x[...], tf) # for recursive objects"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa5_squarebrackets_modify.html","id":"recycling-and-coercion","dir":"Reference","previous_headings":"","what":"Recycling and Coercion","title":"Regarding Modification — aaa5_squarebrackets_modify","text":"Recycling allowed modifcation methods.  , example, length(rp) must equal length selected subset, equal 1.  user also take account auto-coercion rules object's class.  See squarebrackets_immutable_classes squarebrackets_mutable_classes details.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa6_squarebrackets_options.html","id":null,"dir":"Reference","previous_headings":"","what":"squarebrackets Options — aaa6_squarebrackets_options","title":"squarebrackets Options — aaa6_squarebrackets_options","text":"help page explains various global options can set 'squarebrackets' package, affects functionality.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa6_squarebrackets_options.html","id":"check-duplicates","dir":"Reference","previous_headings":"","what":"Check Duplicates","title":"squarebrackets Options — aaa6_squarebrackets_options","text":"sb_x method method providing duplicate indices actually make sense.  methods, make sense.  Giving duplicate indices usually break anything; however, replacing/transforming removing subsets, almost certainly intention provide duplicate indices.  Providing duplicate indices anyway might lead unexpected results.  Therefore, methods giving duplicate indices make sense, chkdup argument present.  argument controls whether method question checks duplicates (TRUE) (FALSE).  Setting chkdup = TRUE means method question check duplicate indices, give error finds .  Setting chkdup = FALSE disable checks, saves time computation power, thus efficient.  Since checking duplicates can expensive, set FALSE default.  default can changed squarebrackets.chkdup option.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa6_squarebrackets_options.html","id":"mutable-atomic-messages","dir":"Reference","previous_headings":"","what":"Mutable Atomic Messages","title":"squarebrackets Options — aaa6_squarebrackets_options","text":"[<-.mutable_atomic method notifies user copy--modification.  user find annoying, user can disable messages setting squarebrackets.ma_messages FALSE.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa6_squarebrackets_PassByReference.html","id":null,"dir":"Reference","previous_headings":"","what":"Regarding Modification By Reference — aaa6_squarebrackets_PassByReference","title":"Regarding Modification By Reference — aaa6_squarebrackets_PassByReference","text":"help page describes modification using \"pass--reference\" semantics handled 'squarebrackets' package.  help page explain basics pass--reference semantics, treated prior knowledge.  functions/methods 'squarebrackets' package word \"set\" name use pass--reference semantics.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa6_squarebrackets_PassByReference.html","id":"advantages-and-disadvantages","dir":"Reference","previous_headings":"","what":"Advantages and Disadvantages","title":"Regarding Modification By Reference — aaa6_squarebrackets_PassByReference","text":"main advantage pass--reference much less memory required modify objects, modification also generally faster.  several disadvantages.  First, coercion rules slightly different: see squarebrackets_mutable_classes.  Second, 2 variables refer exactly object, changing one variable also changes ones.  .e. following code,   modifies just x, also y.  true even one variables locked (see bindingIsLocked).  .e. following code,   modifies x y without error, even though y locked constant.","code":"x <- y <- mutable_atomic(1:16) sb_set(x, i = 1:6, rp = 8) x <- mutable_atomic(1:16) y <- x lockBinding(\"y\", environment()) sb_set(x, i = 1:6, rp = 8)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa6_squarebrackets_PassByReference.html","id":"mutable-vs-immutable-classes","dir":"Reference","previous_headings":"","what":"Mutable vs Immutable Classes","title":"Regarding Modification By Reference — aaa6_squarebrackets_PassByReference","text":"exception environments, base R's S3 classes treated immutable:  Modifying object 'R' make copy object, something called 'copy--modify' semantics.  prominent mutable S3 class data.table class, mutable data.frame class, supported 'squarebrackets'.  Similarly, 'squarebrackets' adds class mutable atomic objects: mutable_atomic.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa6_squarebrackets_PassByReference.html","id":"material-vs-immaterial-objects","dir":"Reference","previous_headings":"","what":"Material vs Immaterial objects","title":"Regarding Modification By Reference — aaa6_squarebrackets_PassByReference","text":"objects 'R' material objects:  values object contains actually stored memory.  example, given x <- rnorm(1e6), x material object:  1 million values (decimal numbers, case) actually stored memory.  contrast, ActiveBindings immaterial:  objects , accessed, call function generate values fly, rather actually storing values.  Since immaterial objects actually store values memory, values obviously also changed memory.  Therefore, Pass--Reference semantics work immaterial objects.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa6_squarebrackets_PassByReference.html","id":"altrep","dir":"Reference","previous_headings":"","what":"ALTREP","title":"Regarding Modification By Reference — aaa6_squarebrackets_PassByReference","text":"subtle type (usually) immaterial objects ALTREP objects.  Although ALTREP can used various different ways, ALTREP objects base 'R' store instructions values stored, actually store values, immaterial.  example, x <- 1:1e6 immaterial object:  Unlike rnorm(1e6), 1:1e6 actually store 1 million values;  Rather, stores simple instruction x[] = .  x modified, given instructions obviously hold , 'R' materialize x, means x actually store values memory.  x materialized, size x memory change bytes Mega Bytes.  'stringfish' package also uses ALTREP, ALTREP objects 'stringfish' actually material objects.  Clearly, ALTREP objects difficult work using pass--reference.  data.table can ALTREP columns.  data.tables coerce column materialized column modified, even reference.  works since data.table recursive object.  mutable_atomic class materializes input, just safe side.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa6_squarebrackets_PassByReference.html","id":"mutability-rules-with-respect-to-recursive-objects","dir":"Reference","previous_headings":"","what":"Mutability Rules With Respect To Recursive Objects","title":"Regarding Modification By Reference — aaa6_squarebrackets_PassByReference","text":"Lists difficult objects contain elements, simply point  objects, one can access via list.  recursive object mutable class, subsets treated mutable, long part object.  hand, recursive object immutable class, recursive subsets retain original mutability. Example 1: Mutable data.tables  data.table mutable class.  columns data.table treated mutable;  requirement , instance, first change columns class mutable_atomic modify columns reference. Example 2: Immutable lists  regular list immutable class.  list immutable, recursive subsets list retain mutability.  list data.table objects, example, data.tables remain mutable.  Therefore, following pass--reference modification work without issue:   Notice code mypointer address x$, therefore copy x$.  Thus changing mypointer also changes x$.  words: mypointer called \"View\" x$.","code":"x <- list(  a = data.table(cola = 1:10, colb = letters[1:10]),  b = data.table(cola = 11:20, colb = letters[11:20]) ) mypointer <- x$a sb_set(mypointer, col = \"cola\", tf = \\(x)x^2)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa6_squarebrackets_PassByReference.html","id":"input-variable","dir":"Reference","previous_headings":"","what":"Input Variable","title":"Regarding Modification By Reference — aaa6_squarebrackets_PassByReference","text":"Methods/functions perform -place modification reference works objects actually exist actual variable, similar functions style some_function(x, ...) <- value.  Thus things like following, sb_set(1:10, ...), sb2_set(x$, ...), sb_set(base::letters),  work.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa6_squarebrackets_PassByReference.html","id":"lock-binding","dir":"Reference","previous_headings":"","what":"Lock Binding","title":"Regarding Modification By Reference — aaa6_squarebrackets_PassByReference","text":"Mutable classes , name suggests, meant mutable.  Locking binding mutable object mostly fruitless (completely; see currentBindings function).  prevent modification object's binding, 2 things must true: object must immutable class. binding must locked (see lockBinding). packages provide pass--reference semantics tend ignore lock object's binding.  Use 'squarebrackets'  methods (course) core/base 'R' methods, case user fears binding locks respected.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa6_squarebrackets_PassByReference.html","id":"protection","dir":"Reference","previous_headings":"","what":"Protection","title":"Regarding Modification By Reference — aaa6_squarebrackets_PassByReference","text":"Due properties described help page, something like following work:   work : addresses baseenv() protected; immutable objects disallowed (create mutable object, create copy original, thus keeping original object safe modification reference); locked bindings disallowed. Despite checks made package, user never actively try modify locked protected object reference, defeat purpose locking object.","code":"# letters = base::letters sb_set(letters, i = 1, rp = \"XXX\")"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa6_squarebrackets_PassByReference.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Regarding Modification By Reference — aaa6_squarebrackets_PassByReference","text":"","code":"# the following code demonstrates how locked bindings, # such as `base::letters`, # are being safe-guarded  x <- list(a = base::letters) mypointer <- x$a # view of a list address(mypointer) == address(base::letters) # TRUE: point to the same memory #> [1] TRUE bindingIsLocked(\"letters\", baseenv()) # base::letters is locked ... #> [1] TRUE bindingIsLocked(\"mypointer\", environment()) # ... but this pointer is not! #> [1] FALSE  if(requireNamespace(\"tinytest\")) {   tinytest::expect_error(     sb_set(mypointer, i = 1, rp = \"XXX\") # this still gives an error though ...   ) } #> Loading required namespace: tinytest #> ----- PASSED      : <--> #>  call| eval(expr, envir, enclos)   is.mutable_atomic(mypointer) # ... because it's not of class `mutable_atomic` #> [1] FALSE   x <- list(   a = as.mutable_atomic(base::letters) # `as.mutable_atomic()` makes a copy ) mypointer <- x$a # view of a list address(mypointer) == address(base::letters) # FALSE: it's a copy #> [1] FALSE sb_set(   mypointer, i = 1, rp = \"XXX\"  # modifies x, does NOT modify `base::letters` ) print(x) # x is modified #> $a #>  [1] \"XXX\" \"b\"   \"c\"   \"d\"   \"e\"   \"f\"   \"g\"   \"h\"   \"i\"   \"j\"   \"k\"   \"l\"   #> [13] \"m\"   \"n\"   \"o\"   \"p\"   \"q\"   \"r\"   \"s\"   \"t\"   \"u\"   \"v\"   \"w\"   \"x\"   #> [25] \"y\"   \"z\"   #> mutable_atomic  #> typeof:  character  #>  base::letters # but this still the same #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" #> [20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa7_squarebrackets_inconveniences.html","id":null,"dir":"Reference","previous_headings":"","what":"Examples Where the Square Bracket Operators Are Less Convenient — aaa7_squarebrackets_inconveniences","title":"Examples Where the Square Bracket Operators Are Less Convenient — aaa7_squarebrackets_inconveniences","text":"help page shows examples square bracket operators ( [, [<-) less optimally convenient, methods provided 'squarebrackets' can helpful cases.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa7_squarebrackets_inconveniences.html","id":"arrays","dir":"Reference","previous_headings":"","what":"Arrays","title":"Examples Where the Square Bracket Operators Are Less Convenient — aaa7_squarebrackets_inconveniences","text":"order perform subset operations array x square brackets operator ([, [<-), one needs know many dimensions .  .e. x 3 dimensions, one use:   one use [ [<- operators, number dimensions x known -priori?  ’s impossible, still rather convoluted.  methods provided 'squarebrackets' use position-based arguments, work arbitrary dimensions without requiring prior knowledge;  see squarebrackets_indx_args details.  extracting/removing dimensional sub-set array, .e. x[indx1, indx2], dimnames(x) preserved (within range subset course), names(x) dropped completely.  methods provided 'squarebrackets' completely remove names(x) extracting/removing subsets.  : bother giving arrays flat names stripped anyway?","code":"x[i, j, k, drop = FALSE]  x[i, j, k] <- value"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa7_squarebrackets_inconveniences.html","id":"rule-sets-for-data-frame-like-objects","dir":"Reference","previous_headings":"","what":"Rule-sets for data.frame-like Objects","title":"Examples Where the Square Bracket Operators Are Less Convenient — aaa7_squarebrackets_inconveniences","text":"data.frame, tibble, data.table, tidytable classes inherit class “data.frame”.  Yet use different rules regarding usage square bracket operators.  Constantly switching rules annoying, makes one's code inconsistent.  methods provided 'squarebrackets' use sub-setting rules data.frame inherited classes, thus solving issue.  'squarebrackets' package attempts keep data.frame methods class agnostic possible, class agnostic functionality 'collapse' 'data.table' R-packages.  attempt keep data.frame-like classes consistent , admittedly, result oddities data.frames treated 'squarebrackets', compared classes treated 'squarebrackets': Whole-columns auto-coerced replaced/transformed sb_mod, partial columns auto-coerced default. sb_x sb_rm methods always automatically conserve attributes (though names dimensions adjusted accordingly, course);  attributes stripped, unlike classes. Giving data.frame-like object non-unique column names sb_-methods returns error;  duplicating columns sb_x automatically adjust column names make unique.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa7_squarebrackets_inconveniences.html","id":"annoying-sub-setting-by-names","dir":"Reference","previous_headings":"","what":"Annoying Sub-setting By Names","title":"Examples Where the Square Bracket Operators Are Less Convenient — aaa7_squarebrackets_inconveniences","text":"selecting names sub-setting, first occurrences names selected sub-set;  un-selecting/removing names sub-setting, syntax different selecting names.  methods provided 'squarebrackets' uses syntax selecting removing sub-sets.  Moreover, selecting/removing sub-sets names always selects/removes sub-sets given names, just first match.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa7_squarebrackets_inconveniences.html","id":"modification-semantics","dir":"Reference","previous_headings":"","what":"Modification Semantics","title":"Examples Where the Square Bracket Operators Are Less Convenient — aaa7_squarebrackets_inconveniences","text":"‘R’ adheres copy--modify semantics replacing values using [<-.  sometimes one like explicit control create copy, modify using pass--reference semantics.  'squarebrackets' package provides sb_mod method return copy object modified subsets,  sb_set method modify using pass--reference semantics.  idx method can used combination R's [<- operator R's default copy--modify semantics.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa7_squarebrackets_inconveniences.html","id":"regarding-other-packages","dir":"Reference","previous_headings":"","what":"Regarding Other Packages","title":"Examples Where the Square Bracket Operators Are Less Convenient — aaa7_squarebrackets_inconveniences","text":"packages solve issues.  using different packages solving different issues common theme (case: solving inconveniences square bracket operators) leads inconsistent code.  found R-package provides holistic approach providing alternative methods square brackets operators.  Thus, 'R' package born.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa7_squarebrackets_PassByReference.html","id":null,"dir":"Reference","previous_headings":"","what":"Regarding Modification By Reference — aaa7_squarebrackets_PassByReference","title":"Regarding Modification By Reference — aaa7_squarebrackets_PassByReference","text":"help page describes modification using \"pass--reference\" semantics handled 'squarebrackets' package.  help page explain basics pass--reference semantics, treated prior knowledge.  functions/methods 'squarebrackets' package word \"set\" name use pass--reference semantics.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa7_squarebrackets_PassByReference.html","id":"advantages-and-disadvantages","dir":"Reference","previous_headings":"","what":"Advantages and Disadvantages","title":"Regarding Modification By Reference — aaa7_squarebrackets_PassByReference","text":"main advantage pass--reference much less memory required modify objects, modification also generally faster.  several disadvantages.  First, coercion rules slightly different: see squarebrackets_mutable_classes.  Second, 2 variables refer exactly object, changing one variable also changes ones.  .e. following code,   modifies just x, also y.  true even one variables locked (see bindingIsLocked).  .e. following code,   modifies x y without error, even though y locked constant.","code":"x <- y <- mutable_atomic(1:16) sb_set(x, i = 1:6, rp = 8) x <- mutable_atomic(1:16) y <- x lockBinding(\"y\", environment()) sb_set(x, i = 1:6, rp = 8)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa7_squarebrackets_PassByReference.html","id":"mutable-vs-immutable-classes","dir":"Reference","previous_headings":"","what":"Mutable vs Immutable Classes","title":"Regarding Modification By Reference — aaa7_squarebrackets_PassByReference","text":"exception environments, base R's S3 classes treated immutable:  Modifying object 'R' make copy object, something called 'copy--modify' semantics.  prominent mutable S3 class data.table class, mutable data.frame class, supported 'squarebrackets'.  Similarly, 'squarebrackets' adds class mutable atomic objects: mutable_atomic.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa7_squarebrackets_PassByReference.html","id":"material-vs-immaterial-objects","dir":"Reference","previous_headings":"","what":"Material vs Immaterial objects","title":"Regarding Modification By Reference — aaa7_squarebrackets_PassByReference","text":"objects 'R' material objects:  values object contains actually stored memory.  example, given x <- rnorm(1e6), x material object:  1 million values (decimal numbers, case) actually stored memory.  contrast, ActiveBindings immaterial:  objects , accessed, call function generate values fly, rather actually storing values.  Since immaterial objects actually store values memory, values obviously also changed memory.  Therefore, Pass--Reference semantics work immaterial objects.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa7_squarebrackets_PassByReference.html","id":"altrep","dir":"Reference","previous_headings":"","what":"ALTREP","title":"Regarding Modification By Reference — aaa7_squarebrackets_PassByReference","text":"mutable_atomic constructors (.e. mutable_atomic, .mutable_atomic, etc.) automatically materialize ALTREP objects, ensure consistent behaviour 'pass--reference' semanthics.  data.table can ALTREP columns.  data.tables coerce column materialized column modified, even reference.  works since data.table recursive object.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa7_squarebrackets_PassByReference.html","id":"mutability-rules-with-respect-to-recursive-objects","dir":"Reference","previous_headings":"","what":"Mutability Rules With Respect To Recursive Objects","title":"Regarding Modification By Reference — aaa7_squarebrackets_PassByReference","text":"Lists difficult objects contain elements, simply point  objects, one can access via list.  recursive object mutable class, subsets treated mutable, long part object.  hand, recursive object immutable class, recursive subsets retain original mutability. Example 1: Mutable data.tables  data.table mutable class.  columns data.table treated mutable;  requirement , instance, first change columns class mutable_atomic modify columns reference. Example 2: Immutable lists  regular list immutable class.  list immutable, recursive subsets list retain mutability.  list data.table objects, example, data.tables remain mutable.  Therefore, following pass--reference modification work without issue:   Notice code mypointer address x$, therefore copy x$.  Thus changing mypointer also changes x$.  words: mypointer called \"View\" x$.","code":"x <- list(  a = data.table(cola = 1:10, colb = letters[1:10]),  b = data.table(cola = 11:20, colb = letters[11:20]) ) mypointer <- x$a sb_set(mypointer, col = \"cola\", tf = \\(x)x^2)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa7_squarebrackets_PassByReference.html","id":"input-variable","dir":"Reference","previous_headings":"","what":"Input Variable","title":"Regarding Modification By Reference — aaa7_squarebrackets_PassByReference","text":"Methods/functions perform -place modification reference works objects actually exist actual variable, similar functions style some_function(x, ...) <- value.  Thus things like following, sb_set(1:10, ...), sb2_set(x$, ...), sb_set(base::letters),  work.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa7_squarebrackets_PassByReference.html","id":"lock-binding","dir":"Reference","previous_headings":"","what":"Lock Binding","title":"Regarding Modification By Reference — aaa7_squarebrackets_PassByReference","text":"Mutable classes , name suggests, meant mutable.  Locking binding mutable object mostly fruitless (completely; see currentBindings function).  prevent modification object's binding, 2 things must true: object must immutable class. binding must locked (see lockBinding). packages provide pass--reference semantics tend ignore lock object's binding.  Use 'squarebrackets'  methods (course) core/base 'R' methods, case user fears binding locks respected.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa7_squarebrackets_PassByReference.html","id":"protection","dir":"Reference","previous_headings":"","what":"Protection","title":"Regarding Modification By Reference — aaa7_squarebrackets_PassByReference","text":"Due properties described help page, something like following work:   work : addresses baseenv() protected; immutable objects disallowed (create mutable object, create copy original, thus keeping original object safe modification reference); locked bindings disallowed. Despite checks made package, user never actively try modify locked protected object reference, defeat purpose locking object.","code":"# letters = base::letters sb_set(letters, i = 1, rp = \"XXX\")"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa7_squarebrackets_PassByReference.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Regarding Modification By Reference — aaa7_squarebrackets_PassByReference","text":"","code":"# the following code demonstrates how locked bindings, # such as `base::letters`, # are being safe-guarded  x <- list(a = base::letters) mypointer <- x$a # view of a list address(mypointer) == address(base::letters) # TRUE: point to the same memory #> [1] TRUE bindingIsLocked(\"letters\", baseenv()) # base::letters is locked ... #> [1] TRUE bindingIsLocked(\"mypointer\", environment()) # ... but this pointer is not! #> [1] FALSE  if(requireNamespace(\"tinytest\")) {   tinytest::expect_error(     sb_set(mypointer, i = 1, rp = \"XXX\") # this still gives an error though ...   ) } #> Loading required namespace: tinytest #> ----- PASSED      : <--> #>  call| eval(expr, envir, enclos)   is.mutable_atomic(mypointer) # ... because it's not of class `mutable_atomic` #> [1] FALSE   x <- list(   a = as.mutable_atomic(base::letters) # `as.mutable_atomic()` makes a copy ) mypointer <- x$a # view of a list address(mypointer) == address(base::letters) # FALSE: it's a copy #> [1] FALSE sb_set(   mypointer, i = 1, rp = \"XXX\"  # modifies x, does NOT modify `base::letters` ) print(x) # x is modified #> $a #>  [1] \"XXX\" \"b\"   \"c\"   \"d\"   \"e\"   \"f\"   \"g\"   \"h\"   \"i\"   \"j\"   \"k\"   \"l\"   #> [13] \"m\"   \"n\"   \"o\"   \"p\"   \"q\"   \"r\"   \"s\"   \"t\"   \"u\"   \"v\"   \"w\"   \"x\"   #> [25] \"y\"   \"z\"   #> mutable_atomic  #> typeof:  character  #>  base::letters # but this still the same #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" #> [20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa8_squarebrackets_inconveniences.html","id":null,"dir":"Reference","previous_headings":"","what":"Examples Where the Square Bracket Operators Are Less Convenient — aaa8_squarebrackets_inconveniences","title":"Examples Where the Square Bracket Operators Are Less Convenient — aaa8_squarebrackets_inconveniences","text":"help page shows examples square bracket operators ( [, [<-) less optimally convenient, methods provided 'squarebrackets' can helpful cases.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa8_squarebrackets_inconveniences.html","id":"arrays","dir":"Reference","previous_headings":"","what":"Arrays","title":"Examples Where the Square Bracket Operators Are Less Convenient — aaa8_squarebrackets_inconveniences","text":"order perform subset operations array x square brackets operator ([, [<-), one needs know many dimensions .  .e. x 3 dimensions, one use:   one use [ [<- operators, number dimensions x known -priori?  ’s impossible, still rather convoluted.  methods provided 'squarebrackets' use position-based arguments, work arbitrary dimensions without requiring prior knowledge;  see squarebrackets_indx_args details.  extracting/removing dimensional sub-set array, .e. x[indx1, indx2], dimnames(x) preserved (within range subset course), names(x) dropped completely.  methods provided 'squarebrackets' completely remove names(x) extracting/removing subsets.  : bother giving arrays flat names stripped anyway?","code":"x[i, j, k, drop = FALSE]  x[i, j, k] <- value"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa8_squarebrackets_inconveniences.html","id":"rule-sets-for-data-frame-like-objects","dir":"Reference","previous_headings":"","what":"Rule-sets for data.frame-like Objects","title":"Examples Where the Square Bracket Operators Are Less Convenient — aaa8_squarebrackets_inconveniences","text":"data.frame, tibble, data.table, tidytable classes inherit class “data.frame”.  Yet use different rules regarding usage square bracket operators.  Constantly switching rules annoying, makes one's code inconsistent.  methods provided 'squarebrackets' use sub-setting rules data.frame inherited classes, thus solving issue.  'squarebrackets' package attempts keep data.frame methods class agnostic possible, class agnostic functionality 'collapse' 'data.table' R-packages.  attempt keep data.frame-like classes consistent , admittedly, result oddities data.frames treated 'squarebrackets', compared classes treated 'squarebrackets': Whole-columns auto-coerced replaced/transformed sb_mod, partial columns auto-coerced default. sb_x sb_rm methods always automatically conserve attributes (though names dimensions adjusted accordingly, course);  attributes stripped, unlike classes. Giving data.frame-like object non-unique column names sb_-methods returns error;  duplicating columns sb_x automatically adjust column names make unique.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa8_squarebrackets_inconveniences.html","id":"long-vectors","dir":"Reference","previous_headings":"","what":"Long Vectors","title":"Examples Where the Square Bracket Operators Are Less Convenient — aaa8_squarebrackets_inconveniences","text":"Performing sub-set operations long vector x using [, like object, requires indexing vector.  indexing vector may need type double (since long vectors can longer 2^31 - 1), indexing vector may need large also.  can quite inefficient, one may need twice memory object .  'squarebrackets' provides slcseq_ methods, can perform sub-set operations large atomic vectors, without need indexing vector .  Note dimensional objects, arrays data.frame-like objects, less dire need slcseq_ method due dimensional indexing:  example, 1500 1500 1500 array already long vector (1500^3 > (2^31 - 1)), yet one need indexing vectors longer 1500 elements type double.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa8_squarebrackets_inconveniences.html","id":"annoying-sub-setting-by-names","dir":"Reference","previous_headings":"","what":"Annoying Sub-setting By Names","title":"Examples Where the Square Bracket Operators Are Less Convenient — aaa8_squarebrackets_inconveniences","text":"selecting names sub-setting, first occurrences names selected sub-set;  un-selecting/removing names sub-setting, syntax different selecting names.  methods provided 'squarebrackets' uses syntax selecting removing sub-sets.  Moreover, selecting/removing sub-sets names always selects/removes sub-sets given names, just first match.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa8_squarebrackets_inconveniences.html","id":"modification-semantics","dir":"Reference","previous_headings":"","what":"Modification Semantics","title":"Examples Where the Square Bracket Operators Are Less Convenient — aaa8_squarebrackets_inconveniences","text":"‘R’ adheres copy--modify semantics replacing values using [<-.  sometimes one like explicit control create copy, modify using pass--reference semantics.  'squarebrackets' package provides sb_mod method return copy object modified subsets,  sb_set method modify using pass--reference semantics.  idx method can used combination R's [<- operator R's default copy--modify semantics.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa8_squarebrackets_inconveniences.html","id":"regarding-other-packages","dir":"Reference","previous_headings":"","what":"Regarding Other Packages","title":"Examples Where the Square Bracket Operators Are Less Convenient — aaa8_squarebrackets_inconveniences","text":"packages solve issues.  using different packages solving different issues common theme (case: solving inconveniences square bracket operators) leads inconsistent code.  found R-package provides holistic approach providing alternative methods square brackets operators.  Thus, 'R' package born.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/bind.html","id":null,"dir":"Reference","previous_headings":"","what":"Dimensional Binding of Objects — bind","title":"Dimensional Binding of Objects — bind","text":"bind_ bind2_ implementations provide dimensional binding functionalities. bind_ atomic objects, bind2_ recursive objects.  possible, bind_/bind2_ functions return mutable classes.  following implementations available: bind_row(), bind_col(), bind2_row(), bind2_col() bind dimensionless vectors row- column-wise.  Can also bind matrices.  output atomic, returns mutable_atomic array. bind_array() binds atomic arrays matrices.  Returns mutable_atomic array. bind2_array() binds recursive arrays matrices.  Returns recursive array (immutable). bind2_dt() binds data.tables data.frame-like objects.  Returns data.table.  Faster .call(cbind, ...) .call(rbind, ...) regular data.frame objects.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/bind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dimensional Binding of Objects — bind","text":"","code":"bind_row(arg.list, deparse.level = 1)  bind2_row(arg.list, deparse.level = 1)  bind_col(arg.list, deparse.level = 1)  bind2_col(arg.list, deparse.level = 1)  bind_array(   arg.list,   along,   name_along = TRUE,   comnames_from = 1L,   name_flat = FALSE )  bind2_array(   arg.list,   along,   name_along = TRUE,   comnames_from = 1L,   name_flat = FALSE )  bind2_dt(arg.list, along)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/bind.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dimensional Binding of Objects — bind","text":"arg.list list appropriate objects.  mix recursive atomic objects list, may result unexpected results. deparse.level see cbind rbind. along single integer, indicating dimension along bind dimensions.  .e. use along = 1 row-binding, along = 2 column-binding, etc.  arrays, additional flexibility available: Specifying along = 0 bind arrays new dimension first, making along new first dimension. Specifying along = n+1, n last available dimension, create additional dimension (n+1) bind arrays along new dimension. name_along Boolean, bind_array() bind2_array().  Indicates dimension along named. comnames_from integer scalar NULL, bind_array() bind2_array().  Indicates object arg.list used naming shared dimension.  NULL, communal names given.  example:  binding columns atomic matrices, comnames_from = 1 results bind_array() using rownames(arg.list[[1]]) row names output. name_flat Boolean, bind_array() bind2_array().  Indicates flat indices named.  Note setting TRUE reduce performance considerably.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/bind.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dimensional Binding of Objects — bind","text":"new object.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/bind.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Dimensional Binding of Objects — bind","text":"bind_array() bind2_array() modified versions fantastic abind::abind function Tony Plare Richard Heiberger (see reference ). bind_array() slightly better performance abind::abind, streamlined naming options. bind2_array() also streamlined naming options, additionally differs abind::abind can handle recursive arrays properly (original abind::abind function unlist everything atomic arrays).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/bind.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Dimensional Binding of Objects — bind","text":"Plate T, Heiberger R (2016). abind: Combine Multidimensional Arrays. R package version 1.4-5, https://CRAN.R-project.org/package=abind.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/bind.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dimensional Binding of Objects — bind","text":"","code":"# atomic arrays ==== x <- matrix(1:12,3,4) dimnames(x) <- n(letters[1:3], LETTERS[1:4]) names(x) <- month.abb print(x) #>   A B C  D #> a 1 4 7 10 #> b 2 5 8 11 #> c 3 6 9 12 #> attr(,\"names\") #>  [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\" y <- x+100 arg.list <- list(x = x, y = y) bind_array(arg.list, along=0, name_flat = TRUE) # binds on new dimension before first #> , , A #>  #>     a   b   c #> x   1   2   3 #> y 101 102 103 #>  #> , , B #>  #>     a   b   c #> x   4   5   6 #> y 104 105 106 #>  #> , , C #>  #>     a   b   c #> x   7   8   9 #> y 107 108 109 #>  #> , , D #>  #>     a   b   c #> x  10  11  12 #> y 110 111 112 #>  #> attr(,\"names\") #>  [1] \"Jan\"  \"y.1\"  \"Feb\"  \"y.2\"  \"Mar\"  \"y.3\"  \"Apr\"  \"y.4\"  \"May\"  \"y.5\"  #> [11] \"Jun\"  \"y.6\"  \"Jul\"  \"y.7\"  \"Aug\"  \"y.8\"  \"Sep\"  \"y.9\"  \"Oct\"  \"y.10\" #> [21] \"Nov\"  \"y.11\" \"Dec\"  \"y.12\" #> mutable_atomic  #> typeof:  double  bind_array(arg.list, along=1, name_flat = TRUE) # binds on first dimension #>     A   B   C   D #> a   1   4   7  10 #> b   2   5   8  11 #> c   3   6   9  12 #> a 101 104 107 110 #> b 102 105 108 111 #> c 103 106 109 112 #> attr(,\"names\") #>  [1] \"Jan\"  \"Feb\"  \"Mar\"  \"y.1\"  \"y.2\"  \"y.3\"  \"Apr\"  \"May\"  \"Jun\"  \"y.4\"  #> [11] \"y.5\"  \"y.6\"  \"Jul\"  \"Aug\"  \"Sep\"  \"y.7\"  \"y.8\"  \"y.9\"  \"Oct\"  \"Nov\"  #> [21] \"Dec\"  \"y.10\" \"y.11\" \"y.12\" #> mutable_atomic  #> typeof:  double  bind_array(arg.list, along=2, name_flat = TRUE) #>   A B C  D   A   B   C   D #> a 1 4 7 10 101 104 107 110 #> b 2 5 8 11 102 105 108 111 #> c 3 6 9 12 103 106 109 112 #> attr(,\"names\") #>  [1] \"Jan\"  \"Feb\"  \"Mar\"  \"Apr\"  \"May\"  \"Jun\"  \"Jul\"  \"Aug\"  \"Sep\"  \"Oct\"  #> [11] \"Nov\"  \"Dec\"  \"y.1\"  \"y.2\"  \"y.3\"  \"y.4\"  \"y.5\"  \"y.6\"  \"y.7\"  \"y.8\"  #> [21] \"y.9\"  \"y.10\" \"y.11\" \"y.12\" #> mutable_atomic  #> typeof:  double  bind_array(arg.list, along=3, name_flat = TRUE) # bind on new dimension after last #> , , x #>  #>   A B C  D #> a 1 4 7 10 #> b 2 5 8 11 #> c 3 6 9 12 #>  #> , , y #>  #>     A   B   C   D #> a 101 104 107 110 #> b 102 105 108 111 #> c 103 106 109 112 #>  #> attr(,\"names\") #>  [1] \"Jan\"  \"Feb\"  \"Mar\"  \"Apr\"  \"May\"  \"Jun\"  \"Jul\"  \"Aug\"  \"Sep\"  \"Oct\"  #> [11] \"Nov\"  \"Dec\"  \"y.1\"  \"y.2\"  \"y.3\"  \"y.4\"  \"y.5\"  \"y.6\"  \"y.7\"  \"y.8\"  #> [21] \"y.9\"  \"y.10\" \"y.11\" \"y.12\" #> mutable_atomic  #> typeof:  double    ################################################################################   # recursiv arrays ==== x <- matrix(as.list(1:12),3,4) dimnames(x) <- n(letters[1:3], LETTERS[1:4]) names(x) <- month.abb print(x) #>   A B C D  #> a 1 4 7 10 #> b 2 5 8 11 #> c 3 6 9 12 #> attr(,\"names\") #>  [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\" y <- lapply(x, \\(x) + 100) dim(y) <- dim(x) arg.list <- list(x = x, y=y) bind2_array(arg.list, along=0, name_flat = TRUE) # binds on new dimension before first #> , , A #>  #>   a   b   c   #> x 1   2   3   #> y 100 100 100 #>  #> , , B #>  #>   a   b   c   #> x 4   5   6   #> y 100 100 100 #>  #> , , C #>  #>   a   b   c   #> x 7   8   9   #> y 100 100 100 #>  #> , , D #>  #>   a   b   c   #> x 10  11  12  #> y 100 100 100 #>  #> attr(,\"names\") #>  [1] \"Jan\"  \"y.1\"  \"Feb\"  \"y.2\"  \"Mar\"  \"y.3\"  \"Apr\"  \"y.4\"  \"May\"  \"y.5\"  #> [11] \"Jun\"  \"y.6\"  \"Jul\"  \"y.7\"  \"Aug\"  \"y.8\"  \"Sep\"  \"y.9\"  \"Oct\"  \"y.10\" #> [21] \"Nov\"  \"y.11\" \"Dec\"  \"y.12\" bind2_array(arg.list, along=1, name_flat = TRUE) # binds on first dimension #>     A   B   C   D   #> a   1   4   7   10  #> b   2   5   8   11  #> c   3   6   9   12  #> y.1 100 100 100 100 #> y.2 100 100 100 100 #> y.3 100 100 100 100 #> attr(,\"names\") #>  [1] \"Jan\"  \"Feb\"  \"Mar\"  \"y.1\"  \"y.2\"  \"y.3\"  \"Apr\"  \"May\"  \"Jun\"  \"y.4\"  #> [11] \"y.5\"  \"y.6\"  \"Jul\"  \"Aug\"  \"Sep\"  \"y.7\"  \"y.8\"  \"y.9\"  \"Oct\"  \"Nov\"  #> [21] \"Dec\"  \"y.10\" \"y.11\" \"y.12\" bind2_array(arg.list, along=2, name_flat = TRUE) #>   A B C D  y.1 y.2 y.3 y.4 #> a 1 4 7 10 100 100 100 100 #> b 2 5 8 11 100 100 100 100 #> c 3 6 9 12 100 100 100 100 #> attr(,\"names\") #>  [1] \"Jan\"  \"Feb\"  \"Mar\"  \"Apr\"  \"May\"  \"Jun\"  \"Jul\"  \"Aug\"  \"Sep\"  \"Oct\"  #> [11] \"Nov\"  \"Dec\"  \"y.1\"  \"y.2\"  \"y.3\"  \"y.4\"  \"y.5\"  \"y.6\"  \"y.7\"  \"y.8\"  #> [21] \"y.9\"  \"y.10\" \"y.11\" \"y.12\" bind2_array(arg.list, along=3, name_flat = TRUE) # bind on new dimension after last #> , , x #>  #>   A B C D  #> a 1 4 7 10 #> b 2 5 8 11 #> c 3 6 9 12 #>  #> , , y #>  #>   A   B   C   D   #> a 100 100 100 100 #> b 100 100 100 100 #> c 100 100 100 100 #>  #> attr(,\"names\") #>  [1] \"Jan\"  \"Feb\"  \"Mar\"  \"Apr\"  \"May\"  \"Jun\"  \"Jul\"  \"Aug\"  \"Sep\"  \"Oct\"  #> [11] \"Nov\"  \"Dec\"  \"y.1\"  \"y.2\"  \"y.3\"  \"y.4\"  \"y.5\"  \"y.6\"  \"y.7\"  \"y.8\"  #> [21] \"y.9\"  \"y.10\" \"y.11\" \"y.12\""},{"path":"https://tony-aw.github.io/squarebrackets/reference/ci.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct Indices — ci_flat","title":"Construct Indices — ci_flat","text":"functions construct flat dimensional indices. ci_flat() constructs integer vector flat indices. ci_margin() constructs integer vector indices one particular dimension margin. ci_sub() constructs list integer subscripts. ci_df() ci_margin(), except specifically designed data.frame-like objects.  separate function, things like dimnames(x)[1] rownames(x) always return output certain data.frame-like objects.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/ci.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct Indices — ci_flat","text":"","code":"ci_flat(   x,   i,   inv = FALSE,   chkdup = FALSE,   uniquely_named = FALSE,   .abortcall = sys.call() )  ci_margin(   x,   slice,   margin,   inv = FALSE,   chkdup = FALSE,   uniquely_named = FALSE,   .abortcall = sys.call() )  ci_sub(   x,   sub,   dims,   inv = FALSE,   chkdup = FALSE,   uniquely_named = FALSE,   .abortcall = sys.call() )  ci_df(   x,   slice,   margin,   inv = FALSE,   chkdup = FALSE,   uniquely_named = FALSE,   .abortcall = sys.call() )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/ci.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct Indices — ci_flat","text":"x object indices meant. , slice, margin, sub, dims, inv See squarebrackets_indx_args. chkdup see squarebrackets_options. uniquely_named Boolean, indicating user knows -priori relevant names x unique.  set TRUE, speed may increase.  specifying TRUE relevant names unique result incorrect output. .abortcall environment error message passed .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/ci.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct Indices — ci_flat","text":"integer vector casted indices.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/ci.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct Indices — ci_flat","text":"","code":"x.dim <- c(10, 10, 3) x.len <- prod(x.dim) x <- array(1:x.len, x.dim) sub <- list(c(4, 3), c(3, 2), c(2, 3)) coord <- sub2coord(sub, x.dim) print(coord) #>      [,1] [,2] [,3] #> [1,]    4    3    2 #> [2,]    3    3    2 #> [3,]    4    2    2 #> [4,]    3    2    2 #> [5,]    4    3    3 #> [6,]    3    3    3 #> [7,]    4    2    3 #> [8,]    3    2    3 ind <- coord2ind(coord, x.dim) print(ind) #> [1] 124 123 114 113 224 223 214 213 all(x[ind] == c(x[c(4, 3), c(3, 2), c(2, 3)])) # TRUE #> [1] TRUE coord2 <- ind2coord(ind, x.dim) print(coord) #>      [,1] [,2] [,3] #> [1,]    4    3    2 #> [2,]    3    3    2 #> [3,]    4    2    2 #> [4,]    3    2    2 #> [5,]    4    3    3 #> [6,]    3    3    3 #> [7,]    4    2    3 #> [8,]    3    2    3 all(coord == coord2) # TRUE #> [1] TRUE sub2 <- coord2sub(coord2) sapply(1:3, \\(i) sub2[[i]] == sub[[i]]) |> all() # TRUE #> [1] TRUE"},{"path":"https://tony-aw.github.io/squarebrackets/reference/class_mutable_atomic.html","id":null,"dir":"Reference","previous_headings":"","what":"Mutable Atomic Classes — class_mutable_atomic","title":"Mutable Atomic Classes — class_mutable_atomic","text":"mutable_atomic class mutable version atomic classes.  works exactly aspects regular atomic classes, one real difference:  'squarebrackets' methods functions perform modification reference (basically methods functions \"set\" name) accept mutable_atomic, accept regular atomic.  See squarebrackets_PassByReference details.  Like data.table, [<- performs R's default copy--modification semantics.  modification  reference, use sb_set.  Exposed functions (beside S3 methods): mutable_atomic(): create mutable_atomic object given data. couldb.mutable_atomic(): checks object become mutable_atomic.  objects can become mutable_atomic one following types: logical, integer, double, character, complex, raw. bit64::integer64 type also supported, since internally defined double. materialize_atomic(): takes immaterial ALTREP atomic object, returns materialized mutable_atomic object. typecast.mutable_atomic() type-casts possibly reshapes (mutable) atomic object, returns mutable_atomic object.  preserve dimension names dimensions changed.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/class_mutable_atomic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mutable Atomic Classes — class_mutable_atomic","text":"","code":"mutable_atomic(data, names = NULL, dim = NULL, dimnames = NULL)  as.mutable_atomic(x, ...)  is.mutable_atomic(x)  couldb.mutable_atomic(x)  typecast.mutable_atomic(x, type = typeof(x), dims = dim(x))  materialize_atomic(x)  # S3 method for mutable_atomic c(..., use.names = TRUE)  # S3 method for mutable_atomic [(x, ...)  # S3 method for mutable_atomic [(x, ...) <- value  # S3 method for mutable_atomic format(x, ...)  # S3 method for mutable_atomic print(x, ...)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/class_mutable_atomic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mutable Atomic Classes — class_mutable_atomic","text":"data atomic vector giving data fill mutable_atomic object. names, dim, dimnames see setNames array. x atomic object. ... method dependent arguments. type string giving type; see typeof. dims integer vector, giving new dimensions. use.names Boolean, indicating names preserved. value see Extract.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/class_mutable_atomic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mutable Atomic Classes — class_mutable_atomic","text":"mutable_atomic(), .mutable_atomic(), materialize_atomic(), typecast.mutable_atomic(): Returns mutable_atomic object.  .mutable_atomic(): Returns TRUE object mutable_atomic, returns FALSE otherwise.  couldb.mutable_atomic(): Returns TRUE object one following types: logical, integer, double, character, complex, raw. bit64::integer64 type also supported, since internally defined double. Returns FALSE otherwise.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/class_mutable_atomic.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"Mutable Atomic Classes — class_mutable_atomic","text":"Always use exported functions given 'squarebrackets' create mutable_atomic object, make necessary checks.  Circumventing checks may break things!","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/class_mutable_atomic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mutable Atomic Classes — class_mutable_atomic","text":"","code":"x <- mutable_atomic(   1:20, dim = c(5, 4), dimnames = list(letters[1:5], letters[1:4]) ) x #>   a  b  c  d #> a 1  6 11 16 #> b 2  7 12 17 #> c 3  8 13 18 #> d 4  9 14 19 #> e 5 10 15 20 #> mutable_atomic  #> typeof:  integer  typecast.mutable_atomic(x, \"character\") #>      [,1] [,2] [,3] [,4] #> [1,] \"1\"  \"6\"  \"11\" \"16\" #> [2,] \"2\"  \"7\"  \"12\" \"17\" #> [3,] \"3\"  \"8\"  \"13\" \"18\" #> [4,] \"4\"  \"9\"  \"14\" \"19\" #> [5,] \"5\"  \"10\" \"15\" \"20\" #> mutable_atomic  #> typeof:  character   x <- matrix(1:10, ncol = 2) x <- as.mutable_atomic(x) is.mutable_atomic(x) #> [1] TRUE print(x) #>      [,1] [,2] #> [1,]    1    6 #> [2,]    2    7 #> [3,]    3    8 #> [4,]    4    9 #> [5,]    5   10 #> mutable_atomic  #> typeof:  integer  x[, 1] #> [1] 1 2 3 4 5 #> mutable_atomic  #> typeof:  integer  x[] <- as.double(x) # notifies the user a copy is being made print(x) #>      [,1] [,2] #> [1,]    1    6 #> [2,]    2    7 #> [3,]    3    8 #> [4,]    4    9 #> [5,]    5   10 #> mutable_atomic  #> typeof:  double  is.mutable_atomic(x) #> [1] TRUE"},{"path":"https://tony-aw.github.io/squarebrackets/reference/cp_seq.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct Parameters for a Sequence Based on Margins — cp_seq","title":"Construct Parameters for a Sequence Based on Margins — cp_seq","text":"cp_seq() returns list parameters construct sequence based margins object.  internally used idx_r function.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/cp_seq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct Parameters for a Sequence Based on Margins — cp_seq","text":"","code":"cp_seq(x, m = 0L, from = NULL, to = NULL, by = 1L)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/cp_seq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct Parameters for a Sequence Based on Margins — cp_seq","text":"x object compute margin-based sequence parameters. m integer complex, giving margin(s).  non-dimensional objects flat indices, specify m = 0L. integer complex, length m length 1, specifying point. integer complex, length m length 1, specifying maximally allowed end value. integer, length m length 1, specifying step size.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/cp_seq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct Parameters for a Sequence Based on Margins — cp_seq","text":"list following elements:  $start: actual starting point sequence. simply translated regular numeric.  $end: actual ending point sequence. , even whe translated regular numeric. example, following code:   specifies = 10L. sequence actually end 10; ends 9. Therefore, cp_seq(x, m, 1, 10, 2) return end = 9, end = 10. allows user easily predict sequence given idx_r.  $: give , sign adjusted, needed.  $length.: actual vector lengths sequences , given translated parameters.","code":"seq(from = 1L, to = 10L, by = 2L) #> [1] 1 3 5 7 9"},{"path":"https://tony-aw.github.io/squarebrackets/reference/cp_seq.html","id":"arguments-details","dir":"Reference","previous_headings":"","what":"Arguments Details","title":"Construct Parameters for a Sequence Based on Margins — cp_seq","text":"Multiple dimensions  cp_seq function can construct sequence parameters needed multiple dimensions , specifying vector m.  lengths arguments recycled needed. Using  , specified, using construct following sequence:  positive, seq.int(1L, n, ).  negative, seq.int(n, 1L, ).  n maximum index (.e. length(x) dim(x)[m], depending situation). Using , ,  , , specified, stored abs(), sign  automatically adjusted ensure sensible sequence created.  , example, construct parameters get n:1, one can simply call cp_seq(x, m, = -1L).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/cp_seq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct Parameters for a Sequence Based on Margins — cp_seq","text":"","code":"x <- data.frame(   a = 1:10, b = letters[1:10], c = factor(letters[1:10]), d = -1:-10 ) print(x) #>     a b c   d #> 1   1 a a  -1 #> 2   2 b b  -2 #> 3   3 c c  -3 #> 4   4 d d  -4 #> 5   5 e e  -5 #> 6   6 f f  -6 #> 7   7 g g  -7 #> 8   8 h h  -8 #> 9   9 i i  -9 #> 10 10 j j -10 ind1 <- idx_r(x, 1, 2, 2* -1i) # rows 2:(nrow(x)-1) sb2_x(x, ind1) # extract the row range #>   a b c  d #> 1 2 b b -2 #> 2 3 c c -3 #> 3 4 d d -4 #> 4 5 e e -5 #> 5 6 f f -6 #> 6 7 g g -7 #> 7 8 h h -8 #> 8 9 i i -9  x <- array(1:125, c(5,5,5)) dims <- 1:3 sub <- idx_r(x, dims, 2, 2* -1i) # 2:(n-1) for every dimension sb_x(x, sub, dims) # same as x[ 2:4, 2:4, 2:4, drop = FALSE] #> , , 1 #>  #>      [,1] [,2] [,3] #> [1,]   32   37   42 #> [2,]   33   38   43 #> [3,]   34   39   44 #>  #> , , 2 #>  #>      [,1] [,2] [,3] #> [1,]   57   62   67 #> [2,]   58   63   68 #> [3,]   59   64   69 #>  #> , , 3 #>  #>      [,1] [,2] [,3] #> [1,]   82   87   92 #> [2,]   83   88   93 #> [3,]   84   89   94 #>   x <- letters x[idx_r(x, 0, 2, 2* -1i)] #>  [1] \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" \"t\" #> [20] \"u\" \"v\" \"w\" \"x\" \"y\""},{"path":"https://tony-aw.github.io/squarebrackets/reference/currentBindings.html","id":null,"dir":"Reference","previous_headings":"","what":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","text":"currentBindings(x, action = \"list\")  lists currently existing objects sharing address x, given environment. currentBindings(x, action = \"checklock\")  searches currently existing objects sharing address x, given environment, reports locked locked. currentBindings(x, action = \"lockbindings\")  searches currently existing objects sharing address x, given environment, locks using lockBinding.  See also squarebrackets_PassByReference information regarding relation locked bindings pass--reference modifications.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/currentBindings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","text":"","code":"currentBindings(x, action = \"list\", env = NULL)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/currentBindings.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","text":"x existing variable whose address use searching bindings. action single string, giving action perform.  Must one following: \"list\" (default). \"checklock\". \"lockbindings\". env environment look objects.  NULL (default), caller environment used.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/currentBindings.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","text":"currentBindings(x, action = \"list\"): Returns character vector.  currentBindings(x, action = \"checklock\"): Returns named logical vector. names give names bindings, associated value indicates whether binding locked (TRUE) locked (FALSE).  currentBindings(x, action = \"lockbindings\"): Returns VOID. just locks currently existing bindings. unlock bindings, remove objects (see rm).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/currentBindings.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","text":"lockBinding function locks binding object, preventing modification.  'R' also uses locked bindings prevent modification objects package namespaces.  pass--reference semantics 'squarebrackets' principle respect , disallows modification objects reference.  However, lockBinding lock address/pointer object, one particular binding object.  problematic; consider following example:   code, x y share address, thus pointing memory, yet y actually locked.  Since x locked, modifying x allowed.  since sb_set()/sb2_set() performs modification reference, y still modified, despite locked.  currentBindings() function allows user : find currently existing bindings caller environment sharing address x, locking bindings.","code":"x <- mutable_atomic(1:16) y <- x lockBinding(\"y\", environment()) sb_set(x, i = 1:6, rp = 8)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/currentBindings.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","text":"currentBindings() function locks currently existing bindings caller environment;  bindings created calling currentBindings() automatically locked.  Thus, every time user creates new binding object, user wishes locked, currentBindings() must called .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/currentBindings.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","text":"","code":"x <- as.mutable_atomic(1:10) y <- x lockBinding(\"y\", environment()) currentBindings(x) #> searching environment: <000002ba016033c0> #> [1] \"x\" \"y\" currentBindings(x, \"checklock\") # only y is locked #> searching environment: <000002ba016033c0> #>     x     y  #> FALSE  TRUE    # since only y is locked, we can still modify y through x by reference: sb_set(x, i = 1, rp = -1) #> coercing `rp` to integer print(y) # modified! #>  [1] -1  2  3  4  5  6  7  8  9 10 #> mutable_atomic  #> typeof:  integer  rm(list= c(\"y\")) # clean up   # one can fix this by locking ALL bindings: y <- x currentBindings(x, \"lockbindings\") # lock all #> searching environment: <000002ba016033c0> currentBindings(x, \"checklock\") # all bindings are locked, including y #> searching environment: <000002ba016033c0> #>    x    y  #> TRUE TRUE  # the 'squarebrackets' package respects the lock of a binding, # provided all bindings of an address are locked; # so this will give an error, as it should:  if(requireNamespace(\"tinytest\")) {   tinytest::expect_error(     sb_set(x, i = 1, rp = -1),     pattern = \"object is locked\"   ) } #> ----- PASSED      : <--> #>  call| eval(expr, envir, enclos)   # creating a new variable will NOT automatically be locked: z <- y # new variable; will not be locked! currentBindings(x, \"checklock\") # z is not locked #> searching environment: <000002ba016033c0> #>     x     y     z  #>  TRUE  TRUE FALSE  currentBindings(x, \"lockbindings\") # we must re-run this #> searching environment: <000002ba016033c0> currentBindings(x, \"checklock\") # now z is also locked #> searching environment: <000002ba016033c0> #>    x    y    z  #> TRUE TRUE TRUE   if(requireNamespace(\"tinytest\")) {   tinytest::expect_error( # now z is also protected     sb_set(z, i = 1, rp = -1),     pattern = \"object is locked\"   ) } #> ----- PASSED      : <--> #>  call| eval(expr, envir, enclos)    rm(list= c(\"x\", \"y\", \"z\")) # clean up"},{"path":"https://tony-aw.github.io/squarebrackets/reference/dt.html","id":null,"dir":"Reference","previous_headings":"","what":"Functional Forms of data.table Operations — dt","title":"Functional Forms of data.table Operations — dt","text":"Functional forms special data.table operations.  functions use Non-Standard Evaluation.  functions also benefit security measures 'squarebrackets' implements pass--reference semantics. dt_aggregate() aggregates data.table tidytable, returns aggregated copy. dt_setcoe() coercively transforms columns data.table tidytable using pass--reference semantics. dt_setrm() removes columns data.table tidytable using pass--reference semantics. dt_setadd(x, new) adds columns data.table/tidytable new data.table/tidytable x, thereby modifying x using pass--reference semantics. dt_setreorder() reorders rows /variables data.table using pass--reference semantics.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/dt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functional Forms of data.table Operations — dt","text":"","code":"dt_aggregate(x, SDcols = NULL, f, by, order_by = FALSE)  dt_setcoe(   x,   col = NULL,   vars = NULL,   v,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  dt_setrm(   x,   col = NULL,   vars = NULL,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  dt_setadd(x, new)  dt_setreorder(x, roworder = NULL, varorder = NULL)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/dt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functional Forms of data.table Operations — dt","text":"x data.table tidytable. SDcols atomic vector, giving columns aggregation function f() applied . f aggregation function atomic vector, giving grouping columns. order_by Boolean, indicating aggregated result ordered columns specified . col, vars see squarebrackets_indx_args.  Duplicates allowed. v coercive transformation function chkdup see squarebrackets_options. new data.frame-like object.  must column names already exist x. roworder integer vector length nrow(x), giving order rows re-order. Internally, numeric vector turned order using order, thus ensuring strict permutation 1:nrow(x). varorder integer character vector length ncol(x), giving new column order.  See data.table::setcolorder.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/dt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functional Forms of data.table Operations — dt","text":"dt_aggregate(): aggregated data.table object.  rest functions: Returns: VOID. functions modify object reference. use assignments like x <- dt_setcoe(x, ...). Since functions return void, just get NULL.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/dt.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Functional Forms of data.table Operations — dt","text":"dt_setreorder(x, roworder = roworder) internally creates new column reorder data.table , removes new column.  column name randomized, extra care given ensure overwrite existing columns.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/dt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functional Forms of data.table Operations — dt","text":"","code":"# dt_aggregate on sf-data.table ====  if(requireNamespace(\"sf\")) {   x <- sf::st_read(system.file(\"shape/nc.shp\", package = \"sf\"))   x <- data.table::as.data.table(x)      x$region <- ifelse(x$CNTY_ID <= 2000, 'high', 'low')   d.aggr <- dt_aggregate(     x, SDcols = \"geometry\", f= sf::st_union, by = \"region\"   )      head(d.aggr) } #> Loading required namespace: sf #> Reading layer `nc' from data source `D:\\Programs\\R-4.4.0\\library\\sf\\shape\\nc.shp' using driver `ESRI Shapefile' #> Simple feature collection with 100 features and 14 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 #> Geodetic CRS:  NAD27 #>    region                       geometry #>    <char>             <sfc_MULTIPOLYGON> #> 1:   high MULTIPOLYGON (((-75.78317 3... #> 2:    low MULTIPOLYGON (((-76.46926 3...    #############################################################################   # dt_setcoe ====  obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb2_set(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost ) #> Warning: 1.414214 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 1 named 'a') #> Warning: 3.464102 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 3 named 'c') str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 1 1 2 2 2 2 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 3 3 3 3 4 4 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) dt_setcoe(obj, vars = is.numeric, v = as.numeric) # integers are now numeric str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb2_set(obj,   filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # SAFE: coercion performed; so no warnings )  str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 1.41 1.73 2 2.24 ... #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  11 3.46 3.61 3.74 3.87 ... #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>    #############################################################################   # dt_setrm ====  obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  dt_setrm(obj, col = 1) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  3 variables: #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>   obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  dt_setrm(obj, vars = is.numeric) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  2 variables: #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>    #############################################################################   # dt_setadd ====  obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) new <- data.table::data.table(   e = sample(c(TRUE, FALSE), 10, TRUE),   f = sample(c(TRUE, FALSE), 10, TRUE) ) dt_setadd(obj, new) print(obj) #>         a      b     c      d      e      f #>     <int> <char> <int> <fctr> <lgcl> <lgcl> #>  1:     1      a    11      a   TRUE  FALSE #>  2:     2      b    12      b   TRUE   TRUE #>  3:     3      c    13      c  FALSE   TRUE #>  4:     4      d    14      d   TRUE   TRUE #>  5:     5      e    15      e   TRUE   TRUE #>  6:     6      f    16      f  FALSE  FALSE #>  7:     7      g    17      g   TRUE   TRUE #>  8:     8      h    18      h   TRUE   TRUE #>  9:     9      i    19      i   TRUE  FALSE #> 10:    10      j    20      j  FALSE  FALSE    #############################################################################   # dt_setreorder====  n <- 1e4 obj <- data.table::data.table(   a = 1L:n, b = n:1L, c = as.double(1:n), d = as.double(n:1) ) dt_setreorder(obj, roworder = n:1) head(obj) #>        a     b     c     d #>    <int> <int> <num> <num> #> 1: 10000     1 10000     1 #> 2:  9999     2  9999     2 #> 3:  9998     3  9998     3 #> 4:  9997     4  9997     4 #> 5:  9996     5  9996     5 #> 6:  9995     6  9995     6 dt_setreorder(obj, varorder = ncol(obj):1) head(obj) #>        d     c     b     a #>    <num> <num> <int> <int> #> 1:     1 10000     1 10000 #> 2:     2  9999     2  9999 #> 3:     3  9998     3  9998 #> 4:     4  9997     4  9997 #> 5:     5  9996     5  9996 #> 6:     6  9995     6  9995"},{"path":"https://tony-aw.github.io/squarebrackets/reference/exported_uilities.html","id":null,"dir":"Reference","previous_headings":"","what":"Exported Utilities — indx_x","title":"Exported Utilities — indx_x","text":"Exported utilities.  Usually user need functions.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/exported_uilities.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exported Utilities — indx_x","text":"","code":"indx_x(i, x, xnames, xsize)  indx_rm(i, x, xnames, xsize)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/exported_uilities.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exported Utilities — indx_x","text":"See squarebrackets_indx_args. x vector, vector-like object, factor, data.frame, data.frame-like object, list. xnames names dimension names xsize length dimension size","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/exported_uilities.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exported Utilities — indx_x","text":"subsetted object.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/exported_uilities.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Exported Utilities — indx_x","text":"","code":"x <- 1:10 names(x) <- letters[1:10] indx_x(1:5, x, names(x), length(x)) #> [1] 1 2 3 4 5 indx_rm(1:5, x, names(x), length(x)) #> [1]  6  7  8  9 10"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx1.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert/Translate Indices (for Copy-On-Modify Substitution) — idx","title":"Convert/Translate Indices (for Copy-On-Modify Substitution) — idx","text":"idx() method converts indices.  type output depends type input index arguments given: idx(x, = , ...) converts linear indices strictly positive integer vector linear indices. idx(x, sub = sub, dims = dims, ...) converts dimensional indices strictly positive integer vector linear indices. idx(x, slice = slice, margin = margin, ...) converts indices one dimension strictly positive integer vector indices specific dimension. Vectors (atomic recursive) index argument .  Data.frame-like objects slice, margin index argument pair.  Arrays (atomic recursive) sub, dims index argument pair, well arguments slice, margin.  result idx() method can used inside regular square-brackets operators.  example like :   thus allowing user benefit convenient index translations 'squarebrackets', whilst still using R's default copy--modification semantics (instead semantics provided 'squarebrackets').","code":"x <- array(...) my_indices <- idx(x, sub, dims) x[my_indices] <- value  y <- data.frame(...) rows <- idx(y, 1:10, 1, inv = TRUE) cols <- idx(y, c(\"a\", \"b\"), 2) y[rows, cols] <- value"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert/Translate Indices (for Copy-On-Modify Substitution) — idx","text":"","code":"idx(x, ...)  # S3 method for default idx(x, i, inv = FALSE, ..., chkdup = getOption(\"squarebrackets.chkdup\", FALSE))  # S3 method for array idx(   x,   sub = NULL,   dims = NULL,   slice = NULL,   margin = NULL,   i = NULL,   inv = FALSE,   ...,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # S3 method for data.frame idx(   x,   slice,   margin,   inv = FALSE,   ...,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx1.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert/Translate Indices (for Copy-On-Modify Substitution) — idx","text":"x vector, matrix, array, data.frame; atomic recursive objects supported. ... see squarebrackets_method_dispatch. , sub, dims, margin, slice, inv See squarebrackets_indx_args.  Duplicates allowed. chkdup see squarebrackets_options.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx1.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert/Translate Indices (for Copy-On-Modify Substitution) — idx","text":"idx(x, = , ...) idx(x, sub = sub, dims = dims, ...): strictly positive integer vector flat indices.  idx(x, margin = margin, slice = slice, ...): strictly positive integer vector indices dimension specified margin.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx1.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert/Translate Indices (for Copy-On-Modify Substitution) — idx","text":"","code":"# atomic ====  x <- 1:10 x[idx(x, \\(x)x>5)] <- -5 print(x) #>  [1]  1  2  3  4  5 -5 -5 -5 -5 -5  x <- array(1:27, dim = c(3,3,3)) x[idx(x, n(1:2, 1:2), c(1,3))] <- -10 print(x) #> , , 1 #>  #>      [,1] [,2] [,3] #> [1,]  -10  -10  -10 #> [2,]  -10  -10  -10 #> [3,]    3    6    9 #>  #> , , 2 #>  #>      [,1] [,2] [,3] #> [1,]  -10  -10  -10 #> [2,]  -10  -10  -10 #> [3,]   12   15   18 #>  #> , , 3 #>  #>      [,1] [,2] [,3] #> [1,]   19   22   25 #> [2,]   20   23   26 #> [3,]   21   24   27 #>    ################################################################################   # recursive ====  x <- as.list(1:10) x[idx(x, \\(x)x>5)] <- -5 print(x) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 3 #>  #> [[4]] #> [1] 4 #>  #> [[5]] #> [1] 5 #>  #> [[6]] #> [1] -5 #>  #> [[7]] #> [1] -5 #>  #> [[8]] #> [1] -5 #>  #> [[9]] #> [1] -5 #>  #> [[10]] #> [1] -5 #>   x <- array(as.list(1:27), dim = c(3,3,3)) x[idx(x, n(1:2, 1:2), c(1,3))] <- -10 print(x) #> , , 1 #>  #>      [,1] [,2] [,3] #> [1,] -10  -10  -10  #> [2,] -10  -10  -10  #> [3,] 3    6    9    #>  #> , , 2 #>  #>      [,1] [,2] [,3] #> [1,] -10  -10  -10  #> [2,] -10  -10  -10  #> [3,] 12   15   18   #>  #> , , 3 #>  #>      [,1] [,2] [,3] #> [1,] 19   22   25   #> [2,] 20   23   26   #> [3,] 21   24   27   #>    x <- data.frame(   a = sample(c(TRUE, FALSE, NA), 10, TRUE),   b = 1:10,   c = rnorm(10),   d = letters[1:10],   e = factor(letters[11:20]) ) rows <- idx(x, 1:5, 1, inv = TRUE) cols <- idx(x, c(\"b\", \"a\"), 2) x[rows, cols] <- NA print(x) #>        a  b            c d e #> 1  FALSE  1 -0.170848972 a k #> 2     NA  2  1.631206007 b l #> 3   TRUE  3 -0.782706041 c m #> 4   TRUE  4 -0.002893626 d n #> 5   TRUE  5  0.413239292 e o #> 6     NA NA  0.724433452 f p #> 7     NA NA  2.353944771 g q #> 8     NA NA -0.281449685 h r #> 9     NA NA -0.481046436 i s #> 10    NA NA  0.079225925 j t"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_by.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Grouped Indices — idx_by","title":"Compute Grouped Indices — idx_by","text":"Given: sub-set function f; object x margin m; grouping factor grp; idx_by() function takes indices per group grp.  result idx_by() can supplied indexing arguments (see squarebrackets_indx_args) perform grouped subset operations.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_by.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Grouped Indices — idx_by","text":"","code":"idx_by(x, m, f, grp, parallel = FALSE, mc.cores = 1L)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_by.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Grouped Indices — idx_by","text":"x object compute indices. m single non-negative integer giving margin compute indices.  flat indices non-dimensional objects, use m = 0L. f subset function applied per group indices.  m == 0L, indices defined setNames(1:length(x), names(x)).  m > 0L, indices defined setNames(1:dim(x)[m], dimnames(x)[[m]]).  function must produce character integer vector output.  example, subset last element per group, specify: f = last grp factor giving groups. parallel, mc.cores see .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_by.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Grouped Indices — idx_by","text":"vector indices.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_by.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Grouped Indices — idx_by","text":"","code":"# vectors ==== (a <- 1:20) #>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 (grp <- factor(rep(letters[1:5], each = 4))) #>  [1] a a a a b b b b c c c c d d d d e e e e #> Levels: a b c d e  # get the last element of `a` for each group in `grp`: i <- idx_by(a, 0L, last, grp) sb_x(cbind(a, grp), row = i) #>       a grp #> [1,]  4   1 #> [2,]  8   2 #> [3,] 12   3 #> [4,] 16   4 #> [5,] 20   5   # data.frame ==== x <- data.frame(   a = sample(1:20),   b = letters[1:20],   group = factor(rep(letters[1:5], each = 4)) ) print(x) #>     a b group #> 1   1 a     a #> 2   6 b     a #> 3   2 c     a #> 4  14 d     a #> 5  20 e     b #> 6   9 f     b #> 7  18 g     b #> 8   5 h     b #> 9   8 i     c #> 10 16 j     c #> 11  3 k     c #> 12 10 l     c #> 13 17 m     d #> 14  7 n     d #> 15 12 o     d #> 16 15 p     d #> 17 19 q     e #> 18  4 r     e #> 19 11 s     e #> 20 13 t     e # get the first row for each group in data.frame `x`: row <- idx_by(x, 1, first, x$group) sb2_x(x, row) #>    a b group #> 1  1 a     a #> 2 20 e     b #> 3  8 i     c #> 4 17 m     d #> 5 19 q     e # get the first row for each group for which a > 10: x2 <- sb2_x(x, filter = ~ a > 10) row <- na.omit(idx_by(x2, 1, first, x2$group)) sb2_x(x2, row) #>    a b group #> 1 14 d     a #> 2 20 e     b #> 3 16 j     c #> 4 17 m     d #> 5 19 q     e"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_ord.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Ordered Indices — idx_ord_v","title":"Compute Ordered Indices — idx_ord_v","text":"Computes ordered indices. Similar order, except user must supply vector, list equal-length vectors, data.frame matrix (row-wise column-wise supported), input.  vector x, idx_ord_v(x) equivalent order(x).  data.frame list equal-length vectors x, p columns/elements, idx_ord_df(x) equivalent order(x[[1]], ..., x[[p]]).  matrix (array) x p rows, idx_ord_m(x, margin = 1) equivalent order(x[1, ], ..., x[p, ], ...).  matrix (array) x p columns, idx_ord_m(x, margin = 2) equivalent order(x[, 1], ..., x[, p], ...).  Note merely convenience functions, actually slightly slower order (except idx_ord_v()), due additional functionality.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_ord.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Ordered Indices — idx_ord_v","text":"","code":"idx_ord_v(   x,   na.last = TRUE,   decr = FALSE,   method = c(\"auto\", \"shell\", \"radix\") )  idx_ord_m(   x,   margin,   na.last = TRUE,   decr = FALSE,   method = c(\"auto\", \"shell\", \"radix\") )  idx_ord_df(   x,   na.last = TRUE,   decr = FALSE,   method = c(\"auto\", \"shell\", \"radix\") )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_ord.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Ordered Indices — idx_ord_v","text":"x vector, data.frame, array na.last, method see order sort. decr see argument decreasing order margin margin cut matrix/array vectors.  .e. margin = 1L cut x individual rows, apply order rows.  margin = 2L cut x columns, etc.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_ord.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Ordered Indices — idx_ord_v","text":"See order.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_ord.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Ordered Indices — idx_ord_v","text":"","code":"x <- sample(1:10) order(x) #>  [1]  4  5  3  7  8  1  6  9 10  2 idx_ord_v(x) #>  [1]  4  5  3  7  8  1  6  9 10  2 idx_ord_m(rbind(x, x), 1) #>  [1]  4  5  3  7  8  1  6  9 10  2 idx_ord_m(cbind(x, x), 2) #>  [1]  4  5  3  7  8  1  6  9 10  2 idx_ord_df(data.frame(x, x)) #>  [1]  4  5  3  7  8  1  6  9 10  2"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_r.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Integer Index Range — idx_r","title":"Compute Integer Index Range — idx_r","text":"idx_r() computes integer index range(s).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_r.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Integer Index Range — idx_r","text":"","code":"idx_r(x, m = 0L, from = NULL, to = NULL, by = 1L)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_r.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Integer Index Range — idx_r","text":"x object compute subset indices. m, , , see cp_seq.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_r.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Integer Index Range — idx_r","text":"length(m) == 1L: vector numeric indices.  length(m) > 1L: list length m, containing numeric vectors indices.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_r.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Integer Index Range — idx_r","text":"","code":"x <- data.frame(   a = 1:10, b = letters[1:10], c = factor(letters[1:10]), d = -1:-10 ) print(x) #>     a b c   d #> 1   1 a a  -1 #> 2   2 b b  -2 #> 3   3 c c  -3 #> 4   4 d d  -4 #> 5   5 e e  -5 #> 6   6 f f  -6 #> 7   7 g g  -7 #> 8   8 h h  -8 #> 9   9 i i  -9 #> 10 10 j j -10 ind1 <- idx_r(x, 1, 2, 2* -1i) # rows 2:(nrow(x)-1) sb2_x(x, ind1) # extract the row range #>   a b c  d #> 1 2 b b -2 #> 2 3 c c -3 #> 3 4 d d -4 #> 4 5 e e -5 #> 5 6 f f -6 #> 6 7 g g -7 #> 7 8 h h -8 #> 8 9 i i -9  x <- array(1:125, c(5,5,5)) dims <- 1:3 sub <- idx_r(x, dims, 2, 2* -1i) # 2:(n-1) for every dimension sb_x(x, sub, dims) # same as x[ 2:4, 2:4, 2:4, drop = FALSE] #> , , 1 #>  #>      [,1] [,2] [,3] #> [1,]   32   37   42 #> [2,]   33   38   43 #> [3,]   34   39   44 #>  #> , , 2 #>  #>      [,1] [,2] [,3] #> [1,]   57   62   67 #> [2,]   58   63   68 #> [3,]   59   64   69 #>  #> , , 3 #>  #>      [,1] [,2] [,3] #> [1,]   82   87   92 #> [2,]   83   88   93 #> [3,]   84   89   94 #>   x <- letters x[idx_r(x, 0, 2, 2* -1i)] #>  [1] \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" \"t\" #> [20] \"u\" \"v\" \"w\" \"x\" \"y\""},{"path":"https://tony-aw.github.io/squarebrackets/reference/lst.html","id":null,"dir":"Reference","previous_headings":"","what":"Unnest Tree-like List to Recursive 2d Array or Flattened Recursive Vector — lst","title":"Unnest Tree-like List to Recursive 2d Array or Flattened Recursive Vector — lst","text":"[[, [[<-, sb2_rec, sb2_recin, can performing recursive subset operation nested list.  recursive subset operations operate single element.  Performing recursive subset operations multiple elements vectorized, requires (potentially slow) loop.  lst_untree() function takes nested tree-like list, turns 2d recursive array (.e. list-matrix), allowing vectorized subset operations performed list. lst_untree() can also simply flatten list, making non-nested list.  See Examples section understand list arranged named.  lst_nlists() counts total number recursive list-elements inside list.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/lst.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unnest Tree-like List to Recursive 2d Array or Flattened Recursive Vector — lst","text":"","code":"lst_nlists(x)  lst_untree(x, margin, use.names = FALSE)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/lst.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Unnest Tree-like List to Recursive 2d Array or Flattened Recursive Vector — lst","text":"x tree-like nested list. margin single integer, indicating result arranged: margin = 0 produces simple flattened recursive vector (.e. list) without dimensions. margin = 1 produces 2D recursive array (.e. matrix lists),  length(x) rows n columns,  n = sapply(x, lst_nlists) |> max().  Empty elements filled list(NULL). margin = 2 produces 2D recursive array (.e. matrix lists),  length(x) columns n rows,  n = sapply(x, lst_nlists) |> max().  Empty elements filled list(NULL). use.names Boolean, indicating elements returned lst_untree() named.  Names nested elements, x[[c(\"\", \"B\", \"C\")]], become \".B.C\", behaviour rapply function (lst_untree() calls internally).  therefore advised use dots (\".\") list names, use underscores (\"_\") instead, calling lst_untree().  See rrapply::rrapply function renaming (forms transforming) recursive subsets lists.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/lst.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Unnest Tree-like List to Recursive 2d Array or Flattened Recursive Vector — lst","text":"lst_untree(): non-nested (dimensional) list. Note margin = 1 margin = 2, lst_untree() returns recursive matrix (.e. recursive array 2 dimensions), data.frame. (One advantage recursive matrix data.frame, recursive matrix can separate column names regular names, whereas names data.frame necessarily equal column names).  lst_nlists(): single integer, giving total number recursive list-elements given list.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/lst.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Unnest Tree-like List to Recursive 2d Array or Flattened Recursive Vector — lst","text":"","code":"# show-casing how the list-elements are arranged and named ====  x <- list(   A = list(     A = list(A = \"AAA\", B = \"AAB\"),     A = list(A  = \"AA2A\", B = \"AA2B\"),     B = list(A = \"ABA\", B = \"ABB\"),     C = letters   ),   Y = list(     Z = list(Z = \"YZZ\", Y = \"YZY\"),     Y = list(Z = \"YYZ\", Y = \"YYY\"),     X = \"YX\"   ) )   # un-tree column-wise: sapply(x, lst_nlists) |> max() # number of rows `y` will have #> [1] 7 y <- lst_untree(x, margin = 2, use.names = TRUE) dim(y) #> [1] 7 2 print(y) #>      A            Y     #> [1,] \"AAA\"        \"YZZ\" #> [2,] \"AAB\"        \"YZY\" #> [3,] \"AA2A\"       \"YYZ\" #> [4,] \"AA2B\"       \"YYY\" #> [5,] \"ABA\"        \"YX\"  #> [6,] \"ABB\"        NULL  #> [7,] character,26 NULL  #> attr(,\"names\") #>  [1] \"A.A.A\" \"A.A.B\" \"A.A.A\" \"A.A.B\" \"A.B.A\" \"A.B.B\" \"A.C\"   \"Y.Z.Z\" \"Y.Z.Y\" #> [10] \"Y.Y.Z\" \"Y.Y.Y\" \"Y.X\"   \"\"      \"\"      y[[\"Y.Z.Y\"]] # you can still use names for selecting/replacing #> [1] \"YZY\" sb2_x(y, 1:3, 1:2) # vectorized selection of multiple recursive elements #>      A      Y     #> [1,] \"AAA\"  \"YZZ\" #> [2,] \"AAB\"  \"YZY\" #> [3,] \"AA2A\" \"YYZ\" #> attr(,\"names\") #> [1] \"A.A.A\" \"A.A.B\" \"A.A.A\" \"Y.Z.Z\" \"Y.Z.Y\" \"Y.Y.Z\"   # un-tree row-wise: sapply(x, lst_nlists) |> max() # number of columns `y` will have #> [1] 7 y <- lst_untree(x, margin = 1, use.names = TRUE) dim(y) #> [1] 2 7 print(y) #>   [,1]  [,2]  [,3]   [,4]   [,5]  [,6]  [,7]         #> A \"AAA\" \"AAB\" \"AA2A\" \"AA2B\" \"ABA\" \"ABB\" character,26 #> Y \"YZZ\" \"YZY\" \"YYZ\"  \"YYY\"  \"YX\"  NULL  NULL         #> attr(,\"names\") #>  [1] \"A.A.A\" \"Y.Z.Z\" \"A.A.B\" \"Y.Z.Y\" \"A.A.A\" \"Y.Y.Z\" \"A.A.B\" \"Y.Y.Y\" \"A.B.A\" #> [10] \"Y.X\"   \"A.B.B\" \"\"      \"A.C\"   \"\"      y[[\"Y.Z.Y\"]] # you can still use names for selecting/replacing #> [1] \"YZY\" sb2_x(y,1:2, 1:3)  # vectorized selection of multiple recursive elements #>   [,1]  [,2]  [,3]   #> A \"AAA\" \"AAB\" \"AA2A\" #> Y \"YZZ\" \"YZY\" \"YYZ\"  #> attr(,\"names\") #> [1] \"A.A.A\" \"Y.Z.Z\" \"A.A.B\" \"Y.Z.Y\" \"A.A.A\" \"Y.Y.Z\"   # simple flattened list: y <- lst_untree(x, margin = 0, use.names = TRUE) print(y) #> $A.A.A #> [1] \"AAA\" #>  #> $A.A.B #> [1] \"AAB\" #>  #> $A.A.A #> [1] \"AA2A\" #>  #> $A.A.B #> [1] \"AA2B\" #>  #> $A.B.A #> [1] \"ABA\" #>  #> $A.B.B #> [1] \"ABB\" #>  #> $A.C #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" #> [20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\" #>  #> $Y.Z.Z #> [1] \"YZZ\" #>  #> $Y.Z.Y #> [1] \"YZY\" #>  #> $Y.Y.Z #> [1] \"YYZ\" #>  #> $Y.Y.Y #> [1] \"YYY\" #>  #> $Y.X #> [1] \"YX\" #>  y[[\"Y.Z.Y\"]] #> [1] \"YZY\" x[[c(\"Y\", \"Z\", \"Y\")]] # equivalent in the original list #> [1] \"YZY\"   ################################################################################  # showcasing that only list-elements are recursively flattened ==== # i.e. atomic vectors in recursive subsets remain atomic  x <- lapply(1:10, \\(x)list(sample(letters), sample(1:10)))  sapply(x, lst_nlists) |> max() #> [1] 2 y <- lst_untree(x, margin = 1) dim(y) #> [1] 10  2 print(y) #>       [,1]         [,2]       #>  [1,] character,26 integer,10 #>  [2,] character,26 integer,10 #>  [3,] character,26 integer,10 #>  [4,] character,26 integer,10 #>  [5,] character,26 integer,10 #>  [6,] character,26 integer,10 #>  [7,] character,26 integer,10 #>  [8,] character,26 integer,10 #>  [9,] character,26 integer,10 #> [10,] character,26 integer,10  lst_untree(x, margin = 1) #>       [,1]         [,2]       #>  [1,] character,26 integer,10 #>  [2,] character,26 integer,10 #>  [3,] character,26 integer,10 #>  [4,] character,26 integer,10 #>  [5,] character,26 integer,10 #>  [6,] character,26 integer,10 #>  [7,] character,26 integer,10 #>  [8,] character,26 integer,10 #>  [9,] character,26 integer,10 #> [10,] character,26 integer,10   ################################################################################  # showcasing vectorized sub-setting ==== x <- lapply(1:10, \\(x) list(   list(sample(letters[1:10]), sample(LETTERS[1:10])),   list(sample(month.abb), sample(month.name)),   list(sample(1:10), rnorm(10)) )) y <- lst_untree(x, 1)  # getting the first recursive elements in the second level/depth in base R: for(i in seq_along(x)) {   x[[c(i, c(1,1))]] }  # the same, but vectorized using the untree'd list: y[seq_len(nrow(y)), 1] #> [[1]] #>  [1] \"a\" \"h\" \"e\" \"j\" \"d\" \"c\" \"g\" \"b\" \"f\" \"i\" #>  #> [[2]] #>  [1] \"i\" \"b\" \"d\" \"e\" \"f\" \"g\" \"a\" \"j\" \"h\" \"c\" #>  #> [[3]] #>  [1] \"g\" \"a\" \"b\" \"f\" \"j\" \"i\" \"d\" \"c\" \"h\" \"e\" #>  #> [[4]] #>  [1] \"a\" \"f\" \"b\" \"j\" \"h\" \"d\" \"e\" \"i\" \"c\" \"g\" #>  #> [[5]] #>  [1] \"c\" \"h\" \"d\" \"a\" \"g\" \"i\" \"j\" \"e\" \"b\" \"f\" #>  #> [[6]] #>  [1] \"a\" \"b\" \"d\" \"j\" \"c\" \"f\" \"i\" \"h\" \"e\" \"g\" #>  #> [[7]] #>  [1] \"a\" \"e\" \"d\" \"g\" \"c\" \"h\" \"f\" \"i\" \"b\" \"j\" #>  #> [[8]] #>  [1] \"f\" \"h\" \"c\" \"j\" \"e\" \"i\" \"a\" \"g\" \"b\" \"d\" #>  #> [[9]] #>  [1] \"d\" \"h\" \"c\" \"e\" \"g\" \"b\" \"f\" \"i\" \"a\" \"j\" #>  #> [[10]] #>  [1] \"j\" \"a\" \"f\" \"b\" \"d\" \"e\" \"h\" \"g\" \"i\" \"c\" #>"},{"path":"https://tony-aw.github.io/squarebrackets/reference/match_all.html","id":null,"dir":"Reference","previous_headings":"","what":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","title":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","text":"Find indices vector haystack equal vector needles, taking account order vectors, duplicate values.  essentially much efficient version :   Like lapply(needles, \\() (haystack == )), NAs ignored.  Core code based suggestion Sebastian Kranz (author 'collapse' package).","code":"lapply(needles, \\(i) which(haystack == i))"},{"path":"https://tony-aw.github.io/squarebrackets/reference/match_all.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","text":"","code":"match_all(needles, haystack, unlist = TRUE)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/match_all.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","text":"needles, haystack vectors unlist Boolean, indicating result single integer vector (TRUE, default), list (length = length(needles)) integer vectors (FALSE).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/match_all.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","text":"integer vector, list integer vector. list, element list corresponds value needles. needles /haystack /empty fully NA, match_all() returns empty integer vector (unlist = TRUE), empty list (unlist = FALSE).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/match_all.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","text":"","code":"n <- 200 haystack <- sample(letters, n, TRUE) needles <- sample(letters, n/2, TRUE) indices1 <- match_all(needles, haystack) head(indices1) #> [1]  71  88 147 154   8  32"},{"path":"https://tony-aw.github.io/squarebrackets/reference/ma_setv.html","id":null,"dir":"Reference","previous_headings":"","what":"Find and Replace Present Values in mutable_atomic Objects By Reference — ma_setv","title":"Find and Replace Present Values in mutable_atomic Objects By Reference — ma_setv","text":"ma_setv(x, v rp) function performs equivalent x[(x == v)] <- rp  using pass--reference semantics.  faster using sb_set(x, = (x == v), rp = rp).  Inspired collapse::setv, written 'C++' 'Rcpp', additional safety checks.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/ma_setv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find and Replace Present Values in mutable_atomic Objects By Reference — ma_setv","text":"","code":"ma_setv(x, v, rp, invert = FALSE, NA.safety = TRUE)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/ma_setv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find and Replace Present Values in mutable_atomic Objects By Reference — ma_setv","text":"x mutable_atomic variable. v non-missing (NA NaN) atomic scalar find. rp atomic scalar giving replacement value. invert Boolean.  FALSE (default), equivalent x[(x == v()] <- rp performed;  TRUE, equivalent x[(x != v)] <- rp performed instead. NA.safety Boolean.  just like , NA NaN results x==v ignored, thus NA.safety TRUE default.  However, known x contains NAs NaNs, setting NA.safety FALSE increase performance bit.  NOTE: Setting NA.safety = FALSE x contain NAs NaNs, may result unexpected behaviour.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/ma_setv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find and Replace Present Values in mutable_atomic Objects By Reference — ma_setv","text":"Returns: VOID. function modifies object reference. use assignment like x <- ma_setv(x, ...). Since function returns void, just get NULL.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/ma_setv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find and Replace Present Values in mutable_atomic Objects By Reference — ma_setv","text":"","code":"x <- mutable_atomic(c(1:20, NA, NaN)) print(x) #>  [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19 #> [20]  20  NA NaN #> mutable_atomic  #> typeof:  double  ma_setv(x, 2, 100) print(x) #>  [1]   1 100   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19 #> [20]  20  NA NaN #> mutable_atomic  #> typeof:  double"},{"path":"https://tony-aw.github.io/squarebrackets/reference/nest.html","id":null,"dir":"Reference","previous_headings":"","what":"Nest — n","title":"Nest — n","text":"c() function concatenates vectors lists vector (possible) else list.  analogy function, n() function nests objects list (atomic vector, atomic vectors nested).  short-hand version list function.  handy lists often needed 'squarebrackets', especially arrays.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/nest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nest — n","text":"","code":"n()"},{"path":"https://tony-aw.github.io/squarebrackets/reference/nest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nest — n","text":"list.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/nest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Nest — n","text":"","code":"obj <- array(1:64, c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  sb_x(obj, n(1:3, 1:2), c(1,3)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #>  # above is equivalent to obj[1:3, , 1:2, drop = FALSE]"},{"path":"https://tony-aw.github.io/squarebrackets/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. data.table address, copy, first, last","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb2_rec.html","id":null,"dir":"Reference","previous_headings":"","what":"Access, Replace, Transform, Remove, or Extend Recursive Subsets — sb2_rec","title":"Access, Replace, Transform, Remove, or Extend Recursive Subsets — sb2_rec","text":"sb2_rec() sb2_recin() methods essentially convenient wrappers around [[ [[<-, respectively. sb2_rec() access recursive subsets lists. sb2_recin() can following things: replace transform recursive subsets list, using R's default Copy--Modify semantics, specifying rp tf argument, respectively. remove recursive subset list, using R's default Copy--Modify semantics, specifying argument rp = NULL. extending list additional recursive elements, using R's default Copy--Modify semantics.  done specifying --bounds index argument rec, entering new values argument rp.  Note adding surface level elements dimensional list remove dimension attributes list.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb2_rec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Access, Replace, Transform, Remove, or Extend Recursive Subsets — sb2_rec","text":"","code":"sb2_rec(x, rec)  sb2_recin(x, rec, rp, tf)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb2_rec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Access, Replace, Transform, Remove, or Extend Recursive Subsets — sb2_rec","text":"x list, list-like object. rec integer (including negative integers) character vector length p, x[[rec]] equivalent x[[ rec[1] ]]...[[ rec[p] ]], providing final indexing results list.  certain subset level nested list, multiple subsets name exist, first one selected performing recursive indexing name, due recursive nature type subsetting. rp optional, allows multiple functionalities: simplest case, performs x[[rec]] <- rp, using R's default semantics.  Since replacement recursive subset, rp necessarily list ; rp can type object. specifying rp = NULL, remove (recursive) subset x[[rec]].  specify actual NULL instead removing subset, use list(NULL). rec integer, specifies --bounds subset, sb2_recin() add value rp list.  empty positions filled NA. rec character, specifies non-existing name, sb2_recin() add value rp list new element end. tf optional function. specified, performs x[[rec]] <- tf(x[[rec]]), using R's default Copy--Modify semantics.  support extending list like argument rp.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb2_rec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Access, Replace, Transform, Remove, or Extend Recursive Subsets — sb2_rec","text":"sb2_rec(): Returns recursive subset.  sb2_recin(..., rp = rp): Returns VOID, replaces, adds, removes specified recursive subset, using R's default Copy--Modify semantics.  sb2_recin(..., tf = tf): Returns VOID, transforms specified recursive subset, using R's default Copy--Modify semantics.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb2_rec.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Access, Replace, Transform, Remove, or Extend Recursive Subsets — sb2_rec","text":"Since recursive objects pointers objects, extending list removing element list copy entire list, contrast atomic vectors.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb2_rec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Access, Replace, Transform, Remove, or Extend Recursive Subsets — sb2_rec","text":"","code":"lst <- list(   A = list(     A = list(A = \"AAA\", B = \"AAB\"),     A = list(A  = \"AA2A\", B = \"AA2B\"),     B = list(A = \"ABA\", B = \"ABB\")   ),   B = list(     A = list(A = \"BAA\", B = \"BAB\"),     B = list(A = \"BBA\", B = \"BBB\")   ) )  #############################################################################  # access recursive subsets ====  sb2_rec(lst, c(1,2,2)) # this gives \"AA2B\" #> [1] \"AA2B\" sb2_rec(lst, c(\"A\", \"B\", \"B\")) # this gives \"ABB\" #> [1] \"ABB\" sb2_rec(lst, c(2,2,1)) # this gives \"BBA\" #> [1] \"BBA\" sb2_rec(lst, c(\"B\", \"B\", \"A\")) # this gives \"BBA\" #> [1] \"BBA\"   #############################################################################  # replace recursive subset with R's default in-place semantics ====  # replace \"AAB\" using R's default in-place semantics: sb2_recin(   lst, c(\"A\", \"A\", \"B\"),   rp = \"THIS IS REPLACED WITH IN-PLACE SEMANTICS\" ) print(lst) #> $A #> $A$A #> $A$A$A #> [1] \"AAA\" #>  #> $A$A$B #> [1] \"THIS IS REPLACED WITH IN-PLACE SEMANTICS\" #>  #>  #> $A$A #> $A$A$A #> [1] \"AA2A\" #>  #> $A$A$B #> [1] \"AA2B\" #>  #>  #> $A$B #> $A$B$A #> [1] \"ABA\" #>  #> $A$B$B #> [1] \"ABB\" #>  #>  #>  #> $B #> $B$A #> $B$A$A #> [1] \"BAA\" #>  #> $B$A$B #> [1] \"BAB\" #>  #>  #> $B$B #> $B$B$A #> [1] \"BBA\" #>  #> $B$B$B #> [1] \"BBB\" #>  #>  #>     #############################################################################  # replace shallow subsets with R's default in-place semantics ====  for(i in c(\"A\", \"B\")) sb2_recin(lst, i, rp = \"AND THEN THERE WERE NONE\")  print(lst) #> $A #> [1] \"AND THEN THERE WERE NONE\" #>  #> $B #> [1] \"AND THEN THERE WERE NONE\" #>    #############################################################################  # Modify View of List By Reference ====  x <- list(  a = data.table::data.table(cola = 1:10, colb = letters[1:10]),  b = data.table::data.table(cola = 11:20, colb = letters[11:20]) ) print(x) #> $a #>      cola   colb #>     <int> <char> #>  1:     1      a #>  2:     2      b #>  3:     3      c #>  4:     4      d #>  5:     5      e #>  6:     6      f #>  7:     7      g #>  8:     8      h #>  9:     9      i #> 10:    10      j #>  #> $b #>      cola   colb #>     <int> <char> #>  1:    11      k #>  2:    12      l #>  3:    13      m #>  4:    14      n #>  5:    15      o #>  6:    16      p #>  7:    17      q #>  8:    18      r #>  9:    19      s #> 10:    20      t #>  mypointer <- sb2_rec(x, \"a\") address(mypointer) == address(x$a) # they are the same #> [1] TRUE sb2_set(mypointer, col = \"cola\", tf = \\(x)x^2) print(x) # notice x has been changed #> $a #>      cola   colb #>     <num> <char> #>  1:     1      a #>  2:     4      b #>  3:     9      c #>  4:    16      d #>  5:    25      e #>  6:    36      f #>  7:    49      g #>  8:    64      h #>  9:    81      i #> 10:   100      j #>  #> $b #>      cola   colb #>     <int> <char> #>  1:    11      k #>  2:    12      l #>  3:    13      m #>  4:    14      n #>  5:    15      o #>  6:    16      p #>  7:    17      q #>  8:    18      r #>  9:    19      s #> 10:    20      t #>"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":null,"dir":"Reference","previous_headings":"","what":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"S3 Method return copy object modified subsets.  Use sb_mod(x, ...) x atomic object; returns full copy.  Use sb2_mod(x, ...) x recursive object (.e. list data.frame-like); returns partial copy.  modifying subsets using R's default copy--modification semantics, see idx.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"","code":"sb_mod(x, ...)  # S3 method for default sb_mod(   x,   i = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # S3 method for matrix sb_mod(   x,   row = NULL,   col = NULL,   i = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # S3 method for array sb_mod(   x,   sub = NULL,   dims = NULL,   i = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  sb2_mod(x, ...)  # S3 method for default sb2_mod(   x,   i = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE),   .lapply = lapply )  # S3 method for matrix sb2_mod(   x,   row = NULL,   col = NULL,   i = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE),   .lapply = lapply )  # S3 method for array sb2_mod(   x,   sub = NULL,   dims = NULL,   i = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE),   .lapply = lapply )  # S3 method for data.frame sb2_mod(   x,   row = NULL,   col = NULL,   filter = NULL,   vars = NULL,   inv = FALSE,   coe = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE),   .lapply = lapply )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"x see squarebrackets_immutable_classes squarebrackets_mutable_classes. ... see squarebrackets_method_dispatch. , row, col, sub, dims, filter, vars, inv See squarebrackets_indx_args.  empty index selection returns original object unchanged. rp, tf, .lapply see squarebrackets_modify. chkdup see squarebrackets_options. coe Either FALSE (default), TRUE, function.  argument coe ignored row filter arguments set NULL.  See Details section info.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"copy object replaced/transformed values.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"Transform Replace  Specifying argument tf transform subset.  Specifying rp replace subset.  One specify tf rp. either one set . Argument coe  data.frame-like objects, sb_mod() can auto-coerce whole columns, subsets columns.  automatically coerce column types row filter also specified.  coe arguments provides 2 ways circumvent : user can supply coercion function argument coe.  function applied entirety every column specified col vars; columns outside subset affected.  coercion function , course, applied replacement (rp) transformation (tf()). user can set coe = TRUE.  case, whole columns specified col vars extracted copied list.  Subsets list element, corresponding selected rows, modified rp tf(), using R's regular auto-coercion rules.  modified list returned data.frame-like object, replacing original columns. Note coercion required additional memory.  larger data.frame-like object, larger memory.  default, coe = FALSE, uses least amount memory.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"","code":"# atomic objects ====  obj <- matrix(1:16, ncol = 4) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 rp <- -1:-9 sb_mod(obj, 1:3, 1:3, rp = rp) #>       a  b  c  a #> [1,] -1 -4 -7 13 #> [2,] -2 -5 -8 14 #> [3,] -3 -6 -9 15 #> [4,]  4  8 12 16 # above is equivalent to  obj[1:3, 1:3] <- -1:-9; obj sb_mod(obj, i = \\(x)x<=5, rp = -1:-5) #>       a  b  c  a #> [1,] -1 -5  9 13 #> [2,] -2  6 10 14 #> [3,] -3  7 11 15 #> [4,] -4  8 12 16 # above is equivalent to  obj[obj <= 5] <- -1:-5; obj sb_mod(obj, col = \"a\", rp = -1:-8) #>       a b  c  a #> [1,] -1 5  9 -5 #> [2,] -2 6 10 -6 #> [3,] -3 7 11 -7 #> [4,] -4 8 12 -8 # above is equivalent to  obj[, which(colnames(obj) %in% \"a\")] <- -1:-8; obj sb_mod(obj, 1:3, 1:3, tf = \\(x) -x) #>       a  b   c  a #> [1,] -1 -5  -9 13 #> [2,] -2 -6 -10 14 #> [3,] -3 -7 -11 15 #> [4,]  4  8  12 16 # above is equivalent to  obj[1:3, 1:3] <- (-1 * obj[1:3, 1:3]); obj sb_mod(obj, i = \\(x)x<=5, tf = \\(x) -x) #>       a  b  c  a #> [1,] -1 -5  9 13 #> [2,] -2  6 10 14 #> [3,] -3  7 11 15 #> [4,] -4  8 12 16 # above is equivalent to  obj[obj <= 5] <- (-1 * obj[obj <= 5]); obj  obj <- matrix(1:16, ncol = 4) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 sb_mod(obj, 1:3, 1:3, tf = \\(x) -x) #>       a  b   c  a #> [1,] -1 -5  -9 13 #> [2,] -2 -6 -10 14 #> [3,] -3 -7 -11 15 #> [4,]  4  8  12 16 # above is equivalent to  obj[1:3, 1:3] <- -1 * obj[1:3, 1:3] sb_mod(obj, i = \\(x)x<=5, tf = \\(x) -x) #>       a  b  c  a #> [1,] -1 -5  9 13 #> [2,] -2  6 10 14 #> [3,] -3  7 11 15 #> [4,] -4  8 12 16 # above is equivalent to  obj[obj <= 5] <- -1:-5; obj sb_mod(obj, col = \"a\", tf = \\(x) -x) #>       a b  c   a #> [1,] -1 5  9 -13 #> [2,] -2 6 10 -14 #> [3,] -3 7 11 -15 #> [4,] -4 8 12 -16 # above is equivalent to  obj[, which(colnames(obj) %in% \"a\")] <- -1:-8; obj  obj <- array(1:64, c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  sb_mod(obj, list(1:3, 1:2), c(1,3), rp = -1:-24) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   -1   -4   -7  -10 #> [2,]   -2   -5   -8  -11 #> [3,]   -3   -6   -9  -12 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]  -13  -16  -19  -22 #> [2,]  -14  -17  -20  -23 #> [3,]  -15  -18  -21  -24 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  # above is equivalent to obj[1:3, , 1:2] <- -1:-24 sb_mod(obj, i = \\(x)x<=5, rp = -1:-5) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   -1   -5    9   13 #> [2,]   -2    6   10   14 #> [3,]   -3    7   11   15 #> [4,]   -4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  # above is equivalent to obj[obj <= 5] <- -1:-5  #############################################################################   # lists ====  obj <- list(a = 1:10, b = letters[1:11], c = 11:20) print(obj) #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  sb2_mod(obj, \"a\", rp = list(1L)) #> $a #> [1] 1 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  # above is equivalent to  obj[[\"a\"]] <- 1L; obj sb2_mod(obj, is.numeric, rp = list(-1:-10, -11:-20)) #> $a #>  [1]  -1  -2  -3  -4  -5  -6  -7  -8  -9 -10 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] -11 -12 -13 -14 -15 -16 -17 -18 -19 -20 #>  # above is equivalent to  obj[which(sapply(obj, is.numeric))] <- list(-1:-10, -11:-20); obj  #############################################################################   # dimensional lists ==== obj <- rbind(   lapply(1:4, \\(x)sample(c(TRUE, FALSE, NA))),   lapply(1:4, \\(x)sample(1:10)),   lapply(1:4, \\(x)rnorm(10)),   lapply(1:4, \\(x)sample(letters)) ) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a            b            c            a            #> [1,] logical,3    logical,3    logical,3    logical,3    #> [2,] integer,10   integer,10   integer,10   integer,10   #> [3,] numeric,10   numeric,10   numeric,10   numeric,10   #> [4,] character,26 character,26 character,26 character,26 sb2_mod(obj, 1:3, 1:3, rp = n(-1)) #>      a            b            c            a            #> [1,] -1           -1           -1           logical,3    #> [2,] -1           -1           -1           integer,10   #> [3,] -1           -1           -1           numeric,10   #> [4,] character,26 character,26 character,26 character,26 # above is equivalent to obj[1:3, 1:3] <- list(-1) sb2_mod(obj, i = is.numeric, rp = n(-1)) #>      a            b            c            a            #> [1,] logical,3    logical,3    logical,3    logical,3    #> [2,] -1           -1           -1           -1           #> [3,] -1           -1           -1           -1           #> [4,] character,26 character,26 character,26 character,26 # above is equivalent to obj[sapply(obj, is.numeric)] <- list(-1) sb2_mod(obj, col = c(\"a\"), rp = n(-1)) #>      a  b            c            a  #> [1,] -1 logical,3    logical,3    -1 #> [2,] -1 integer,10   integer,10   -1 #> [3,] -1 numeric,10   numeric,10   -1 #> [4,] -1 character,26 character,26 -1 # above is equivalent to # obj[, lapply(c(\"a\", \"a\"), \\(i) which(colnames(obj) == i)) |> unlist()] <- list(-1)   obj <- array(as.list(1:64), c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 1    5    9    13   #> [2,] 2    6    10   14   #> [3,] 3    7    11   15   #> [4,] 4    8    12   16   #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 17   21   25   29   #> [2,] 18   22   26   30   #> [3,] 19   23   27   31   #> [4,] 20   24   28   32   #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 33   37   41   45   #> [2,] 34   38   42   46   #> [3,] 35   39   43   47   #> [4,] 36   40   44   48   #>  sb2_mod(obj, list(1:3, 1:2), c(1,3), rp = as.list(-1:-24)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,] -1   -4   -7   -10  #> [2,] -2   -5   -8   -11  #> [3,] -3   -6   -9   -12  #> [4,] 4    8    12   16   #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,] -13  -16  -19  -22  #> [2,] -14  -17  -20  -23  #> [3,] -15  -18  -21  -24  #> [4,] 20   24   28   32   #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 33   37   41   45   #> [2,] 34   38   42   46   #> [3,] 35   39   43   47   #> [4,] 36   40   44   48   #>  # above is equivalent to obj[1:3, , 1:2] <- as.list(-1:-24) sb2_mod(obj, i = \\(x)x<=5, rp = as.list(-1:-5)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,] -1   -5   9    13   #> [2,] -2   6    10   14   #> [3,] -3   7    11   15   #> [4,] -4   8    12   16   #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 17   21   25   29   #> [2,] 18   22   26   30   #> [3,] 19   23   27   31   #> [4,] 20   24   28   32   #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 33   37   41   45   #> [2,] 34   38   42   46   #> [3,] 35   39   43   47   #> [4,] 36   40   44   48   #>  # above is equivalent to obj[sapply(onj, \\(x) x <= 5)] <- as.list(-1:-5)   #############################################################################  # data.frame-like objects  - whole columns ====  obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 sb2_mod(   obj, vars = is.numeric,   tf = sqrt # SAFE: row=NULL & filter = NULL, so coercion performed ) #>           a b        c d #> 1  1.000000 a 3.316625 a #> 2  1.414214 b 3.464102 b #> 3  1.732051 c 3.605551 c #> 4  2.000000 d 3.741657 d #> 5  2.236068 e 3.872983 e #> 6  2.449490 f 4.000000 f #> 7  2.645751 g 4.123106 g #> 8  2.828427 h 4.242641 h #> 9  3.000000 i 4.358899 i #> 10 3.162278 j 4.472136 j  #############################################################################  # data.frame-like objects  - partial columns ====  obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10  sb2_mod(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost )  #> Warning: 1.414214 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 1 named 'a') #> Warning: 3.464102 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 3 named 'c') #>     a b  c d #> 1   1 a 11 a #> 2   1 b  3 b #> 3   1 c  3 c #> 4   2 d  3 d #> 5   2 e  3 e #> 6   2 f  4 f #> 7   2 g  4 g #> 8   8 h 18 h #> 9   9 i 19 i #> 10 10 j 20 j sb2_mod(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   coe = as.double, tf = sqrt # SAFE: coercion performed )  #>            a b         c d #> 1   1.000000 a 11.000000 a #> 2   1.414214 b  3.464102 b #> 3   1.732051 c  3.605551 c #> 4   2.000000 d  3.741657 d #> 5   2.236068 e  3.872983 e #> 6   2.449490 f  4.000000 f #> 7   2.645751 g  4.123106 g #> 8   8.000000 h 18.000000 h #> 9   9.000000 i 19.000000 i #> 10 10.000000 j 20.000000 j sb2_mod(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   coe = TRUE, tf = sqrt # SAFE: coercion performed )  #>            a b         c d #> 1   1.000000 a 11.000000 a #> 2   1.414214 b  3.464102 b #> 3   1.732051 c  3.605551 c #> 4   2.000000 d  3.741657 d #> 5   2.236068 e  3.872983 e #> 6   2.449490 f  4.000000 f #> 7   2.645751 g  4.123106 g #> 8   8.000000 h 18.000000 h #> 9   9.000000 i 19.000000 i #> 10 10.000000 j 20.000000 j"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_rm.html","id":null,"dir":"Reference","previous_headings":"","what":"Method to Un-Select/Remove Subsets of an Object — sb_rm","title":"Method to Un-Select/Remove Subsets of an Object — sb_rm","text":"S3 Method un-select/remove subsets object.  Use sb_rm(x, ...) x atomic object.  Use sb2_rm(x, ...) x recursive object (.e. list data.frame-like).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_rm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method to Un-Select/Remove Subsets of an Object — sb_rm","text":"","code":"sb_rm(x, ...)  # S3 method for default sb_rm(x, i = NULL, ..., chkdup = getOption(\"squarebrackets.chkdup\", FALSE))  # S3 method for matrix sb_rm(   x,   row = NULL,   col = NULL,   i = NULL,   ...,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # S3 method for array sb_rm(   x,   sub = NULL,   dims = NULL,   i = NULL,   ...,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  sb2_rm(x, ...)  # S3 method for default sb2_rm(   x,   i = NULL,   red = FALSE,   ...,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # S3 method for matrix sb2_rm(   x,   row = NULL,   col = NULL,   i = NULL,   red = FALSE,   ...,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # S3 method for array sb2_rm(   x,   sub = NULL,   dims = NULL,   i = NULL,   red = FALSE,   ...,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # S3 method for data.frame sb2_rm(   x,   row = NULL,   col = NULL,   filter = NULL,   vars = NULL,   ...,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_rm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method to Un-Select/Remove Subsets of an Object — sb_rm","text":"x see squarebrackets_immutable_classes squarebrackets_mutable_classes. ... see squarebrackets_method_dispatch. , row, col, sub, dims, filter, vars See squarebrackets_indx_args.  empty index selection results nothing removed, entire object returned. chkdup see squarebrackets_options. red Boolean, list .  f red = TRUE, selecting single element non-empty arguments give simplified result, like using [[]].  red = FALSE, list always returned regardless number elements.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_rm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Method to Un-Select/Remove Subsets of an Object — sb_rm","text":"copy sub-setted object.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_rm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Method to Un-Select/Remove Subsets of an Object — sb_rm","text":"","code":"# atomic objects ====  obj <- matrix(1:16, ncol = 4) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 sb_rm(obj, 1:3, 1:3) #>       a #> [1,] 16 # above is equivalent to  obj[-1:-3, -1:-3, drop = FALSE] sb_rm(obj, i = \\(x)x>5) #> [1] 1 2 3 4 5 # above is equivalent to  obj[!obj > 5] sb_rm(obj, col = \"a\") #>      b  c #> [1,] 5  9 #> [2,] 6 10 #> [3,] 7 11 #> [4,] 8 12 # above is equivalent to  obj[, which(!colnames(obj) %in% \"a\")]  obj <- array(1:64, c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  sb_rm(obj, n(1, c(1, 3)), c(1, 3)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   18   22   26   30 #> [2,]   19   23   27   31 #> [3,]   20   24   28   32 #>  # above is equivalent to obj[-1, , c(-1, -3), drop = FALSE] sb_rm(obj, i = \\(x)x>5) #> [1] 1 2 3 4 5 # above is equivalent to obj[!obj > 5]    #############################################################################   # lists ====  obj <- list(a = 1:10, b = letters[1:11], c = 11:20) print(obj) #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  sb2_rm(obj, \"a\") #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  # above is equivalent to obj[which(!names(obj) %in% \"a\")] sb2_rm(obj, 1) # obj[-1] #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  sb2_rm(obj, 1:2) #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  # above is equivalent to obj[seq_len(length(obj))[-1:-2]] sb2_rm(obj, is.numeric, red = TRUE) #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" # above is equivalent to obj[[!sapply(obj, is.numeric)]] IF this returns a single element obj <- list(a = 1:10, b = letters[1:11], c = letters) sb2_rm(obj, is.numeric) #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" #> [20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\" #>  # above is equivalent to obj[!sapply(obj, is.numeric)] # this time singular brackets? # for recusive indexing, see sb2_rec()   #############################################################################   # dimensional lists ====  obj <- rbind(   lapply(1:4, \\(x)sample(c(TRUE, FALSE, NA))),   lapply(1:4, \\(x)sample(1:10)),   lapply(1:4, \\(x)rnorm(10)),   lapply(1:4, \\(x)sample(letters)) ) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a            b            c            a            #> [1,] logical,3    logical,3    logical,3    logical,3    #> [2,] integer,10   integer,10   integer,10   integer,10   #> [3,] numeric,10   numeric,10   numeric,10   numeric,10   #> [4,] character,26 character,26 character,26 character,26 sb2_rm(obj, 1:3, 1:3) #>      a            #> [1,] character,26 # above is equivalent to obj[1:3, 1:3, drop = FALSE] sb2_rm(obj, i = is.numeric) #> [[1]] #> [1]    NA FALSE  TRUE #>  #> [[2]] #>  [1] \"x\" \"g\" \"k\" \"c\" \"s\" \"q\" \"m\" \"o\" \"d\" \"t\" \"p\" \"n\" \"v\" \"r\" \"b\" \"e\" \"y\" \"z\" \"i\" #> [20] \"a\" \"f\" \"w\" \"u\" \"h\" \"j\" \"l\" #>  #> [[3]] #> [1] FALSE  TRUE    NA #>  #> [[4]] #>  [1] \"h\" \"f\" \"z\" \"r\" \"y\" \"j\" \"o\" \"c\" \"w\" \"t\" \"g\" \"q\" \"a\" \"s\" \"k\" \"v\" \"n\" \"e\" \"i\" #> [20] \"u\" \"l\" \"p\" \"m\" \"x\" \"b\" \"d\" #>  #> [[5]] #> [1] FALSE    NA  TRUE #>  #> [[6]] #>  [1] \"r\" \"x\" \"c\" \"z\" \"v\" \"p\" \"n\" \"y\" \"o\" \"w\" \"q\" \"i\" \"k\" \"b\" \"j\" \"d\" \"m\" \"t\" \"l\" #> [20] \"u\" \"e\" \"g\" \"s\" \"f\" \"a\" \"h\" #>  #> [[7]] #> [1]    NA  TRUE FALSE #>  #> [[8]] #>  [1] \"r\" \"y\" \"d\" \"c\" \"i\" \"x\" \"n\" \"l\" \"z\" \"p\" \"a\" \"u\" \"h\" \"t\" \"v\" \"j\" \"m\" \"e\" \"s\" #> [20] \"w\" \"g\" \"k\" \"q\" \"f\" \"b\" \"o\" #>  # above is equivalent to obj[sapply(obj, is.numeric)] sb2_rm(obj, col = c(\"a\", \"a\")) #>      b            c            #> [1,] logical,3    logical,3    #> [2,] integer,10   integer,10   #> [3,] numeric,10   numeric,10   #> [4,] character,26 character,26 # above is equivalent to obj[, lapply(c(\"a\", \"a\"), \\(i) which(colnames(obj) == i)) |> unlist()]  obj <- array(as.list(1:64), c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 1    5    9    13   #> [2,] 2    6    10   14   #> [3,] 3    7    11   15   #> [4,] 4    8    12   16   #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 17   21   25   29   #> [2,] 18   22   26   30   #> [3,] 19   23   27   31   #> [4,] 20   24   28   32   #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 33   37   41   45   #> [2,] 34   38   42   46   #> [3,] 35   39   43   47   #> [4,] 36   40   44   48   #>  sb2_rm(obj, n(1, c(1, 3)), c(1, 3)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 18   22   26   30   #> [2,] 19   23   27   31   #> [3,] 20   24   28   32   #>  # above is equivalent to obj[-1, , c(-1, -3), drop = FALSE] sb2_rm(obj, i = \\(x)x>5) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 3 #>  #> [[4]] #> [1] 4 #>  #> [[5]] #> [1] 5 #>  # above is equivalent to obj[!sapply(obj, \\(x) x > 5)]    #############################################################################  # data.frame-like objects ====  obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) print(obj) #>     a b  c d #> 1   1 a 11 a #> 2   2 b 12 b #> 3   3 c 13 c #> 4   4 d 14 d #> 5   5 e 15 e #> 6   6 f 16 f #> 7   7 g 17 g #> 8   8 h 18 h #> 9   9 i 19 i #> 10 10 j 20 j sb2_rm(obj, 1:3, 1:3) #>   d #> 1 d #> 2 e #> 3 f #> 4 g #> 5 h #> 6 i #> 7 j # above is equivalent to obj[-1:-3, -1:-3, drop = FALSE] sb2_rm(obj, filter = ~ (a > 5) & (c < 19), vars = is.numeric) #>   b d #> 1 a a #> 2 b b #> 3 c c #> 4 d d #> 5 e e #> 6 i i #> 7 j j"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":null,"dir":"Reference","previous_headings":"","what":"Method to Modify Subsets of a Mutable Object By Reference — sb_set","title":"Method to Modify Subsets of a Mutable Object By Reference — sb_set","text":"S3 Method replace transform subset supported mutable object using pass--reference semantics  Use sb_set(x, ...) x atomic object (.e. mutable_atomic).  Use sb2_set(x, ...) x recursive object (.e. data.table).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method to Modify Subsets of a Mutable Object By Reference — sb_set","text":"","code":"sb_set(x, ...)  # S3 method for default sb_set(   x,   i = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # S3 method for matrix sb_set(   x,   row = NULL,   col = NULL,   i = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # S3 method for array sb_set(   x,   sub = NULL,   dims = NULL,   i = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  sb2_set(x, ...)  # S3 method for default sb2_set(x, ...)  # S3 method for data.table sb2_set(   x,   row = NULL,   col = NULL,   filter = NULL,   vars = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE),   .lapply = lapply )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method to Modify Subsets of a Mutable Object By Reference — sb_set","text":"x variable belonging one supported mutable classes. ... see squarebrackets_method_dispatch. , row, col, sub, dims, filter, vars, inv See squarebrackets_indx_args.  empty index selection leaves original object unchanged. rp, tf, .lapply see squarebrackets_modify. chkdup see squarebrackets_options.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Method to Modify Subsets of a Mutable Object By Reference — sb_set","text":"Returns: VOID. method modifies object reference. use assignments like x <- sb_set(x, ...). Since function returns void, just get NULL.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Method to Modify Subsets of a Mutable Object By Reference — sb_set","text":"Transform Replace  Specifying argument tf transform subset. Specifying rp replace subset. One specify tf rp. either one set .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Method to Modify Subsets of a Mutable Object By Reference — sb_set","text":"","code":"# mutable_atomic objects ====  gen_mat <- function() {   obj <- as.mutable_atomic(matrix(1:16, ncol = 4))   colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\")   return(obj) }  obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutable_atomic  #> typeof:  integer  sb_set(obj, 1:3, 1:3, rp = -1:-9) obj2 #>       a  b  c  a #> [1,] -1 -4 -7 13 #> [2,] -2 -5 -8 14 #> [3,] -3 -6 -9 15 #> [4,]  4  8 12 16 #> mutable_atomic  #> typeof:  integer  obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutable_atomic  #> typeof:  integer  sb_set(obj, i = \\(x)x<=5, rp = -1:-5) obj2 #>       a  b  c  a #> [1,] -1 -5  9 13 #> [2,] -2  6 10 14 #> [3,] -3  7 11 15 #> [4,] -4  8 12 16 #> mutable_atomic  #> typeof:  integer  obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutable_atomic  #> typeof:  integer  sb_set(obj, col = \"a\", rp = cbind(-1:-4, -5:-8)) obj2 #>       a b  c  a #> [1,] -1 5  9 -5 #> [2,] -2 6 10 -6 #> [3,] -3 7 11 -7 #> [4,] -4 8 12 -8 #> mutable_atomic  #> typeof:  integer   obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutable_atomic  #> typeof:  integer  sb_set(obj, 1:3, 1:3, tf = \\(x) -x) obj2 #>       a  b   c  a #> [1,] -1 -5  -9 13 #> [2,] -2 -6 -10 14 #> [3,] -3 -7 -11 15 #> [4,]  4  8  12 16 #> mutable_atomic  #> typeof:  integer  obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutable_atomic  #> typeof:  integer  sb_set(obj, i = \\(x)x<=5, tf = \\(x) -x) obj2 #>       a  b  c  a #> [1,] -1 -5  9 13 #> [2,] -2  6 10 14 #> [3,] -3  7 11 15 #> [4,] -4  8 12 16 #> mutable_atomic  #> typeof:  integer  obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutable_atomic  #> typeof:  integer  sb_set(obj, col = \"a\", tf = \\(x) -x) obj2 #>       a b  c   a #> [1,] -1 5  9 -13 #> [2,] -2 6 10 -14 #> [3,] -3 7 11 -15 #> [4,] -4 8 12 -16 #> mutable_atomic  #> typeof:  integer    gen_array <- function() {   as.mutable_atomic(array(1:64, c(4,4,3))) } obj <- gen_array() obj #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  #> mutable_atomic  #> typeof:  integer  sb_set(obj, list(1:3, 1:2, c(1, 3)), 1:3, rp = -1:-12) obj #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   -1   -4    9   13 #> [2,]   -2   -5   10   14 #> [3,]   -3   -6   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   -7  -10   41   45 #> [2,]   -8  -11   42   46 #> [3,]   -9  -12   43   47 #> [4,]   36   40   44   48 #>  #> mutable_atomic  #> typeof:  integer  obj <- gen_array() obj #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  #> mutable_atomic  #> typeof:  integer  sb_set(obj, i = \\(x)x<=5, rp = -1:-5) obj #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   -1   -5    9   13 #> [2,]   -2    6   10   14 #> [3,]   -3    7   11   15 #> [4,]   -4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  #> mutable_atomic  #> typeof:  integer    #############################################################################  # data.table ====  obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb2_set(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost ) #> Warning: 1.414214 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 1 named 'a') #> Warning: 3.464102 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 3 named 'c') print(obj) #>         a      b     c      d #>     <int> <char> <int> <fctr> #>  1:     1      a    11      a #>  2:     1      b     3      b #>  3:     1      c     3      c #>  4:     2      d     3      d #>  5:     2      e     3      e #>  6:     2      f     4      f #>  7:     2      g     4      g #>  8:     8      h    18      h #>  9:     9      i    19      i #> 10:    10      j    20      j  obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) dt_setcoe(obj, vars = is.numeric, v = as.numeric) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb2_set(obj,   filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # SAFE: coercion performed by dt_setcoe(); so no warnings )  print(obj) #>             a      b         c      d #>         <num> <char>     <num> <fctr> #>  1:  1.000000      a 11.000000      a #>  2:  1.414214      b  3.464102      b #>  3:  1.732051      c  3.605551      c #>  4:  2.000000      d  3.741657      d #>  5:  2.236068      e  3.872983      e #>  6:  2.449490      f  4.000000      f #>  7:  2.645751      g  4.123106      g #>  8:  8.000000      h 18.000000      h #>  9:  9.000000      i 19.000000      i #> 10: 10.000000      j 20.000000      j  obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb2_set(   obj, vars = is.numeric,   tf = sqrt # SAFE: row=NULL & filter = NULL, so coercion performed ) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 1.41 1.73 2 2.24 ... #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  3.32 3.46 3.61 3.74 3.87 ... #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_setRename.html","id":null,"dir":"Reference","previous_headings":"","what":"Change the Names of a Mutable Object By Reference — sb_setRename","title":"Change the Names of a Mutable Object By Reference — sb_setRename","text":"Functions rename supported mutable object using pass--reference semantics: sb_setFlatnames() renames (flat) names mutable_atomic object. sb_setDimnames() renames dimension names mutable_atomic object. sb2_setVarnames() renames variable names data.table object.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_setRename.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Change the Names of a Mutable Object By Reference — sb_setRename","text":"","code":"sb_setFlatnames(x, i = NULL, newnames, ...)  sb_setDimnames(x, m, newdimnames, ...)  sb2_setVarnames(x, old, new, skip_absent = FALSE, ...)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_setRename.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Change the Names of a Mutable Object By Reference — sb_setRename","text":"x variable belonging one supported mutable classes. logical, numeric, character, imaginary indices, indicating flatnames changed.  = NULL, names completely replaced. newnames Atomic character vector giving new names.  Specifying NULL remove names. ... see squarebrackets_method_dispatch. m integer vector giving margin(s) change names (m = 1L rows, m = 2L columns, etc.). newdimnames list length m.  first element list corresponds margin m[1], second element m[2], .  components list can either NULL, character vector length corresponding dimension.  Instead list, simply NULL can specified, remove dimnames completely. old old column names new new column names, order old skip_absent Skip items old missing (.e. absent) names(x).  Default FALSE halts error missing.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_setRename.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Change the Names of a Mutable Object By Reference — sb_setRename","text":"Returns: VOID. method modifies object reference. use assignment like names(x) <- sb_setRename(x, ...). Since function returns void, just get NULL.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_setRename.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Change the Names of a Mutable Object By Reference — sb_setRename","text":"methods take extra care modify objects happen share address (dim)names x.  .e. following code:   modify base::letters, even though names(x) shared address.  Thus, functions can used safely without fearing accidents.","code":"x <- mutable_atomic(1:26) names(x) <- base::letters y <- x sb_setFlatname(x, newnames = rev(names(x)))"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_setRename.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Change the Names of a Mutable Object By Reference — sb_setRename","text":"","code":"# mutable atomic vector ==== x <- y <- mutable_atomic(1:10, names = letters[1:10]) print(x) #>  a  b  c  d  e  f  g  h  i  j  #>  1  2  3  4  5  6  7  8  9 10  #> mutable_atomic  #> typeof:  integer  sb_setFlatnames(x, newnames = rev(letters[1:10])) print(y) #>  j  i  h  g  f  e  d  c  b  a  #>  1  2  3  4  5  6  7  8  9 10  #> mutable_atomic  #> typeof:  integer   x <- y <- mutable_atomic(1:10, names = letters[1:10]) print(x) #>  a  b  c  d  e  f  g  h  i  j  #>  1  2  3  4  5  6  7  8  9 10  #> mutable_atomic  #> typeof:  integer  sb_setFlatnames(x, 1L, \"XXX\") print(y) #> XXX   b   c   d   e   f   g   h   i   j  #>   1   2   3   4   5   6   7   8   9  10  #> mutable_atomic  #> typeof:  integer   ################################################################################   # mutable atomic matrix ==== x <- mutable_atomic(   1:20, dim = c(5, 4), dimnames = n(letters[1:5], letters[1:4]) ) print(x) #>   a  b  c  d #> a 1  6 11 16 #> b 2  7 12 17 #> c 3  8 13 18 #> d 4  9 14 19 #> e 5 10 15 20 #> mutable_atomic  #> typeof:  integer  sb_setDimnames(   x,   1:2,   lapply(dimnames(x), rev) ) print(x) #>   d  c  b  a #> e 1  6 11 16 #> d 2  7 12 17 #> c 3  8 13 18 #> b 4  9 14 19 #> a 5 10 15 20 #> mutable_atomic  #> typeof:  integer     ################################################################################    # data.table ====  x <- data.table::data.table(   a = 1:20,   b = letters[1:20] ) print(x) #>         a      b #>     <int> <char> #>  1:     1      a #>  2:     2      b #>  3:     3      c #>  4:     4      d #>  5:     5      e #>  6:     6      f #>  7:     7      g #>  8:     8      h #>  9:     9      i #> 10:    10      j #> 11:    11      k #> 12:    12      l #> 13:    13      m #> 14:    14      n #> 15:    15      o #> 16:    16      p #> 17:    17      q #> 18:    18      r #> 19:    19      s #> 20:    20      t #>         a      b sb2_setVarnames(x, old = names(x), new = rev(names(x))) print(x) #>         b      a #>     <int> <char> #>  1:     1      a #>  2:     2      b #>  3:     3      c #>  4:     4      d #>  5:     5      e #>  6:     6      f #>  7:     7      g #>  8:     8      h #>  9:     9      i #> 10:    10      j #> 11:    11      k #> 12:    12      l #> 13:    13      m #> 14:    14      n #> 15:    15      o #> 16:    16      p #> 17:    17      q #> 18:    18      r #> 19:    19      s #> 20:    20      t #>         b      a"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_x.html","id":null,"dir":"Reference","previous_headings":"","what":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","title":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","text":"S3 Method extract, exchange, duplicate (.e. repeat x times) subsets object.  Use sb_x(x, ...) x atomic object.  Use sb2_x(x, ...) x recursive object (.e. list data.frame-like).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_x.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","text":"","code":"sb_x(x, ...)  # S3 method for default sb_x(x, i = NULL, ...)  # S3 method for matrix sb_x(x, row = NULL, col = NULL, i = NULL, ...)  # S3 method for array sb_x(x, sub = NULL, dims = NULL, i = NULL, ...)  sb2_x(x, ...)  # S3 method for default sb2_x(x, i = NULL, red = FALSE, ...)  # S3 method for matrix sb2_x(x, row = NULL, col = NULL, i = NULL, red = FALSE, ...)  # S3 method for array sb2_x(x, sub = NULL, dims = NULL, i = NULL, red = FALSE, ...)  # S3 method for data.frame sb2_x(x, row = NULL, col = NULL, filter = NULL, vars = NULL, ...)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_x.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","text":"x see squarebrackets_immutable_classes squarebrackets_mutable_classes. ... see squarebrackets_method_dispatch. , row, col, sub, dims, filter, vars See squarebrackets_indx_args.  Duplicates allowed, resulting duplicated indices.  empty index selection results empty object length 0. red Boolean, lists , indicating result reduced.  red = TRUE, selecting single element non-empty arguments give simplified result, like using [[]].  red = FALSE, list always returned regardless number elements.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_x.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","text":"Returns copy sub-setted object.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_x.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","text":"","code":"# atomic objects ====  obj <- matrix(1:16, ncol = 4) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 sb_x(obj, 1:3, 1:3) #>      a b  c #> [1,] 1 5  9 #> [2,] 2 6 10 #> [3,] 3 7 11 # above is equivalent to obj[1:3, 1:3, drop = FALSE] sb_x(obj, i = \\(x)x>5) #>  [1]  6  7  8  9 10 11 12 13 14 15 16 # above is equivalent to obj[obj > 5] sb_x(obj, col = c(\"a\", \"a\")) #>      a  a a  a #> [1,] 1 13 1 13 #> [2,] 2 14 2 14 #> [3,] 3 15 3 15 #> [4,] 4 16 4 16 # above is equivalent to obj[, lapply(c(\"a\", \"a\"), \\(i) which(colnames(obj) == i)) |> unlist()]  obj <- array(1:64, c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  sb_x(obj, n(1:3, 1:2), c(1,3)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #>  # above is equivalent to obj[1:3, , 1:2, drop = FALSE] sb_x(obj, i = \\(x)x>5) #>  [1]  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #> [26] 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 # above is equivalent to obj[obj > 5]   #############################################################################   # lists ====  obj <- list(a = 1:10, b = letters[1:11], c = 11:20) print(obj) #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  sb2_x(obj, 1) # obj[1] #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  sb2_x(obj, 1, red = TRUE) # obj[[1]] #>  [1]  1  2  3  4  5  6  7  8  9 10 sb2_x(obj, 1:2) # obj[1:2] #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  sb2_x(obj, is.numeric) # obj[sapply(obj, is.numeric)] #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  # for recursive subsets, see sb2_rec()   ################################################################################  # dimensional lists ====  obj <- rbind(   lapply(1:4, \\(x)sample(c(TRUE, FALSE, NA))),   lapply(1:4, \\(x)sample(1:10)),   lapply(1:4, \\(x)rnorm(10)),   lapply(1:4, \\(x)sample(letters)) ) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a            b            c            a            #> [1,] logical,3    logical,3    logical,3    logical,3    #> [2,] integer,10   integer,10   integer,10   integer,10   #> [3,] numeric,10   numeric,10   numeric,10   numeric,10   #> [4,] character,26 character,26 character,26 character,26 sb2_x(obj, 1:3, 1:3) #>      a          b          c          #> [1,] logical,3  logical,3  logical,3  #> [2,] integer,10 integer,10 integer,10 #> [3,] numeric,10 numeric,10 numeric,10 # above is equivalent to obj[1:3, 1:3, drop = FALSE] sb2_x(obj, i = is.numeric) #> [[1]] #>  [1] 10  9  2  7  6  5  1  8  4  3 #>  #> [[2]] #>  [1] -0.72386911  1.33058037 -0.81133302  1.79503611  0.68662633  0.08937800 #>  [7]  0.32454774  0.07131812  0.23304838  1.98637658 #>  #> [[3]] #>  [1]  4  9  3  7  6 10  5  1  2  8 #>  #> [[4]] #>  [1] -0.95167079 -0.55864232  0.25581454 -0.19807617  0.42878914  0.07077011 #>  [7] -1.53665380  0.45398437  0.87439857 -1.29773757 #>  #> [[5]] #>  [1]  2  3  7  1  4  8  6 10  5  9 #>  #> [[6]] #>  [1] -1.07896524 -1.13484994  0.02261431 -0.02146122 -0.27877244 -0.02420641 #>  [7]  0.82502030 -0.75018278  0.53621047 -1.57271748 #>  #> [[7]] #>  [1]  9  6  2  1  4  3  5 10  8  7 #>  #> [[8]] #>  [1] -0.9864274  1.9835123 -1.8513784 -0.9097882 -1.9514400 -0.8002765 #>  [7] -1.8693616 -0.7505715 -0.5909384 -0.7420993 #>  # above is equivalent to obj[sapply(obj, is.numeric)] sb2_x(obj, col = c(\"a\", \"a\")) #>      a            a            a            a            #> [1,] logical,3    logical,3    logical,3    logical,3    #> [2,] integer,10   integer,10   integer,10   integer,10   #> [3,] numeric,10   numeric,10   numeric,10   numeric,10   #> [4,] character,26 character,26 character,26 character,26 # above is equivalent to obj[, lapply(c(\"a\", \"a\"), \\(i) which(colnames(obj) == i)) |> unlist()]  obj <- array(as.list(1:64), c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 1    5    9    13   #> [2,] 2    6    10   14   #> [3,] 3    7    11   15   #> [4,] 4    8    12   16   #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 17   21   25   29   #> [2,] 18   22   26   30   #> [3,] 19   23   27   31   #> [4,] 20   24   28   32   #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 33   37   41   45   #> [2,] 34   38   42   46   #> [3,] 35   39   43   47   #> [4,] 36   40   44   48   #>  sb2_x(obj, n(1:3, 1:2), c(1,3)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 1    5    9    13   #> [2,] 2    6    10   14   #> [3,] 3    7    11   15   #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,] 17   21   25   29   #> [2,] 18   22   26   30   #> [3,] 19   23   27   31   #>  # above is equivalent to obj[1:3, , 1:2, drop = FALSE] sb2_x(obj, i = \\(x)x>5) #> [[1]] #> [1] 6 #>  #> [[2]] #> [1] 7 #>  #> [[3]] #> [1] 8 #>  #> [[4]] #> [1] 9 #>  #> [[5]] #> [1] 10 #>  #> [[6]] #> [1] 11 #>  #> [[7]] #> [1] 12 #>  #> [[8]] #> [1] 13 #>  #> [[9]] #> [1] 14 #>  #> [[10]] #> [1] 15 #>  #> [[11]] #> [1] 16 #>  #> [[12]] #> [1] 17 #>  #> [[13]] #> [1] 18 #>  #> [[14]] #> [1] 19 #>  #> [[15]] #> [1] 20 #>  #> [[16]] #> [1] 21 #>  #> [[17]] #> [1] 22 #>  #> [[18]] #> [1] 23 #>  #> [[19]] #> [1] 24 #>  #> [[20]] #> [1] 25 #>  #> [[21]] #> [1] 26 #>  #> [[22]] #> [1] 27 #>  #> [[23]] #> [1] 28 #>  #> [[24]] #> [1] 29 #>  #> [[25]] #> [1] 30 #>  #> [[26]] #> [1] 31 #>  #> [[27]] #> [1] 32 #>  #> [[28]] #> [1] 33 #>  #> [[29]] #> [1] 34 #>  #> [[30]] #> [1] 35 #>  #> [[31]] #> [1] 36 #>  #> [[32]] #> [1] 37 #>  #> [[33]] #> [1] 38 #>  #> [[34]] #> [1] 39 #>  #> [[35]] #> [1] 40 #>  #> [[36]] #> [1] 41 #>  #> [[37]] #> [1] 42 #>  #> [[38]] #> [1] 43 #>  #> [[39]] #> [1] 44 #>  #> [[40]] #> [1] 45 #>  #> [[41]] #> [1] 46 #>  #> [[42]] #> [1] 47 #>  #> [[43]] #> [1] 48 #>  # above is equivalent to obj[sapply(obj, \\(x) x > 5)]  #############################################################################  # data.frame-like objects ====  obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) print(obj) #>     a b  c d #> 1   1 a 11 a #> 2   2 b 12 b #> 3   3 c 13 c #> 4   4 d 14 d #> 5   5 e 15 e #> 6   6 f 16 f #> 7   7 g 17 g #> 8   8 h 18 h #> 9   9 i 19 i #> 10 10 j 20 j sb2_x(obj, 1:3, 1:3) # obj[1:3, 1:3, drop = FALSE] #>   a b  c #> 1 1 a 11 #> 2 2 b 12 #> 3 3 c 13 sb2_x(obj, filter = ~ (a > 5) & (c < 19), vars = is.numeric) #>   a  c #> 1 6 16 #> 2 7 17 #> 3 8 18"},{"path":"https://tony-aw.github.io/squarebrackets/reference/seq_rec2.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Recursive Sequence Through Repeated Arithmetic Infix Operations — seq_rec2","title":"Generate Recursive Sequence Through Repeated Arithmetic Infix Operations — seq_rec2","text":"recursive sequence generator.  function essentially highly generalized version Fibonacci sequence generator.  Starting 2 initial values, next value generated either one 2 formulas: x[] = (s[1] + m[1] * x[-1]) %inop% (s[2] + m[2] * x[-2]) x[] = (m[1] * (x[-1] + s[1])) %inop% (m[2] * (x[-2] + s[2])) %inop% arithmetic infix operator chosen,  m s numeric vector length 2.  order x[-1] x[-2] can also swapped.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/seq_rec2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Recursive Sequence Through Repeated Arithmetic Infix Operations — seq_rec2","text":"","code":"seq_rec2(   inits = c(0L, 1L),   n = 10L,   s = c(0L, 0L),   m = c(1L, 1L),   inop = \"+\",   form = 1L,   rev = FALSE )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/seq_rec2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Recursive Sequence Through Repeated Arithmetic Infix Operations — seq_rec2","text":"inits numeric (double integer) vector length 2, giving initial values.  numbers allowed, even negative /fractional numbers.  Note numbers given must give valid results passed function f(). n single integer, giving size numeric vector generate.  NOTE: must hold n > 2. s, m numeric vectors length 2 used formula. inop single string, giving arithmetic infix operator used.  Currently supported: \"+\", \"-\", \"*\", \"/\".  fibonacci sequence, inop = \"+\". form either 1 2, indicating formula used (see Description section ). rev reverse order x[-1] x[-2].  example, using form = 1: rev = FALSE (default), holds: x[] = (s[1] + m[1] * x[-1]) %inop% (s[2] + m[2] * x[-2]). rev = TRUE, holds: x[] = (s[1] + m[1] * x[-2]) %inop% (s[2] + m[2] * x[-1])","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/seq_rec2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Recursive Sequence Through Repeated Arithmetic Infix Operations — seq_rec2","text":"sequence numbers.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/seq_rec2.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Recursive Sequence Through Repeated Arithmetic Infix Operations — seq_rec2","text":"default values arguments give first 10 numbers regular Fibonacci sequence.  See examples several number series created function.  function written C++ using Rcpp better performance.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/seq_rec2.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Generate Recursive Sequence Through Repeated Arithmetic Infix Operations — seq_rec2","text":"supply NAs NaNs function, handle .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/seq_rec2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Recursive Sequence Through Repeated Arithmetic Infix Operations — seq_rec2","text":"","code":"seq_rec2() # by default gives Fibonacci numbers #>  [1]  0  1  1  2  3  5  8 13 21 34 seq_rec2(inits = 2:1) # Lucas numbers #>  [1]  2  1  3  4  7 11 18 29 47 76 c(1, seq_rec2(c(1, 2), inop = \"*\")) # Multiplicative Fibonacci #>  [1]           1           1           2           2           4           8 #>  [7]          32         256        8192     2097152 17179869184 seq_rec2(m = c(2L, 1L)) # Pell numbers #>  [1]   0   1   2   5  12  29  70 169 408 985 seq_rec2(inits = c(1, 0), m = c(0L, 2L)) # see https://oeis.org/A077957 #>  [1]  1  0  2  0  4  0  8  0 16  0 seq_rec2(m = c(1L, 2L)) # Jacobsthal numbers #>  [1]   0   1   1   3   5  11  21  43  85 171"},{"path":"https://tony-aw.github.io/squarebrackets/reference/setapply.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply Functions Over mutable_atomic Matrix Margins By Reference — setapply","title":"Apply Functions Over mutable_atomic Matrix Margins By Reference — setapply","text":"setapply() function applies functions rows columns mutable_atomic matrix, pass--reference semantics.  every iteration, copy single row column (depending margin) made, function applied copy, original row/column replaced modified copy pass--reference semantics.  setapply() bit faster uses less memory apply.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/setapply.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply Functions Over mutable_atomic Matrix Margins By Reference — setapply","text":"","code":"setapply(x, MARGIN, FUN)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/setapply.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply Functions Over mutable_atomic Matrix Margins By Reference — setapply","text":"x mutable_atomic matrix. Arrays supported. MARGIN single integer scalar, giving subscript apply function . 1 indicates rows, 2 indicates columns. FUN function applied.  function must return vector type x, appropriate length (.e. length ncol(x) MARGIN == 1 length nrow(x) MARGIN == 2).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/setapply.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply Functions Over mutable_atomic Matrix Margins By Reference — setapply","text":"Returns: VOID. function modifies object reference. use assignment like x <- setapply(x, ...). Since function returns void, just get NULL.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/setapply.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply Functions Over mutable_atomic Matrix Margins By Reference — setapply","text":"","code":"# re-order elements matrix by reference ==== x <- mutable_atomic(1:20, dim = c(5,4)) print(x) #>      [,1] [,2] [,3] [,4] #> [1,]    1    6   11   16 #> [2,]    2    7   12   17 #> [3,]    3    8   13   18 #> [4,]    4    9   14   19 #> [5,]    5   10   15   20 #> mutable_atomic  #> typeof:  integer  setapply(x, 1, FUN = \\(x)x[c(4,1,3,2)]) print(x) #>      [,1] [,2] [,3] [,4] #> [1,]   16    1   11    6 #> [2,]   17    2   12    7 #> [3,]   18    3   13    8 #> [4,]   19    4   14    9 #> [5,]   20    5   15   10 #> mutable_atomic  #> typeof:  integer    # sort elements of matrix by reference ==== x <- mutable_atomic(20:1, dim = c(5,4)) print(x) #>      [,1] [,2] [,3] [,4] #> [1,]   20   15   10    5 #> [2,]   19   14    9    4 #> [3,]   18   13    8    3 #> [4,]   17   12    7    2 #> [5,]   16   11    6    1 #> mutable_atomic  #> typeof:  integer  setapply(x, 2, FUN = sort) print(x) #>      [,1] [,2] [,3] [,4] #> [1,]   16   11    6    1 #> [2,]   17   12    7    2 #> [3,]   18   13    8    3 #> [4,]   19   14    9    4 #> [5,]   20   15   10    5 #> mutable_atomic  #> typeof:  integer"},{"path":"https://tony-aw.github.io/squarebrackets/reference/slcseq.html","id":null,"dir":"Reference","previous_headings":"","what":"Efficient Sequence-based Subset Methods on (Long) Vectors — slcseq_x","title":"Efficient Sequence-based Subset Methods on (Long) Vectors — slcseq_x","text":"slcseq_ - methods similar sb_ - methods, except require indexing vector, designed memory efficiency.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/slcseq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Efficient Sequence-based Subset Methods on (Long) Vectors — slcseq_x","text":"","code":"slcseq_x(x, ...)  # S3 method for default slcseq_x(x, from = NULL, to = NULL, by = 1L, ..., use.names = TRUE)  slcseq_rm(x, ...)  # S3 method for default slcseq_rm(x, from = NULL, to = NULL, by = 1L, ..., use.names = TRUE)  slcseq_set(x, ...)  # S3 method for default slcseq_set(x, from = NULL, to = NULL, by = 1L, inv = FALSE, ..., rp, tf)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/slcseq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Efficient Sequence-based Subset Methods on (Long) Vectors — slcseq_x","text":"x atomic object.  slcseq_set must mutable_atomic variable. ... see squarebrackets_method_dispatch , , see cp_seq. use.names Boolean, indicating flat names preserved.  Note , since slcseq operates flat indices , dimnames always dropped. inv Boolean, indicating whether invert sequence.  TRUE, slcseq_set() apply replacement/transformation elements vector, except elements specified sequence. rp, tf see squarebrackets_modify.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/slcseq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Efficient Sequence-based Subset Methods on (Long) Vectors — slcseq_x","text":"Similar sb_ methods.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/slcseq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Efficient Sequence-based Subset Methods on (Long) Vectors — slcseq_x","text":"","code":"x <- mutable_atomic(1:1e7)  # extract: slcseq_x(x, 1, 10) #>  [1]  1  2  3  4  5  6  7  8  9 10 #> mutable_atomic  #> typeof:  integer   # reverse: slcseq_x(x, -1i, 1) |> head() #> [1] 10000000  9999999  9999998  9999997  9999996  9999995 #> mutable_atomic  #> typeof:  integer   # remove: slcseq_rm(x, 1, -11i) # all elements except the last 10 #>  [1]  9999991  9999992  9999993  9999994  9999995  9999996  9999997  9999998 #>  [9]  9999999 10000000 #> mutable_atomic  #> typeof:  integer   # replace every other element: x <- mutable_atomic(1:1e7) slcseq_set(x, 2, -1i, 2, rp = -1) head(x) #> [1]  1 -1  3 -1  5 -1 #> mutable_atomic  #> typeof:  integer   # replace all elements except the first element: x <- mutable_atomic(1:1e7) slcseq_set(x, 1, 1, inv = TRUE, rp = -1) head(x) #> [1]  1 -1 -1 -1 -1 -1 #> mutable_atomic  #> typeof:  integer"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"functions convert list integer subscripts integer matrix coordinates, integer matrix coordinates integer vector flat indices, vice-versa.  Inspired sub2ind function 'MatLab'. sub2coord() converts list integer subscripts integer matrix coordinates. coord2ind() converts integer matrix coordinates integer vector flat indices. ind2coord() converts integer vector flat indices integer matrix coordinates. coord2sub() converts integer matrix coordinates list integer subscripts;  performs simple (one might even say naive) conversion. sub2ind() faster memory efficient version coord2ind(sub2coord(sub, x.dims), x.dims)  (especially 8 dimensions). functions written memory-efficient.  coord2ind() thus opposite arrayInd, ind2coord merely convenient wrapper around arrayInd.  Note equivalent sub2ind function 'MatLab' actually coord2ind() function .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"","code":"sub2coord(sub, x.dim)  coord2sub(coord)  coord2ind(coord, x.dim, checks = TRUE)  ind2coord(ind, x.dim)  sub2ind(sub, x.dim, checks = TRUE)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"sub list integer subscripts.  first element list corresponds first dimension (rows), second element second dimensions (columns), etc.  length sub must equal length x.dim.  One give empty subscript; instead fill something like seq_len(dim(x)[margin]).  NOTE: coord2sub() function support duplicate subscripts. x.dim integer vector giving dimensions array question. .e. dim(x). coord integer matrix, giving coordinate indices (subscripts) convert.  row index, column dimension.  first columns corresponds first dimension, second column second dimensions, etc.  number columns coord must equal length x.dim. checks Boolean, indicating arguments checks performed.  Defaults TRUE.  Can set FALSE minor speed improvements. ind integer vector, giving flat position indices convert.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"sub2coord() ind2coord(): Returns integer matrix coordinates (properties described argument coord).  coord2ind(): Returns integer vector flat indices (properties described argument ind).  coord2sub(): Returns list integer subscripts (properties described argument sub)","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"Subscripts coordinates exist dimensional objects (arrays).  Flat indices (just \"indices\" non-dimensional objects) exist objects (data.frame-like objects, flat indices actually equal column indices).  Thus flat indices \"default\" indices.  base S3 vector classes 'R' use standard Linear Algebraic convention, academic fields like Mathematics Statistics, following sense: vectors column vectors (.e. vertically aligned vectors); index counting starts 1; rows first dimension/subscript, columns second dimension/subscript, etc. Thus, orientation flat indices , example, 4 4 matrix, follows:   subscript [1,2] refers first row second column. 4 4 matrix, subscript [1,2] corresponds flat index 5.  functions described thus follow also convention.","code":"[,1] [,2] [,3] [,4]  [1,]    1    5    9   13  [2,]    2    6   10   14  [3,]    3    7   11   15  [4,]    4    8   12   16"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"functions specifically designed duplicate indices per-sé.  efficiency, check duplicate indices either.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"","code":"x.dim <- c(10, 10, 3) x.len <- prod(x.dim) x <- array(1:x.len, x.dim) sub <- list(c(4, 3), c(3, 2), c(2, 3)) coord <- sub2coord(sub, x.dim) print(coord) #>      [,1] [,2] [,3] #> [1,]    4    3    2 #> [2,]    3    3    2 #> [3,]    4    2    2 #> [4,]    3    2    2 #> [5,]    4    3    3 #> [6,]    3    3    3 #> [7,]    4    2    3 #> [8,]    3    2    3 ind <- coord2ind(coord, x.dim) print(ind) #> [1] 124 123 114 113 224 223 214 213 all(x[ind] == c(x[c(4, 3), c(3, 2), c(2, 3)])) # TRUE #> [1] TRUE coord2 <- ind2coord(ind, x.dim) print(coord) #>      [,1] [,2] [,3] #> [1,]    4    3    2 #> [2,]    3    3    2 #> [3,]    4    2    2 #> [4,]    3    2    2 #> [5,]    4    3    3 #> [6,]    3    3    3 #> [7,]    4    2    3 #> [8,]    3    2    3 all(coord == coord2) # TRUE #> [1] TRUE sub2 <- coord2sub(coord2) sapply(1:3, \\(i) sub2[[i]] == sub[[i]]) |> all() # TRUE #> [1] TRUE"},{"path":"https://tony-aw.github.io/squarebrackets/reference/tci.html","id":null,"dir":"Reference","previous_headings":"","what":"Type Cast Indices — tci_bool","title":"Type Cast Indices — tci_bool","text":"functions typecast indices proper integer indices.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/tci.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Type Cast Indices — tci_bool","text":"","code":"tci_bool(indx, n, inv = FALSE, .abortcall = sys.call())  tci_int(indx, n, inv = FALSE, chkdup = FALSE, .abortcall = sys.call())  tci_chr(   indx,   nms,   inv = FALSE,   chkdup = FALSE,   uniquely_named = FALSE,   .abortcall = sys.call() )  tci_cplx(indx, n, inv = FALSE, chkdup = FALSE, .abortcall = sys.call())"},{"path":"https://tony-aw.github.io/squarebrackets/reference/tci.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Type Cast Indices — tci_bool","text":"indx indices typecast n relevant size, typecasting integer logical indices.  Examples: target row indices, input nrow n. target flat indices, input length n. inv Boolean, indicating indices inverted.  See squarebrackets_indx_args. .abortcall environment error message passed . chkdup see squarebrackets_options. nms relevant names, typecasting character indices.  Examples: target row indices, input row names nms. target flat indices, input flat names nms. uniquely_named Boolean, indicating user knows -priori relevant names x unique.  set TRUE, speed may increase.  specifying TRUE relevant names unique result incorrect output.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/tci.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Type Cast Indices — tci_bool","text":"integer vector casted indices.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/tci.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Type Cast Indices — tci_bool","text":"","code":"x.dim <- c(10, 10, 3) x.len <- prod(x.dim) x <- array(1:x.len, x.dim) sub <- list(c(4, 3), c(3, 2), c(2, 3)) coord <- sub2coord(sub, x.dim) print(coord) #>      [,1] [,2] [,3] #> [1,]    4    3    2 #> [2,]    3    3    2 #> [3,]    4    2    2 #> [4,]    3    2    2 #> [5,]    4    3    3 #> [6,]    3    3    3 #> [7,]    4    2    3 #> [8,]    3    2    3 ind <- coord2ind(coord, x.dim) print(ind) #> [1] 124 123 114 113 224 223 214 213 all(x[ind] == c(x[c(4, 3), c(3, 2), c(2, 3)])) # TRUE #> [1] TRUE coord2 <- ind2coord(ind, x.dim) print(coord) #>      [,1] [,2] [,3] #> [1,]    4    3    2 #> [2,]    3    3    2 #> [3,]    4    2    2 #> [4,]    3    2    2 #> [5,]    4    3    3 #> [6,]    3    3    3 #> [7,]    4    2    3 #> [8,]    3    2    3 all(coord == coord2) # TRUE #> [1] TRUE sub2 <- coord2sub(coord2) sapply(1:3, \\(i) sub2[[i]] == sub[[i]]) |> all() # TRUE #> [1] TRUE"}]
