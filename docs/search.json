[{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Benchmarks - sb_x","text":"Due many checks conversions performed squarebrackets:: functions, make sub-setting programmatically beginner friendly, functions almost necessarily slower base R’s [-like operators. However, considerable effort made keep speed loss minimum. Generally, speed loss indeed negligible, cases even speed improvement (thanks heavy lifting performed ‘collapse’ package). benchmarks give one idea speed loss. just examples; speed determined great number factors.  ","code":"library(bench) library(ggplot2) library(patchwork)"},{"path":[]},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"matrix","dir":"Articles","previous_headings":"Atomic objects","what":"Matrix","title":"Benchmarks - sb_x","text":" ","code":"n <- 5e3 x.mat <- matrix(seq_len(n*n), ncol = n) colnames(x.mat) <- sample(c(letters, NA), n, TRUE) sel.rows <- 1:100 sel.cols <- rep(sample(letters[1:13]), 10) bm.sb_x.matrix <- bench::mark(   \"squarebrackets\" = sb_x(x.mat, sel.rows, sel.cols),   \"base R\" = x.mat[sel.rows, lapply(sel.cols, \\(i) which(colnames(x.mat) == i)) |> unlist(), drop = FALSE],   min_iterations = 500 ) bm.sb_x.matrix summary(bm.sb_x.matrix) #> # A tibble: 2 × 6 #>   expression          min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>     <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 squarebrackets   4.99ms   5.56ms      177.    9.82MB     28.3 #> 2 base R           7.81ms    8.9ms      111.   14.67MB     16.6"},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"array-3d","dir":"Articles","previous_headings":"Atomic objects","what":"Array (3D)","title":"Benchmarks - sb_x","text":" ","code":"x.dims <- c(5000, 2000, 4) x.3d <- array(1:prod(x.dims), x.dims) sel.rows <- 1:900 sel.lyrs <- c(TRUE, FALSE, TRUE, FALSE) bm.sb_x.3d <- bench::mark(   \"squarebrackets\" =  sb_x(x.3d, rcl = n(sel.rows, NULL, sel.lyrs)),   \"base R + abind\" = abind::asub(x.3d, idx = list(sel.rows, sel.lyrs), dims = c(1,3)),   min_iterations = 500 ) summary(bm.sb_x.3d) #> # A tibble: 2 × 6 #>   expression          min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>     <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 squarebrackets   9.64ms   10.6ms      94.1    13.7MB     7.52 #> 2 base R + abind    9.7ms   10.7ms      92.8    13.7MB     6.56"},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"plot","dir":"Articles","previous_headings":"Atomic objects","what":"Plot","title":"Benchmarks - sb_x","text":" ","code":"#> Loading required namespace: tidyr"},{"path":[]},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"data-frame","dir":"Articles","previous_headings":"Data.frame-like objects","what":"data.frame","title":"Benchmarks - sb_x","text":" ","code":"n <- 1e5 chrmat <- matrix(   sample(letters, n*400, replace = TRUE), ncol = 400 ) intmat <- matrix(   seq.int(n*400), ncol = 400 ) x <- cbind(chrmat, intmat) |> as.data.frame() rm(list = c(\"chrmat\", \"intmat\")) colnames(x) <- make.names(colnames(x), unique = TRUE) sel.cols <- rep(sample(names(x), 10), 4) sel.rows <- 1:1000 bm.sb_x.df <- bench::mark(   \"squarebrackets\" = sb2_x(x, sel.rows, sel.cols),   \"collapse::ss\" = collapse::ss(x, sel.rows, match(sel.cols, names(x))),   \"base R\" = x[sel.rows, match(sel.cols, names(x)), drop = FALSE],   min_iterations = 1e4 ) summary(bm.sb_x.df) #> # A tibble: 2 × 6 #>   expression          min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>     <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 squarebrackets    124µs    193µs     4466.     441KB     8.95 #> 2 base R            345µs    879µs     1052.     362KB     2.11"},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"data-table","dir":"Articles","previous_headings":"Data.frame-like objects","what":"data.table","title":"Benchmarks - sb_x","text":" ","code":"x <- as.data.table(x) tempfun <- function(x, i, j) {   x <- collapse::ss(x, i, j, check = TRUE)   names(x) <- make.names(names(x), unique = TRUE)   return(x) } bm.sb_x.dt <- bench::mark(   \"squarebrackets\" = sb2_x(x, sel.rows, sel.cols),   \"data.table + collapse\" = tempfun(x, sel.rows, match(sel.cols, names(x))),   min_iterations = 1e4 ) summary(bm.sb_x.dt) #> # A tibble: 2 × 6 #>   expression                 min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>            <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 squarebrackets           112µs    125µs     7610.     324KB     4.57 #> 2 data.table + collapse    106µs    124µs     5508.     339KB     0"},{"path":"https://tony-aw.github.io/squarebrackets/articles/a_benchmarks_x.html","id":"plot-1","dir":"Articles","previous_headings":"Data.frame-like objects","what":"plot","title":"Benchmarks - sb_x","text":" ","code":""},{"path":"https://tony-aw.github.io/squarebrackets/articles/b_benchmarks_tf.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Benchmarks - transform operations","text":"Base R’s [<-, [[<-, $<- methods perform -place modification subsets objects using “copy--modify” semantics. ‘squarebrackets’ R-package provides 2 alternative semantics modification: “pass--reference” sb_set() method, “deep-copy” sb_mod() method. Moreover, base ‘R’ provides direct replacement , ‘squarebrackets’ provides replacement (rp argument) transformation (tf argument) mechanics. Thus, ‘squarebrackets’ base R really directly comparable terms benchmarking. Nonetheless, tried keep comparisons somewhat fair. sb_set() method generally several times (2 5 times) faster base R’s -place modification, generally uses half memory. sb_mod() method generally fast base R’s -place modification, uses amount memory. benchmarks give one idea speed loss. just examples; speed determined great number factors. keep comparisons classes fair, objects approximately 1e7 elements.  ","code":"library(bench) library(ggplot2) library(patchwork) library(tinycodet) #> Run `?tinycodet::tinycodet` to open the introduction help page of 'tinycodet'. plotfun <- function(title1, bm1, title2, bm2) {    plotdat1 <- bm1 |> tidyr::unnest(cols = c(\"time\", \"gc\", \"mem_alloc\"))   plotdat1$expression <- paste(     plotdat1$expression,     \"\\n (\", as.character(plotdat1$mem_alloc), \")\"   )   p1 <- ggplot(plotdat1, aes_pro(x = ~ time, y = ~ expression, color = ~ gc)) +   ggbeeswarm::geom_quasirandom() + ggtitle(title1)    plotdat2 <- bm2 |> tidyr::unnest(cols = c(\"time\", \"gc\", \"mem_alloc\"))   plotdat2$expression <- paste(     plotdat2$expression,     \"\\n (\", as.character(plotdat2$mem_alloc), \")\"   )   p2 <- ggplot(plotdat2, aes_pro(x = ~ time, y = ~ expression, color = ~ gc)) +   ggbeeswarm::geom_quasirandom() + ggtitle(title2)    combined <- p1 + p2 & theme(legend.position = \"bottom\")   combined + plot_layout(guides = \"collect\") }"},{"path":[]},{"path":"https://tony-aw.github.io/squarebrackets/articles/b_benchmarks_tf.html","id":"matrix","dir":"Articles","previous_headings":"Atomic objects","what":"Matrix","title":"Benchmarks - transform operations","text":" ","code":"n <- 3162 # approx sqrt(1e7) x.mat <- matrix(seq_len(n*n), ncol = n) x.mat2 <- as.mutable_atomic(x.mat) colnames(x.mat) <- sample(c(letters, LETTERS, NA), n, TRUE) sel.rows <- 1:1000 sel.cols <- 1:1000 basefun <- function(x, rows, cols, tf) {   x[rows, cols] <- tf(x[rows, cols])   return(x) } tf <- function(x) { return(-1 * x) } bm.sb_tf.matrix <- bench::mark(   \"base [<-\" =  basefun(x.mat, sel.rows, sel.cols, tf = tf),   \"sb_set\" = sb_set(x.mat2, sel.rows, sel.cols, tf = tf),   \"sb_mod\" = sb_mod(x.mat, sel.rows, sel.cols, tf = tf),   check = FALSE,   min_iterations = 500 ) bm.sb_tf.matrix summary(bm.sb_tf.matrix) #> # A tibble: 3 × 6 #>   expression      min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 base [<-    23.86ms  29.02ms      33.9    87.7MB     46.4 #> 2 sb_set       4.83ms   6.07ms     165.     15.4MB     14.7 #> 3 sb_mod      24.82ms  29.69ms      32.5    87.8MB     29.5"},{"path":"https://tony-aw.github.io/squarebrackets/articles/b_benchmarks_tf.html","id":"array-3d","dir":"Articles","previous_headings":"Atomic objects","what":"Array (3D)","title":"Benchmarks - transform operations","text":" ","code":"x.dims <- c(1900, 1900, 3) # leads to approx 1e7 elements x.3d <- array(1:prod(x.dims), x.dims) x.3d2 <- as.mutable_atomic(x.3d) sel.rows <- 1:900 sel.lyrs <- c(TRUE, FALSE, TRUE) basefun <- function(x, rows, lyrs, tf) {   x[rows, , lyrs] <- tf(x[rows, , lyrs])   return(x) } tf <- function(x) { return(-1 * x) } bm.sb_tf.3d <- bench::mark(   \"base [<-\" = basefun(x.3d, sel.rows, sel.lyrs, tf = tf ),   \"sb_set\" =  sb_set(x.3d2, rcl = n(sel.rows, NULL, sel.lyrs), tf = tf),   \"sb_mod\" = sb_mod(x.3d, rcl = n(sel.rows, NULL, sel.lyrs), tf = tf),   check = FALSE,   min_iterations = 500 ) summary(bm.sb_tf.3d) #> # A tibble: 3 × 6 #>   expression      min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 base [<-     48.5ms     52ms      19.0   121.8MB     44.8 #> 2 sb_set       22.2ms   26.9ms      37.1    52.3MB     10.9 #> 3 sb_mod       45.5ms   52.9ms      18.8   121.8MB     21.9"},{"path":"https://tony-aw.github.io/squarebrackets/articles/b_benchmarks_tf.html","id":"plot","dir":"Articles","previous_headings":"Atomic objects","what":"Plot","title":"Benchmarks - transform operations","text":" ","code":"#> Warning: The `trans` argument of `continuous_scale()` is deprecated as of ggplot2 3.5.0. #> ℹ Please use the `transform` argument instead. #> This warning is displayed once every 8 hours. #> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was #> generated. #> Orientation inferred to be along y-axis; override with #> `position_quasirandom(orientation = 'x')` #> Orientation inferred to be along y-axis; override with #> `position_quasirandom(orientation = 'x')`"},{"path":"https://tony-aw.github.io/squarebrackets/articles/b_benchmarks_tf.html","id":"data-frame-like","dir":"Articles","previous_headings":"","what":"Data.frame-like","title":"Benchmarks - transform operations","text":"    ","code":"n <- 1e5 ncol <- 200 # times 2 chrmat <- matrix(   sample(letters, n*ncol, replace = TRUE), ncol = ncol ) intmat <- matrix(   seq.int(n*ncol), ncol = ncol ) x <- cbind(chrmat, intmat) |> as.data.frame() colnames(x) <- make.names(colnames(x), unique = TRUE) x2 <- data.table::as.data.table(x) rm(list = c(\"chrmat\", \"intmat\"))  sel.rows <- 1:1000 basefun <- function(x, rows, tf) {   x[rows, sapply(x, is.numeric)] <- lapply(x[rows, sapply(x, is.numeric)], tf)   return(x) } bm.sb_tf.df <- bench::mark(   \"base [<-\" = basefun(x, sel.rows, tf = \\(x) -1 * x),   \"sb_set\" = sb2_set.data.table(     x2, rows = sel.rows, vars = is.numeric, tf = \\(x) -1 * x   ),   \"sb_mod\" = sb2_mod.data.frame(     x, rows = sel.rows, vars = is.numeric, tf = \\(x) -1 * x, coe = TRUE   ),   check = FALSE,   min_iterations = 500 ) summary(bm.sb_tf.df) #> # A tibble: 3 × 6 #>   expression      min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 base [<-    237.9µs    307µs     3060.    62.3KB     12.3 #> 2 sb_set       84.3µs    122µs     7339.   932.8KB      0   #> 3 sb_mod      100.5µs    131µs     7400.    46.7KB      0 #> Orientation inferred to be along y-axis; override with #> `position_quasirandom(orientation = 'x')`"},{"path":"https://tony-aw.github.io/squarebrackets/articles/Extra_Examples.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Additional Examples","text":"function documentation ‘squarebrackets’ package rich examples. article adds additional examples focussed combining ‘squarebrackets’ packages.  ","code":""},{"path":"https://tony-aw.github.io/squarebrackets/articles/Extra_Examples.html","id":"aggregate-sf-data-table","dir":"Articles","previous_headings":"","what":"Aggregate sf-data.table","title":"Additional Examples","text":"‘sf’ package adds data.frames/data.tables spatial features. example, functionality ‘squarebrackets’ used ‘sf’ class data.table. plot created (using ‘ggplot2’, ‘ggh4x’, ‘tinycodet’) aggregation region spatial data.table:   ","code":"library(ggplot2) library(ggh4x) library(tinycodet) #> Run `?tinycodet::tinycodet` to open the introduction help page of 'tinycodet'. import_as(~dt., \"data.table\") #> Importing packages and registering methods... #> Done #> You can now access the functions using `dt.$` #> For conflicts report, packages order, and other attributes, run `attr.import(dt.)` x <- sf::st_read(system.file(\"shape/nc.shp\", package = \"sf\")) #> Reading layer `nc' from data source `D:\\Programs\\R-4.4.0\\library\\sf\\shape\\nc.shp' using driver `ESRI Shapefile' #> Simple feature collection with 100 features and 14 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 #> Geodetic CRS:  NAD27 x <- dt.$as.data.table(x)  x$region <- ifelse(x$CNTY_ID <= 2000, 'high', 'low') plotdat <- dt_aggregate(   x, SDcols = \"geometry\", f = sf::st_union, by = \"region\" ) geometry <- ~geometry fill <- ~region fct <- ~region ggplot(plotdat, aes_pro(geometry = geometry, fill = fill)) +    facet_wrap2(fct, nrow = 2) +   geom_sf()"},{"path":"https://tony-aw.github.io/squarebrackets/articles/Extra_Examples.html","id":"re-order-an-array-like-a-rubiks-cube","dir":"Articles","previous_headings":"","what":"Re-order an array like a Rubik’s cube","title":"Additional Examples","text":"%row~% %col~% operators ‘tinycodet’ can quickly re-order elements row column independently rows columns. One can combine operators sb_ methods ‘squarebrackets’ re-order matrix slices array, like re-ordering panels Rubik’s cube. using sb_set() one can even reference better memory efficiency - exactly done . Let’s first create mutable array: Now let’s numerically sort every column slices array reference: Now, let’s see successful: Yes, column layer independently sorted numerically. One can thing character array; note time use stringi::stri_rank() determining proper order: : successful.    ","code":"x <- mutable_atomic(sample(1:27), dim = c(3,3,3)) print(x) #> , , 1 #>  #>      [,1] [,2] [,3] #> [1,]   13    5   22 #> [2,]   23    6    4 #> [3,]   12   15   26 #>  #> , , 2 #>  #>      [,1] [,2] [,3] #> [1,]    9   21    2 #> [2,]   24    8    7 #> [3,]   17   27   16 #>  #> , , 3 #>  #>      [,1] [,2] [,3] #> [1,]   10   25   19 #> [2,]   20   14    1 #> [3,]   18   11    3 #>  #> mutable_atomic  #> typeof:  integer library(tinycodet)  for(i in 1:3) {   y <- sb_x(x, n(i), 3) |> drop()   rp <- y %col~% y   sb_set(x, n(i), 3, rp = rp) } print(x) #> , , 1 #>  #>      [,1] [,2] [,3] #> [1,]   12    5    4 #> [2,]   13    6   22 #> [3,]   23   15   26 #>  #> , , 2 #>  #>      [,1] [,2] [,3] #> [1,]    9    8    2 #> [2,]   17   21    7 #> [3,]   24   27   16 #>  #> , , 3 #>  #>      [,1] [,2] [,3] #> [1,]   10   11    1 #> [2,]   18   14    3 #> [3,]   20   25   19 #>  #> mutable_atomic  #> typeof:  integer x <- mutable_atomic(sample(c(letters, 1e3)), dim = c(3,3,3)) print(x) #> , , 1 #>  #>      [,1] [,2] [,3] #> [1,] \"v\"  \"u\"  \"j\"  #> [2,] \"k\"  \"f\"  \"b\"  #> [3,] \"g\"  \"i\"  \"q\"  #>  #> , , 2 #>  #>      [,1] [,2] [,3]   #> [1,] \"a\"  \"c\"  \"1000\" #> [2,] \"w\"  \"n\"  \"p\"    #> [3,] \"t\"  \"r\"  \"e\"    #>  #> , , 3 #>  #>      [,1] [,2] [,3] #> [1,] \"h\"  \"o\"  \"s\"  #> [2,] \"m\"  \"y\"  \"z\"  #> [3,] \"d\"  \"x\"  \"l\"  #>  #> mutable_atomic  #> typeof:  character for(i in 1:3) {   y <- sb_x(x, n(i), 3) |> drop()   rp <- y %col~% stringi::stri_rank(y)   sb_set(x, n(i), 3, rp = rp) } print(x) #> , , 1 #>  #>      [,1] [,2] [,3] #> [1,] \"g\"  \"f\"  \"b\"  #> [2,] \"k\"  \"i\"  \"j\"  #> [3,] \"v\"  \"u\"  \"q\"  #>  #> , , 2 #>  #>      [,1] [,2] [,3]   #> [1,] \"a\"  \"c\"  \"1000\" #> [2,] \"t\"  \"n\"  \"e\"    #> [3,] \"w\"  \"r\"  \"p\"    #>  #> , , 3 #>  #>      [,1] [,2] [,3] #> [1,] \"d\"  \"o\"  \"l\"  #> [2,] \"h\"  \"x\"  \"s\"  #> [3,] \"m\"  \"y\"  \"z\"  #>  #> mutable_atomic  #> typeof:  character"},{"path":"https://tony-aw.github.io/squarebrackets/articles/Extra_Examples.html","id":"mutate-column-of-data-table","dir":"Articles","previous_headings":"","what":"Mutate column of data.table","title":"Additional Examples","text":"can mutate column data.table reference, combining ‘squarebrackets’ tinycodet::with_pro(), follows:  ","code":"x <- sf::st_read(system.file(\"shape/nc.shp\", package = \"sf\")) #> Reading layer `nc' from data source `D:\\Programs\\R-4.4.0\\library\\sf\\shape\\nc.shp' using driver `ESRI Shapefile' #> Simple feature collection with 100 features and 14 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 #> Geodetic CRS:  NAD27 x <- dt.$as.data.table(x)  myform <- ~ PERIMETER / AREA x$newcolumn <- 1:nrow(x) mutated <- dt.$as.data.table(with_pro(x, myform)) sb2_set(x, col = \"newcolumn\", rp = mutated) summary(x) #>       AREA          PERIMETER         CNTY_         CNTY_ID     #>  Min.   :0.0420   Min.   :0.999   Min.   :1825   Min.   :1825   #>  1st Qu.:0.0910   1st Qu.:1.324   1st Qu.:1902   1st Qu.:1902   #>  Median :0.1205   Median :1.609   Median :1982   Median :1982   #>  Mean   :0.1263   Mean   :1.673   Mean   :1986   Mean   :1986   #>  3rd Qu.:0.1542   3rd Qu.:1.859   3rd Qu.:2067   3rd Qu.:2067   #>  Max.   :0.2410   Max.   :3.640   Max.   :2241   Max.   :2241   #>      NAME               FIPS               FIPSNO         CRESS_ID      #>  Length:100         Length:100         Min.   :37001   Min.   :  1.00   #>  Class :character   Class :character   1st Qu.:37051   1st Qu.: 25.75   #>  Mode  :character   Mode  :character   Median :37100   Median : 50.50   #>                                        Mean   :37100   Mean   : 50.50   #>                                        3rd Qu.:37150   3rd Qu.: 75.25   #>                                        Max.   :37199   Max.   :100.00   #>      BIR74           SID74          NWBIR74           BIR79       #>  Min.   :  248   Min.   : 0.00   Min.   :   1.0   Min.   :  319   #>  1st Qu.: 1077   1st Qu.: 2.00   1st Qu.: 190.0   1st Qu.: 1336   #>  Median : 2180   Median : 4.00   Median : 697.5   Median : 2636   #>  Mean   : 3300   Mean   : 6.67   Mean   :1050.8   Mean   : 4224   #>  3rd Qu.: 3936   3rd Qu.: 8.25   3rd Qu.:1168.5   3rd Qu.: 4889   #>  Max.   :21588   Max.   :44.00   Max.   :8027.0   Max.   :30757   #>      SID79          NWBIR79                 geometry     newcolumn     #>  Min.   : 0.00   Min.   :    3.0   MULTIPOLYGON :100   Min.   : 8.35   #>  1st Qu.: 2.00   1st Qu.:  250.5   epsg:4267    :  0   1st Qu.:11.62   #>  Median : 5.00   Median :  874.5   +proj=long...:  0   Median :13.32   #>  Mean   : 8.36   Mean   : 1352.8                       Mean   :14.49   #>  3rd Qu.:10.25   3rd Qu.: 1406.8                       3rd Qu.:16.11   #>  Max.   :57.00   Max.   :11631.0                       Max.   :42.40"},{"path":"https://tony-aw.github.io/squarebrackets/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Tony Wilkes. Author, maintainer, copyright holder.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Wilkes T (2024). squarebrackets: Subset Methods Alternatives Square Brackets Operators. R package version 0.0.0.9, https://tony-aw.github.io/squarebrackets/, https://github.com/tony-aw/squarebrackets/.","code":"@Manual{,   title = {squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators},   author = {Tony Wilkes},   year = {2024},   note = {R package version 0.0.0.9, https://tony-aw.github.io/squarebrackets/},   url = {https://github.com/tony-aw/squarebrackets/}, }"},{"path":"https://tony-aw.github.io/squarebrackets/index.html","id":"squarebrackets","dir":"","previous_headings":"","what":"Subset Methods as Alternatives to the Square Brackets Operators","title":"Subset Methods as Alternatives to the Square Brackets Operators","text":"squarebrackets: Subset Methods Alternatives Square Brackets Operators","code":""},{"path":"https://tony-aw.github.io/squarebrackets/index.html","id":"description","dir":"","previous_headings":"","what":"Description","title":"Subset Methods as Alternatives to the Square Brackets Operators","text":"Provides subset methods (supporting non-recursive recursive S3 classes) may convenient alternatives [ [<- operators, whilst maintaining similar performance. nice properties methods include, limited , following: [ [<- operators use different rule-sets different data.frame-like types (data.frames, tibbles, data.tables, tibbles, etc.). ‘squarebrackets’ methods use rule-sets different data.frame-like types. Performing dimensional subset operations array using [ [<-, requires -priori knowledge number dimensions array . ‘squarebrackets’ methods work arbitrary dimensions without requiring prior knowledge. selecting names [ [<- operators, first occurrence names selected case duplicate names. ‘squarebrackets’ methods always perform names case duplicates, just first. [[ [[<- operators allow operating recursive subset nested list. operate single recursive subset, vectorized multiple recursive subsets nested list . ‘squarebrackets’ provides way reshape nested list 2D recursive array lists, thereby allowing vectorized operations recursive subsets nested list. [<- operator supports copy--modify semantics classes. ‘squarebrackets’ methods provides explicit pass--reference pass--value semantics, whilst still respecting things like binding-locks mutability rules.  ","code":""},{"path":"https://tony-aw.github.io/squarebrackets/index.html","id":"get-started","dir":"","previous_headings":"","what":"Get Started","title":"Subset Methods as Alternatives to the Square Brackets Operators","text":"get started see ?squarebrackets_help  ","code":""},{"path":"https://tony-aw.github.io/squarebrackets/index.html","id":"installing--loading","dir":"","previous_headings":"","what":"Installing & Loading","title":"Subset Methods as Alternatives to the Square Brackets Operators","text":"One can install ‘squarebrackets’ GitHub like : Special care taken make sure function names clear, function names unlikely conflict core R, recommended R packages, rstudioapi package, major packages fastverse. one can attach package - thus exposing functions namespace - using: user wish expose specific functions ‘squarebrackets’ within current/local environment, one can use following:  ","code":"remotes::install_github(\"https://github.com/tony-aw/squarebrackets\") library(squarebrackets) tinycodet::import_LL(\"squarebrackets\", selection = ... )"},{"path":"https://tony-aw.github.io/squarebrackets/index.html","id":"changelog-experimental-versions","dir":"","previous_headings":"","what":"Changelog (EXPERIMENTAL VERSIONS)","title":"Subset Methods as Alternatives to the Square Brackets Operators","text":"10 March 2024: First GitHub upload - Package much experimental. 12 March 2024: Changed introduction help page bit, added dt_setadd(), added tests dt_ - functions. slightly 50,000 tests now. 15 March 2024: Added sb_setRename() method, added tests method also. 16 March 2024: Fixed bug “rcpp_set_rowcol” source code. Tweaked documentation bit. Improved tests bit. 17 March 2024: Added tests, tweaked documentation bit. 19 March 2024: methods/functions support mutable_atomic type “complex”; now fixed. Added support mutable_atomic type “raw”. Added tests atomic type handling. Added functions ma_setv(), couldb.mutable_atomic(). Added options “sb.rat” “sb.chkdup”; argument chkdup now also set FALSE default. Added badges documentation. 20 March 2024: user can now also specify coe = TRUE sb_mod.data.frame(). 24 March 2024: Methods now split methods non-recursive objects (sb_), methods recursive objects (sb2_). 26 March 2024: Replaced seq_rec() seq_rec2(). 27 March 2024: Added dt_setreorder(), added tests also. ‘abind’ now dependency, ‘abind’ based code removed, redundant. 29 March 2024: Added sb2_before.array() sb2_after.array(), added tests also. Added tests data.frame-like coercion types. Tweaked documentation bit. 30 March 2024: Removed separate NA checks, redundant. Fixed linguistic mistakes documentation. 1 April 2024: Removed sb_coe() kept sb2_coe(). Added inv argument sb_mod()/sb2_mod(), sb_set()/sb2_set(), sb2_coe(), added tests . Added idx1() Copy--Modification Substitution, added tests idx1() also.Fixed bug character subset ordering sb/sb2_mod/set/coe - generic methods. Fixed bug introduction message. Added even tests. Added idx1_dim(), added tests also. 5 April 2024: Replaced idx1/idx0 idx(). 18 May 2024: Added tests idx() method (need add ). Fixed export pattern expressions Namespace file. Adjusted documentation. 26 May 2024: Removed sb2_coe(), redundant. 6 June 2024: Removed sb(2)_before/methods favour new bind_/bind2_ implementations. Added lst_ functions. Added options help page.  ","code":""},{"path":"https://tony-aw.github.io/squarebrackets/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 Tony Wilkes Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa0_squarebrackets_help.html","id":null,"dir":"Reference","previous_headings":"","what":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators — aaa0_squarebrackets_help","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators — aaa0_squarebrackets_help","text":"squarebrackets: Subset Methods Alternatives Square Brackets Operators","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa0_squarebrackets_help.html","id":"goal-amp-properties","dir":"Reference","previous_headings":"","what":"Goal & Properties","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators — aaa0_squarebrackets_help","text":"Among programming languages, 'R' perhaps one flexible comprehensive sub-setting functionality, provided square brackets operators ([, [<-).  situations square brackets operators occasionally less optimally convenient  (see squarebrackets_inconveniences).  Goal 'squarebrackets' package replace square-brackets operators, provide alternative sub-setting methods functions, used situations square bracket operators inconvenient.  alternative sub-setting methods functions following properties: Programmatically friendly: Unlike base [, required know number dimensions array -priori, perform subset-operations array. Missing arguments can filled NULL, instead using dark magic like base::quote(expr =    ). Non-standard evaluation. Functions pipe-friendly. (silent) vector recycling. Extracting removing subsets uses syntax. Class consistent: sub-setting multi-dimensional objects specifying dimensions (.e. rows, columns, ...) use drop = FALSE.  matrix , matrix . methods deliver results data.frames, data.tables, tibbles, tidytables.  longer one re-learn different brackets-based sub-setting rules different types data.frame-like objects.  Powered subclass agnostic 'C'-code 'collapse' 'data.table'. Explicit copy semantics: Sub-set operations change memory allocations, always return modified copy object. sub-set operations just change values -place (similar [<- [[<- methods) user can choose method modifies object reference, choose method returns deep copy. Careful handling names attributes: Sub-setting object index names returns indices name, just first. Data.frame-like objects (see supported classes ) forced unique column names. Attributes data.frame-like objects (see supported classes ) always preserved sub-setting. object types, user can specify whether preserve Attributes, use R's [ attribute behaviour (.e. drop attributes).  ensure compatibility R-packages create attribute behaviour sub-setting. Concise function argument names. Performance aware:  Despite many checks performed, functions kept reasonably speedy, use 'Rcpp', 'collapse', 'data.table' R-packages.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa0_squarebrackets_help.html","id":"supported-classes","dir":"Reference","previous_headings":"","what":"Supported  Classes","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators — aaa0_squarebrackets_help","text":"'squarebrackets' supports S3 classes, primarily use square brackets sub-setting (hence name package).  Supported immutable classes: atomic, factor, list, data.frame (including tibble sf-data.frame).  Supported  mutable classes: mutable_atomic, data.table (including tidytable sf-data.table).  , course, lot classes supported 'squarebrackets'.  notably, key-value stores, environments, various 'collections' classes 'collections' package, supported.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa0_squarebrackets_help.html","id":"methods-and-functions","dir":"Reference","previous_headings":"","what":"Methods and Functions","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators — aaa0_squarebrackets_help","text":"main focus package generic methods binding implementations.  Generic methods non-recursive objects (atomic, factor, etc.) start sb_.  Generic methods recursive objects (list, data.frame, etc.) start sb2_.  binding implementations non-recursive objects (atomic, factor, etc.) start bind_.  binding implementations recursive objects (list, data.frame, etc.) start bind2_.  also somewhat separate idx method, works recursive non-recursive objects.  available generic methods following: sb_x, sb2_x: extract, exchange, duplicate subsets. sb_rm,  sb2_rm: un-select/remove subsets. sb_set, sb2_set: modify (transform replace) subsets mutable object using pass--reference semantics. sb_mod, sb2_mod: return copy object modified (transformed replaced) subsets. sb2_rec: access recursive subsets lists. sb2_reccom: replace, transform, remove, add recursive subsets list, R's default Copy--Modify semantics. sb_setRename, sb2_setRename: change names mutable object using pass--reference semantics. bind_, bind2_:  implementations binding dimensional objects. idx: translate given indices/subscripts, purpose copy--modify substitution. example, use sb_rm() remove subsets atomic arrays, use sb2_rm() remove subsets recursive arrays. Additional specialized sub-setting functions provided: lst_untree: unnest tree-like nested list, make vectorized sub-setting recursive subsets list easier. dt_-functions programmatically perform data.table-specific [-operations, security measures provided 'squarebrackets' package. setapply: apply functions mutable matrix margins using pass--reference semantics. ma_setv: Find & Replace values mutable_atomic objects using pass--reference semantics.  considerably faster memory efficient using sb_set . sb_str: extract replace subset characters single string (single character treated single element). sb_a: extract multiple attributes object. finally, couple helper functions creating ranges, sequences, indices (often needed sub-setting) provided: lst: list-related helper functions. currentBindings: list lock currently existing bindings share share address input variable. n: Nested version c, short-hand list. sub2coord, coord2ind: Convert subscripts (array indices) coordinates, coordinates flat indices, vice-versa. match_all: Find matches, one vector another, taking account order duplicate values vectors. Computing indices: idx_by compute grouped indices. idx_ord_-functions compute ordered indices. Computing sequences: seq_rec2 recursive sequence generator (example generate Fibonacci sequence). seq_names create range indices specified starting ending name.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa0_squarebrackets_help.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators — aaa0_squarebrackets_help","text":"badges shown documentation R-package made using services : https://shields.io/","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa0_squarebrackets_help.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"squarebrackets: Subset Methods as Alternatives to the Square Brackets Operators — aaa0_squarebrackets_help","text":"Maintainer: Tony Wilkes tony_a_wilkes@outlook.com (ORCID)","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa1_squarebrackets_immutable_classes.html","id":null,"dir":"Reference","previous_headings":"","what":"Supported Immutable S3 Classes, With Auto-Coercion Rules — aaa1_squarebrackets_immutable_classes","title":"Supported Immutable S3 Classes, With Auto-Coercion Rules — aaa1_squarebrackets_immutable_classes","text":"sb_ generic methods support following immutable S3 classes: atomic classes  (atomic vectors, matrices, arrays); factor; list - including dimensional lists  (note lists merely pointers objects, objects may different class may even mutable); data.frame  (including classes tibble, sf-data.frame sf-tibble) Note \"immutable\" mean modify .  simply means modification leads copy made.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa1_squarebrackets_immutable_classes.html","id":"auto-coercion-rules","dir":"Reference","previous_headings":"","what":"Auto-Coercion Rules","title":"Supported Immutable S3 Classes, With Auto-Coercion Rules — aaa1_squarebrackets_immutable_classes","text":"Atomic  Atomic objects automatically coerced fit modified subset values, modifying copy.  example, replacing one multiple values integer vector (type int) decimal number (type dbl) coerce entire vector type dbl. Factor  Factors accept values part levels, thus support coercion modification. mechanism changing factors reference .  Replacing value new value part levels, result replacement value NA. List  Lists allow complete change elements, since lists merely pointers.  example, following code performs full coercion:   However, recursive subset list list, follows coercion rules whatever class recursive subset .  example following code:   transforms recursive subsets according - case - atomic auto-coercion rules. Data.frames replacing/transforming whole columns  data.frame actually list, column list. , replacing/transforming whole columns, row = NULL filter = NULL, allows completely changing type column.  Note coercion columns needs arguments row = NULL filter = NULL sb_mod sb_set methods; auto-coercion take place specifying something like row = 1:nrow(x) (see next section). Data.frames, partially replacing/transforming columns  rows specified sb_mod sb_set methods, thus whole columns parts columns replaced transformed, auto-coercion takes place.  .e.: replacing/transforming value integer (int) column become 1.5, coerce column decimal type (dbl); instead, replacement value 1.5 coerced integer 1.  coe argument sb_mod method allows user enforce coercion, even subsets columns replaced/transformed instead whole columns.  Specifically, coe arguments allows user specify coercive function applied entirety every column specified col vars; columns outside subset affected.  coercion function , course, applied replacement (rp) transformation (tf()).","code":"x <- list(factor(letters), factor(letters)) sb_mod(x, 1, rp = list(1)) x <- list(1:10, 1:10) sb_rec(x, 1, rp = \"a\") # coerces to character"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa1_squarebrackets_immutable_classes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Supported Immutable S3 Classes, With Auto-Coercion Rules — aaa1_squarebrackets_immutable_classes","text":"","code":"# Coercion examples - lists ==== x <- list(factor(letters), factor(letters)) print(x) #> [[1]] #>  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z #> Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z #>  #> [[2]] #>  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z #> Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z #>  sb2_mod(x, 1, rp = list(1)) # first element fully changed. #> [[1]] #> [1] 1 #>  #> [[2]] #>  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z #> Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z #>   x <- list(1:10, 1:10) print(x) #> [[1]] #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> [[2]] #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  sb2_reccom(x, 1, rp = \"a\") # coerces first element to character print(x) #> [[1]] #> [1] \"a\" #>  #> [[2]] #>  [1]  1  2  3  4  5  6  7  8  9 10 #>    #############################################################################   # Coercion examples - data.frame-like - whole columns ====  obj <- data.frame(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 sb2_mod(   obj, vars = is.numeric,   tf = sqrt # SAFE: row=NULL & filter = NULL, so coercion performed ) #>           a b        c d #> 1  1.000000 a 3.316625 a #> 2  1.414214 b 3.464102 b #> 3  1.732051 c 3.605551 c #> 4  2.000000 d 3.741657 d #> 5  2.236068 e 3.872983 e #> 6  2.449490 f 4.000000 f #> 7  2.645751 g 4.123106 g #> 8  2.828427 h 4.242641 h #> 9  3.000000 i 4.358899 i #> 10 3.162278 j 4.472136 j  #############################################################################   # Coercion examples - data.frame-like - partial columns ====  # sb_mod(): obj <- data.frame(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10  sb2_mod(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost ) #> Warning: 1.414214 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 1 named 'a') #> Warning: 3.464102 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 3 named 'c') #>     a b  c d #> 1   1 a 11 a #> 2   1 b  3 b #> 3   1 c  3 c #> 4   2 d  3 d #> 5   2 e  3 e #> 6   2 f  4 f #> 7   2 g  4 g #> 8   8 h 18 h #> 9   9 i 19 i #> 10 10 j 20 j sb2_mod(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   coe = as.double, tf = sqrt # SAFE: coercion performed ) #>            a b         c d #> 1   1.000000 a 11.000000 a #> 2   1.414214 b  3.464102 b #> 3   1.732051 c  3.605551 c #> 4   2.000000 d  3.741657 d #> 5   2.236068 e  3.872983 e #> 6   2.449490 f  4.000000 f #> 7   2.645751 g  4.123106 g #> 8   8.000000 h 18.000000 h #> 9   9.000000 i 19.000000 i #> 10 10.000000 j 20.000000 j"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa2_squarebrackets_mutable_classes.html","id":null,"dir":"Reference","previous_headings":"","what":"Supported Mutable S3 Classes, With Auto-Coercion Rules — aaa2_squarebrackets_mutable_classes","title":"Supported Mutable S3 Classes, With Auto-Coercion Rules — aaa2_squarebrackets_mutable_classes","text":"sb_ generic methods support following Mutable S3 classes: mutable_atomic (vector class supports dimension, thus also matrices arrays); data.table (including classes tidytable sf-data.table); Views Lists: Though lists treated immutable, lists can contain mutable objects, modification reference mutable views lists support 'squarebrackets'. mutable version list class environment class, various key-value storage classes available packages, 'collapse' package.  Key-value storage classes generally use square brackets primary sub-setting method, thus covered package.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa2_squarebrackets_mutable_classes.html","id":"auto-coercion-rules","dir":"Reference","previous_headings":"","what":"Auto-Coercion Rules","title":"Supported Mutable S3 Classes, With Auto-Coercion Rules — aaa2_squarebrackets_mutable_classes","text":"Coercion Semantics  mutable classes support \"copy--modify\" semantics like immutable classes, - unlike immutable classes - also support \"pass--reference\" semantics.  sb_mod method modify subsets object deep copy.  sb_set method dt_setcoe function modify subsets object reference.  2 copy semantics - \"pass reference\" \"modify copy\" - slightly different auto-coercion rules.  explained section. mutable_atomic  Mutable atomic objects automatically coerced fit modified subset values, modifying copy, just like regular atomic classes.  example, replacing one multiple values integer vector (type int) decimal number (type dbl) coerce entire vector type dbl.  Replacing transforming subsets mutable atomic objects reference support coercion. Thus, example, following code,   gives c(rep(8, 6) 7:16) instead c(rep(8.5, 6), 7:16), x type integer, rp interpreted type integer also. data.table, replacing/transforming whole columns  data.table actually list made mutable, column list. , replacing/transforming whole columns, row = NULL filter = NULL, allows completely changing type column.  Note coercion columns needs arguments row = NULL filter = NULL sb_mod sb_set methods; auto-coercion take place specifying something like row = 1:nrow(x) (see next section). data.table, partially replacing/transforming columns  rows specified sb_mod sb_set methods, thus whole columns parts columns replaced transformed, auto-coercion takes place.  .e.: replacing/transforming value integer (int) column become 1.5, coerce column decimal type (dbl); instead, replacement value 1.5 coerced integer 1.  coe argument sb_mod method allows user enforce coercion, even subsets columns replaced/transformed instead whole columns.  Specifically, coe arguments allows user specify coercive function applied entirety every column specified col vars; columns outside subset affected.  coercion function , course, applied replacement (rp) transformation (tf()). Views Lists  Regular lists treated mutable objects 'squarebrackets'.  However, lists actually really objects, merely (potentially hierarchical) structure pointers.  Thus, even list treated mutable, subsets list mutable classes, mutable.  example, list data.table objects, data.tables mutable.  Therefore, following work:   Notice code mypointer copy x$, since address.  Thus changing mypointer also changes x$.  words: mypointer called \"view\" x$.  Notice also sb_set(x$, ...) work, since sb_set() requires actual variables, similar -place functions style `myfun()<-`.  auto-coercion rules Views Lists, depends entirely object .  Thus list subset data.table, mutable matrix, coercion rules data.tables apply.  list subset data.table, coercion rules mutable matrices apply., etc.","code":"x <- 1:16 sb_set(x, i = 1:6, rp = 8.5) x x <- list(  a = data.table(cola = 1:10, colb = letters[1:10]),  b = data.table(cola = 11:20, colb = letters[11:20]) ) mypointer <- x$a sb_set(mypointer, col = \"cola\", tf = \\(x)x^2)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa2_squarebrackets_mutable_classes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Supported Mutable S3 Classes, With Auto-Coercion Rules — aaa2_squarebrackets_mutable_classes","text":"","code":"# Coercion examples - mutable_atomic ====  x <- as.mutable_atomic(1:16) sb_set(x, i = 1:6, rp = 8.5) # 8.5 coerced to 8, because `x` is of type `integer` #> Warning: Type of R (double) is larger than X (integer) and thus coerced. This incurs loss of information, such as digits of real numbers being truncated upon coercion to integer. To avoid this, make sure X has a larger type than R: character > double > integer > logical. print(x) #>  [1]  8  8  8  8  8  8  7  8  9 10 11 12 13 14 15 16 #> mutable_atomic  #> typeof:  integer   #############################################################################  # Coercion examples - data.table - whole columns ====  # sb_mod(): obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb2_mod(   obj, vars = is.numeric,   tf = sqrt # SAFE: row=NULL & filter = NULL, so coercion performed ) #>            a      b        c      d #>        <num> <char>    <num> <fctr> #>  1: 1.000000      a 3.316625      a #>  2: 1.414214      b 3.464102      b #>  3: 1.732051      c 3.605551      c #>  4: 2.000000      d 3.741657      d #>  5: 2.236068      e 3.872983      e #>  6: 2.449490      f 4.000000      f #>  7: 2.645751      g 4.123106      g #>  8: 2.828427      h 4.242641      h #>  9: 3.000000      i 4.358899      i #> 10: 3.162278      j 4.472136      j  # sb_set(): sb2_set(   obj, vars = is.numeric,   tf = sqrt # SAFE: row=NULL & filter = NULL, so coercion performed ) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 1.41 1.73 2 2.24 ... #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  3.32 3.46 3.61 3.74 3.87 ... #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>   #############################################################################   # Coercion examples - data.table - partial columns ====  # sb_mod(): obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>   sb2_mod(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt   # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost )  #> Warning: 1.414214 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 1 named 'a') #> Warning: 3.464102 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 3 named 'c') #>         a      b     c      d #>     <int> <char> <int> <fctr> #>  1:     1      a    11      a #>  2:     1      b     3      b #>  3:     1      c     3      c #>  4:     2      d     3      d #>  5:     2      e     3      e #>  6:     2      f     4      f #>  7:     2      g     4      g #>  8:     8      h    18      h #>  9:     9      i    19      i #> 10:    10      j    20      j sb2_mod(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   coe = as.double, tf = sqrt # SAFE: coercion performed ) #>             a      b         c      d #>         <num> <char>     <num> <fctr> #>  1:  1.000000      a 11.000000      a #>  2:  1.414214      b  3.464102      b #>  3:  1.732051      c  3.605551      c #>  4:  2.000000      d  3.741657      d #>  5:  2.236068      e  3.872983      e #>  6:  2.449490      f  4.000000      f #>  7:  2.645751      g  4.123106      g #>  8:  8.000000      h 18.000000      h #>  9:  9.000000      i 19.000000      i #> 10: 10.000000      j 20.000000      j  # sb_set(): obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb2_set(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt   # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost ) #> Warning: 1.414214 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 1 named 'a') #> Warning: 3.464102 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 3 named 'c') print(obj) #>         a      b     c      d #>     <int> <char> <int> <fctr> #>  1:     1      a    11      a #>  2:     1      b     3      b #>  3:     1      c     3      c #>  4:     2      d     3      d #>  5:     2      e     3      e #>  6:     2      f     4      f #>  7:     2      g     4      g #>  8:     8      h    18      h #>  9:     9      i    19      i #> 10:    10      j    20      j  obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  dt_setcoe(obj, vars = is.numeric, v = as.numeric) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb2_set(obj,   filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # SAFE: coercion performed by dt_setcoe(); so no warnings )  print(obj) #>             a      b         c      d #>         <num> <char>     <num> <fctr> #>  1:  1.000000      a 11.000000      a #>  2:  1.414214      b  3.464102      b #>  3:  1.732051      c  3.605551      c #>  4:  2.000000      d  3.741657      d #>  5:  2.236068      e  3.872983      e #>  6:  2.449490      f  4.000000      f #>  7:  2.645751      g  4.123106      g #>  8:  8.000000      h 18.000000      h #>  9:  9.000000      i 19.000000      i #> 10: 10.000000      j 20.000000      j   #############################################################################  # View of List ====  x <- list(  a = data.table::data.table(cola = 1:10, colb = letters[1:10]),  b = data.table::data.table(cola = 11:20, colb = letters[11:20]) ) print(x) #> $a #>      cola   colb #>     <int> <char> #>  1:     1      a #>  2:     2      b #>  3:     3      c #>  4:     4      d #>  5:     5      e #>  6:     6      f #>  7:     7      g #>  8:     8      h #>  9:     9      i #> 10:    10      j #>  #> $b #>      cola   colb #>     <int> <char> #>  1:    11      k #>  2:    12      l #>  3:    13      m #>  4:    14      n #>  5:    15      o #>  6:    16      p #>  7:    17      q #>  8:    18      r #>  9:    19      s #> 10:    20      t #>  mypointer <- x$a address(mypointer) == address(x$a) # they are the same #> [1] TRUE sb2_set(mypointer, col = \"cola\", tf = \\(x)x^2) print(x) # notice x has been changed #> $a #>      cola   colb #>     <num> <char> #>  1:     1      a #>  2:     4      b #>  3:     9      c #>  4:    16      d #>  5:    25      e #>  6:    36      f #>  7:    49      g #>  8:    64      h #>  9:    81      i #> 10:   100      j #>  #> $b #>      cola   colb #>     <int> <char> #>  1:    11      k #>  2:    12      l #>  3:    13      m #>  4:    14      n #>  5:    15      o #>  6:    16      p #>  7:    17      q #>  8:    18      r #>  9:    19      s #> 10:    20      t #>"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":null,"dir":"Reference","previous_headings":"","what":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"7 types arguments can used generic methods 'squarebrackets' specify indices perform operations : : specify flat (.e. dimensionless) indices. row, col: specify rows /columns tabular objects. idx, dims: specify indices arbitrary dimensions arrays. rcl: specify rows (first dimension), columns (second dimension), layers (third dimension), arrays exactly 3 dimensions. lvl: specify levels, factors . filter, vars: specify rows /columns specifically data.frame-like objects. margin, slice: specify indices one particular dimension. help page x refers object subset operations performed.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"argument-i","dir":"Reference","previous_headings":"","what":"Argument i","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"following can specified argument : NULL, multi-dimensional objects factors, specifying arguments (.e. dimensional indices factor levels.) vector length 0, case indices selected operation (.e. empty selection). strictly positive integer vector indices. logical vector, length x, giving indices select operation. character vector index names.  object multiple indices given name, corresponding indices selected operation. function takes input x, returns logical vector, giving element indices select operation.  atomic objects, interpreted (x).  lists, interpreted lapply(x, ). Using arguments corresponds something like following:   brief explanation relationship flat indices (), dimension indices (row, col, etc.), see Details section sub2ind.","code":"sb_x(x, i = i) # ==> x[i]"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"arguments-row-col","dir":"Reference","previous_headings":"","what":"Arguments row, col","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"following can specified arguments row / col: NULL (default), corresponds missing argument, results indices dimension selected operation. vector length 0, case indices selected operation (.e. empty selection). strictly positive integer vector dimension indices select operation. logical vector length corresponding dimension size, giving indices dimension select operation. character vector index names.  dimension multiple indices given name, corresponding indices selected operation. NOTE: arguments row col ignored specified. Using row, col arguments corresponds something like following:","code":"sb_x(x, row = row, col = col) # ==> x[row, col, drop = FALSE]"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"argument-pair-idx-dims","dir":"Reference","previous_headings":"","what":"Argument Pair idx, dims","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"idx must list indices. dims must integer vector length idx, giving dimensions indices given idx correspond .  elements idx follow rules rules row col, EXCEPT one fill NULL.  NOTE: arguments idx dims ignored specified.  keep syntax short, user can use n function instead list() specify idx.  Using idx, dims arguments, corresponds something like following, using example 4-dimensional array:","code":"sb_x(x, n(1:10, 1:5), c(1, 3)) # ==> x[1:10, , 1:5, , drop = FALSE]"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"argument-rcl","dir":"Reference","previous_headings":"","what":"Argument rcl","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"rcl argument applicable atomic arrays exactly 3 dimensions.  user knows -priori array 3 dimensions, using rcl efficient using idx, dims arguments.  rcl argument must list exactly 3 elements, first element giving indices first dimension (rows), second element giving indices second dimension (columns), third element giving indices third last dimension (layers); thus rcl stands \"rows, columns, layers\" (.e. 3 dimensions 3-dimensional array).  aforementioned 3 elements list rcl, following can specified: NULL, corresponds missing argument, results indices dimension selected operation. vector length 0, case indices selected operation (.e. empty selection). strictly positive integer vector dimension indices select operation. logical vector length corresponding dimension size, giving indices dimension select operation. character vector index names.  object multiple indices given name, corresponding indices selected operation. default rcl list simply NULL, used specifying arguments (either idx, dims ).  keep syntax short, user can use n function instead list() specify rcl.  Using rcl argument corresponds something like following:","code":"sb_x(x, rcl = n(NULL, 1:10, 1:5)) # ==> x[, 1:10, 1:5, drop = FALSE]"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"argument-lvl","dir":"Reference","previous_headings":"","what":"Argument lvl","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"argument, names levels x can given, selecting corresponding indices operation.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"arguments-filter-vars","dir":"Reference","previous_headings":"","what":"Arguments filter, vars","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"filter must one-sided formula single logical expression using column names data.frame, giving condition observation/row indices selected operation.  example, perform operation rows column height > 2 column sex != \"female\", specify following formula:   formula linked environment, variables found data set searched environment. vars must function returns logical vector, giving column indices select operation.  example, select numeric columns, specify vars = .numeric.","code":"~ (height > 2) & (sex != \"female\")"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"argument-pair-margin-slice","dir":"Reference","previous_headings":"","what":"Argument Pair margin, slice","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"Relevant idx method.  margin argument specifies dimension argument slice used.  .e. margin = 1, slice selects rows;  margin = 2, slice selects columns;  etc.  slice argument can following: strictly positive integer vector dimension indices select operation. logical vector length corresponding dimension size, giving dimension indices select operation. character vector index names.  dimension multiple indices given name, corresponding indices selected operation. One also give vector length 0 slice;  Argument slice used method idx, result idx meant used inside regular [ [<- operators.  Thus result zero-length index specification depends rule-set [.class(x) [<-.class(x).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"argument-inv","dir":"Reference","previous_headings":"","what":"Argument inv","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"Relevant sb_mod/sb2_mod, sb_set/sb2_set, idx methods.  default, inv = FALSE, translates indices like normally.  inv = TRUE, inverse indices taken.  Consider, example, atomic matrix x;  using sb_mod(x, 1:2, 1:2, tf = tf) corresponds something like following:   using sb_mod(x, 1:2, 1:2, inv = TRUE, tf = tf) corresponds something like following:   NOTE  order user gives indices inv = TRUE generally matter.  order indices appear original object x maintained, just like base 'R'.  Therefore, replacing multiple values order replacement matters, better keep inv = FALSE, default.  replacement single value transformation function, inv = TRUE can used without considering ordering.","code":"x[1:2, 1:2] <- tf(x[1:2, 1:2]) x x[-1:-2, -1:-2] <- tf(x[-1:-2, -1:-2]) x"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"out-of-bounds-integers-non-existing-names-levels-and-nas","dir":"Reference","previous_headings":"","what":"Out-of-Bounds Integers, Non-Existing Names/Levels, and NAs","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"Integer indices bounds (including NaN NA_integer_) always give error. Specifying non-existing names/levels (including NA_character_) indices considered form zero-length indexing. Logical indices translated internally integers using , NAs ignored.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"disallowed-combinations-of-index-arguments","dir":"Reference","previous_headings":"","what":"Disallowed Combinations of Index Arguments","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"One specify  indexing arguments simultaneously; either , arguments.  arguments  evaluated following order: Argument Argument lvl (factors) argument rcl (3-dimensional arrays) rest indexing arguments. One specify row filter simultaneously; either one .  One specify col vars simultaneously; either one .  One specify idx, dims pair slice, margin pair simultaneously; either one pair pair.  cases holds one set specified, set ignored.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"drop","dir":"Reference","previous_headings":"","what":"Drop","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"Sub-setting generic methods 'squarebrackets' R-package using dimensional arguments (row, col, lyr, idx, dims, filter, vars) always use drop = FALSE.  drop potentially redundant (.e. single level) dimensions, use drop function, like :","code":"sb_x(x, row = row, col = col) |> drop() # ==> x[row, col, drop = TRUE]"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"first-last-and-shuffle","dir":"Reference","previous_headings":"","what":"First, Last, and Shuffle","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"indices counted forward. .e. 1 first element, last.  One can use last function get last N indices.  One can use first function get first N indices.  shuffle elements indices, use sample function.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa3_squarebrackets_indx_args.html","id":"regarding-performance","dir":"Reference","previous_headings":"","what":"Regarding Performance","title":"Index Arguments in the Generic Sub-setting Methods — aaa3_squarebrackets_indx_args","text":"Integer indices logical indices fastest.  Indexing names levels (.e. character vectors) slowest.  Thus performance important, use integer logical indices.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa4_squarebrackets_options.html","id":null,"dir":"Reference","previous_headings":"","what":"squarebrackets Options — aaa4_squarebrackets_options","title":"squarebrackets Options — aaa4_squarebrackets_options","text":"help page explains various global options can set 'squarebrackets' package, affects functionality.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa4_squarebrackets_options.html","id":"check-duplicates","dir":"Reference","previous_headings":"","what":"Check Duplicates","title":"squarebrackets Options — aaa4_squarebrackets_options","text":"sb_x method method providing duplicate indices actually make sense.  methods, make sense.  Giving duplicate indices usually break anything; however, replacing/transforming removing subsets, almost certainly intention provide duplicate indices.  Providing duplicate indices anyway might lead unexpected results.  Therefore, methods giving duplicate indices make sense, chkdup argument present.  argument controls whether method question checks duplicates (TRUE) (FALSE).  Setting chkdup = TRUE means method question check duplicate indices, give error finds .  Setting chkdup = FALSE disable checks, saves time computation power, thus efficient.  Since checking duplicates can expensive, set FALSE default.  default can changed squarebrackets.chkdup option.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa4_squarebrackets_options.html","id":"retain-attributes","dir":"Reference","previous_headings":"","what":"Retain Attributes","title":"squarebrackets Options — aaa4_squarebrackets_options","text":"Like [ - methods, sb_x sb_rm default strip () attributes.  sb_x sb_rm methods 'squarebrackets' rat argument, control control attribute stripping behaviour.  rat = FALSE, default behaviour preserved, compatibility special classes. fastest option.  rat = TRUE, attributes x missing sub-setting re-assigned x. Already existing attributes sub-setting overwritten.  rat argument data.frame-like object: attributes always preserved.  NOTE: following situations, rat argument ignored, attributes necessarily dropped: x list, drop = TRUE, single element selected, sub-setting done argument. x atomic matrix array, sub-setting done argument. default value rat argument can changed squarebrackets.rat option.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa4_squarebrackets_options.html","id":"mutable-atomic-messages","dir":"Reference","previous_headings":"","what":"Mutable Atomic Messages","title":"squarebrackets Options — aaa4_squarebrackets_options","text":"[<-.mutable_atomic method notifies user copy--modification.  user find annoying, user can disable messages setting squarebrackets.ma_messages FALSE.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa4_squarebrackets_options.html","id":"squarebrackets-protected","dir":"Reference","previous_headings":"","what":"squarebrackets.protected","title":"squarebrackets Options — aaa4_squarebrackets_options","text":"user NEVER touch squarebrackets.protected option.  option lists locked non-functions base environment, order protect accidental pass--reference modification methods/functions 'squarebrackets'.  packages provide pass--reference modification, 'collapse' package, generally provide protections, blocked squarebrackets.protected.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa5_squarebrackets_PassByReference.html","id":null,"dir":"Reference","previous_headings":"","what":"Regarding Modification By Reference — aaa5_squarebrackets_PassByReference","title":"Regarding Modification By Reference — aaa5_squarebrackets_PassByReference","text":"help page describes modification using \"pass--reference\" semantics handled 'squarebrackets' package.  help page explain basics pass--reference semantics, treated prior knowledge.  functions/methods 'squarebrackets' package word \"set\" name use pass--reference semantics.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa5_squarebrackets_PassByReference.html","id":"advantages-and-disadvantages","dir":"Reference","previous_headings":"","what":"Advantages and Disadvantages","title":"Regarding Modification By Reference — aaa5_squarebrackets_PassByReference","text":"main advantage pass--reference much less memory required modify objects.  several disadvantages.  First, coercion rules slightly different: see squarebrackets_mutable_classes.  Second, 2 variables refer exactly object, changing one variable also changes ones.  .e. following code,   modifies just x, also y.  true even one variables locked (see bindingIsLocked).  .e. following code,   modifies x y without error, even though y locked constant.","code":"x <- y <- mutable_atomic(1:16) sb_set(x, i = 1:6, rp = 8) x <- mutable_atomic(1:16) y <- x lockBinding(\"y\", environment()) sb_set(x, i = 1:6, rp = 8)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa5_squarebrackets_PassByReference.html","id":"mutable-vs-immutable-types","dir":"Reference","previous_headings":"","what":"Mutable vs Immutable types","title":"Regarding Modification By Reference — aaa5_squarebrackets_PassByReference","text":"exception environments, base R's data types treated immutable:  Modifying object 'R' make copy object, something called 'copy--modify' semantics.  However, almost base R's data types can modified reference, R's 'C' API, 'C++' code (like via 'Rcpp'), thus treating objects mutable, even though \"supposed\" mutable.  Modifying base 'R' object reference can problematic.  Since 'R', also R-packages, treat objects immutable, modifying -mutable may produce undesired results.  prevent issue described , 'squarebrackets' supports pass--reference semantics objects actually supposed mutable.  relation restriction, 'squarebrackets' adds new class objects, mutable_atomic, simply atomic objects permission modified reference.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa5_squarebrackets_PassByReference.html","id":"mutability-rules-with-respect-to-recursive-objects","dir":"Reference","previous_headings":"","what":"Mutability Rules With Respect To Recursive Objects","title":"Regarding Modification By Reference — aaa5_squarebrackets_PassByReference","text":"Lists difficult objects contain elements, simply point  objects, one can access via list.  recursive object mutable class, subsets treated mutable, long part object.  hand, recursive object immutable class, recursive subsets retain original mutability. Example 1: Mutable data.tables  data.table mutable class.  columns data.table treated mutable;  requirement , instance, first change columns class mutable_atomic modify columns reference. Example 2: Immutable lists  regular list immutable class.  list immutable, recursive subsets list retain mutability.  list data.table objects, example, data.tables remain mutable.  Therefore, following pass--reference modification work:   Notice code mypointer address x$, therefore copy x$.  Thus changing mypointer also changes x$.  words: mypointer called \"View\" x$.","code":"x <- list(  a = data.table(cola = 1:10, colb = letters[1:10]),  b = data.table(cola = 11:20, colb = letters[11:20]) ) mypointer <- x$a sb_set(mypointer, col = \"cola\", tf = \\(x)x^2)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa5_squarebrackets_PassByReference.html","id":"input-variable","dir":"Reference","previous_headings":"","what":"Input Variable","title":"Regarding Modification By Reference — aaa5_squarebrackets_PassByReference","text":"Methods/functions perform -place modification reference can thought similar functions style some_function(x, ...) <- value, sense variable must actually exist actual variable.  Thus things like following, sb_set(1:10, ...), sb2_set(x$, ...), sb_set(base::letters),  work.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa5_squarebrackets_PassByReference.html","id":"lock-binding","dir":"Reference","previous_headings":"","what":"Lock Binding","title":"Regarding Modification By Reference — aaa5_squarebrackets_PassByReference","text":"Mutable classes , name suggests, meant mutable.  Locking binding mutable object mostly fruitless (completely; see currentBindings function).  prevent modification object's binding, 2 things must true: object must immutable class. binding must locked (see lockBinding). packages provide pass--reference semantics tend ignore lock object's binding.  Use 'squarebrackets'  methods (course) core/base 'R' methods, case user fears binding locks respected.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa5_squarebrackets_PassByReference.html","id":"protected-addresses","dir":"Reference","previous_headings":"","what":"Protected Addresses","title":"Regarding Modification By Reference — aaa5_squarebrackets_PassByReference","text":"prevent accidental pass--reference modification objects base environment, addresses exported objects base environment (baseenv) stored option squarebrackets.protected whenever 'squarebrackets' loaded, either directly indirectly.  Needless say, user never touch option.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa5_squarebrackets_PassByReference.html","id":"protection","dir":"Reference","previous_headings":"","what":"Protection","title":"Regarding Modification By Reference — aaa5_squarebrackets_PassByReference","text":"Due properties described help page, something like following work:   work : addresses baseenv() protected; immutable objects disallowed (create mutable object, create copy original, thus keeping original object safe modification reference); locked bindings disallowed. Despite checks made package, user never actively try modify locked protected object reference, defeat purpose locking object.  packages provide functions change class-related attributes objects reference.  Using functions discouraged, unless know exactly .","code":"# letters = base::letters sb_set(letters, i = 1, rp = \"XXX\")"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa5_squarebrackets_PassByReference.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Regarding Modification By Reference — aaa5_squarebrackets_PassByReference","text":"","code":"# the following code demonstrates how locked bindings, # such as `base::letters`, # are being safe-guarded  x <- list(a = base::letters) mypointer <- x$a # view of a list address(mypointer) == address(base::letters) # TRUE: point to the same memory #> [1] TRUE bindingIsLocked(\"letters\", baseenv()) # base::letters is locked ... #> [1] TRUE bindingIsLocked(\"mypointer\", environment()) # ... but this pointer is not! #> [1] FALSE  if(requireNamespace(\"tinytest\")) {   tinytest::expect_error(     sb_set(mypointer, i = 1, rp = \"XXX\") # this still gives an error though ...   ) } #> Loading required namespace: tinytest #> ----- PASSED      : <--> #>  call| eval(expr, envir, enclos)   is.mutable_atomic(mypointer) # ... because it's not of class `mutable_atomic` #> [1] FALSE   x <- list(   a = as.mutable_atomic(base::letters) # `as.mutable_atomic()` makes a copy ) mypointer <- x$a # view of a list address(mypointer) == address(base::letters) # FALSE: it's a copy #> [1] FALSE sb_set(   mypointer, i = 1, rp = \"XXX\"  # modifies x, does NOT modify `base::letters` ) print(x) # x is modified #> $a #>  [1] \"XXX\" \"b\"   \"c\"   \"d\"   \"e\"   \"f\"   \"g\"   \"h\"   \"i\"   \"j\"   \"k\"   \"l\"   #> [13] \"m\"   \"n\"   \"o\"   \"p\"   \"q\"   \"r\"   \"s\"   \"t\"   \"u\"   \"v\"   \"w\"   \"x\"   #> [25] \"y\"   \"z\"   #> mutable_atomic  #> typeof:  character  #>  base::letters # but this still the same #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" #> [20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"  # Word of warning: # the safe-guard in 'squarebrackets' is good, but definitely not perfect. # Do not actively try to break things; you might actually succeed."},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa6_squarebrackets_inconveniences.html","id":null,"dir":"Reference","previous_headings":"","what":"Examples Where the Square Bracket Operators Are Less Convenient — aaa6_squarebrackets_inconveniences","title":"Examples Where the Square Bracket Operators Are Less Convenient — aaa6_squarebrackets_inconveniences","text":"help page shows examples square bracket operators ( [, [<-) less optimally convenient, methods provided 'squarebrackets' can helpful cases.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa6_squarebrackets_inconveniences.html","id":"array-with-unknown-number-of-dimensions","dir":"Reference","previous_headings":"","what":"Array with Unknown Number of Dimensions","title":"Examples Where the Square Bracket Operators Are Less Convenient — aaa6_squarebrackets_inconveniences","text":"order perform subset operations array x square brackets operator ([, [<-), one needs know many dimensions .  .e. x 3 dimensions, one use:   one use [ [<- operators, number dimensions x known -priori?  ’s impossible, still rather convoluted.  methods provided 'squarebrackets' use position-based arguments, work arbitrary dimensions without requiring prior knowledge;  see squarebrackets_indx_args details.","code":"x[i, j, k, drop = FALSE]  x[i, j, k] <- value"},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa6_squarebrackets_inconveniences.html","id":"rule-sets-for-data-frame-like-objects","dir":"Reference","previous_headings":"","what":"Rule-sets for data.frame-like Objects","title":"Examples Where the Square Bracket Operators Are Less Convenient — aaa6_squarebrackets_inconveniences","text":"data.frame, tibble, data.table, tidytable classes inherit class “data.frame”.  Yet use different rules regarding usage square bracket operators.  Constantly switching rules annoying, makes one's code inconsistent.  methods provided 'squarebrackets' use sub-setting rules data.frame inherited classes, thus solving issue.  'squarebrackets' package attempts keep data.frame methods class agnostic possible, class agnostic functionality 'collapse' 'data.table' R-packages.  attempt keep data.frame-like classes consistent , admittedly, result oddities data.frames treated 'squarebrackets', compared classes treated 'squarebrackets': Whole-columns auto-coerced replaced/transformed sb_mod, partial columns auto-coerced default. sb_x sb_rm methods always automatically conserve attributes (though names dimensions adjusted accordingly, course);  attributes stripped, unlike classes. Giving data.frame-like object non-unique column names sb_-methods returns error;  duplicating columns sb_x automatically adjust column names make unique.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa6_squarebrackets_inconveniences.html","id":"annoying-sub-setting-by-names","dir":"Reference","previous_headings":"","what":"Annoying Sub-setting By Names","title":"Examples Where the Square Bracket Operators Are Less Convenient — aaa6_squarebrackets_inconveniences","text":"selecting names sub-setting, first occurrences names selected sub-set;  un-selecting/removing names sub-setting, syntax different selecting names.  methods provided 'squarebrackets' uses syntax selecting removing sub-sets.  Moreover, selecting/removing sub-sets names always selects/removes sub-sets given names, just first match.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa6_squarebrackets_inconveniences.html","id":"modification-semantics","dir":"Reference","previous_headings":"","what":"Modification Semantics","title":"Examples Where the Square Bracket Operators Are Less Convenient — aaa6_squarebrackets_inconveniences","text":"‘R’ adheres copy--modify semantics replacing values using [<-.  sometimes one like explicit control create copy, modify using pass--reference semantics.  'squarebrackets' package provides sb_mod method return copy object modified subsets,  sb_set method modify using pass--reference semantics.  idx method can used combination R's [<- operator R's default copy--modify semantics.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/aaa6_squarebrackets_inconveniences.html","id":"regarding-other-packages","dir":"Reference","previous_headings":"","what":"Regarding Other Packages","title":"Examples Where the Square Bracket Operators Are Less Convenient — aaa6_squarebrackets_inconveniences","text":"packages solve issues.  using different packages solving different issues common theme (case: solving inconveniences square bracket operators) leads inconsistent code.  found R-package provides holistic approach providing alternative methods square brackets operators.  Thus, 'R' package born.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/bind.html","id":null,"dir":"Reference","previous_headings":"","what":"Dimensional Binding of Objects — bind","title":"Dimensional Binding of Objects — bind","text":"bind_ bind2_ implementations provide dimensional binding functionalities. bind_ atomic objects, bind2_ recursive objects.  possible, bind_/bind2_ functions return mutable classes.  following implementations available: bind_array() binds atomic arrays matrices.  Returns mutable_atomic array. bind2_array() binds recursive arrays matrices.  modified version fantastic abind::abind function Tony Plare Richard Heiberger, can handle recursive arrays (abind::abind unlist everything atomic).  Returns dimensional lists. bind2_dt() binds data.tables data.frame-like objects.  Returns data.table.  Faster .call(cbind, ...) .call(rbind, ...) regular data.frame objects.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/bind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dimensional Binding of Objects — bind","text":"","code":"bind_array(arg.list, along, name_along = TRUE, name_flat = FALSE)  bind2_array(arg.list, along, name_along = TRUE, name_flat = FALSE)  bind2_dt(arg.list, along)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/bind.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dimensional Binding of Objects — bind","text":"arg.list list appropriate objects. mix different types objects. along single integer, indicating dimension along bind dimensions.  .e. use along = 1 row-binding, along = 2 column-binding, etc. name_along Boolean, bind_array() bind2_array().  Indicates dimension along named.  dimensions never named. name_flat Boolean, bind_array() bind2_array().  Indicates flat indices named.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/bind.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dimensional Binding of Objects — bind","text":"new object.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/bind.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Dimensional Binding of Objects — bind","text":"Plate T, Heiberger R (2016). abind: Combine Multidimensional Arrays. R package version 1.4-5, https://CRAN.R-project.org/package=abind.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/bind.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dimensional Binding of Objects — bind","text":"","code":"# atomic arrays ==== x <- matrix(1:12,3,4) y <- x+100 arg.list <- list(x = x, y=y) bind_array(arg.list, along=0) # binds on new dimension before first #> , , 1 #>  #>   [,1] [,2] [,3] #> x    1    2    3 #> y  101  102  103 #>  #> , , 2 #>  #>   [,1] [,2] [,3] #> x    4    5    6 #> y  104  105  106 #>  #> , , 3 #>  #>   [,1] [,2] [,3] #> x    7    8    9 #> y  107  108  109 #>  #> , , 4 #>  #>   [,1] [,2] [,3] #> x   10   11   12 #> y  110  111  112 #>  #> mutable_atomic  #> typeof:  double  bind_array(arg.list, along=1) # binds on first dimension #>     [,1] [,2] [,3] [,4] #> x.1    1    4    7   10 #> x.2    2    5    8   11 #> x.3    3    6    9   12 #> y.1  101  104  107  110 #> y.2  102  105  108  111 #> y.3  103  106  109  112 #> mutable_atomic  #> typeof:  double  bind_array(arg.list, along=2) #>      x.1 x.2 x.3 x.4 y.1 y.2 y.3 y.4 #> [1,]   1   4   7  10 101 104 107 110 #> [2,]   2   5   8  11 102 105 108 111 #> [3,]   3   6   9  12 103 106 109 112 #> mutable_atomic  #> typeof:  double  bind_array(arg.list, along=3) # bind on new dimension after last #> , , x #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    4    7   10 #> [2,]    2    5    8   11 #> [3,]    3    6    9   12 #>  #> , , y #>  #>      [,1] [,2] [,3] [,4] #> [1,]  101  104  107  110 #> [2,]  102  105  108  111 #> [3,]  103  106  109  112 #>  #> mutable_atomic  #> typeof:  double    ################################################################################   # recursiv arrays ==== x <- matrix(as.list(1:12),3,4) y <- lapply(x, \\(x) + 100) dim(y) <- dim(x) arg.list <- list(x = x, y=y) bind2_array(arg.list, along=0) # binds on new dimension before first #> , , 1 #>  #>   [,1] [,2] [,3] #> x 1    2    3    #> y 100  100  100  #>  #> , , 2 #>  #>   [,1] [,2] [,3] #> x 4    5    6    #> y 100  100  100  #>  #> , , 3 #>  #>   [,1] [,2] [,3] #> x 7    8    9    #> y 100  100  100  #>  #> , , 4 #>  #>   [,1] [,2] [,3] #> x 10   11   12   #> y 100  100  100  #>  bind2_array(arg.list, along=1) # binds on first dimension #>     [,1] [,2] [,3] [,4] #> x.1 1    4    7    10   #> x.2 2    5    8    11   #> x.3 3    6    9    12   #> y.1 100  100  100  100  #> y.2 100  100  100  100  #> y.3 100  100  100  100  bind2_array(arg.list, along=2) #>      x.1 x.2 x.3 x.4 y.1 y.2 y.3 y.4 #> [1,] 1   4   7   10  100 100 100 100 #> [2,] 2   5   8   11  100 100 100 100 #> [3,] 3   6   9   12  100 100 100 100 bind2_array(arg.list, along=3) # bind on new dimension after last #> , , x #>  #>      [,1] [,2] [,3] [,4] #> [1,] 1    4    7    10   #> [2,] 2    5    8    11   #> [3,] 3    6    9    12   #>  #> , , y #>  #>      [,1] [,2] [,3] [,4] #> [1,] 100  100  100  100  #> [2,] 100  100  100  100  #> [3,] 100  100  100  100  #>"},{"path":"https://tony-aw.github.io/squarebrackets/reference/class_mutable_atomic.html","id":null,"dir":"Reference","previous_headings":"","what":"Mutable Atomic Classes — class_mutable_atomic","title":"Mutable Atomic Classes — class_mutable_atomic","text":"mutable_atomic class mutable version atomic classes.  works exactly aspects regular atomic classes, one real difference:  'squarebrackets' methods functions perform modification reference (basically methods functions \"set\" name) accept mutable_atomic, accept regular atomic.  See squarebrackets_PassByReference details.  Like data.table, [<- performs R's default copy--modification semantics.  modification  reference, use sb_set.  Exposed functions (beside S3 methods): mutable_atomic(): create mutable_atomic object. .mutable_atomic(): checks object atomic. .mutable_atomic(): converts regular atomic object mutable_atomic. couldb.mutable_atomic(): checks object mutable_atomic.  objects can become mutable_atomic one following types: logical, integer, double, character, complex, raw. bit64::integer64 type also supported, since internally defined double.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/class_mutable_atomic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mutable Atomic Classes — class_mutable_atomic","text":"","code":"mutable_atomic(data, names = NULL, dim = NULL, dimnames = NULL)  as.mutable_atomic(x, ...)  is.mutable_atomic(x)  couldb.mutable_atomic(x)  # S3 method for mutable_atomic [(x, ...)  # S3 method for mutable_atomic [(x, ...) <- value  # S3 method for mutable_atomic format(x, ...)  # S3 method for mutable_atomic print(x, ...)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/class_mutable_atomic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mutable Atomic Classes — class_mutable_atomic","text":"data atomic vector giving data fill mutable_atomic object. names, dim, dimnames see setNames array. x atomic object. ... method dependent arguments. value see Extract.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/class_mutable_atomic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mutable Atomic Classes — class_mutable_atomic","text":"mutable_atomic(): Returns mutable_atomic object.  .mutable_atomic(): Converts atomic object (vector, matrix, array) object, additional class \"mutable_atomic\", additional attribute \"typeof\".  .mutable_atomic(): Returns TRUE object atomic, class \"mutable_atomic\", correctly set attribute \"typeof\", address overlap addresses base objects. .mutable_atomic returns FALSE otherwise.  couldb.mutable_atomic(): Returns TRUE object one following types: logical, integer, double, character, complex, raw. bit64::integer64 type also supported, since internally defined double. Returns FALSE otherwise.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/class_mutable_atomic.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"Mutable Atomic Classes — class_mutable_atomic","text":"Always use mutable_atomic() .mutable_atomic create mutable object, make necessary checks.  Circumventing checks may break things.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/class_mutable_atomic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mutable Atomic Classes — class_mutable_atomic","text":"","code":"x <- mutable_atomic(   1:20, dim = c(5, 4), dimnames = list(letters[1:5], letters[1:4]) ) x #>   a  b  c  d #> a 1  6 11 16 #> b 2  7 12 17 #> c 3  8 13 18 #> d 4  9 14 19 #> e 5 10 15 20 #> mutable_atomic  #> typeof:  integer   x <- matrix(1:10, ncol = 2) x <- as.mutable_atomic(x) is.mutable_atomic(x) #> [1] TRUE print(x) #>      [,1] [,2] #> [1,]    1    6 #> [2,]    2    7 #> [3,]    3    8 #> [4,]    4    9 #> [5,]    5   10 #> mutable_atomic  #> typeof:  integer  x[, 1] #> [1] 1 2 3 4 5 #> mutable_atomic  #> typeof:  integer  x[] <- as.double(x) # notifies the user a copy is being made #> copying on modification; for modification by reference, use `sb_set()` print(x) # \"typeof\" attribute adjusted accordingly, and class still present #>      [,1] [,2] #> [1,]    1    6 #> [2,]    2    7 #> [3,]    3    8 #> [4,]    4    9 #> [5,]    5   10 #> mutable_atomic  #> typeof:  double"},{"path":"https://tony-aw.github.io/squarebrackets/reference/currentBindings.html","id":null,"dir":"Reference","previous_headings":"","what":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","text":"currentBindings(x, action = \"list\")  lists currently existing objects sharing address x, given environment. currentBindings(x, action = \"checklock\")  searches currently existing objects sharing address x, given environment, reports locked locked. currentBindings(x, action = \"lockbindings\")  searches currently existing objects sharing address x, given environment, locks using lockBinding.  See also squarebrackets_PassByReference information regarding relation locked bindings pass--reference modifications.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/currentBindings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","text":"","code":"currentBindings(x, action = \"list\", env = NULL)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/currentBindings.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","text":"x existing variable whose address use searching bindings. action single string, giving action perform.  Must one following: \"list\" (default). \"checklock\". \"lockbindings\". env environment look objects.  NULL (default), caller environment used.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/currentBindings.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","text":"currentBindings(x, action = \"list\"): Returns character vector.  currentBindings(x, action = \"checklock\"): Returns named logical vector. names give names bindings, associated value indicates whether binding locked (TRUE) locked (FALSE).  currentBindings(x, action = \"lockbindings\"): Returns VOID. just locks currently existing bindings. unlock bindings, remove objects (see rm).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/currentBindings.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","text":"lockBinding function locks binding object, preventing modification.  'R' also uses locked bindings prevent modification objects package namespaces.  pass--reference semantics 'squarebrackets' principle respect , disallows modification objects reference.  However, lockBinding lock address/pointer object, one particular binding object.  problematic; consider following example:   code, x y share address, thus pointing memory, yet y actually locked.  Since x locked, modifying x allowed.  since sb_set()/sb2_set() performs modification reference, y still modified, despite locked.  currentBindings() function allows user : find currently existing bindings caller environment sharing address x, locking bindings.","code":"x <- mutable_atomic(1:16) y <- x lockBinding(\"y\", environment()) sb_set(x, i = 1:6, rp = 8)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/currentBindings.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","text":"currentBindings() function locks currently existing bindings caller environment;  bindings created calling currentBindings() automatically locked.  Thus, every time user creates new binding object, user wishes locked, currentBindings() must called .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/currentBindings.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"List or Lock All Currently Existing Bindings Pointing To Same Address — currentBindings","text":"","code":"x <- as.mutable_atomic(1:10) y <- x lockBinding(\"y\", environment()) currentBindings(x) #> searching environment: <0000025946098c88> #> [1] \"x\" \"y\" currentBindings(x, \"checklock\") # only y is locked #> searching environment: <0000025946098c88> #>     x     y  #> FALSE  TRUE    # since only y is locked, we can still modify y through x by reference: sb_set(x, i = 1, rp = -1) print(y) # modified! #>  [1] -1  2  3  4  5  6  7  8  9 10 #> mutable_atomic  #> typeof:  integer  rm(list= c(\"y\")) # clean up   # one can fix this by locking ALL bindings: y <- x currentBindings(x, \"lockbindings\") # lock all #> searching environment: <0000025946098c88> currentBindings(x, \"checklock\") # all bindings are locked, including y #> searching environment: <0000025946098c88> #>    x    y  #> TRUE TRUE  # the 'squarebrackets' package respects the lock of a binding, # provided all bindings of an address are locked; # so this will give an error, as it should:  if(requireNamespace(\"tinytest\")) {   tinytest::expect_error(     sb_set(x, i = 1, rp = -1),     pattern = \"object is locked\"   ) } #> ----- PASSED      : <--> #>  call| eval(expr, envir, enclos)   # creating a new variable will NOT automatically be locked: z <- y # new variable; will not be locked! currentBindings(x, \"checklock\") # z is not locked #> searching environment: <0000025946098c88> #>     x     y     z  #>  TRUE  TRUE FALSE  currentBindings(x, \"lockbindings\") # we must re-run this #> searching environment: <0000025946098c88> currentBindings(x, \"checklock\") # now z is also locked #> searching environment: <0000025946098c88> #>    x    y    z  #> TRUE TRUE TRUE   if(requireNamespace(\"tinytest\")) {   tinytest::expect_error( # now z is also protected     sb_set(z, i = 1, rp = -1),     pattern = \"object is locked\"   ) } #> ----- PASSED      : <--> #>  call| eval(expr, envir, enclos)    rm(list= c(\"x\", \"y\", \"z\")) # clean up"},{"path":"https://tony-aw.github.io/squarebrackets/reference/dt.html","id":null,"dir":"Reference","previous_headings":"","what":"Functional Forms of data.table Operations — dt","title":"Functional Forms of data.table Operations — dt","text":"Functional forms special data.table operations.  functions use Non-Standard Evaluation.  functions also benefit security measures 'squarebrackets' implements pass--reference semantics. dt_aggregate() aggregates data.table tidytable, returns aggregated copy. dt_setcoe() coercively transforms columns data.table tidytable using pass--reference semantics. dt_setrm() removes columns data.table tidytable using pass--reference semantics. dt_setadd(x, new) adds columns data.table/tidytable new data.table/tidytable x, thereby modifying x using pass--reference semantics. dt_setreorder() reorders rows /variables data.table using pass--reference semantics.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/dt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functional Forms of data.table Operations — dt","text":"","code":"dt_aggregate(x, SDcols = NULL, f, by, order_by = FALSE)  dt_setcoe(   x,   col = NULL,   vars = NULL,   v,   chkdup = getOption(\"sb.chkdup\", FALSE) )  dt_setrm(x, col = NULL, vars = NULL, chkdup = getOption(\"sb.chkdup\", FALSE))  dt_setadd(x, new)  dt_setreorder(x, roworder = NULL, varorder = NULL)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/dt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functional Forms of data.table Operations — dt","text":"x data.table tidytable. SDcols atomic vector, giving columns aggregation function f() applied . f aggregation function atomic vector, giving grouping columns. order_by Boolean, indicating aggregated result ordered columns specified . col, vars see squarebrackets_indx_args.  Duplicates allowed. v coercive transformation function chkdup see squarebrackets_options. new data.table tidytable.  must column names already exist x. roworder integer vector length nrow(x), giving order rows re-order. Internally, numeric vector turned order using order, thus ensuring strict permutation 1:nrow(x). varorder integer character vector length ncol(x), giving new column order.  See data.table::setcolorder.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/dt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functional Forms of data.table Operations — dt","text":"dt_aggregate(): aggregated data.table object.  rest functions: Returns: VOID. functions modify object reference. use assignments like x <- dt_setcoe(x, ...). Since functions return void, just get NULL.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/dt.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Functional Forms of data.table Operations — dt","text":"dt_setreorder(x, roworder = roworder) internally creates new column reorder data.table , removes new column.  column name randomized, extra care given ensure overwrite existing columns.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/dt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functional Forms of data.table Operations — dt","text":"","code":"# dt_aggregate on sf-data.table ====  if(requireNamespace(\"sf\")) {   x <- sf::st_read(system.file(\"shape/nc.shp\", package = \"sf\"))   x <- data.table::as.data.table(x)      x$region <- ifelse(x$CNTY_ID <= 2000, 'high', 'low')   d.aggr <- dt_aggregate(     x, SDcols = \"geometry\", f= sf::st_union, by = \"region\"   )      head(d.aggr) } #> Loading required namespace: sf #> Reading layer `nc' from data source `D:\\Programs\\R-4.4.0\\library\\sf\\shape\\nc.shp' using driver `ESRI Shapefile' #> Simple feature collection with 100 features and 14 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 #> Geodetic CRS:  NAD27 #>    region                       geometry #>    <char>             <sfc_MULTIPOLYGON> #> 1:   high MULTIPOLYGON (((-75.78317 3... #> 2:    low MULTIPOLYGON (((-76.46926 3...    #############################################################################   # dt_setcoe ====  obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb2_set(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost ) #> Warning: 1.414214 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 1 named 'a') #> Warning: 3.464102 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 3 named 'c') str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 1 1 2 2 2 2 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 3 3 3 3 4 4 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) dt_setcoe(obj, vars = is.numeric, v = as.numeric) # integers are now numeric str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb2_set(obj,   filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # SAFE: coercion performed; so no warnings )  str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 1.41 1.73 2 2.24 ... #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  11 3.46 3.61 3.74 3.87 ... #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>    #############################################################################   # dt_setrm ====  obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  dt_setrm(obj, col = 1) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  3 variables: #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>   obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  dt_setrm(obj, vars = is.numeric) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  2 variables: #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>    #############################################################################   # dt_setadd ====  obj <- data.table::data.table(   a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]) ) new <- data.table::data.table(   e = sample(c(TRUE, FALSE), 10, TRUE),   f = sample(c(TRUE, FALSE), 10, TRUE) ) dt_setadd(obj, new) print(obj) #>         a      b     c      d      e      f #>     <int> <char> <int> <fctr> <lgcl> <lgcl> #>  1:     1      a    11      a   TRUE  FALSE #>  2:     2      b    12      b   TRUE   TRUE #>  3:     3      c    13      c  FALSE   TRUE #>  4:     4      d    14      d   TRUE   TRUE #>  5:     5      e    15      e   TRUE   TRUE #>  6:     6      f    16      f  FALSE  FALSE #>  7:     7      g    17      g   TRUE   TRUE #>  8:     8      h    18      h   TRUE   TRUE #>  9:     9      i    19      i   TRUE  FALSE #> 10:    10      j    20      j  FALSE  FALSE    #############################################################################   # dt_setreorder====  n <- 1e4 obj <- data.table::data.table(   a = 1L:n, b = n:1L, c = as.double(1:n), d = as.double(n:1) ) dt_setreorder(obj, roworder = n:1) head(obj) #>        a     b     c     d #>    <int> <int> <num> <num> #> 1: 10000     1 10000     1 #> 2:  9999     2  9999     2 #> 3:  9998     3  9998     3 #> 4:  9997     4  9997     4 #> 5:  9996     5  9996     5 #> 6:  9995     6  9995     6 dt_setreorder(obj, varorder = ncol(obj):1) head(obj) #>        d     c     b     a #>    <num> <num> <int> <int> #> 1:     1 10000     1 10000 #> 2:     2  9999     2  9999 #> 3:     3  9998     3  9998 #> 4:     4  9997     4  9997 #> 5:     5  9996     5  9996 #> 6:     6  9995     6  9995"},{"path":"https://tony-aw.github.io/squarebrackets/reference/exported_uilities.html","id":null,"dir":"Reference","previous_headings":"","what":"Exported Utilities — indx_x","title":"Exported Utilities — indx_x","text":"Exported utilities.  Usually user need functions.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/exported_uilities.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exported Utilities — indx_x","text":"","code":"indx_x(i, x, xnames, xsize)  indx_rm(i, x, xnames, xsize)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/exported_uilities.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exported Utilities — indx_x","text":"See squarebrackets_indx_args. x vector, vector-like object, factor, data.frame, data.frame-like object, list. xnames names dimension names xsize length dimension size","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/exported_uilities.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exported Utilities — indx_x","text":"subsetted object.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/exported_uilities.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Exported Utilities — indx_x","text":"","code":"x <- 1:10 names(x) <- letters[1:10] indx_x(1:5, x, names(x), length(x)) #> [1] 1 2 3 4 5 indx_rm(1:5, x, names(x), length(x)) #> [1]  6  7  8  9 10"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx1.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert/Translate Indices (for Copy-On-Modify Substitution) — idx","title":"Convert/Translate Indices (for Copy-On-Modify Substitution) — idx","text":"idx() method converts indices.  type output depends type input index arguments given: idx(x, = , ...) converts linear indices strictly positive integer vector linear indices. idx(x, idx = idx, dims = dims, ...) converts dimensional indices strictly positive integer vector linear indices. idx(x, slice = slice, margin = margin, ...) converts indices one dimension strictly positive integer vector indices specific dimension. Vectors (atomic recursive) index argument .  Data.frame-like objects slice, margin index argument pair.  Arrays (atomic recursive) idx, dims index argument pair, well arguments slice, margin.  result idx() method can used inside regular square-brackets operators.  example like :   thus allowing user benefit convenient index translations 'squarebrackets', whilst still using R's default copy--modification semantics (instead deep copy semantics pass--reference semantics provided 'squarebrackets').  idx() method particularly handy replacing coercively transforming shallow subsets recursive objects, without return copy entire object.  Thus combining [<- idx efficient sb2_mod recursive objects.","code":"x <- array(...) my_indices <- idx(x, idx, dims) x[my_indices] <- value  y <- data.frame(...) rows <- idx(y, 1:10, 1, inv = TRUE) cols <- idx(y, c(\"a\", \"b\"), 2) y[rows, cols] <- value"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert/Translate Indices (for Copy-On-Modify Substitution) — idx","text":"","code":"idx(x, ...)  # S3 method for default idx(x, i, inv = FALSE, ..., chkdup = getOption(\"squarebrackets.chkdup\", FALSE))  # S3 method for array idx(   x,   idx = NULL,   dims = NULL,   slice = NULL,   margin = NULL,   i = NULL,   inv = FALSE,   ...,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # S3 method for data.frame idx(   x,   slice,   margin,   inv = FALSE,   ...,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx1.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert/Translate Indices (for Copy-On-Modify Substitution) — idx","text":"x vector, matrix, array, data.frame; atomic recursive objects supported. ... arguments passed methods. , idx, dims, margin, slice, inv See squarebrackets_indx_args.  Duplicates allowed. chkdup see squarebrackets_options.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx1.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert/Translate Indices (for Copy-On-Modify Substitution) — idx","text":"idx(x, = , ...) idx(x, idx = idx, dims = dims, ...): strictly positive integer vector flat indices.  idx(x, margin = margin, slice = slice, ...): strictly positive integer vector indices dimension specified margin.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx1.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert/Translate Indices (for Copy-On-Modify Substitution) — idx","text":"","code":"# atomic ====  x <- 1:10 x[idx(x, \\(x)x>5)] <- -5 print(x) #>  [1]  1  2  3  4  5 -5 -5 -5 -5 -5  x <- array(1:27, dim = c(3,3,3)) x[idx(x, n(1:2, 1:2), c(1,3))] <- -10 print(x) #> , , 1 #>  #>      [,1] [,2] [,3] #> [1,]  -10  -10  -10 #> [2,]  -10  -10  -10 #> [3,]    3    6    9 #>  #> , , 2 #>  #>      [,1] [,2] [,3] #> [1,]  -10  -10  -10 #> [2,]  -10  -10  -10 #> [3,]   12   15   18 #>  #> , , 3 #>  #>      [,1] [,2] [,3] #> [1,]   19   22   25 #> [2,]   20   23   26 #> [3,]   21   24   27 #>    ################################################################################   # recursive ====  x <- as.list(1:10) x[idx(x, \\(x)x>5)] <- -5 print(x) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 3 #>  #> [[4]] #> [1] 4 #>  #> [[5]] #> [1] 5 #>  #> [[6]] #> [1] -5 #>  #> [[7]] #> [1] -5 #>  #> [[8]] #> [1] -5 #>  #> [[9]] #> [1] -5 #>  #> [[10]] #> [1] -5 #>   x <- array(as.list(1:27), dim = c(3,3,3)) x[idx(x, n(1:2, 1:2), c(1,3))] <- -10 print(x) #> , , 1 #>  #>      [,1] [,2] [,3] #> [1,] -10  -10  -10  #> [2,] -10  -10  -10  #> [3,] 3    6    9    #>  #> , , 2 #>  #>      [,1] [,2] [,3] #> [1,] -10  -10  -10  #> [2,] -10  -10  -10  #> [3,] 12   15   18   #>  #> , , 3 #>  #>      [,1] [,2] [,3] #> [1,] 19   22   25   #> [2,] 20   23   26   #> [3,] 21   24   27   #>    x <- data.frame(   a = sample(c(TRUE, FALSE, NA), 10, TRUE),   b = 1:10,   c = rnorm(10),   d = letters[1:10],   e = factor(letters[11:20]) ) rows <- idx(x, 1:5, 1, inv = TRUE) cols <- idx(x, c(\"b\", \"a\"), 2) x[rows, cols] <- NA print(x) #>        a  b            c d e #> 1  FALSE  1 -0.170848972 a k #> 2     NA  2  1.631206007 b l #> 3   TRUE  3 -0.782706041 c m #> 4   TRUE  4 -0.002893626 d n #> 5   TRUE  5  0.413239292 e o #> 6     NA NA  0.724433452 f p #> 7     NA NA  2.353944771 g q #> 8     NA NA -0.281449685 h r #> 9     NA NA -0.481046436 i s #> 10    NA NA  0.079225925 j t"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_by.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Grouped Indices — idx_by","title":"Compute Grouped Indices — idx_by","text":"Given: sub-set function f; complete range indices r object x; grouping factor grp; idx_by() function takes indices f(r) per group grp.  result idx_by() can supplied indexing arguments (see squarebrackets_indx_args) perform grouped subset operations.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_by.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Grouped Indices — idx_by","text":"","code":"idx_by(f, r, grp, parallel = FALSE, mc.cores = 1L)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_by.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Grouped Indices — idx_by","text":"f subset function applied per group r.  function must accept character integer vector input, produce character integer vector output.  example, subset last element per group, specify: f = last r integer character vector, giving complete range indices object.  example: colnames(x), 1:nrow(x), etc. grp factor giving groups. Make sure order corresponds r, otherwise makes sense. parallel, mc.cores see .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_by.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Grouped Indices — idx_by","text":"vector indices type r.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_by.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Grouped Indices — idx_by","text":"","code":"# vectors ==== (a <- 1:20) #>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 (grp <- factor(rep(letters[1:5], each = 4))) #>  [1] a a a a b b b b c c c c d d d d e e e e #> Levels: a b c d e  # get the last element of `a` for each group in `grp`: i <- idx_by(last, seq_along(a), grp) sb_x(cbind(a, grp), row = i) #>       a grp #> [1,]  4   1 #> [2,]  8   2 #> [3,] 12   3 #> [4,] 16   4 #> [5,] 20   5   # data.frame ==== x <- data.frame(   a = sample(1:20),   b = letters[1:20],   group = factor(rep(letters[1:5], each = 4)) ) print(x) #>     a b group #> 1   1 a     a #> 2   6 b     a #> 3   2 c     a #> 4  14 d     a #> 5  20 e     b #> 6   9 f     b #> 7  18 g     b #> 8   5 h     b #> 9   8 i     c #> 10 16 j     c #> 11  3 k     c #> 12 10 l     c #> 13 17 m     d #> 14  7 n     d #> 15 12 o     d #> 16 15 p     d #> 17 19 q     e #> 18  4 r     e #> 19 11 s     e #> 20 13 t     e # get the first row for each group in data.frame `x`: row <- idx_by(first, 1:nrow(x), x$group) sb2_x(x, row) #>    a b group #> 1  1 a     a #> 2 20 e     b #> 3  8 i     c #> 4 17 m     d #> 5 19 q     e # get the first row for each group for which a > 10: x2 <- sb2_x(x, filter = ~ a > 10) row <- na.omit(idx_by(first, 1:nrow(x2), x2$group)) sb2_x(x2, row) #>    a b group #> 1 14 d     a #> 2 20 e     b #> 3 16 j     c #> 4 17 m     d #> 5 19 q     e"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_ord.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Ordered Indices — idx_ord_v","title":"Compute Ordered Indices — idx_ord_v","text":"Computes ordered indices. Similar order, except user must supply vector, list equal-length vectors, data.frame matrix (row-wise column-wise supported), input.  vector x, idx_ord_v(x) equivalent order(x).  data.frame list equal-length vectors x, p columns/elements, idx_ord_df(x) equivalent order(x[[1]], ..., x[[p]]).  matrix (array) x p rows, idx_ord_m(x, margin = 1) equivalent order(x[1, ], ..., x[p, ], ...).  matrix (array) x p columns, idx_ord_m(x, margin = 2) equivalent order(x[, 1], ..., x[, p], ...).  Note merely convenience functions, actually slightly slower order (except idx_ord_v()), due additional functionality.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_ord.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Ordered Indices — idx_ord_v","text":"","code":"idx_ord_v(   x,   na.last = TRUE,   decr = FALSE,   method = c(\"auto\", \"shell\", \"radix\") )  idx_ord_m(   x,   margin,   na.last = TRUE,   decr = FALSE,   method = c(\"auto\", \"shell\", \"radix\") )  idx_ord_df(   x,   na.last = TRUE,   decr = FALSE,   method = c(\"auto\", \"shell\", \"radix\") )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_ord.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Ordered Indices — idx_ord_v","text":"x vector, data.frame, array na.last, method see order sort. decr see argument decreasing order margin margin cut matrix/array vectors.  .e. margin = 1 cut x individual rows, apply order rows.  margin = 2 cut x columns, etc.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_ord.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Ordered Indices — idx_ord_v","text":"See order.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/idx_ord.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Ordered Indices — idx_ord_v","text":"","code":"x <- sample(1:10) order(x) #>  [1]  4  5  3  7  8  1  6  9 10  2 idx_ord_v(x) #>  [1]  4  5  3  7  8  1  6  9 10  2 idx_ord_m(rbind(x, x), 1) #>  [1]  4  5  3  7  8  1  6  9 10  2 idx_ord_m(cbind(x, x), 2) #>  [1]  4  5  3  7  8  1  6  9 10  2 idx_ord_df(data.frame(x, x)) #>  [1]  4  5  3  7  8  1  6  9 10  2"},{"path":"https://tony-aw.github.io/squarebrackets/reference/lst.html","id":null,"dir":"Reference","previous_headings":"","what":"Unnest Tree-like List to Recursive 2d Array or Flattened Recursive Vector — lst","title":"Unnest Tree-like List to Recursive 2d Array or Flattened Recursive Vector — lst","text":"[[, [[<-, sb2_rec, sb2_reccom, can performing recursive subset operation nested list.  recursive subset operations operate single element.  Performing recursive subset operations multiple elements vectorized, requires (potentially slow) loop.  lst_untree() funtion takes nested tree-like list, turns 2d recursive array (.e. list-matrix), allowing vectorized subset operations performed list. lst_untree() can also simply flatten list, making non-nested list.  See Examples section understand list arranged named.  lst_nlists() counts total number recursive list-elements inside list.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/lst.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unnest Tree-like List to Recursive 2d Array or Flattened Recursive Vector — lst","text":"","code":"lst_nlists(x)  lst_untree(x, margin, use.names = FALSE)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/lst.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Unnest Tree-like List to Recursive 2d Array or Flattened Recursive Vector — lst","text":"x tree-like nested list. margin single integer, indicating result arranged: margin = 0 produces simple flattened recursive vector (.e. list) without dimensions. margin = 1 produces 2D recursive array (.e. matrix lists),  length(x) rows n columns,  n = sapply(x, lst_nlists) |> max().  Empty elements filled list(NULL). margin = 2 pproduces 2D recursive array (.e. matrix lists),  length(x) columns n rows,  n = sapply(x, lst_nlists) |> max().  Empty elements filled list(NULL). use.names Boolean, indicating elements returned lst_untree() named.  Names nested elements, x[[c(\"\", \"B\", \"C\")]], become \".B.C\", behaviour rapply function (lst_untree() calls internally).  therefore advised use dots (\".\") list names, use underscores (\"_\") instead, calling lst_untree().  See rrapply::rrapply function renaming (forms transforming) recursive subsets lists.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/lst.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Unnest Tree-like List to Recursive 2d Array or Flattened Recursive Vector — lst","text":"lst_untree(): non-nested (dimensional) list. Note margin = 1 margin = 2, lst_untree() returns recursive matrix (.e. recursive array 2 dimensions), data.frame. (One advantage recursive matrix data.frame, recursive matrix can separate column names regular names, whereas names data.frame necessarily equal column names).  lst_nlists(): single integer, giving total number recursive list-elements given list.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/lst.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Unnest Tree-like List to Recursive 2d Array or Flattened Recursive Vector — lst","text":"","code":"# show-casing how the list-elements are arranged and named ====  x <- list(   A = list(     A = list(A = \"AAA\", B = \"AAB\"),     A = list(A  = \"AA2A\", B = \"AA2B\"),     B = list(A = \"ABA\", B = \"ABB\"),     C = letters   ),   Y = list(     Z = list(Z = \"YZZ\", Y = \"YZY\"),     Y = list(Z = \"YYZ\", Y = \"YYY\"),     X = \"YX\"   ) )  # simple flattened list: y <- lst_untree(x, margin = 0, use.names = TRUE) print(y) #> $A.A.A #> [1] \"AAA\" #>  #> $A.A.B #> [1] \"AAB\" #>  #> $A.A.A #> [1] \"AA2A\" #>  #> $A.A.B #> [1] \"AA2B\" #>  #> $A.B.A #> [1] \"ABA\" #>  #> $A.B.B #> [1] \"ABB\" #>  #> $A.C #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" #> [20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\" #>  #> $Y.Z.Z #> [1] \"YZZ\" #>  #> $Y.Z.Y #> [1] \"YZY\" #>  #> $Y.Y.Z #> [1] \"YYZ\" #>  #> $Y.Y.Y #> [1] \"YYY\" #>  #> $Y.X #> [1] \"YX\" #>  y[[\"Y.Z.Y\"]] #> [1] \"YZY\" x[[c(\"Y\", \"Z\", \"Y\")]] # equivalent in the original list #> [1] \"YZY\"  # un-tree row-wise: sapply(x, lst_nlists) |> max() # number of columns `y` will have #> [1] 7 y <- lst_untree(x, margin = 1, use.names = TRUE) dim(y) #> [1] 2 7 print(y) #>   [,1]  [,2]  [,3]   [,4]   [,5]  [,6]  [,7]         #> A \"AAA\" \"AAB\" \"AA2A\" \"AA2B\" \"ABA\" \"ABB\" character,26 #> Y \"YZZ\" \"YZY\" \"YYZ\"  \"YYY\"  \"YX\"  NULL  NULL         #> attr(,\"names\") #>  [1] \"A.A.A\" \"Y.Z.Z\" \"A.A.B\" \"Y.Z.Y\" \"A.A.A\" \"Y.Y.Z\" \"A.A.B\" \"Y.Y.Y\" \"A.B.A\" #> [10] \"Y.X\"   \"A.B.B\" \"\"      \"A.C\"   \"\"      y[[\"Y.Z.Y\"]] # you can still use names for selecting/replacing #> [1] \"YZY\" y[1:2, 1:3] # vectorized selection of multiple recursive elements #>   [,1]  [,2]  [,3]   #> A \"AAA\" \"AAB\" \"AA2A\" #> Y \"YZZ\" \"YZY\" \"YYZ\"  sb2_x(y, n(1:2, 1:3), 1:2) # equivalent #>   [,1]  [,2]  [,3]   #> A \"AAA\" \"AAB\" \"AA2A\" #> Y \"YZZ\" \"YZY\" \"YYZ\"   # un-tree column-wise: sapply(x, lst_nlists) |> max() # number of rows `y` will have #> [1] 7 y <- lst_untree(x, margin = 2, use.names = TRUE) dim(y) #> [1] 7 2 print(y) #>      A            Y     #> [1,] \"AAA\"        \"YZZ\" #> [2,] \"AAB\"        \"YZY\" #> [3,] \"AA2A\"       \"YYZ\" #> [4,] \"AA2B\"       \"YYY\" #> [5,] \"ABA\"        \"YX\"  #> [6,] \"ABB\"        NULL  #> [7,] character,26 NULL  #> attr(,\"names\") #>  [1] \"A.A.A\" \"A.A.B\" \"A.A.A\" \"A.A.B\" \"A.B.A\" \"A.B.B\" \"A.C\"   \"Y.Z.Z\" \"Y.Z.Y\" #> [10] \"Y.Y.Z\" \"Y.Y.Y\" \"Y.X\"   \"\"      \"\"      y[[\"Y.Z.Y\"]] # you can still use names for selecting/replacing #> [1] \"YZY\" y[1:3, 1:2] # vectorized selection of multiple recursive elements #>      A      Y     #> [1,] \"AAA\"  \"YZZ\" #> [2,] \"AAB\"  \"YZY\" #> [3,] \"AA2A\" \"YYZ\" sb2_x(y, n(1:3, 1:2), 1:2) # equivalent #>      A      Y     #> [1,] \"AAA\"  \"YZZ\" #> [2,] \"AAB\"  \"YZY\" #> [3,] \"AA2A\" \"YYZ\"   ################################################################################  # showcasing that only list-elements are recursively flattened ==== # i.e. atomic vectors in recursive subsets remain atomic  x <- lapply(1:10, \\(x)list(sample(letters), sample(1:10)))  sapply(x, lst_nlists) |> max() #> [1] 2 y <- lst_untree(x, margin = 1) dim(y) #> [1] 10  2 print(y) #>       [,1]         [,2]       #>  [1,] character,26 integer,10 #>  [2,] character,26 integer,10 #>  [3,] character,26 integer,10 #>  [4,] character,26 integer,10 #>  [5,] character,26 integer,10 #>  [6,] character,26 integer,10 #>  [7,] character,26 integer,10 #>  [8,] character,26 integer,10 #>  [9,] character,26 integer,10 #> [10,] character,26 integer,10  lst_untree(x, margin = 0) #> [[1]] #>  [1] \"v\" \"i\" \"j\" \"b\" \"f\" \"g\" \"l\" \"n\" \"e\" \"u\" \"c\" \"t\" \"a\" \"r\" \"s\" \"z\" \"o\" \"x\" \"m\" #> [20] \"w\" \"h\" \"p\" \"y\" \"k\" \"d\" \"q\" #>  #> [[2]] #>  [1]  2  8  1  3  9  7  6 10  4  5 #>  #> [[3]] #>  [1] \"y\" \"u\" \"c\" \"m\" \"r\" \"t\" \"k\" \"d\" \"b\" \"i\" \"v\" \"n\" \"x\" \"l\" \"o\" \"a\" \"j\" \"g\" \"e\" #> [20] \"s\" \"z\" \"w\" \"h\" \"f\" \"p\" \"q\" #>  #> [[4]] #>  [1]  7  8  6  1  4  9  3  2  5 10 #>  #> [[5]] #>  [1] \"u\" \"j\" \"c\" \"d\" \"m\" \"f\" \"n\" \"b\" \"e\" \"r\" \"y\" \"l\" \"w\" \"x\" \"h\" \"t\" \"i\" \"a\" \"g\" #> [20] \"o\" \"q\" \"k\" \"z\" \"s\" \"v\" \"p\" #>  #> [[6]] #>  [1]  9 10  2  1  3  7  6  4  5  8 #>  #> [[7]] #>  [1] \"o\" \"w\" \"e\" \"t\" \"k\" \"z\" \"h\" \"g\" \"y\" \"l\" \"c\" \"r\" \"q\" \"u\" \"b\" \"s\" \"n\" \"a\" \"x\" #> [20] \"j\" \"v\" \"i\" \"m\" \"p\" \"d\" \"f\" #>  #> [[8]] #>  [1]  7  4  3  1  9 10  5  6  2  8 #>  #> [[9]] #>  [1] \"t\" \"v\" \"o\" \"r\" \"b\" \"j\" \"w\" \"e\" \"n\" \"y\" \"s\" \"p\" \"f\" \"c\" \"a\" \"h\" \"k\" \"z\" \"u\" #> [20] \"i\" \"m\" \"q\" \"g\" \"d\" \"x\" \"l\" #>  #> [[10]] #>  [1]  8  7  2  5 10  9  4  3  6  1 #>  #> [[11]] #>  [1] \"y\" \"m\" \"b\" \"w\" \"z\" \"s\" \"c\" \"q\" \"a\" \"i\" \"p\" \"j\" \"o\" \"k\" \"e\" \"x\" \"n\" \"h\" \"v\" #> [20] \"d\" \"l\" \"g\" \"f\" \"t\" \"r\" \"u\" #>  #> [[12]] #>  [1]  4 10  3  6  5  7  9  8  2  1 #>  #> [[13]] #>  [1] \"n\" \"t\" \"u\" \"f\" \"g\" \"v\" \"w\" \"e\" \"l\" \"h\" \"k\" \"p\" \"b\" \"j\" \"o\" \"q\" \"z\" \"y\" \"i\" #> [20] \"a\" \"s\" \"r\" \"d\" \"m\" \"x\" \"c\" #>  #> [[14]] #>  [1]  1 10  9  4  2  3  6  5  7  8 #>  #> [[15]] #>  [1] \"j\" \"i\" \"v\" \"n\" \"c\" \"l\" \"z\" \"t\" \"b\" \"s\" \"g\" \"p\" \"d\" \"u\" \"m\" \"o\" \"q\" \"r\" \"a\" #> [20] \"y\" \"w\" \"e\" \"k\" \"f\" \"x\" \"h\" #>  #> [[16]] #>  [1]  1 10  9  4  8  6  2  3  7  5 #>  #> [[17]] #>  [1] \"i\" \"l\" \"m\" \"n\" \"e\" \"h\" \"f\" \"a\" \"j\" \"c\" \"b\" \"g\" \"w\" \"r\" \"x\" \"p\" \"v\" \"t\" \"o\" #> [20] \"k\" \"y\" \"q\" \"d\" \"z\" \"u\" \"s\" #>  #> [[18]] #>  [1] 10  7  3  5  1  6  9  8  2  4 #>  #> [[19]] #>  [1] \"r\" \"s\" \"j\" \"m\" \"q\" \"n\" \"w\" \"k\" \"x\" \"e\" \"p\" \"v\" \"y\" \"g\" \"t\" \"h\" \"o\" \"f\" \"b\" #> [20] \"d\" \"l\" \"z\" \"a\" \"i\" \"c\" \"u\" #>  #> [[20]] #>  [1]  9  4  3  6  7  2  8 10  5  1 #>"},{"path":"https://tony-aw.github.io/squarebrackets/reference/match_all.html","id":null,"dir":"Reference","previous_headings":"","what":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","title":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","text":"Find indices vector haystack equal vector needles, taking account order vectors, duplicate values.  essentially much efficient version :   Like lapply(needles, \\() (haystack == )), NAs ignored.  Core code based suggestion Sebastian Kranz (author 'collapse' package).","code":"lapply(needles, \\(i) which(haystack == i))"},{"path":"https://tony-aw.github.io/squarebrackets/reference/match_all.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","text":"","code":"match_all(needles, haystack, unlist = TRUE)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/match_all.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","text":"needles, haystack vectors unlist Boolean, indicating result vector (TRUE, default), list (FALSE).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/match_all.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","text":"integer vector, list integer vector. list, element list corresponds value needles. needles /haystack /empty fully NA, match_all() returns empty integer vector (unlist = TRUe), empty list (unlist = FALSE).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/match_all.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Match All, Order-Sensitive and Duplicates-Sensitive — match_all","text":"","code":"n <- 200 haystack <- sample(letters, n, TRUE) needles <- sample(letters, n/2, TRUE) indices1 <- match_all(needles, haystack) head(indices1) #> [1]   8  14  40  64 132 136"},{"path":"https://tony-aw.github.io/squarebrackets/reference/ma_setv.html","id":null,"dir":"Reference","previous_headings":"","what":"Find and Replace Present Values in mutable_atomic Objects By Reference — ma_setv","title":"Find and Replace Present Values in mutable_atomic Objects By Reference — ma_setv","text":"ma_setv(x, v rp) function performs equivalent x[(x == v)] <- rp  using pass--reference semantics.  faster using sb_set(x, = (x == v), rp = rp).  Inspired collapse::setv, written 'C++' 'Rcpp', additional safety checks.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/ma_setv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find and Replace Present Values in mutable_atomic Objects By Reference — ma_setv","text":"","code":"ma_setv(x, v, rp, invert = FALSE, NA.safety = TRUE)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/ma_setv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find and Replace Present Values in mutable_atomic Objects By Reference — ma_setv","text":"x mutable_atomic variable. v non-missing (NA NaN) atomic scalar find. rp atomic scalar giving replacement value. invert Boolean.  FALSE (default), equivalent x[(x == v()] <- rp performed;  TRUE, equivalent x[(x != v)] <- rp performed instead. NA.safety Boolean.  just like , NA NaN results x==v ignored, thus NA.safety TRUE default.  However, known x contains NAs NaNs, setting NA.safety FALSE increase performance bit.  NOTE: Setting NA.safety = FALSE x contain NAs NaNs, may result unexpected behaviour.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/ma_setv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find and Replace Present Values in mutable_atomic Objects By Reference — ma_setv","text":"Returns: VOID. function modifies object reference. use assignment like x <- ma_setv(x, ...). Since function returns void, just get NULL.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/ma_setv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find and Replace Present Values in mutable_atomic Objects By Reference — ma_setv","text":"","code":"x <- mutable_atomic(c(1:20, NA, NaN)) print(x) #>  [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19 #> [20]  20  NA NaN #> mutable_atomic  #> typeof:  double  ma_setv(x, 2, 100) print(x) #>  [1]   1 100   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19 #> [20]  20  NA NaN #> mutable_atomic  #> typeof:  double"},{"path":"https://tony-aw.github.io/squarebrackets/reference/nest.html","id":null,"dir":"Reference","previous_headings":"","what":"Nest — n","title":"Nest — n","text":"c() function concatenates vectors lists vector (possible) else list.  analogy function, n() function nests objects list (atomic vector, atomic vectors nested).  short-hand version list function.  handy lists often needed 'squarebrackets', especially arrays.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/nest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nest — n","text":"","code":"n()"},{"path":"https://tony-aw.github.io/squarebrackets/reference/nest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nest — n","text":"list.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/nest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Nest — n","text":"","code":"obj <- array(1:64, c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  sb_x(obj, n(1:3, 1:2), c(1,3)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #>  # above is equivalent to obj[1:3, , 1:2, drop = FALSE]"},{"path":"https://tony-aw.github.io/squarebrackets/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. data.table address, copy, first, last","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb2_rec.html","id":null,"dir":"Reference","previous_headings":"","what":"Access, Replace, Transform, Remove, and Extend Recursive Subsets — sb2_rec","title":"Access, Replace, Transform, Remove, and Extend Recursive Subsets — sb2_rec","text":"sb2_rec() sb2_reccom() methods essentially convenient wrappers around [[ [[<-, respectively. sb2_rec() access recursive subsets lists. sb2_reccom() can following things: replace transform recursive subsets list, using R's default Copy--Modify semantics, specifying rp tf argument, respectively. remove recursive subset list, using R's default Copy--Modify semantics, specifying argument rp = NULL. extending list additional recursive elements, using R's default Copy--Modify semantics.  done specifying --bounds index argument rec, entering new values argument rp.  Note adding surface level elements dimensional list remove dimension attributes list.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb2_rec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Access, Replace, Transform, Remove, and Extend Recursive Subsets — sb2_rec","text":"","code":"sb2_rec(x, rec)  sb2_reccom(x, rec, rp, tf)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb2_rec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Access, Replace, Transform, Remove, and Extend Recursive Subsets — sb2_rec","text":"x list, list-like object. rec integer (including negative integers) character vector length p, x[[rec]] equivalent x[[ rec[1] ]]...[[ rec[p] ]], providing final indexing results list.  certain subset level nested list, multiple subsets name exist, first one selected performing recursive indexing name, due recursive nature type subsetting. rp optional, allows multiple functionalities: simplest case, performs x[[rec]] <- rp, using R's default semantics.  Since replacement recursive subset, rp necessarily list ; rp can type object. specifying rp = NULL, remove (recursive) subset x[[rec]].  specify actual NULL instead removing subset, use list(NULL). rec integer, specifies --bounds subset, sb2_reccom() add value rp list.  empty positions filled NA. rec character, specifies non-existing name, sb2_reccom() add value rp list new element end. tf optional function. specified, performs x[[rec]] <- tf(x[[rec]]), using R's default Copy--Modify semantics.  support extending list like argument rp.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb2_rec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Access, Replace, Transform, Remove, and Extend Recursive Subsets — sb2_rec","text":"sb2_rec(): Returns recursive subset.  sb2_reccom(..., rp = rp): Returns VOID, replaces, adds, removes specified recursive subset, using R's default Copy--Modify semantics.  sb2_reccom(..., tf = tf): Returns VOID, transforms specified recursive subset, using R's default Copy--Modify semantics.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb2_rec.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Access, Replace, Transform, Remove, and Extend Recursive Subsets — sb2_rec","text":"Since recursive objects pointers objects, extending list removing element list copy entire list, contrast atomic vectors.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb2_rec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Access, Replace, Transform, Remove, and Extend Recursive Subsets — sb2_rec","text":"","code":"lst <- list(   A = list(     A = list(A = \"AAA\", B = \"AAB\"),     A = list(A  = \"AA2A\", B = \"AA2B\"),     B = list(A = \"ABA\", B = \"ABB\")   ),   B = list(     A = list(A = \"BAA\", B = \"BAB\"),     B = list(A = \"BBA\", B = \"BBB\")   ) )  #############################################################################  # access recursive subsets ====  sb2_rec(lst, c(1,2,2)) # this gives \"AA2B\" #> [1] \"AA2B\" sb2_rec(lst, c(\"A\", \"B\", \"B\")) # this gives \"ABB\" #> [1] \"ABB\" sb2_rec(lst, c(2,2,1)) # this gives \"BBA\" #> [1] \"BBA\" sb2_rec(lst, c(\"B\", \"B\", \"A\")) # this gives \"BBA\" #> [1] \"BBA\"   #############################################################################  # replace recursive subset with R's default in-place semantics ====  # replace \"AAB\" using R's default in-place semantics: sb2_reccom(   lst, c(\"A\", \"A\", \"B\"),   rp = \"THIS IS REPLACED WITH IN-PLACE SEMANTICS\" ) print(lst) #> $A #> $A$A #> $A$A$A #> [1] \"AAA\" #>  #> $A$A$B #> [1] \"THIS IS REPLACED WITH IN-PLACE SEMANTICS\" #>  #>  #> $A$A #> $A$A$A #> [1] \"AA2A\" #>  #> $A$A$B #> [1] \"AA2B\" #>  #>  #> $A$B #> $A$B$A #> [1] \"ABA\" #>  #> $A$B$B #> [1] \"ABB\" #>  #>  #>  #> $B #> $B$A #> $B$A$A #> [1] \"BAA\" #>  #> $B$A$B #> [1] \"BAB\" #>  #>  #> $B$B #> $B$B$A #> [1] \"BBA\" #>  #> $B$B$B #> [1] \"BBB\" #>  #>  #>     #############################################################################  # replace shallow subsets with R's default in-place semantics ====  for(i in c(\"A\", \"B\")) sb2_reccom(lst, i, rp = \"AND THEN THERE WERE NONE\")  print(lst) #> $A #> [1] \"AND THEN THERE WERE NONE\" #>  #> $B #> [1] \"AND THEN THERE WERE NONE\" #>    #############################################################################  # Modify View of List By Reference ====  x <- list(  a = data.table::data.table(cola = 1:10, colb = letters[1:10]),  b = data.table::data.table(cola = 11:20, colb = letters[11:20]) ) print(x) #> $a #>      cola   colb #>     <int> <char> #>  1:     1      a #>  2:     2      b #>  3:     3      c #>  4:     4      d #>  5:     5      e #>  6:     6      f #>  7:     7      g #>  8:     8      h #>  9:     9      i #> 10:    10      j #>  #> $b #>      cola   colb #>     <int> <char> #>  1:    11      k #>  2:    12      l #>  3:    13      m #>  4:    14      n #>  5:    15      o #>  6:    16      p #>  7:    17      q #>  8:    18      r #>  9:    19      s #> 10:    20      t #>  mypointer <- sb2_rec(x, \"a\") address(mypointer) == address(x$a) # they are the same #> [1] TRUE sb2_set(mypointer, col = \"cola\", tf = \\(x)x^2) print(x) # notice x has been changed #> $a #>      cola   colb #>     <num> <char> #>  1:     1      a #>  2:     4      b #>  3:     9      c #>  4:    16      d #>  5:    25      e #>  6:    36      f #>  7:    49      g #>  8:    64      h #>  9:    81      i #> 10:   100      j #>  #> $b #>      cola   colb #>     <int> <char> #>  1:    11      k #>  2:    12      l #>  3:    13      m #>  4:    14      n #>  5:    15      o #>  6:    16      p #>  7:    17      q #>  8:    18      r #>  9:    19      s #> 10:    20      t #>"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":null,"dir":"Reference","previous_headings":"","what":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"S3 Method return copy object modified subsets.  Use sb_mod(x, ...) x non-recursive object (.e. atomic factor).  Use sb2_mod(x, ...) x recursive object (.e. list data.frame-like).  modifying subsets using R's default copy--modification semantics, see idx.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"","code":"sb_mod(x, ...)  # S3 method for default sb_mod(   x,   i,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # S3 method for matrix sb_mod(   x,   row = NULL,   col = NULL,   i = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # S3 method for array sb_mod(   x,   idx = NULL,   dims = NULL,   rcl = NULL,   i = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # S3 method for factor sb_mod(   x,   i = NULL,   lvl = NULL,   inv = FALSE,   ...,   rp,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  sb2_mod(x, ...)  # S3 method for default sb2_mod(   x,   i,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE),   .lapply = lapply )  # S3 method for array sb2_mod(   x,   idx = NULL,   dims = NULL,   i = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE),   .lapply = lapply )  # S3 method for data.frame sb2_mod(   x,   row = NULL,   col = NULL,   filter = NULL,   vars = NULL,   inv = FALSE,   coe = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE),   .lapply = lapply )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"x see squarebrackets_immutable_classes squarebrackets_mutable_classes. ... arguments passed methods. , lvl, row, col, idx, dims, rcl, filter, vars, inv See squarebrackets_indx_args.  empty index selection returns original object unchanged. rp object somewhat type selected subset x, length selected subset x length 1.  remove recursive subsets recursive objects, see either sb2_rec sb2_rm. tf transformation function. chkdup see squarebrackets_options. .lapply generic methods use lapply list- data.frame-like objects compute tf() every list element dataset column.  user may supply custom lapply()-like function argument use instead.  example, perform parallel transformation, user may supply future.apply::future_lapply.  supplied function must use exact argument convention lapply, otherwise errors unexpected behaviour may occur. coe Either FALSE (default), TRUE, function.  argument coe ignored row filter arguments set NULL.  See Details section info.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"copy object replaced/transformed values.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"Transform Replace  Specifying argument tf transform subset.  Specifying rp replace subset.  One specify tf rp. either one set .  Note tf argument available factors: intentional. Argument coe  data.frame-like objects, sb_mod() can auto-coerce whole columns, subsets columns.  automatically coerce column types row filter also specified.  coe arguments provides 2 ways circumvent : user can supply coercion function argument coe.  function applied entirety every column specified col vars; columns outside subset affected.  coercion function , course, applied replacement (rp) transformation (tf()). user can set coe = TRUE.  case, whole columns specified col vars extracted copied list.  Subsets list element, corresponding selected rows, modified rp tf(), using R's regular auto-coercion rules.  modified list returned data.frame-like object, replacing original columns. Note coercion required additional memory.  larger data.frame-like object, larger memory.  default, coe = FALSE, uses least amount memory.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_mod.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"","code":"# atomic objects ====  obj <- matrix(1:16, ncol = 4) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 rp <- -1:-9 sb_mod(obj, 1:3, 1:3, rp = rp) #>       a  b  c  a #> [1,] -1 -4 -7 13 #> [2,] -2 -5 -8 14 #> [3,] -3 -6 -9 15 #> [4,]  4  8 12 16 # above is equivalent to  obj[1:3, 1:3] <- -1:-9; obj sb_mod(obj, i = \\(x)x<=5, rp = -1:-5) #>       a  b  c  a #> [1,] -1 -5  9 13 #> [2,] -2  6 10 14 #> [3,] -3  7 11 15 #> [4,] -4  8 12 16 # above is equivalent to  obj[obj <= 5] <- -1:-5; obj sb_mod(obj, col = \"a\", rp = -1:-8) #>       a b  c  a #> [1,] -1 5  9 -5 #> [2,] -2 6 10 -6 #> [3,] -3 7 11 -7 #> [4,] -4 8 12 -8 # above is equivalent to  obj[, which(colnames(obj) %in% \"a\")] <- -1:-8; obj sb_mod(obj, 1:3, 1:3, tf = \\(x) -x) #>       a  b   c  a #> [1,] -1 -5  -9 13 #> [2,] -2 -6 -10 14 #> [3,] -3 -7 -11 15 #> [4,]  4  8  12 16 # above is equivalent to  obj[1:3, 1:3] <- (-1 * obj[1:3, 1:3]); obj sb_mod(obj, i = \\(x)x<=5, tf = \\(x) -x) #>       a  b  c  a #> [1,] -1 -5  9 13 #> [2,] -2  6 10 14 #> [3,] -3  7 11 15 #> [4,] -4  8 12 16 # above is equivalent to  obj[obj <= 5] <- (-1 * obj[obj <= 5]); obj  obj <- matrix(1:16, ncol = 4) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 sb_mod(obj, 1:3, 1:3, tf = \\(x) -x) #>       a  b   c  a #> [1,] -1 -5  -9 13 #> [2,] -2 -6 -10 14 #> [3,] -3 -7 -11 15 #> [4,]  4  8  12 16 # above is equivalent to  obj[1:3, 1:3] <- -1 * obj[1:3, 1:3] sb_mod(obj, i = \\(x)x<=5, tf = \\(x) -x) #>       a  b  c  a #> [1,] -1 -5  9 13 #> [2,] -2  6 10 14 #> [3,] -3  7 11 15 #> [4,] -4  8 12 16 # above is equivalent to  obj[obj <= 5] <- -1:-5; obj sb_mod(obj, col = \"a\", tf = \\(x) -x) #>       a b  c   a #> [1,] -1 5  9 -13 #> [2,] -2 6 10 -14 #> [3,] -3 7 11 -15 #> [4,] -4 8 12 -16 # above is equivalent to  obj[, which(colnames(obj) %in% \"a\")] <- -1:-8; obj  obj <- array(1:64, c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  sb_mod(obj, list(1:3, 1:2), c(1,3), rp = -1:-24) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   -1   -4   -7  -10 #> [2,]   -2   -5   -8  -11 #> [3,]   -3   -6   -9  -12 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]  -13  -16  -19  -22 #> [2,]  -14  -17  -20  -23 #> [3,]  -15  -18  -21  -24 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  # above is equivalent to obj[1:3, , 1:2] <- -1:-24 sb_mod(obj, i = \\(x)x<=5, rp = -1:-5) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   -1   -5    9   13 #> [2,]   -2    6   10   14 #> [3,]   -3    7   11   15 #> [4,]   -4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  # above is equivalent to obj[obj <= 5] <- -1:-5  #############################################################################   # lists ====  obj <- list(a = 1:10, b = letters[1:11], c = 11:20) print(obj) #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  sb2_mod(obj, \"a\", rp = list(1L)) #> $a #> [1] 1 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  # above is equivalent to  obj[[\"a\"]] <- 1L; obj sb2_mod(obj, is.numeric, rp = list(-1:-10, -11:-20)) #> $a #>  [1]  -1  -2  -3  -4  -5  -6  -7  -8  -9 -10 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] -11 -12 -13 -14 -15 -16 -17 -18 -19 -20 #>  # above is equivalent to  obj[which(sapply(obj, is.numeric))] <- list(-1:-10, -11:-20); obj  #############################################################################   # recursive arrays / dimensional lists ==== obj <- c(as.list(1:10), as.list(letters[1:10])) |> array(dim = c(5, 4)) |> t() print(obj) #>      [,1] [,2] [,3] [,4] [,5] #> [1,] 1    2    3    4    5    #> [2,] 6    7    8    9    10   #> [3,] \"a\"  \"b\"  \"c\"  \"d\"  \"e\"  #> [4,] \"f\"  \"g\"  \"h\"  \"i\"  \"j\"  sb2_mod(obj, list(1:3), 1, rp = list(FALSE)) #>      [,1]  [,2]  [,3]  [,4]  [,5]  #> [1,] FALSE FALSE FALSE FALSE FALSE #> [2,] FALSE FALSE FALSE FALSE FALSE #> [3,] FALSE FALSE FALSE FALSE FALSE #> [4,] \"f\"   \"g\"   \"h\"   \"i\"   \"j\"   # above is equivalent to obj[1:3, ] <- list(FALSE)   #############################################################################  # data.frame-like objects  - whole columns ====  obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 sb2_mod(   obj, vars = is.numeric,   tf = sqrt # SAFE: row=NULL & filter = NULL, so coercion performed ) #>           a b        c d #> 1  1.000000 a 3.316625 a #> 2  1.414214 b 3.464102 b #> 3  1.732051 c 3.605551 c #> 4  2.000000 d 3.741657 d #> 5  2.236068 e 3.872983 e #> 6  2.449490 f 4.000000 f #> 7  2.645751 g 4.123106 g #> 8  2.828427 h 4.242641 h #> 9  3.000000 i 4.358899 i #> 10 3.162278 j 4.472136 j  #############################################################################  # data.frame-like objects  - partial columns ====  obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10  sb2_mod(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost )  #> Warning: 1.414214 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 1 named 'a') #> Warning: 3.464102 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 3 named 'c') #>     a b  c d #> 1   1 a 11 a #> 2   1 b  3 b #> 3   1 c  3 c #> 4   2 d  3 d #> 5   2 e  3 e #> 6   2 f  4 f #> 7   2 g  4 g #> 8   8 h 18 h #> 9   9 i 19 i #> 10 10 j 20 j sb2_mod(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   coe = as.double, tf = sqrt # SAFE: coercion performed )  #>            a b         c d #> 1   1.000000 a 11.000000 a #> 2   1.414214 b  3.464102 b #> 3   1.732051 c  3.605551 c #> 4   2.000000 d  3.741657 d #> 5   2.236068 e  3.872983 e #> 6   2.449490 f  4.000000 f #> 7   2.645751 g  4.123106 g #> 8   8.000000 h 18.000000 h #> 9   9.000000 i 19.000000 i #> 10 10.000000 j 20.000000 j sb2_mod(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   coe = TRUE, tf = sqrt # SAFE: coercion performed )  #>            a b         c d #> 1   1.000000 a 11.000000 a #> 2   1.414214 b  3.464102 b #> 3   1.732051 c  3.605551 c #> 4   2.000000 d  3.741657 d #> 5   2.236068 e  3.872983 e #> 6   2.449490 f  4.000000 f #> 7   2.645751 g  4.123106 g #> 8   8.000000 h 18.000000 h #> 9   9.000000 i 19.000000 i #> 10 10.000000 j 20.000000 j"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_rm.html","id":null,"dir":"Reference","previous_headings":"","what":"Method to Un-Select/Remove Subsets of an Object — sb_rm","title":"Method to Un-Select/Remove Subsets of an Object — sb_rm","text":"S3 Method un-select/remove subsets object.  Use sb_rm(x, ...) x non-recursive object (.e. atomic factor).  Use sb2_rm(x, ...) x recursive object (.e. list data.frame-like).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_rm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method to Un-Select/Remove Subsets of an Object — sb_rm","text":"","code":"sb_rm(x, ...)  # S3 method for default sb_rm(   x,   i,   ...,   rat = getOption(\"squarebrackets.rat\", FALSE),   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # S3 method for matrix sb_rm(   x,   row = NULL,   col = NULL,   i = NULL,   ...,   rat = getOption(\"squarebrackets.rat\", FALSE),   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # S3 method for array sb_rm(   x,   idx = NULL,   dims = NULL,   rcl = NULL,   i = NULL,   ...,   rat = getOption(\"squarebrackets.rat\", FALSE),   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # S3 method for factor sb_rm(   x,   i = NULL,   lvl = NULL,   drop = FALSE,   ...,   rat = getOption(\"squarebrackets.rat\", FALSE),   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  sb2_rm(x, ...)  # S3 method for default sb2_rm(   x,   i,   drop = FALSE,   ...,   rat = getOption(\"squarebrackets.rat\", FALSE),   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # S3 method for array sb2_rm(   x,   idx = NULL,   dims = NULL,   i = NULL,   drop = FALSE,   ...,   rat = getOption(\"squarebrackets.rat\", FALSE),   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # S3 method for data.frame sb2_rm(   x,   row = NULL,   col = NULL,   filter = NULL,   vars = NULL,   ...,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_rm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method to Un-Select/Remove Subsets of an Object — sb_rm","text":"x see squarebrackets_immutable_classes squarebrackets_mutable_classes. ... arguments passed methods. , lvl, row, col, idx, dims, rcl, filter, vars See squarebrackets_indx_args.  empty index selection results nothing removed, entire object returned. rat, chkdup see squarebrackets_options. drop Boolean. factors: drop = TRUE, unused levels dropped, drop = FALSE dropped. lists: drop = TRUE, sub-setting done using argument , selecting single element give simplified result, like using [[]]. drop = FALSE, list always returned regardless number elements.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_rm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Method to Un-Select/Remove Subsets of an Object — sb_rm","text":"copy sub-setted object.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_rm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Method to Un-Select/Remove Subsets of an Object — sb_rm","text":"","code":"# atomic objects ====  obj <- matrix(1:16, ncol = 4) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 sb_rm(obj, 1:3, 1:3) #>       a #> [1,] 16 # above is equivalent to  obj[-1:-3, -1:-3, drop = FALSE] sb_rm(obj, i = \\(x)x>5) #> [1] 1 2 3 4 5 # above is equivalent to  obj[!obj > 5] sb_rm(obj, col = \"a\") #>      b  c #> [1,] 5  9 #> [2,] 6 10 #> [3,] 7 11 #> [4,] 8 12 # above is equivalent to  obj[, which(!colnames(obj) %in% \"a\")]  obj <- array(1:64, c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  sb_rm(obj, n(1, c(1, 3)), c(1, 3)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   18   22   26   30 #> [2,]   19   23   27   31 #> [3,]   20   24   28   32 #>  sb_rm(obj, rcl = n(1, NULL, c(1, 3))) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   18   22   26   30 #> [2,]   19   23   27   31 #> [3,]   20   24   28   32 #>  # above 2 lines are equivalent to obj[-1, c(-1, -3), drop = FALSE] sb_rm(obj, i = \\(x)x>5) #> [1] 1 2 3 4 5 # above is equivalent to obj[!obj > 5]  #############################################################################   # factors ====  obj <- factor(rep(letters[1:5], 2)) sb_rm(obj, lvl = \"a\") #> [1] b c d e b c d e #> Levels: a b c d e # above is equivalent to obj[which(!obj %in% \"a\")]   #############################################################################   # lists ====  obj <- list(a = 1:10, b = letters[1:11], c = 11:20) print(obj) #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  sb2_rm(obj, \"a\") #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  # above is equivalent to obj[which(!names(obj) %in% \"a\")] sb2_rm(obj, 1) # obj[-1] #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  sb2_rm(obj, 1:2) #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  # above is equivalent to obj[seq_len(length(obj))[-1:-2]] sb2_rm(obj, is.numeric, drop = TRUE) #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" # above is equivalent to obj[[!sapply(obj, is.numeric)]] IF this returns a single element obj <- list(a = 1:10, b = letters[1:11], c = letters) sb2_rm(obj, is.numeric) #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" #> [20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\" #>  # above is equivalent to obj[!sapply(obj, is.numeric)] # this time singular brackets? # for recusive indexing, see sb2_rec()   #############################################################################   # recursive arrays / dimensional lists ==== obj <- c(as.list(1:10), as.list(letters[1:10])) |> array(dim = c(5, 4)) |> t() print(obj) #>      [,1] [,2] [,3] [,4] [,5] #> [1,] 1    2    3    4    5    #> [2,] 6    7    8    9    10   #> [3,] \"a\"  \"b\"  \"c\"  \"d\"  \"e\"  #> [4,] \"f\"  \"g\"  \"h\"  \"i\"  \"j\"  sb2_rm(obj, list(1:3), 1) #>      [,1] [,2] [,3] [,4] [,5] #> [1,] \"f\"  \"g\"  \"h\"  \"i\"  \"j\"  # above is equivalent to obj[-1:-3, ]   #############################################################################  # data.frame-like objects ====  obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) print(obj) #>     a b  c d #> 1   1 a 11 a #> 2   2 b 12 b #> 3   3 c 13 c #> 4   4 d 14 d #> 5   5 e 15 e #> 6   6 f 16 f #> 7   7 g 17 g #> 8   8 h 18 h #> 9   9 i 19 i #> 10 10 j 20 j sb2_rm(obj, 1:3, 1:3) #>   d #> 1 d #> 2 e #> 3 f #> 4 g #> 5 h #> 6 i #> 7 j # above is equivalent to obj[-1:-3, -1:-3, drop = FALSE] sb2_rm(obj, filter = ~ (a > 5) & (c < 19), vars = is.numeric) #>   b d #> 1 a a #> 2 b b #> 3 c c #> 4 d d #> 5 e e #> 6 i i #> 7 j j"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":null,"dir":"Reference","previous_headings":"","what":"Method to Modify Subsets of a Mutable Object By Reference — sb_set","title":"Method to Modify Subsets of a Mutable Object By Reference — sb_set","text":"S3 Method replace transform subset supported mutable object using pass--reference semantics  Use sb_set(x, ...) x non-recursive object (.e. mutable_atomic).  Use sb2_set(x, ...) x recursive object (.e. data.table).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method to Modify Subsets of a Mutable Object By Reference — sb_set","text":"","code":"sb_set(x, ...)  # S3 method for default sb_set(   x,   i,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # S3 method for matrix sb_set(   x,   row = NULL,   col = NULL,   i = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  # S3 method for array sb_set(   x,   idx = NULL,   dims = NULL,   rcl = NULL,   i = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE) )  sb2_set(x, ...)  # S3 method for default sb2_set(x, ...)  # S3 method for data.table sb2_set(   x,   row = NULL,   col = NULL,   filter = NULL,   vars = NULL,   inv = FALSE,   ...,   rp,   tf,   chkdup = getOption(\"squarebrackets.chkdup\", FALSE),   .lapply = lapply )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method to Modify Subsets of a Mutable Object By Reference — sb_set","text":"x variable belonging one supported mutable classes. ... arguments passed methods. , row, col, idx, dims, rcl, filter, vars, inv See squarebrackets_indx_args.  empty index selection leaves original object unchanged. rp object somewhat type selected subset x, length selected subset x length 1.  remove recursive subsets recursive objects, see either sb2_rec sb2_rm. tf transformation function. chkdup see squarebrackets_options. .lapply generic methods use lapply list- data.frame-like objects compute tf() every list element dataset column.  user may supply custom lapply()-like function argument use instead.  example, perform parallel transformation, user may supply future.apply::future_lapply.  supplied function must use exact argument convention lapply, otherwise errors unexpected behaviour may occur.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Method to Modify Subsets of a Mutable Object By Reference — sb_set","text":"Returns: VOID. method modifies object reference. use assignments like x <- sb_set(x, ...). Since function returns void, just get NULL.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Method to Modify Subsets of a Mutable Object By Reference — sb_set","text":"Transform Replace  Specifying argument tf transform subset. Specifying rp replace subset. One specify tf rp. either one set .  Note sb_set() method factors: intentional.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_set.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Method to Modify Subsets of a Mutable Object By Reference — sb_set","text":"","code":"# mutable_atomic objects ====  gen_mat <- function() {   obj <- as.mutable_atomic(matrix(1:16, ncol = 4))   colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\")   return(obj) }  obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutable_atomic  #> typeof:  integer  sb_set(obj, 1:3, 1:3, rp = -1:-9) obj2 #>       a  b  c  a #> [1,] -1 -4 -7 13 #> [2,] -2 -5 -8 14 #> [3,] -3 -6 -9 15 #> [4,]  4  8 12 16 #> mutable_atomic  #> typeof:  integer  obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutable_atomic  #> typeof:  integer  sb_set(obj, i = \\(x)x<=5, rp = -1:-5) obj2 #>       a  b  c  a #> [1,] -1 -5  9 13 #> [2,] -2  6 10 14 #> [3,] -3  7 11 15 #> [4,] -4  8 12 16 #> mutable_atomic  #> typeof:  integer  obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutable_atomic  #> typeof:  integer  sb_set(obj, col = \"a\", rp = cbind(-1:-4, -5:-8)) obj2 #>       a b  c  a #> [1,] -1 5  9 -5 #> [2,] -2 6 10 -6 #> [3,] -3 7 11 -7 #> [4,] -4 8 12 -8 #> mutable_atomic  #> typeof:  integer   obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutable_atomic  #> typeof:  integer  sb_set(obj, 1:3, 1:3, tf = \\(x) -x) obj2 #>       a  b   c  a #> [1,] -1 -5  -9 13 #> [2,] -2 -6 -10 14 #> [3,] -3 -7 -11 15 #> [4,]  4  8  12 16 #> mutable_atomic  #> typeof:  integer  obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutable_atomic  #> typeof:  integer  sb_set(obj, i = \\(x)x<=5, tf = \\(x) -x) obj2 #>       a  b  c  a #> [1,] -1 -5  9 13 #> [2,] -2  6 10 14 #> [3,] -3  7 11 15 #> [4,] -4  8 12 16 #> mutable_atomic  #> typeof:  integer  obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 #> mutable_atomic  #> typeof:  integer  sb_set(obj, col = \"a\", tf = \\(x) -x) obj2 #>       a b  c   a #> [1,] -1 5  9 -13 #> [2,] -2 6 10 -14 #> [3,] -3 7 11 -15 #> [4,] -4 8 12 -16 #> mutable_atomic  #> typeof:  integer    gen_array <- function() {   as.mutable_atomic(array(1:64, c(4,4,3))) } obj <- gen_array() obj #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  #> mutable_atomic  #> typeof:  integer  sb_set(obj, list(1:3, 1:2, c(1, 3)), 1:3, rp = -1:-12) obj #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   -1   -4    9   13 #> [2,]   -2   -5   10   14 #> [3,]   -3   -6   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   -7  -10   41   45 #> [2,]   -8  -11   42   46 #> [3,]   -9  -12   43   47 #> [4,]   36   40   44   48 #>  #> mutable_atomic  #> typeof:  integer  obj <- gen_array() obj #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  #> mutable_atomic  #> typeof:  integer  sb_set(obj, i = \\(x)x<=5, rp = -1:-5) obj #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   -1   -5    9   13 #> [2,]   -2    6   10   14 #> [3,]   -3    7   11   15 #> [4,]   -4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  #> mutable_atomic  #> typeof:  integer    #############################################################################  # data.table ====  obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb2_set(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost ) #> Warning: 1.414214 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 1 named 'a') #> Warning: 3.464102 (type 'double') at RHS position 1 out-of-range(NA) or truncated (precision lost) when assigning to type 'integer' (column 3 named 'c') print(obj) #>         a      b     c      d #>     <int> <char> <int> <fctr> #>  1:     1      a    11      a #>  2:     1      b     3      b #>  3:     1      c     3      c #>  4:     2      d     3      d #>  5:     2      e     3      e #>  6:     2      f     4      f #>  7:     2      g     4      g #>  8:     8      h    18      h #>  9:     9      i    19      i #> 10:    10      j    20      j  obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) dt_setcoe(obj, vars = is.numeric, v = as.numeric) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb2_set(obj,   filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # SAFE: coercion performed by dt_setcoe(); so no warnings )  print(obj) #>             a      b         c      d #>         <num> <char>     <num> <fctr> #>  1:  1.000000      a 11.000000      a #>  2:  1.414214      b  3.464102      b #>  3:  1.732051      c  3.605551      c #>  4:  2.000000      d  3.741657      d #>  5:  2.236068      e  3.872983      e #>  6:  2.449490      f  4.000000      f #>  7:  2.645751      g  4.123106      g #>  8:  8.000000      h 18.000000      h #>  9:  9.000000      i 19.000000      i #> 10: 10.000000      j 20.000000      j  obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb2_set(   obj, vars = is.numeric,   tf = sqrt # SAFE: row=NULL & filter = NULL, so coercion performed ) str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 1.41 1.73 2 2.24 ... #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  3.32 3.46 3.61 3.74 3.87 ... #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_setRename.html","id":null,"dir":"Reference","previous_headings":"","what":"Method to Change the Names of a Mutable Object By Reference — sb_setRename","title":"Method to Change the Names of a Mutable Object By Reference — sb_setRename","text":"S3 Method rename supported mutable object using pass--reference semantics.  method takes extra care modify objects happen share address (dim)names x.  .e. following code:   modify base::letters, even though names(x) shared address.  Thus, sb_setRename() can used safely without fearing accidents.  Use sb_setRename(x, ...) x non-recursive object (.e. mutable_atomic).  Use sb2_setRename(x, ...) x recursive object (.e. data.table).","code":"x <- mutable_atomic(1:26) names(x) <- base::letters y <- x sb_setRename(x, newnames = rev(names(x)))"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_setRename.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method to Change the Names of a Mutable Object By Reference — sb_setRename","text":"","code":"sb_setRename(x, ...)  # S3 method for default sb_setRename(x, newnames, ...)  # S3 method for array sb_setRename(x, newdimnames, newnames, ...)  sb2_setRename(x, ...)  # S3 method for data.table sb2_setRename(x, old, new, skip_absent = FALSE, ...)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_setRename.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method to Change the Names of a Mutable Object By Reference — sb_setRename","text":"x variable belonging one supported mutable classes. ... arguments passed methods. newnames atomic character vector giving new names.  Specifying NULL remove names. newdimnames list length dim(x).  first element list corresponds first dimension (.e. rows), second element second dimension (.e. columns), .  components list can either NULL, character vector length corresponding dimension.  Instead list, simply NULL can specified, remove dimnames completely. old old column names new new column names, order old skip_absent Skip items old missing (.e. absent) names(x).  Default FALSE halts error missing.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_setRename.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Method to Change the Names of a Mutable Object By Reference — sb_setRename","text":"Returns: VOID. method modifies object reference. use assignment like names(x) <- sb_setRename(x, ...). Since function returns void, just get NULL.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_setRename.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Method to Change the Names of a Mutable Object By Reference — sb_setRename","text":"","code":"# mutable atomic vector ==== x <- y <- mutable_atomic(1:10, names = letters[1:10]) sb_setRename(x, rev(letters[1:10])) print(x) #>  j  i  h  g  f  e  d  c  b  a  #>  1  2  3  4  5  6  7  8  9 10  #> mutable_atomic  #> typeof:  integer   ################################################################################   # mutable atomic matrix ==== x <- mutable_atomic(   1:20, dim = c(5, 4), dimnames = n(letters[1:5], letters[1:4]) ) print(x) #>   a  b  c  d #> a 1  6 11 16 #> b 2  7 12 17 #> c 3  8 13 18 #> d 4  9 14 19 #> e 5 10 15 20 #> mutable_atomic  #> typeof:  integer  sb_setRename(   x,   lapply(dimnames(x), rev) ) print(x) #>   d  c  b  a #> e 1  6 11 16 #> d 2  7 12 17 #> c 3  8 13 18 #> b 4  9 14 19 #> a 5 10 15 20 #> mutable_atomic  #> typeof:  integer    x <- mutable_atomic(    1:20, letters[1:20], dim = c(5, 4), dimnames = n(letters[1:5], letters[1:4]) ) print(x) #>   a  b  c  d #> a 1  6 11 16 #> b 2  7 12 17 #> c 3  8 13 18 #> d 4  9 14 19 #> e 5 10 15 20 #> attr(,\"names\") #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" #> [20] \"t\" #> mutable_atomic  #> typeof:  integer  sb_setRename(   x,   newdimnames = lapply(dimnames(x), rev),   newnames = rev(names(x)) ) print(x) #>   d  c  b  a #> e 1  6 11 16 #> d 2  7 12 17 #> c 3  8 13 18 #> b 4  9 14 19 #> a 5 10 15 20 #> attr(,\"names\") #>  [1] \"t\" \"s\" \"r\" \"q\" \"p\" \"o\" \"n\" \"m\" \"l\" \"k\" \"j\" \"i\" \"h\" \"g\" \"f\" \"e\" \"d\" \"c\" \"b\" #> [20] \"a\" #> mutable_atomic  #> typeof:  integer    ################################################################################    # data.table ====  x <- data.table::data.table(   a = 1:20,   b = letters[1:20] ) print(x) #>         a      b #>     <int> <char> #>  1:     1      a #>  2:     2      b #>  3:     3      c #>  4:     4      d #>  5:     5      e #>  6:     6      f #>  7:     7      g #>  8:     8      h #>  9:     9      i #> 10:    10      j #> 11:    11      k #> 12:    12      l #> 13:    13      m #> 14:    14      n #> 15:    15      o #> 16:    16      p #> 17:    17      q #> 18:    18      r #> 19:    19      s #> 20:    20      t #>         a      b sb2_setRename(x, old = names(x), new = rev(names(x))) print(x) #>         b      a #>     <int> <char> #>  1:     1      a #>  2:     2      b #>  3:     3      c #>  4:     4      d #>  5:     5      e #>  6:     6      f #>  7:     7      g #>  8:     8      h #>  9:     9      i #> 10:    10      j #> 11:    11      k #> 12:    12      l #> 13:    13      m #> 14:    14      n #> 15:    15      o #> 16:    16      p #> 17:    17      q #> 18:    18      r #> 19:    19      s #> 20:    20      t #>         b      a"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_special.html","id":null,"dir":"Reference","previous_headings":"","what":"Specialized Sub-setting Functions — sb_special","title":"Specialized Sub-setting Functions — sb_special","text":"sb_a() function subsets extracts one attributes object.  sb_str() function subsets characters single string, replace subset characters single string subsets characters another string. cases, single string treated iterable vector, single character string single element. sb_str() function considerably faster equivalent operation base 'R' even 'stringi'.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_special.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specialized Sub-setting Functions — sb_special","text":"","code":"sb_str(str, ind, rp.str, rp.ind)  sb_a(x, a = NULL)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_special.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specialized Sub-setting Functions — sb_special","text":"str single string. ind integer vector, giving positions string subset. rp.str, rp.ind similar str ind, respectively.  specified, sb_str() perform something like str[ind]  treating str iterable vector.  specified, sb_str() perform something like str[ind] <- rp.str[rp.ind]  treating str rp.str iterable vectors. x object character vector attribute names. NULL (default), attributes returned.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_special.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Specialized Sub-setting Functions — sb_special","text":"sub-setted object.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_special.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Specialized Sub-setting Functions — sb_special","text":"","code":"x <- matrix(1:10, ncol = 2) colnames(x) <- c(\"a\", \"b\") attr(x, \"test\") <- \"test\" sb_a(x, \"test\") #> $test #> [1] \"test\" #>  sb_a(x) #> $dim #> [1] 5 2 #>  #> $dimnames #> $dimnames[[1]] #> NULL #>  #> $dimnames[[2]] #> [1] \"a\" \"b\" #>  #>  #> $test #> [1] \"test\" #>    x <- \"hello\" sb_str(x, 5:1) # this gives \"olleh\" #> [1] \"olleh\" sb_str(x, c(1:5, 5)) # this gives \"helloo\" #> [1] \"helloo\" sb_str(x, c(2:5)) # this gives \"ello\" #> [1] \"ello\" sb_str(x, seq(1, 5, by = 2)) # this gives \"hlo\" #> [1] \"hlo\" sb_str(x, 1:4, \"world\", 1:4) # this gives \"worlo\" #> [1] \"worlo\""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_x.html","id":null,"dir":"Reference","previous_headings":"","what":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","title":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","text":"S3 Method extract, exchange, duplicate (.e. repeat x times) subsets object.  Use sb_x(x, ...) x non-recursive object (.e. atomic factor).  Use sb2_x(x, ...) x recursive object (.e. list data.frame-like).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_x.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","text":"","code":"sb_x(x, ...)  # S3 method for default sb_x(x, i, ..., rat = getOption(\"squarebrackets.rat\", FALSE))  # S3 method for matrix sb_x(   x,   row = NULL,   col = NULL,   i = NULL,   ...,   rat = getOption(\"squarebrackets.rat\", FALSE) )  # S3 method for array sb_x(   x,   idx = NULL,   dims = NULL,   rcl = NULL,   i = NULL,   ...,   rat = getOption(\"squarebrackets.rat\", FALSE) )  # S3 method for factor sb_x(   x,   i = NULL,   lvl = NULL,   drop = FALSE,   ...,   rat = getOption(\"squarebrackets.rat\", FALSE) )  sb2_x(x, ...)  # S3 method for default sb2_x(x, i, drop = FALSE, ..., rat = getOption(\"squarebrackets.rat\", FALSE))  # S3 method for array sb2_x(   x,   idx = NULL,   dims = NULL,   i = NULL,   drop = FALSE,   ...,   rat = getOption(\"squarebrackets.rat\", FALSE) )  # S3 method for data.frame sb2_x(x, row = NULL, col = NULL, filter = NULL, vars = NULL, ...)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_x.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","text":"x see squarebrackets_immutable_classes squarebrackets_mutable_classes. ... arguments passed methods. , lvl, row, col, idx, dims, rcl, filter, vars See squarebrackets_indx_args.  Duplicates allowed, resulting duplicated indices.  empty index selection results empty object length 0. rat see squarebrackets_options. drop Boolean. factors: drop = TRUE, unused levels dropped, drop = FALSE dropped. lists: drop = TRUE, sub-setting done using argument , selecting single element give simplified result, like using [[]]. drop = FALSE, list always returned regardless number elements.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_x.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","text":"Returns copy sub-setted object.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sb_x.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","text":"","code":"# atomic objects ====  obj <- matrix(1:16, ncol = 4) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 sb_x(obj, 1:3, 1:3) #>      a b  c #> [1,] 1 5  9 #> [2,] 2 6 10 #> [3,] 3 7 11 # above is equivalent to obj[1:3, 1:3, drop = FALSE] sb_x(obj, i = \\(x)x>5) #>  [1]  6  7  8  9 10 11 12 13 14 15 16 # above is equivalent to obj[obj > 5] sb_x(obj, col = c(\"a\", \"a\")) #>      a  a a  a #> [1,] 1 13 1 13 #> [2,] 2 14 2 14 #> [3,] 3 15 3 15 #> [4,] 4 16 4 16 # above is equivalent to obj[, lapply(c(\"a\", \"a\"), \\(i) which(colnames(obj) == i)) |> unlist()]  obj <- array(1:64, c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  sb_x(obj, n(1:3, 1:2), c(1,3)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #>  sb_x(obj, rcl = n(1:3, NULL, 1:2)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #>  # above 2 lines are equivalent to obj[1:3, , 1:2, drop = FALSE] sb_x(obj, i = \\(x)x>5) #>  [1]  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #> [26] 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 # above is equivalent to obj[obj > 5]  #############################################################################    # factors ====  obj <- factor(rep(letters[1:5], 2)) sb_x(obj, lvl = c(\"a\", \"a\")) #> [1] a a a a #> Levels: a b c d e # above is equivalent to obj[lapply(c(\"a\", \"a\"), \\(i) which(obj == i)) |> unlist()]  #############################################################################   # lists ====  obj <- list(a = 1:10, b = letters[1:11], c = 11:20) print(obj) #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  sb2_x(obj, 1) # obj[1] #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  sb2_x(obj, 1, drop = TRUE) # obj[[1]] #>  [1]  1  2  3  4  5  6  7  8  9 10 sb2_x(obj, 1:2) # obj[1:2] #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  sb2_x(obj, is.numeric) # obj[sapply(obj, is.numeric)] #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  # for recursive indexing, see sb2_rec()  ################################################################################   # recursive arrays / dimensional lists ==== obj <- c(as.list(1:10), as.list(letters[1:10])) |> array(dim = c(5, 4)) |> t() print(obj) #>      [,1] [,2] [,3] [,4] [,5] #> [1,] 1    2    3    4    5    #> [2,] 6    7    8    9    10   #> [3,] \"a\"  \"b\"  \"c\"  \"d\"  \"e\"  #> [4,] \"f\"  \"g\"  \"h\"  \"i\"  \"j\"  sb2_x(obj, list(1:3), 1) #>      [,1] [,2] [,3] [,4] [,5] #> [1,] 1    2    3    4    5    #> [2,] 6    7    8    9    10   #> [3,] \"a\"  \"b\"  \"c\"  \"d\"  \"e\"  # above is equivalent to obj[1:3, ]   #############################################################################  # data.frame-like objects ====  obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) print(obj) #>     a b  c d #> 1   1 a 11 a #> 2   2 b 12 b #> 3   3 c 13 c #> 4   4 d 14 d #> 5   5 e 15 e #> 6   6 f 16 f #> 7   7 g 17 g #> 8   8 h 18 h #> 9   9 i 19 i #> 10 10 j 20 j sb2_x(obj, 1:3, 1:3) # obj[1:3, 1:3, drop = FALSE] #>   a b  c #> 1 1 a 11 #> 2 2 b 12 #> 3 3 c 13 sb2_x(obj, filter = ~ (a > 5) & (c < 19), vars = is.numeric) #>   a  c #> 1 6 16 #> 2 7 17 #> 3 8 18"},{"path":"https://tony-aw.github.io/squarebrackets/reference/seq_names.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Integer Sequence From a Range of Names — seq_names","title":"Generate Integer Sequence From a Range of Names — seq_names","text":"Generate integer sequence range names.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/seq_names.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Integer Sequence From a Range of Names — seq_names","text":"","code":"seq_names(names, start, end, inv = FALSE)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/seq_names.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Integer Sequence From a Range of Names — seq_names","text":"names character vector names.  Duplicate names, empty names, character vector length zero allowed. start name giving starting index sequence end name giving ending index sequence inv Boolean. TRUE, indices names except names specified sequence given.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/seq_names.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Integer Sequence From a Range of Names — seq_names","text":"integer vector.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/seq_names.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Integer Sequence From a Range of Names — seq_names","text":"","code":"x <- data.frame(   a = 1:10, b = letters[1:10], c = factor(letters[1:10]), d = -1:-10 ) ind <- seq_names(colnames(x), \"b\", \"d\") sb2_x(x, col = ind) #>    b c   d #> 1  a a  -1 #> 2  b b  -2 #> 3  c c  -3 #> 4  d d  -4 #> 5  e e  -5 #> 6  f f  -6 #> 7  g g  -7 #> 8  h h  -8 #> 9  i i  -9 #> 10 j j -10"},{"path":"https://tony-aw.github.io/squarebrackets/reference/seq_rec2.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Recursive Sequence Through Repeated Arithmetic Infix Operations — seq_rec2","title":"Generate Recursive Sequence Through Repeated Arithmetic Infix Operations — seq_rec2","text":"recursive sequence generator.  function essentially highly generalized version Fibonacci sequence generator.  Starting 2 initial values, next value generated either one 2 formulas: x[] = (s[1] + m[1] * x[-1]) %inop% (s[2] + m[2] * x[-2]) x[] = (m[1] * (x[-1] + s[1])) %inop% (m[2] * (x[-2] + s[2])) %inop% arithmetic infix operator chosen,  m s numeric vector length 2.  order x[-1] x[-2] can also swapped.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/seq_rec2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Recursive Sequence Through Repeated Arithmetic Infix Operations — seq_rec2","text":"","code":"seq_rec2(   inits = c(0L, 1L),   n = 10L,   s = c(0L, 0L),   m = c(1L, 1L),   inop = \"+\",   form = 1L,   rev = FALSE )"},{"path":"https://tony-aw.github.io/squarebrackets/reference/seq_rec2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Recursive Sequence Through Repeated Arithmetic Infix Operations — seq_rec2","text":"inits numeric (double integer) vector length 2, giving initial values.  numbers allowed, even negative /fractional numbers.  Note numbers given must give valid results passed function f(). n single integer, giving size numeric vector generate.  NOTE: must hold n > 2. s, m numeric vectors length 2 used formula. inop single string, giving arithmetic infix operator used.  Currently supported: \"+\", \"-\", \"*\", \"/\".  fibonacci sequence, inop = \"+\". form either 1 2, indicating formula used (see Description section ). rev reverse order x[-1] x[-2].  example, using form = 1: rev = FALSE (default), holds: x[] = (s[1] + m[1] * x[-1]) %inop% (s[2] + m[2] * x[-2]). rev = TRUE, holds: x[] = (s[1] + m[1] * x[-2]) %inop% (s[2] + m[2] * x[-1])","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/seq_rec2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Recursive Sequence Through Repeated Arithmetic Infix Operations — seq_rec2","text":"sequence numbers.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/seq_rec2.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Recursive Sequence Through Repeated Arithmetic Infix Operations — seq_rec2","text":"default values arguments give first 10 numbers regular Fibonacci sequence.  See examples several number series created function.  function written C++ using Rcpp better performance.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/seq_rec2.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Generate Recursive Sequence Through Repeated Arithmetic Infix Operations — seq_rec2","text":"supply NAs NaNs function, handle .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/seq_rec2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Recursive Sequence Through Repeated Arithmetic Infix Operations — seq_rec2","text":"","code":"seq_rec2() # by default gives Fibonacci numbers #>  [1]  0  1  1  2  3  5  8 13 21 34 seq_rec2(inits = 2:1) # Lucas numbers #>  [1]  2  1  3  4  7 11 18 29 47 76 c(1, seq_rec2(c(1, 2), inop = \"*\")) # Multiplicative Fibonacci #>  [1]           1           1           2           2           4           8 #>  [7]          32         256        8192     2097152 17179869184 seq_rec2(m = c(2L, 1L)) # Pell numbers #>  [1]   0   1   2   5  12  29  70 169 408 985 seq_rec2(inits = c(1, 0), m = c(0L, 2L)) # see https://oeis.org/A077957 #>  [1]  1  0  2  0  4  0  8  0 16  0 seq_rec2(m = c(1L, 2L)) # Jacobsthal numbers #>  [1]   0   1   1   3   5  11  21  43  85 171"},{"path":"https://tony-aw.github.io/squarebrackets/reference/setapply.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply Functions Over mutable_atomic Matrix Margins By Reference — setapply","title":"Apply Functions Over mutable_atomic Matrix Margins By Reference — setapply","text":"setapply() function applies functions rows columns mutable_atomic matrix, pass--reference semantics.  every iteration, copy single row column (depending margin) made, function applied copy, original row/column replaced modified copy pass--reference semantics.  setapply() bit faster uses less memory apply.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/setapply.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply Functions Over mutable_atomic Matrix Margins By Reference — setapply","text":"","code":"setapply(x, MARGIN, FUN)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/setapply.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply Functions Over mutable_atomic Matrix Margins By Reference — setapply","text":"x mutable_atomic matrix. Arrays supported. MARGIN single integer scalar, giving subscript apply function . 1 indicates rows, 2 indicates columns. FUN function applied.  function must return vector type x, appropriate length (.e. length ncol(x) MARGIN == 1 length nrow(x) MARGIN == 2).","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/setapply.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply Functions Over mutable_atomic Matrix Margins By Reference — setapply","text":"Returns: VOID. function modifies object reference. use assignment like x <- setapply(x, ...). Since function returns void, just get NULL.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/setapply.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply Functions Over mutable_atomic Matrix Margins By Reference — setapply","text":"","code":"# re-order elements matrix by reference ==== x <- mutable_atomic(1:20, dim = c(5,4)) print(x) #>      [,1] [,2] [,3] [,4] #> [1,]    1    6   11   16 #> [2,]    2    7   12   17 #> [3,]    3    8   13   18 #> [4,]    4    9   14   19 #> [5,]    5   10   15   20 #> mutable_atomic  #> typeof:  integer  setapply(x, 1, FUN = \\(x)x[c(4,1,3,2)]) print(x) #>      [,1] [,2] [,3] [,4] #> [1,]   16    1   11    6 #> [2,]   17    2   12    7 #> [3,]   18    3   13    8 #> [4,]   19    4   14    9 #> [5,]   20    5   15   10 #> mutable_atomic  #> typeof:  integer    # sort elements of matrix by reference ==== x <- mutable_atomic(20:1, dim = c(5,4)) print(x) #>      [,1] [,2] [,3] [,4] #> [1,]   20   15   10    5 #> [2,]   19   14    9    4 #> [3,]   18   13    8    3 #> [4,]   17   12    7    2 #> [5,]   16   11    6    1 #> mutable_atomic  #> typeof:  integer  setapply(x, 2, FUN = sort) print(x) #>      [,1] [,2] [,3] [,4] #> [1,]   16   11    6    1 #> [2,]   17   12    7    2 #> [3,]   18   13    8    3 #> [4,]   19   14    9    4 #> [5,]   20   15   10    5 #> mutable_atomic  #> typeof:  integer"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"functions convert list integer subscripts integer matrix coordinates, integer matrix coordinates integer vector flat indices, vice-versa.  Inspired sub2ind function 'MatLab'. sub2coord() converts list integer subscripts integer matrix coordinates. coord2ind() converts integer matrix coordinates integer vector flat indices. ind2coord() converts integer vector flat indices integer matrix coordinates. coord2sub() converts integer matrix coordinates list integer subscripts;  performs simple (one might even say naive) conversion. sub2ind() faster memory efficient version coord2ind(sub2coord(sub, x.dims), x.dims)  (especially 5 dimensions). functions written memory-efficient.  coord2ind() thus opposite arrayInd, ind2coord merely convenient wrapper around arrayInd.  Note equivalent sub2ind function 'MatLab' actually coord2ind() function .","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"","code":"sub2coord(sub, x.dim)  coord2sub(coord)  coord2ind(coord, x.dim, checks = TRUE)  ind2coord(ind, x.dim)  sub2ind(sub, x.dim, checks = TRUE)"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"sub list integer subscripts.  first element list corresponds first dimension (rows), second element second dimensions (columns), etc.  length sub must equal length x.dim.  One give empty subscript; instead fill something like seq_len(dim(x)[margin]).  NOTE: coord2sub() function support duplicate subscripts. x.dim integer vector giving dimensions array question. .e. dim(x). coord integer matrix, giving coordinate indices (subscripts) convert.  row index, column dimension.  first columns corresponds first dimension, second column second dimensions, etc.  number columns coord must equal length x.dim. checks Boolean, indicating arguments checks performed.  Defaults TRUE.  Can set FALSE minor speed improvements. ind integer vector, giving flat position indices convert.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"sub2coord() ind2coord(): Returns integer matrix coordinates (properties described argument coord).  coord2ind(): Returns integer vector flat indices (properties described argument ind).  coord2sub(): Returns list integer subscripts (properties described argument sub)","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"S3 classes 'R' use standard Linear Algebraic convention, academic fields like Mathematics Statistics, following sense: vectors column vectors (.e. vertically aligned vectors); index counting starts 1; rows first dimension/subscript, columns second dimension/subscript, etc. Thus, orientation flat indices , example, 4 4 matrix, follows:   subscript [1,2] refers first row second column. 4 4 matrix, subscript [1,2] corresponds flat index 5.  functions described thus follow also convention.","code":"[,1] [,2] [,3] [,4]  [1,]    1    5    9   13  [2,]    2    6   10   14  [3,]    3    7   11   15  [4,]    4    8   12   16"},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"functions specifically designed duplicate indices per-sé.  efficiency, check duplicate indices either.","code":""},{"path":"https://tony-aw.github.io/squarebrackets/reference/sub2ind.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"","code":"x.dim <- c(10, 10, 3) x.len <- prod(x.dim) x <- array(1:x.len, x.dim) sub <- list(c(4, 3), c(3, 2), c(2, 3)) coord <- sub2coord(sub, x.dim) print(coord) #>      [,1] [,2] [,3] #> [1,]    4    3    2 #> [2,]    3    3    2 #> [3,]    4    2    2 #> [4,]    3    2    2 #> [5,]    4    3    3 #> [6,]    3    3    3 #> [7,]    4    2    3 #> [8,]    3    2    3 ind <- coord2ind(coord, x.dim) print(ind) #> [1] 124 123 114 113 224 223 214 213 all(x[ind] == c(x[c(4, 3), c(3, 2), c(2, 3)])) # TRUE #> [1] TRUE coord2 <- ind2coord(ind, x.dim) print(coord) #>      [,1] [,2] [,3] #> [1,]    4    3    2 #> [2,]    3    3    2 #> [3,]    4    2    2 #> [4,]    3    2    2 #> [5,]    4    3    3 #> [6,]    3    3    3 #> [7,]    4    2    3 #> [8,]    3    2    3 all(coord == coord2) # TRUE #> [1] TRUE sub2 <- coord2sub(coord2) sapply(1:3, \\(i) sub2[[i]] == sub[[i]]) |> all() # TRUE #> [1] TRUE"}]
