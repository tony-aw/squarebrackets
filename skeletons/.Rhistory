dim.n <- dim(x)[[dim.i]]
dim.n1 <- dim.n - round(dim.n/2)
dim.n2 <- dim.n - dim.n1
out <- list(
logical(0),
rep(TRUE, dim.n),
rep(FALSE, dim.n),
c(rep(TRUE, dim.n1), rep(FALSE, dim.n2)),
1,
1:3,
3:1,
c(2, 3, 1),
1 * -1i,
1:3 * -1i,
3:1 * -1i,
c(2, 3, 1) * -1i,
1 * 1i,
1:3 * 1i,
3:1 * 1i,
c(2, 3, 1) * 1i
)
return(out)
}
indx_named <- function(x, dim.i) {
if(dim.i == 1L) {
out <- indx_general(x, dim.i)
}
if(dim.i == 2L) {
out <- c(
indx_general(x, dim.i), list("a", c("a", "b"), c("b", "a"))
)
}
return(out)
}
.dt_make_args <- squarebrackets:::.dt_make_args
rows <- indx_named(x, 1L)
cols <- indx_named(x, 2L)
list_sd <- list_ov <- vector("list", length(rows) * length(cols) * 2)
i <- 1L
for(iRow in 1:length(rows)) {
for(iCol in 1:length(cols)) {
for(iInv in c(TRUE, FALSE)) {
s <- n(rows[[iRow]], cols[[iCol]])
d <- 1:2
list_sd[[i]] <- .dt_make_args(
x, s = s, d = d, obs = NULL, vars = NULL,
inv = iInv, chkdup = FALSE, sys.call()
)
list_ov[[i]] <- .dt_make_args(
x, s = NULL, d = integer(0L), obs = rows[[iRow]], vars = cols[[iCol]],
iInv, FALSE, sys.call()
)
expect_equal(
list_sd[[i]],
list_ov[[i]]
) |> errorfun()
i <- i + 1L
}
}
}
expect_equal(list_sd, list_ov)
# set-up ====
setwd("D:/D Desktop/Publications/R package squarebrackets")
sessionInfo()
pkgs <- c("devtools", "roxygen2", "usethis", "rcmdcheck", "spelling", "tinytex",
"tinytest",
"Rcpp", "pkgdown", "tinytest")
for(i in pkgs) if(!requireNamespace(i))install.packages(i)
library(tinytest)
# install(file.path("D:/D Desktop/Publications/ImageMagick-7.1.0-62-Q16-HDRI-x64-dll"))
# tinytex::install_tinytex()
# tinytex::tlmgr_install("unfonts-extra")
# tinytex::tlmgr_install("makeindex")
#  create("squarebrackets")
# Rcpp::Rcpp.package.skeleton("squarebrackets")
# set version ====
package_tarname <- "squarebrackets_0.0.0.9.tar.gz"
# document ====
Rcpp::compileAttributes("squarebrackets")
devtools::document("./squarebrackets")
tinytest::run_test_dir("./squarebrackets/inst/tinytest/developer")
tinytest::run_test_dir("./squarebrackets/inst/tinytest/src_related")
dirs <- list.dirs("./squarebrackets/inst/tinytest/")
for(i in dirs) {
print(i)
foo <- tinytest::run_test_dir(i)
if(!all_pass(foo)) {
stop("not all pass")
}
}
foo <- devtools::check("./squarebrackets")
setwd("D:/D Desktop/Publications/R package squarebrackets/squarebrackets/skeletons")
# set-up ====
source("source.R")
library(stringi)
header_for_source <- "
#include <Rcpp.h>
using namespace Rcpp;
inline int rcpp_count_stringmatches(String y, SEXP v) {
int n = Rf_length(v);
const SEXP *pv = STRING_PTR_RO(v);
int count = 0;
for(int i = 0; i < n; ++i) {
if(y == pv[i]) {
count++;
}
}
return count;
}
"
header_for_package <- "
#include <Rcpp.h>
#include \"squarebrackets.h\"
using namespace Rcpp;
inline int rcpp_count_stringmatches(String y, SEXP v) {
int n = Rf_length(v);
const SEXP *pv = STRING_PTR_RO(v);
int count = 0;
for(int i = 0; i < n; ++i) {
if(y == pv[i]) {
count++;
}
}
return count;
}
#define MACRO_SET_ATOMIC(POINTER, INDEX, REPLACEMENT) do {  \\
POINTER[INDEX] = REPLACEMENT; \\
} while(0)
"
macro_slicev <- readr::read_file("macros_slicev.txt")
################################################################################
# countv & whichv ====
code_countv <- "
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_countv)]]
R_xlen_t rcpp_countv(
SEXP y, SEXP v, LogicalVector na, LogicalVector invert, R_xlen_t start, R_xlen_t end, R_xlen_t by, R_xlen_t len
) {
R_xlen_t count = 0;
if(len == 0) {
return count;
}
MACRO_SLICEV_DO(count++);
return count;
}
"
cat(code_countv)
code <- paste0(header_for_source,"\n", macro_slicev, "\n", code_countv)
Rcpp::sourceCpp(code = code)
code_whichv <-
"
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_whichv_32)]]
IntegerVector rcpp_whichv_32(
SEXP y, SEXP v, LogicalVector na, LogicalVector invert, R_xlen_t start, R_xlen_t end, R_xlen_t by, R_xlen_t len
) {
R_xlen_t count = 0;
R_xlen_t amount = rcpp_countv(y, v, na, invert, start, end, by, len);
int *pout;
SEXP out = PROTECT(Rf_allocVector(INTSXP, amount));
pout = INTEGER(out);
if(amount == 0) {
UNPROTECT(1);
return out;
}
MACRO_SLICEV_DO(pout[count] = i + 1; count++);
UNPROTECT(1);
return out;
}
"
cat(code_whichv)
code <- paste0(header_for_source, macro_slicev, code_countv, code_whichv, collapse = "\n\n")
cat(code)
Rcpp::sourceCpp(code = code)
################################################################################
# slicev_x ====
templatecode <- "
SEXP rcpp_slicev_x_<Rcpp_Type>(
SEXP x, SEXP y, SEXP v, LogicalVector na, LogicalVector invert, R_xlen_t start, R_xlen_t end, R_xlen_t by, R_xlen_t len
) {
R_xlen_t count = 0;
if(Rf_xlength(x) != Rf_xlength(y)) {
stop(\"`x` and `y` must have equal lengths\");
}
<scalar_type> *px = <FUN_TYPE>(x);
R_xlen_t size = rcpp_countv(y, v, na, invert, start, end, by, len);
SEXP out = PROTECT(Rf_allocVector(<SXP_TYPE>, size));
<COMMENT> <scalar_type> *pout = <FUN_TYPE>(out);
if(size == 0) {
UNPROTECT(1);
return out;
}
MACRO_SLICEV_DO(<SET_FUN>out, count, px[i]); count++);
UNPROTECT(1);
return out;
}
"
templatecodes <- character(6L)
for(i in 1:6) {
find <- c("<Rcpp_Type>", "<scalar_type>", "<FUN_TYPE>", "<SXP_TYPE>", "<COMMENT>",  "<SET_FUN>")
replace <- c(RCPP_TYPES[i], scalar_types[i], FUN_TYPES[i], SXP_TYPES[i], COMMENTS[i], SET_FUNS[i])
templatecodes[i] <- stri_replace_all(
templatecode, replace, fixed = find, vectorize_all = FALSE
)
}
templatecodes <- stri_c(templatecodes, collapse = "\n\n")
cat(templatecodes)
switches <- make_atomic_switches(
"x", "return", "rcpp_slicev_x", "x, y, v, na, invert, start, end, by, len", SXP_TYPES, RCPP_TYPES
)
cat(switches)
code_slicev_x <- stri_c(
templatecodes,
"
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_slicev_x_atomic)]]
SEXP rcpp_slicev_x_atomic(
SEXP x, SEXP y, SEXP v, LogicalVector na, LogicalVector invert, R_xlen_t start, R_xlen_t end, R_xlen_t by, R_xlen_t len
) {
",
switches,
"
return R_NilValue;
}
"
)
cat(code_slicev_x)
code <- stri_paste(header_for_source, macro_slicev, code_countv, code_whichv, code_slicev_x)
cat(code)
Rcpp::sourceCpp(code = code) # no errors, good!
setwd("D:/D Desktop/Publications/R package squarebrackets/squarebrackets/skeletons")
# set-up ====
source("source.R")
library(stringi)
header_for_source <- "
#include <Rcpp.h>
using namespace Rcpp;
inline int rcpp_count_stringmatches(String y, SEXP v) {
int n = Rf_length(v);
const SEXP *pv = STRING_PTR_RO(v);
int count = 0;
for(int i = 0; i < n; ++i) {
if(y == pv[i]) {
count++;
}
}
return count;
}
"
header_for_package <- "
#include <Rcpp.h>
#include \"squarebrackets.h\"
using namespace Rcpp;
inline int rcpp_count_stringmatches(String y, SEXP v) {
int n = Rf_length(v);
const SEXP *pv = STRING_PTR_RO(v);
int count = 0;
for(int i = 0; i < n; ++i) {
if(y == pv[i]) {
count++;
}
}
return count;
}
#define MACRO_SET_ATOMIC(POINTER, INDEX, REPLACEMENT) do {  \\
POINTER[INDEX] = REPLACEMENT; \\
} while(0)
"
macro_slicev <- readr::read_file("macros_slicev.txt")
################################################################################
# countv & whichv ====
code_countv <- "
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_countv)]]
R_xlen_t rcpp_countv(
SEXP y, SEXP v, LogicalVector na, LogicalVector invert, R_xlen_t start, R_xlen_t end, R_xlen_t by, R_xlen_t len
) {
R_xlen_t count = 0;
if(len == 0) {
return count;
}
MACRO_SLICEV_DO(count++);
return count;
}
"
cat(code_countv)
code <- paste0(header_for_source,"\n", macro_slicev, "\n", code_countv)
Rcpp::sourceCpp(code = code)
code_whichv <-
"
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_whichv_32)]]
IntegerVector rcpp_whichv_32(
SEXP y, SEXP v, LogicalVector na, LogicalVector invert, R_xlen_t start, R_xlen_t end, R_xlen_t by, R_xlen_t len
) {
R_xlen_t count = 0;
R_xlen_t amount = rcpp_countv(y, v, na, invert, start, end, by, len);
int *pout;
SEXP out = PROTECT(Rf_allocVector(INTSXP, amount));
pout = INTEGER(out);
if(amount == 0) {
UNPROTECT(1);
return out;
}
MACRO_SLICEV_DO(pout[count] = i + 1; count++);
UNPROTECT(1);
return out;
}
"
cat(code_whichv)
code <- paste0(header_for_source, macro_slicev, code_countv, code_whichv, collapse = "\n\n")
cat(code)
Rcpp::sourceCpp(code = code)
################################################################################
# slicev_x ====
templatecode <- "
SEXP rcpp_slicev_x_<Rcpp_Type>(
SEXP x, SEXP y, SEXP v, LogicalVector na, LogicalVector invert, R_xlen_t start, R_xlen_t end, R_xlen_t by, R_xlen_t len
) {
R_xlen_t count = 0;
if(Rf_xlength(x) != Rf_xlength(y)) {
stop(\"`x` and `y` must have equal lengths\");
}
const <scalar_type> *px = <FUN_TYPE>(x);
R_xlen_t size = rcpp_countv(y, v, na, invert, start, end, by, len);
SEXP out = PROTECT(Rf_allocVector(<SXP_TYPE>, size));
<COMMENT> <scalar_type> *pout = <FUN_TYPE>(out);
if(size == 0) {
UNPROTECT(1);
return out;
}
MACRO_SLICEV_DO(<SET_FUN>out, count, px[i]); count++);
UNPROTECT(1);
return out;
}
"
templatecodes <- character(6L)
for(i in 1:6) {
find <- c("<Rcpp_Type>", "<scalar_type>", "<FUN_TYPE>", "<SXP_TYPE>", "<COMMENT>",  "<SET_FUN>")
replace <- c(RCPP_TYPES[i], scalar_types[i], FUN_TYPES[i], SXP_TYPES[i], COMMENTS[i], SET_FUNS[i])
templatecodes[i] <- stri_replace_all(
templatecode, replace, fixed = find, vectorize_all = FALSE
)
}
templatecodes <- stri_c(templatecodes, collapse = "\n\n")
cat(templatecodes)
switches <- make_atomic_switches(
"x", "return", "rcpp_slicev_x", "x, y, v, na, invert, start, end, by, len", SXP_TYPES, RCPP_TYPES
)
cat(switches)
code_slicev_x <- stri_c(
templatecodes,
"
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_slicev_x_atomic)]]
SEXP rcpp_slicev_x_atomic(
SEXP x, SEXP y, SEXP v, LogicalVector na, LogicalVector invert, R_xlen_t start, R_xlen_t end, R_xlen_t by, R_xlen_t len
) {
",
switches,
"
return R_NilValue;
}
"
)
cat(code_slicev_x)
code <- stri_paste(header_for_source, macro_slicev, code_countv, code_whichv, code_slicev_x)
cat(code)
Rcpp::sourceCpp(code = code) # no errors, good!
setwd("D:/D Desktop/Publications/R package squarebrackets/squarebrackets/skeletons")
source("source.R")
library(stringi)
header_for_source <- "
#include <Rcpp.h>
using namespace Rcpp;
inline int rcpp_count_stringmatches(String y, SEXP v) {
int n = Rf_length(v);
const SEXP *pv = STRING_PTR_RO(v);
int count = 0;
for(int i = 0; i < n; ++i) {
if(y == pv[i]) {
count++;
}
}
return count;
}
"
header_for_package <- "
#include <Rcpp.h>
#include \"squarebrackets.h\"
using namespace Rcpp;
inline int rcpp_count_stringmatches(String y, SEXP v) {
int n = Rf_length(v);
const SEXP *pv = STRING_PTR_RO(v);
int count = 0;
for(int i = 0; i < n; ++i) {
if(y == pv[i]) {
count++;
}
}
return count;
}
#define MACRO_SET_ATOMIC(POINTER, INDEX, REPLACEMENT) do {  \\
POINTER[INDEX] = REPLACEMENT; \\
} while(0)
"
macro_slicev <- readr::read_file("macros_slicev.txt")
code_countv <- "
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_countv)]]
R_xlen_t rcpp_countv(
SEXP y, SEXP v, LogicalVector na, LogicalVector invert, R_xlen_t start, R_xlen_t end, R_xlen_t by, R_xlen_t len
) {
R_xlen_t count = 0;
if(len == 0) {
return count;
}
MACRO_SLICEV_DO(count++);
return count;
}
"
cat(code_countv)
code <- paste0(header_for_source,"\n", macro_slicev, "\n", code_countv)
Rcpp::sourceCpp(code = code)
code_whichv <-
"
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_whichv_32)]]
IntegerVector rcpp_whichv_32(
SEXP y, SEXP v, LogicalVector na, LogicalVector invert, R_xlen_t start, R_xlen_t end, R_xlen_t by, R_xlen_t len
) {
R_xlen_t count = 0;
R_xlen_t amount = rcpp_countv(y, v, na, invert, start, end, by, len);
int *pout;
SEXP out = PROTECT(Rf_allocVector(INTSXP, amount));
pout = INTEGER(out);
if(amount == 0) {
UNPROTECT(1);
return out;
}
MACRO_SLICEV_DO(pout[count] = i + 1; count++);
UNPROTECT(1);
return out;
}
"
cat(code_whichv)
code <- paste0(header_for_source, macro_slicev, code_countv, code_whichv, collapse = "\n\n")
cat(code)
Rcpp::sourceCpp(code = code)
templatecode <- "
SEXP rcpp_slicev_x_<Rcpp_Type>(
SEXP x, SEXP y, SEXP v, LogicalVector na, LogicalVector invert, R_xlen_t start, R_xlen_t end, R_xlen_t by, R_xlen_t len
) {
R_xlen_t count = 0;
if(Rf_xlength(x) != Rf_xlength(y)) {
stop(\"`x` and `y` must have equal lengths\");
}
const <scalar_type> *px = <FUN_TYPE>(x);
R_xlen_t size = rcpp_countv(y, v, na, invert, start, end, by, len);
SEXP out = PROTECT(Rf_allocVector(<SXP_TYPE>, size));
<COMMENT> <scalar_type> *pout = <FUN_TYPE>(out);
if(size == 0) {
UNPROTECT(1);
return out;
}
MACRO_SLICEV_DO(<SET_FUN>out, count, px[i]); count++);
UNPROTECT(1);
return out;
}
"
templatecodes <- character(6L)
for(i in 1:6) {
find <- c("<Rcpp_Type>", "<scalar_type>", "<FUN_TYPE>", "<SXP_TYPE>", "<COMMENT>",  "<SET_FUN>")
replace <- c(RCPP_TYPES[i], scalar_types[i], FUN_TYPES[i], SXP_TYPES[i], COMMENTS[i], SET_FUNS[i])
templatecodes[i] <- stri_replace_all(
templatecode, replace, fixed = find, vectorize_all = FALSE
)
}
templatecodes <- stri_c(templatecodes, collapse = "\n\n")
cat(templatecodes)
switches <- make_atomic_switches(
"x", "return", "rcpp_slicev_x", "x, y, v, na, invert, start, end, by, len", SXP_TYPES, RCPP_TYPES
)
cat(switches)
code_slicev_x <- stri_c(
templatecodes,
"
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_slicev_x_atomic)]]
SEXP rcpp_slicev_x_atomic(
SEXP x, SEXP y, SEXP v, LogicalVector na, LogicalVector invert, R_xlen_t start, R_xlen_t end, R_xlen_t by, R_xlen_t len
) {
",
switches,
"
return R_NilValue;
}
"
)
cat(code_slicev_x)
code <- stri_paste(header_for_source, macro_slicev, code_countv, code_whichv, code_slicev_x)
cat(code)
Rcpp::sourceCpp(code = code) # no errors, good!
