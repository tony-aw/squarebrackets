const double *py = REAL(y);
for(R_xlen_t i = start; i != (end + by); i += by) {
if(R_isnancpp(py[i]) == condition) {
DOCODE;
}
}
break;
}
case CPLXSXP:
{
const Rcomplex *py = COMPLEX(y);
bool condition = !invert[0];
for(R_xlen_t i = start; i != (end + by); i += by) {
if((R_isnancpp(py[i].r) || R_isnancpp(py[i].i)) == condition){
DOCODE;
}
}
break;
}
case STRSXP:
{
const SEXP *py = STRING_PTR_RO(y);
bool condition = !invert[0];
for(R_xlen_t i = start; i != (end + by); i += by) {
if((py[i] == NA_STRING) == condition) {
DOCODE;
}
}
break;
}
case RAWSXP :
{
stop(\"NAs not defined for type `raw`\");
}
default: stop(\"Unsupported type \");
}
} while(0)
"
macro_slicev_do_naonly <- convert_macro(macro_slicev_do_naonly)
cat(macro_slicev_do_naonly)
macro_slicev_do <- "
#define MACRO_SLICEV_DO(DOCODE) do {
if(LogicalVector::is_na(na[0])) {
MACRO_SLICEV_DO_NAONLY(DOCODE);
}
else if(na[0]) {
MACRO_SLICEV_DO_NAKEEP(DOCODE);
}
else if(!na[0]) {
MACRO_SLICEV_DO_NARM(DOCODE);
}
else {
stop(\"unknow value for `na` given\");
}
} while(0)
"
macro_slicev_do <- convert_macro(macro_slicev_do)
cat(macro_slicev_do)
macro_slicev <- stri_c(
macro_slicev_do_narm,
"\n",
macro_slicev_do_nakeep,
"\n",
macro_slicev_do_naonly,
"\n",
macro_slicev_do,
"\n",
collapse = "\n"
)
cat(macro_slicev)
Rcpp::sourceCpp(code = stri_c(header, macro_slicev, collapse = "\n"))
code_countv <- "
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_countv)]]
R_xlen_t rcpp_countv(
SEXP y, SEXP v, LogicalVector na, LogicalVector invert, R_xlen_t start, R_xlen_t end, R_xlen_t by, R_xlen_t len
) {
R_xlen_t count = 0;
if(len == 0) {
return count;
}
MACRO_SLICEV_DO(count++);
return count;
}
"
cat(code_countv)
code <- paste0(header,"\n", macro_slicev, "\n", code_countv)
Rcpp::sourceCpp(code = code)
code_whichv <-
"
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_whichv_32)]]
IntegerVector rcpp_whichv_32(
SEXP y, SEXP v, LogicalVector na, LogicalVector invert, R_xlen_t start, R_xlen_t end, R_xlen_t by, R_xlen_t len
) {
R_xlen_t count = 0;
R_xlen_t amount = rcpp_countv(y, v, na, invert, start, end, by, len);
int *pout;
SEXP out = PROTECT(Rf_allocVector(INTSXP, amount));
pout = INTEGER(out);
if(amount == 0) {
UNPROTECT(1);
return out;
}
MACRO_SLICEV_DO(pout[count] = i + 1; count++);
UNPROTECT(1);
return out;
}
"
cat(code_whichv)
code <- paste0(header, macro_slicev, code_countv, code_whichv, collapse = "\n\n")
cat(code)
Rcpp::sourceCpp(code = code)
templatecode <- "
SEXP rcpp_slicev_x_<Rcpp_Type>(
SEXP x, SEXP y, SEXP v, LogicalVector na, LogicalVector invert, R_xlen_t start, R_xlen_t end, R_xlen_t by, R_xlen_t len
) {
R_xlen_t count = 0;
if(Rf_xlength(x) != Rf_xlength(y)) {
stop(\"`x` and `y` must have equal lengths\");
}
<scalar_type> *px = <FUN_TYPE>(x);
R_xlen_t size = rcpp_countv(y, v, na, invert, start, end, by, len);
SEXP out = PROTECT(Rf_allocVector(<SXP_TYPE>, len));
<COMMENT> <scalar_type> *pout = <FUN_TYPE>(out);
if(size == 0) {
UNPROTECT(1);
return out;
}
MACRO_SLICEV_DO(<SET_FUN>out, count, px[i]); count++);
UNPROTECT(1);
return out;
}
"
templatecodes <- character(6L)
for(i in 1:6) {
find <- c("<Rcpp_Type>", "<scalar_type>", "<FUN_TYPE>", "<SXP_TYPE>", "<COMMENT>",  "<SET_FUN>")
replace <- c(RCPP_TYPES[i], scalar_types[i], FUN_TYPES[i], SXPTYPES[i], COMMENTS[i], SET_FUNS[i])
templatecodes[i] <- stri_replace_all(
templatecode, replace, fixed = find, vectorize_all = FALSE
)
}
cat(templatecodes)
templatecode <- "
SEXP rcpp_slicev_x_<Rcpp_Type>(
SEXP x, SEXP y, SEXP v, LogicalVector na, LogicalVector invert, R_xlen_t start, R_xlen_t end, R_xlen_t by, R_xlen_t len
) {
R_xlen_t count = 0;
if(Rf_xlength(x) != Rf_xlength(y)) {
stop(\"`x` and `y` must have equal lengths\");
}
<scalar_type> *px = <FUN_TYPE>(x);
R_xlen_t size = rcpp_countv(y, v, na, invert, start, end, by, len);
SEXP out = PROTECT(Rf_allocVector(<SXP_TYPE>, len));
<COMMENT> <scalar_type> *pout = <FUN_TYPE>(out);
if(size == 0) {
UNPROTECT(1);
return out;
}
MACRO_SLICEV_DO(<SET_FUN>out, count, px[i]); count++);
UNPROTECT(1);
return out;
}
"
templatecodes <- character(6L)
for(i in 1:6) {
find <- c("<Rcpp_Type>", "<scalar_type>", "<FUN_TYPE>", "<SXP_TYPE>", "<COMMENT>",  "<SET_FUN>")
replace <- c(RCPP_TYPES[i], scalar_types[i], FUN_TYPES[i], SXPTYPES[i], COMMENTS[i], SET_FUNS[i])
templatecodes[i] <- stri_replace_all(
templatecode, replace, fixed = find, vectorize_all = FALSE
)
}
cat(templatecodes)
switchpiece <- "
case TYPESXP:
{
return rcpp_slicev_x_template<TYPESXP>(as<RCPPTYPEVector>(x), y, v, na, invert, start, end, by, len);
}
"
templatecode <- "
SEXP rcpp_slicev_x_<Rcpp_Type>(
SEXP x, SEXP y, SEXP v, LogicalVector na, LogicalVector invert, R_xlen_t start, R_xlen_t end, R_xlen_t by, R_xlen_t len
) {
R_xlen_t count = 0;
if(Rf_xlength(x) != Rf_xlength(y)) {
stop(\"`x` and `y` must have equal lengths\");
}
<scalar_type> *px = <FUN_TYPE>(x);
R_xlen_t size = rcpp_countv(y, v, na, invert, start, end, by, len);
SEXP out = PROTECT(Rf_allocVector(<SXP_TYPE>, len));
<COMMENT> <scalar_type> *pout = <FUN_TYPE>(out);
if(size == 0) {
UNPROTECT(1);
return out;
}
MACRO_SLICEV_DO(<SET_FUN>out, count, px[i]); count++);
UNPROTECT(1);
return out;
}
"
templatecodes <- character(6L)
for(i in 1:6) {
find <- c("<Rcpp_Type>", "<scalar_type>", "<FUN_TYPE>", "<SXP_TYPE>", "<COMMENT>",  "<SET_FUN>")
replace <- c(RCPP_TYPES[i], scalar_types[i], FUN_TYPES[i], SXP_TYPES[i], COMMENTS[i], SET_FUNS[i])
templatecodes[i] <- stri_replace_all(
templatecode, replace, fixed = find, vectorize_all = FALSE
)
}
cat(templatecodes)
switchpiece <- "
case TYPESXP:
{
return rcpp_slicev_x_template<TYPESXP>(as<RCPPTYPEVector>(x), y, v, na, invert, start, end, by, len);
}
"
switches <- character(6L)
switches <- make_atomic_switches(
"return", "rcpp_slicev_x", "x, y, v, na, invert, start, end, by, len", SXP_TYPES, RCPP_TYPES
)
cat(switches)
make_atomic_switches <- function(keyword_return, template_name, template_inputs, SXP_TYPES, RCPP_TYPES) {
atomic_switches <- "
switch(TYPEOF(x)){
case LGLSXP:
{
<return> <fun>_Logical(<inputs>);
break;
}
case INTSXP:
{
<return> <fun>_Integer(<inputs>);
break;
}
case REALSXP:
{
<return> <fun>_Numeric(<inputs>);
break;
}
case CPLXSXP:
{
<return> <fun>_Complex(<inputs>);
break;
}
case RAWSXP:
{
<return> <fun>_Raw(<inputs>);
break;
}
case STRSXP:
{
<return> <fun>_Character(<inputs>);
break;
}
default: stop(\"unsupported type given\");
}
"
out <- stri_replace_all_fixed(
atomic_switches, c("<return>", "<fun>", "<inputs>"),
c(keyword_return, template_name, template_inputs), vectorize_all = FALSE
)
return(out)
}
make_atomic_switches(
"return", "rcpp_slicev_x", "x, y, v, na, invert, start, end, by, len", SXP_TYPES, RCPP_TYPES
)
switches <- make_atomic_switches(
"return", "rcpp_slicev_x", "x, y, v, na, invert, start, end, by, len", SXP_TYPES, RCPP_TYPES
)
cat(switches)
code_slicev_x <- stri_c(
templatecode,
"
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_slicev_x_atomic)]]
SEXP rcpp_slicev_x_atomic(
SEXP x, SEXP y, SEXP v, LogicalVector na, LogicalVector invert, R_xlen_t start, R_xlen_t end, R_xlen_t by, R_xlen_t len
) {
",
switches,
"
return R_NilValue;
}
"
)
cat(code_slicev_x)
library(stringi)
SXP_TYPES <- c("LGLSXP", "INTSXP", "REALSXP", "CPLXSXP", "RAWSXP", "STRSXP")
scalar_types <- c("int", "int", "double", "Rcomplex", "Rbyte", "SEXP")
FUN_TYPES <- c("LOGICAL", "INTEGER", "REAL", "COMPLEX", "RAW", "STRING_PTR")
RCPP_TYPES <- c("Logical", "Integer", "Numeric", "Complex", "Raw", "Character")
SET_FUNS <- c(rep("MACRO_SET_ATOMIC(p", 5), "SET_STRING_ELT(")
COMMENTS <- c(rep("", 5L), "//")
convert_macro <- function(x) {
x <- stri_split(x, regex = "\\n")[[1L]]
ind <- 2:(length(x) - 2L)
x[ind] <- stri_c(x[ind], "\t\\")
x <- stri_c(x, collapse = "\n")
return(x)
}
make_atomic_switches <- function(dispatch_variable, keyword_return, template_name, template_inputs, SXP_TYPES, RCPP_TYPES) {
atomic_switches <- "
switch(TYPEOF(<dispatch_variable>)){
case LGLSXP:
{
<return> <fun>_Logical(<inputs>);
break;
}
case INTSXP:
{
<return> <fun>_Integer(<inputs>);
break;
}
case REALSXP:
{
<return> <fun>_Numeric(<inputs>);
break;
}
case CPLXSXP:
{
<return> <fun>_Complex(<inputs>);
break;
}
case RAWSXP:
{
<return> <fun>_Raw(<inputs>);
break;
}
case STRSXP:
{
<return> <fun>_Character(<inputs>);
break;
}
default: stop(\"unsupported type given\");
}
"
out <- stri_replace_all_fixed(
atomic_switches, c("<dispatch_variable>", "<return>", "<fun>", "<inputs>"),
c(dispatch_variable, keyword_return, template_name, template_inputs), vectorize_all = FALSE
)
return(out)
}
switches <- make_atomic_switches(
"x", "return", "rcpp_slicev_x", "x, y, v, na, invert, start, end, by, len", SXP_TYPES, RCPP_TYPES
)
cat(switches)
code_slicev_x <- stri_c(
templatecode,
"
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_slicev_x_atomic)]]
SEXP rcpp_slicev_x_atomic(
SEXP x, SEXP y, SEXP v, LogicalVector na, LogicalVector invert, R_xlen_t start, R_xlen_t end, R_xlen_t by, R_xlen_t len
) {
",
switches,
"
return R_NilValue;
}
"
)
cat(code_slicev_x)
cat(code_slicev_x)
code <- stri_paste(header, code_countv, code_slicev_x)
cat(code)
code_slicev_x <- stri_c(
templatecodes,
"
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_slicev_x_atomic)]]
SEXP rcpp_slicev_x_atomic(
SEXP x, SEXP y, SEXP v, LogicalVector na, LogicalVector invert, R_xlen_t start, R_xlen_t end, R_xlen_t by, R_xlen_t len
) {
",
switches,
"
return R_NilValue;
}
"
)
cat(code_slicev_x)
switches
code_slicev_x <- stri_c(
templatecodes,
"
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_slicev_x_atomic)]]
SEXP rcpp_slicev_x_atomic(
SEXP x, SEXP y, SEXP v, LogicalVector na, LogicalVector invert, R_xlen_t start, R_xlen_t end, R_xlen_t by, R_xlen_t len
) {
",
switches,
"
return R_NilValue;
}
"
)
cat(code_slicev_x)
templatecodes
templatecodes <- stri_c(templatecodes, collapse = "\n\n")
cat(templatecodes)
switches <- make_atomic_switches(
"x", "return", "rcpp_slicev_x", "x, y, v, na, invert, start, end, by, len", SXP_TYPES, RCPP_TYPES
)
cat(switches)
code_slicev_x <- stri_c(
templatecodes,
"
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_slicev_x_atomic)]]
SEXP rcpp_slicev_x_atomic(
SEXP x, SEXP y, SEXP v, LogicalVector na, LogicalVector invert, R_xlen_t start, R_xlen_t end, R_xlen_t by, R_xlen_t len
) {
",
switches,
"
return R_NilValue;
}
"
)
cat(code_slicev_x)
code_slicev_x <- stri_c(
header,
templatecodes,
"
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_slicev_x_atomic)]]
SEXP rcpp_slicev_x_atomic(
SEXP x, SEXP y, SEXP v, LogicalVector na, LogicalVector invert, R_xlen_t start, R_xlen_t end, R_xlen_t by, R_xlen_t len
) {
",
switches,
"
return R_NilValue;
}
"
)
cat(code_slicev_x)
code_slicev_x <- stri_c(
header,
macro_slicev,
templatecodes,
"
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_slicev_x_atomic)]]
SEXP rcpp_slicev_x_atomic(
SEXP x, SEXP y, SEXP v, LogicalVector na, LogicalVector invert, R_xlen_t start, R_xlen_t end, R_xlen_t by, R_xlen_t len
) {
",
switches,
"
return R_NilValue;
}
"
)
cat(code_slicev_x)
code <- stri_paste(header, code_countv, code_slicev_x)
cat(code)
Rcpp::sourceCpp(code = code)
macro_slicev
header
code_slicev_x <- stri_c(
header,
macro_slicev,
templatecodes,
"
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_slicev_x_atomic)]]
SEXP rcpp_slicev_x_atomic(
SEXP x, SEXP y, SEXP v, LogicalVector na, LogicalVector invert, R_xlen_t start, R_xlen_t end, R_xlen_t by, R_xlen_t len
) {
",
switches,
"
return R_NilValue;
}
"
)
cat(code_slicev_x)
code_slicev_x <- stri_c(
templatecodes,
"
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_slicev_x_atomic)]]
SEXP rcpp_slicev_x_atomic(
SEXP x, SEXP y, SEXP v, LogicalVector na, LogicalVector invert, R_xlen_t start, R_xlen_t end, R_xlen_t by, R_xlen_t len
) {
",
switches,
"
return R_NilValue;
}
"
)
cat(code_slicev_x)
code <- stri_paste(header, macro_slicev, code_countv, code_slicev_x)
cat(code)
Rcpp::sourceCpp(code = code)
code_whichv
code <- stri_paste(header, macro_slicev, code_countv, code_whichv, code_slicev_x)
cat(code)
Rcpp::sourceCpp(code = code) # no errors, good!
