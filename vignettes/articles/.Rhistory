SEXP current_indices,
SEXP counters,
SEXP start,
int m
) {
int *pi;
pi = INTEGER(current_indices);
int *ps;
ps = INTEGER(start);
int *pc;
pc = INTEGER(counters);
for(int i = 0; i < m; ++i) {
pi[i] = ps[i] + pc[i];
}
}
// [[Rcpp::export(C_sub2ind_slice)]]
SEXP C_sub2ind_slice(
SEXP start, SEXP end, SEXP by, R_xlen_t total, SEXP xdim, SEXP dimcumprod
) {
int m = Rf_length(xdim);
IntegerVector counters = rep(0, m);
IntegerVector indices = clone(start);
double *restrict pout;
SEXP out = PROTECT(allocVector(REALSXP, total));
pout = REAL(out);
for(R_xlen_t i = 0; i < total; ++i) {
pout[i] = C_sub2ind_lincomb1(indices, dimcumprod, m);
C_sub2ind_count(counters, start, end, by, m);
C_sub2ind_set_indices(indices, counters, start, m);
}
UNPROTECT(1);
return out;
}
"
)
Rcpp::sourceCpp(
code = "
#include <Rcpp.h>
using namespace Rcpp;
// [[Rcpp::export(C_sub2ind_lincomb1)]]
double C_sub2ind_lincomb1(
const SEXP indices, const SEXP dimcumprod, const int m
) {
int *pi;
pi = INTEGER(indices);
double *pdim;
pdim = REAL(dimcumprod);
double out = pi[0];
for(int i = 1; i < m; ++i) {
out = out + pdim[i - 1] * (pi[i] - 1);
}
return(out);
}
// [[Rcpp::export(C_sub2ind_count)]]
void C_sub2ind_count(
SEXP counters,
const SEXP start,
const SEXP end,
const SEXP by,
const int m
) {
int *ps;
ps = INTEGER(start);
int *pe;
pe = INTEGER(end);
int *pc;
pc = INTEGER(counters);
int *pby;
pby = INTEGER(by);
pc[0] = pc[0] + pby[0];
for(int i = 0; i < (m-1); ++i) {
if((ps[i] + pc[i]) > pe[i]) {
pc[i] = 0;
pc[i + 1] = pc[i + 1] + pby[i + 1];
}
}
}
// [[Rcpp::export(C_sub2ind_set_indices)]]
void C_sub2ind_set_indices(
SEXP current_indices,
SEXP counters,
SEXP start,
int m
) {
int *pi;
pi = INTEGER(current_indices);
int *ps;
ps = INTEGER(start);
int *pc;
pc = INTEGER(counters);
for(int i = 0; i < m; ++i) {
pi[i] = ps[i] + pc[i];
}
}
// [[Rcpp::export(C_sub2ind_slice)]]
SEXP C_sub2ind_slice(
SEXP start, SEXP end, SEXP by, R_xlen_t total, SEXP xdim, SEXP dimcumprod
) {
int m = Rf_length(xdim);
IntegerVector counters = rep(0, m);
IntegerVector indices = clone(start);
double *restrict pout;
SEXP out = PROTECT(Rf_allocVector(REALSXP, total));
pout = REAL(out);
for(R_xlen_t i = 0; i < total; ++i) {
pout[i] = C_sub2ind_lincomb1(indices, dimcumprod, m);
C_sub2ind_count(counters, start, end, by, m);
C_sub2ind_set_indices(indices, counters, start, m);
}
UNPROTECT(1);
return out;
}
"
)
Rcpp::sourceCpp(
code = "
#include <Rcpp.h>
using namespace Rcpp;
// [[Rcpp::export(C_sub2ind_lincomb1)]]
double C_sub2ind_lincomb1(
const SEXP indices, const SEXP dimcumprod, const int m
) {
int *pi;
pi = INTEGER(indices);
double *pdim;
pdim = REAL(dimcumprod);
double out = pi[0];
for(int i = 1; i < m; ++i) {
out = out + pdim[i - 1] * (pi[i] - 1);
}
return(out);
}
// [[Rcpp::export(C_sub2ind_count)]]
void C_sub2ind_count(
SEXP counters,
const SEXP start,
const SEXP end,
const SEXP by,
const int m
) {
int *ps;
ps = INTEGER(start);
int *pe;
pe = INTEGER(end);
int *pc;
pc = INTEGER(counters);
int *pby;
pby = INTEGER(by);
pc[0] = pc[0] + pby[0];
for(int i = 0; i < (m-1); ++i) {
if((ps[i] + pc[i]) > pe[i]) {
pc[i] = 0;
pc[i + 1] = pc[i + 1] + pby[i + 1];
}
}
}
// [[Rcpp::export(C_sub2ind_set_indices)]]
void C_sub2ind_set_indices(
SEXP current_indices,
SEXP counters,
SEXP start,
int m
) {
int *pi;
pi = INTEGER(current_indices);
int *ps;
ps = INTEGER(start);
int *pc;
pc = INTEGER(counters);
for(int i = 0; i < m; ++i) {
pi[i] = ps[i] + pc[i];
}
}
// [[Rcpp::export(C_sub2ind_slice)]]
SEXP C_sub2ind_slice(
SEXP start, SEXP end, SEXP by, R_xlen_t total, SEXP xdim, SEXP dimcumprod
) {
int m = Rf_length(xdim);
IntegerVector counters = rep(0, m);
IntegerVector indices = clone(start);
double *pout;
SEXP out = PROTECT(Rf_allocVector(REALSXP, total));
pout = REAL(out);
for(R_xlen_t i = 0; i < total; ++i) {
pout[i] = C_sub2ind_lincomb1(indices, dimcumprod, m);
C_sub2ind_count(counters, start, end, by, m);
C_sub2ind_set_indices(indices, counters, start, m);
}
UNPROTECT(1);
return out;
}
"
)
start <- c(1L, 2L, 3L)
end <- c(3L, 5L, 7L) * 50L
by <- 1:3
sub <- mapply(seq.int, from = start, to = end, by = by)
x.dim <- rep(500L, 3)
x.len <- prod(x.dim)
dimcumprod <- cumprod(x.dim)
n <- length(x.dim)
ns <- collapse::vlengths(sub)
total <- prod(ns)
expected <- squarebrackets:::.sub2ind_general(sub, x.dim)
out <- rcpp_sub2ind_slice(start, end, by, total, x.dim, dimcumprod)
Rcpp::sourceCpp(
code = "
#include <Rcpp.h>
using namespace Rcpp;
// [[Rcpp::export(C_sub2ind_lincomb1)]]
double C_sub2ind_lincomb1(
const SEXP indices, const SEXP dimcumprod, const int m
) {
int *pi;
pi = INTEGER(indices);
double *pdim;
pdim = REAL(dimcumprod);
double out = pi[0];
for(int i = 1; i < m; ++i) {
out = out + pdim[i - 1] * (pi[i] - 1);
}
return(out);
}
// [[Rcpp::export(C_sub2ind_count)]]
void C_sub2ind_count(
SEXP counters,
const SEXP start,
const SEXP end,
const SEXP by,
const int m
) {
int *ps;
ps = INTEGER(start);
int *pe;
pe = INTEGER(end);
int *pc;
pc = INTEGER(counters);
int *pby;
pby = INTEGER(by);
pc[0] = pc[0] + pby[0];
for(int i = 0; i < (m-1); ++i) {
if((ps[i] + pc[i]) > pe[i]) {
pc[i] = 0;
pc[i + 1] = pc[i + 1] + pby[i + 1];
}
}
}
// [[Rcpp::export(C_sub2ind_set_indices)]]
void C_sub2ind_set_indices(
SEXP current_indices,
SEXP counters,
SEXP start,
int m
) {
int *pi;
pi = INTEGER(current_indices);
int *ps;
ps = INTEGER(start);
int *pc;
pc = INTEGER(counters);
for(int i = 0; i < m; ++i) {
pi[i] = ps[i] + pc[i];
}
}
// [[Rcpp::export(C_sub2ind_slice)]]
SEXP C_sub2ind_slice(
SEXP start, SEXP end, SEXP by, R_xlen_t total, SEXP xdim, SEXP dimcumprod
) {
int m = Rf_length(xdim);
IntegerVector counters = rep(0, m);
IntegerVector indices = clone(start);
double out;
for(R_xlen_t i = 0; i < total; ++i) {
out = C_sub2ind_lincomb1(indices, dimcumprod, m);
C_sub2ind_count(counters, start, end, by, m);
C_sub2ind_set_indices(indices, counters, start, m);
}
return out;
}
"
)
Rcpp::sourceCpp(
code = "
#include <Rcpp.h>
using namespace Rcpp;
// [[Rcpp::export(C_sub2ind_lincomb1)]]
double C_sub2ind_lincomb1(
const SEXP indices, const SEXP dimcumprod, const int m
) {
int *pi;
pi = INTEGER(indices);
double *pdim;
pdim = REAL(dimcumprod);
double out = pi[0];
for(int i = 1; i < m; ++i) {
out = out + pdim[i - 1] * (pi[i] - 1);
}
return(out);
}
// [[Rcpp::export(C_sub2ind_count)]]
void C_sub2ind_count(
SEXP counters,
const SEXP start,
const SEXP end,
const SEXP by,
const int m
) {
int *ps;
ps = INTEGER(start);
int *pe;
pe = INTEGER(end);
int *pc;
pc = INTEGER(counters);
int *pby;
pby = INTEGER(by);
pc[0] = pc[0] + pby[0];
for(int i = 0; i < (m-1); ++i) {
if((ps[i] + pc[i]) > pe[i]) {
pc[i] = 0;
pc[i + 1] = pc[i + 1] + pby[i + 1];
}
}
}
// [[Rcpp::export(C_sub2ind_set_indices)]]
void C_sub2ind_set_indices(
SEXP current_indices,
SEXP counters,
SEXP start,
int m
) {
int *pi;
pi = INTEGER(current_indices);
int *ps;
ps = INTEGER(start);
int *pc;
pc = INTEGER(counters);
for(int i = 0; i < m; ++i) {
pi[i] = ps[i] + pc[i];
}
}
// [[Rcpp::export(C_sub2ind_slice)]]
void C_sub2ind_slice(
SEXP start, SEXP end, SEXP by, R_xlen_t total, SEXP xdim, SEXP dimcumprod
) {
int m = Rf_length(xdim);
IntegerVector counters = rep(0, m);
IntegerVector indices = clone(start);
double out;
for(R_xlen_t i = 0; i < total; ++i) {
out = C_sub2ind_lincomb1(indices, dimcumprod, m);
C_sub2ind_count(counters, start, end, by, m);
C_sub2ind_set_indices(indices, counters, start, m);
}
}
"
)
start <- c(1L, 2L, 3L)
end <- c(3L, 5L, 7L) * 50L
by <- 1:3
sub <- mapply(seq.int, from = start, to = end, by = by)
x.dim <- rep(500L, 3)
x.len <- prod(x.dim)
dimcumprod <- cumprod(x.dim)
n <- length(x.dim)
ns <- collapse::vlengths(sub)
total <- prod(ns)
expected <- squarebrackets:::.sub2ind_general(sub, x.dim)
out <- rcpp_sub2ind_slice(start, end, by, total, x.dim, dimcumprod)
x <- array(1:prod(x.dim), dim = x.dim)
y <- cbind(expected, out, x[sub[[1]], sub[[2]], sub[[3]]])
Rcpp::sourceCpp(
code = "
#include <Rcpp.h>
using namespace Rcpp;
// [[Rcpp::export(C_sub2ind_lincomb1)]]
double C_sub2ind_lincomb1(
const SEXP indices, const SEXP dimcumprod, const int m
) {
int *pi;
pi = INTEGER(indices);
double *pdim;
pdim = REAL(dimcumprod);
double out = pi[0];
for(int i = 1; i < m; ++i) {
out = out + pdim[i - 1] * (pi[i] - 1);
}
return(out);
}
// [[Rcpp::export(C_sub2ind_count)]]
void C_sub2ind_count(
SEXP counters,
const SEXP start,
const SEXP end,
const SEXP by,
const int m
) {
int *ps;
ps = INTEGER(start);
int *pe;
pe = INTEGER(end);
int *pc;
pc = INTEGER(counters);
int *pby;
pby = INTEGER(by);
pc[0] = pc[0] + pby[0];
for(int i = 0; i < (m-1); ++i) {
if((ps[i] + pc[i]) > pe[i]) {
pc[i] = 0;
pc[i + 1] = pc[i + 1] + pby[i + 1];
}
}
}
// [[Rcpp::export(C_sub2ind_set_indices)]]
void C_sub2ind_set_indices(
SEXP current_indices,
SEXP counters,
SEXP start,
int m
) {
int *pi;
pi = INTEGER(current_indices);
int *ps;
ps = INTEGER(start);
int *pc;
pc = INTEGER(counters);
for(int i = 0; i < m; ++i) {
pi[i] = ps[i] + pc[i];
}
}
// [[Rcpp::export(C_sub2ind_slice)]]
void C_sub2ind_slice(
SEXP start, SEXP end, SEXP by, R_xlen_t total, SEXP xdim, SEXP dimcumprod
) {
int m = Rf_length(xdim);
IntegerVector counters = rep(0, m);
IntegerVector indices = clone(start);
double out;
for(R_xlen_t i = 0; i < total; ++i) {
out = C_sub2ind_lincomb1(indices, dimcumprod, m);
C_sub2ind_count(counters, start, end, by, m);
C_sub2ind_set_indices(indices, counters, start, m);
}
}
"
)
foo <- bench::mark(
sb_general = squarebrackets:::.sub2ind_general(sub, x.dim),
slice = rcpp_sub2ind_slice(start, end, by, total, x.dim, dimcumprod),
min_iterations = 400,
check = FALSE
)
summary(foo)
ggplot2::autoplot(foo)
# sub2ind vs base R ====
library(squarebrackets)
n <- 1000
x.dim <- c(1000, 1000, 100)
x.len <- prod(x.dim)
x <- array(1:x.len, dim = x.dim)
sub <- n(1:900, 1:900, 1:90)
ind <- sub2ind(sub, x.dim, checks = FALSE)
foo <- bench::mark(
base = x[1:900, 1:900, 1:90],
sub2ind = sub2ind(sub, dim(x), checks = FALSE),
linear = x[ind],
min_iterations = 500,
check = FALSE
)
summary(foo)
ggplot2::autoplot(foo)
setwd("D:/D Desktop/Publications/R package squarebrackets/squarebrackets/vignettes/articles")
library(squarebrackets)
library(ggplot2)
library(data.table)
loadNamespace("bench")
library(future.apply)
x.dim <- c(200, 200, 100)
x.len <- prod(x.dim)
x <- array(1:x.len, dim = x.dim)
sub <- n(1:150, 1:150, 1:90)
ind <- sub2ind(sub, x.dim, checks = FALSE)
bm.sub2ind <- bench::mark(
base = x[1:150, 1:150, 1:90] |> as.vector(),
sub2ind = sub2ind(sub, dim(x), checks = FALSE),
min_iterations = 500
)
x.dim <- c(400, 400, 100)
x.len <- prod(x.dim)
x <- array(1:x.len, dim = x.dim)
x.dim <- c(500, 500, 100)
x.len <- prod(x.dim)
x <- array(1:x.len, dim = x.dim)
x.dim <- c(500, 500, 100)
x.len <- prod(x.dim)
x <- array(1:x.len, dim = x.dim)
sub <- n(1:450, 1:450, 1:90)
ind <- sub2ind(sub, x.dim, checks = FALSE)
bm.sub2ind <- bench::mark(
base = x[1:450, 1:450, 1:90] |> as.vector(),
sub2ind = sub2ind(sub, dim(x), checks = FALSE),
min_iterations = 500
)
summary(bm.sub2ind)
ggplot2::autoplot(bm.sub2ind)
as.integer
pryr::object_size(bm.sub2ind)
bm.sub2ind$result <- NULL
pryr::object_size(bm.sub2ind)
summary(bm.sub2ind)
ggplot2::autoplot(bm.sub2ind)
save(bm.sub2ind, file = "bm.sub2ind.RData")
getwd()
