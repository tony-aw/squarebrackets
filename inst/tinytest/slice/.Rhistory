library(tinytest)
# install(file.path("D:/D Desktop/Publications/ImageMagick-7.1.0-62-Q16-HDRI-x64-dll"))
# tinytex::install_tinytex()
# tinytex::tlmgr_install("unfonts-extra")
# tinytex::tlmgr_install("makeindex")
#  create("squarebrackets")
# Rcpp::Rcpp.package.skeleton("squarebrackets")
# set version ====
package_tarname <- "squarebrackets_0.0.0.9.tar.gz"
# document ====
Rcpp::compileAttributes("squarebrackets")
devtools::document("./squarebrackets")
# codetools checks:
codetools::checkUsagePackage("squarebrackets")
ns <- loadNamespace("squarebrackets") |> as.list(all.names = TRUE)
ns <- ns[!stringi::stri_detect(names(ns), fixed = ".__")]
checks <- sapply(ns, \(x) any(deparse(x) |> stringi::stri_detect(regex = "return")))
names(checks)[!checks] |> sort()
# if(!require(tinytest)){install.packages("tinytest")}
# tinytest::setup_tinytest("./squarebrackets")
# check package in general:
# Note: edit .Rbuildignore to make it ignore things R CMD CHECK should not check
devtools::run_examples("./squarebrackets", fresh = TRUE)
tinytest::run_test_dir("./squarebrackets/inst/tinytest/slice")
setwd("D:/D Desktop/Publications/R package squarebrackets/squarebrackets/inst/tinytest/slice")
# set-up ====
enumerate <- 0
sys.source(file.path(getwd(), "source", "functions4testing.R"), envir = environment())
tempfun1 <- function(x, from = NULL, to = NULL, by = 1L, tf) {
myslice <- cp_seq(x, 0L, from, to, by)
start <- myslice$start
end <- myslice$end
by <- myslice$by
ind <- seq(start, end, by)
x[ind] <- as.integer(tf(x[ind]))
return(x)
}
tempfun2 <- function(x, from = NULL, to = NULL, by = 1L, tf) {
slice_set(x, from, to, by, tf = tf)
expect_equal(x, y) |> errorfun()
return(x)
}
list_fromto <- list(
1, -1i, 2, -2i, 10, -10i, 100, -100i, 99, -99i, 98, -98i
)
list_by <- list(
1, 2, 3, 100, -1, -2, -3, -100
)
n <- length(list_fromto) * length(list_fromto) * length(list_by)
# equal length replacement ====
x <- mutable_atomic(1:100)
expected <- out <- vector("list", n)
counter <- 1L
for(iF in seq_along(list_fromto)) {
for(iT in seq_along(list_fromto)) {
for(iB in seq_along(list_by)) {
from = list_fromto[[iF]]
to = list_fromto[[iT]]
by = list_by[[iB]]
expected[[counter]] <- tempfun1(x, from, to, by, \(x) x^2)
out[[counter]] <- tempfun2(x, from, to, by, \(x) x^2)
counter <- counter + 1L
enumerate <- enumerate + 1L
}
}
}
# set-up ====
enumerate <- 0
sys.source(file.path(getwd(), "source", "functions4testing.R"), envir = environment())
tempfun1 <- function(x, from = NULL, to = NULL, by = 1L, tf) {
myslice <- cp_seq(x, 0L, from, to, by)
start <- myslice$start
end <- myslice$end
by <- myslice$by
ind <- seq(start, end, by)
x[ind] <- as.integer(tf(x[ind]))
return(x)
}
tempfun2 <- function(x, from = NULL, to = NULL, by = 1L, tf) {
x <- data.table::copy(x)
slice_set(x, from, to, by, tf = tf)
return(x)
}
# vector ====
x.data <- list(
sample(c(TRUE, FALSE, NA), 100, TRUE),
sample(c(1:98, NA, NA)),
rnorm(100),
sample(c(NA, NaN, -Inf, Inf, 0), 100, TRUE),
sample(c(letters, LETTERS, NA, NA), 100, TRUE),
as.complex(c(1:99, NA)),
as.raw(0:99),
rep(NA, 100)
)
# vector ====
x.data <- list(
sample(c(TRUE, FALSE, NA), 100, TRUE),
sample(c(1:98, NA, NA)),
rnorm(100),
sample(c(NA, NaN, -Inf, Inf, 0), 100, TRUE),
sample(c(letters, LETTERS, NA, NA), 100, TRUE),
as.complex(c(1:99, NA)),
as.raw(0:99),
rep(NA, 100)
)
x.data <- lapply(x, as.mutable_atomic)
# vector ====
x.data <- list(
sample(c(TRUE, FALSE, NA), 100, TRUE),
sample(c(1:98, NA, NA)),
rnorm(100),
sample(c(NA, NaN, -Inf, Inf, 0), 100, TRUE),
sample(c(letters, LETTERS, NA, NA), 100, TRUE),
as.complex(c(1:99, NA)),
as.raw(0:99),
rep(NA, 100)
)
x.data <- lapply(x.data, as.mutable_atomic)
# set-up ====
enumerate <- 0
sys.source(file.path(getwd(), "source", "functions4testing.R"), envir = environment())
tempfun1 <- function(x, from = NULL, to = NULL, by = 1L, tf) {
myslice <- cp_seq(x, 0L, from, to, by)
start <- myslice$start
end <- myslice$end
by <- myslice$by
ind <- seq(start, end, by)
x[ind] <- tf(x[ind])
return(x)
}
tempfun2 <- function(x, from = NULL, to = NULL, by = 1L, tf) {
x <- data.table::copy(x)
slice_set(x, from, to, by, tf = tf)
return(x)
}
list_fromto <- list(
1, -1i, 2, -2i, 10, -10i, 100, -100i, 99, -99i, 98, -98i
)
list_by <- list(
1, 2, 3, 100, -1, -2, -3, -100
)
n <- length(list_fromto) * length(list_fromto) * length(list_by)
x.data <- list(
sample(c(TRUE, FALSE, NA), 100, TRUE),
sample(c(1:98, NA, NA)),
rnorm(100),
sample(c(NA, NaN, -Inf, Inf, 0), 100, TRUE),
sample(c(letters, LETTERS, NA, NA), 100, TRUE),
as.complex(c(1:99, NA)),
as.raw(0:99),
rep(NA, 100)
)
x.data <- lapply(x.data, as.mutable_atomic)
# set-up ====
enumerate <- 0
sys.source(file.path(getwd(), "source", "functions4testing.R"), envir = environment())
tempfun1 <- function(x, from = NULL, to = NULL, by = 1L, tf) {
myslice <- cp_seq(x, 0L, from, to, by)
start <- myslice$start
end <- myslice$end
by <- myslice$by
ind <- seq(start, end, by)
x[ind] <- tf(x[ind])
return(x)
}
tempfun2 <- function(x, from = NULL, to = NULL, by = 1L, tf) {
x <- data.table::copy(x)
slice_set(x, from, to, by, tf = tf)
return(x)
}
list_fromto <- list(
1, -1i, 2, -2i, 10, -10i, 100, -100i, 99, -99i, 98, -98i
)
list_by <- list(
1, 2, 3, 100, -1, -2, -3, -100
)
n <- length(list_fromto) * length(list_fromto) * length(list_by)
x.data <- list(
sample(c(TRUE, FALSE, NA), 100, TRUE),
sample(c(1:98, NA, NA)),
rnorm(100),
sample(c(NA, NaN, -Inf, Inf, 0), 100, TRUE),
sample(c(letters, LETTERS, NA, NA), 100, TRUE),
as.complex(c(1:99, NA)),
as.raw(0:99),
rep(NA, 100)
)
x.data <- lapply(x.data, as.mutable_atomic)
# set-up ====
enumerate <- 0
sys.source(file.path(getwd(), "source", "functions4testing.R"), envir = environment())
tempfun1 <- function(x, from = NULL, to = NULL, by = 1L, tf) {
myslice <- cp_seq(x, 0L, from, to, by)
start <- myslice$start
end <- myslice$end
by <- myslice$by
ind <- seq(start, end, by)
x[ind] <- tf(x[ind])
return(x)
}
tempfun2 <- function(x, from = NULL, to = NULL, by = 1L, tf) {
x <- data.table::copy(x)
slice_set(x, from, to, by, tf = tf)
return(x)
}
list_fromto <- list(
1, -1i, 2, -2i, 10, -10i, 100, -100i, 99, -99i, 98, -98i
)
list_by <- list(
1, 2, 3, 100, -1, -2, -3, -100
)
n <- length(list_fromto) * length(list_fromto) * length(list_by)
x.data <- list(
sample(c(TRUE, FALSE, NA), 100, TRUE),
sample(c(1:98, NA, NA)),
rnorm(100),
sample(c(NA, NaN, -Inf, Inf, 0), 100, TRUE),
sample(c(letters, LETTERS, NA, NA), 100, TRUE),
as.complex(c(1:99, NA)),
as.raw(0:99),
rep(NA, 100)
)
n <- length(list_fromto) * length(list_fromto) * length(list_by) * length(x.data)
x.data <- list(
sample(c(TRUE, FALSE, NA), 100, TRUE),
sample(c(1:98, NA, NA)),
rnorm(100),
sample(c(NA, NaN, -Inf, Inf, 0), 100, TRUE),
sample(c(letters, LETTERS, NA, NA), 100, TRUE),
as.complex(c(1:99, NA)),
as.raw(0:99),
rep(NA, 100)
)
x.data <- lapply(x.data, as.mutable_atomic)
n <- length(list_fromto) * length(list_fromto) * length(list_by) * length(x.data)
# equal length replacement ====
for(iType in seq_along(x.data)) {
# set-up ====
enumerate <- 0
sys.source(file.path(getwd(), "source", "functions4testing.R"), envir = environment())
tempfun1 <- function(x, from = NULL, to = NULL, by = 1L, tf) {
myslice <- cp_seq(x, 0L, from, to, by)
start <- myslice$start
end <- myslice$end
by <- myslice$by
ind <- seq(start, end, by)
x[ind] <- tf(x[ind])
return(x)
}
tempfun2 <- function(x, from = NULL, to = NULL, by = 1L, tf) {
x <- data.table::copy(x)
slice_set(x, from, to, by, tf = tf)
return(x)
}
list_fromto <- list(
1, -1i, 2, -2i, 10, -10i, 100, -100i, 99, -99i, 98, -98i
)
list_by <- list(
1, 2, 3, 100, -1, -2, -3, -100
)
x.data <- list(
sample(c(TRUE, FALSE, NA), 100, TRUE),
sample(c(1:98, NA, NA)),
rnorm(100),
sample(c(NA, NaN, -Inf, Inf, 0), 100, TRUE),
sample(c(letters, LETTERS, NA, NA), 100, TRUE),
as.complex(c(1:99, NA)),
as.raw(0:99),
rep(NA, 100)
)
x.data <- lapply(x.data, as.mutable_atomic)
n <- length(list_fromto) * length(list_fromto) * length(list_by) * length(x.data)
# set-up ====
enumerate <- 0
sys.source(file.path(getwd(), "source", "functions4testing.R"), envir = environment())
tempfun1 <- function(x, from = NULL, to = NULL, by = 1L, tf) {
myslice <- cp_seq(x, 0L, from, to, by)
start <- myslice$start
end <- myslice$end
by <- myslice$by
ind <- seq(start, end, by)
x[ind] <- tf(x[ind])
return(x)
}
tempfun2 <- function(x, from = NULL, to = NULL, by = 1L, tf) {
x <- data.table::copy(x)
slice_set(x, from, to, by, tf = tf)
return(x)
}
list_fromto <- list(
1, -1i, 2, -2i, 10, -10i, 100, -100i, 99, -99i, 98, -98i
)
list_by <- list(
1, 2, 3, 100, -1, -2, -3, -100
)
x.data <- list(
sample(c(TRUE, FALSE, NA), 100, TRUE),
sample(c(1:98, NA, NA)),
rnorm(100),
sample(c(NA, NaN, -Inf, Inf, 0), 100, TRUE),
sample(c(letters, LETTERS, NA, NA), 100, TRUE),
as.complex(c(1:99, NA)),
as.raw(0:99),
rep(NA, 100)
)
x.data <- lapply(x.data, as.mutable_atomic)
n <- length(list_fromto) * length(list_fromto) * length(list_by) * length(x.data)
# equal length replacement ====
# equal length replacement ====
x <- x.data[[iType]]
n <- length(list_fromto) * length(list_fromto) * length(list_by)
# equal length replacement ====
x <- x.data[[iType]]
expected <- out <- vector("list", n)
for(iType in seq_along(x.data)) {
x <- x.data[[iType]]
expected <- out <- vector("list", n)
counter <- 1L
for(iF in seq_along(list_fromto)) {
for(iT in seq_along(list_fromto)) {
for(iB in seq_along(list_by)) {
from = list_fromto[[iF]]
to = list_fromto[[iT]]
by = list_by[[iB]]
expected[[counter]] <- tempfun1(x, from, to, by, rev)
out[[counter]] <- tempfun2(x, from, to, by, rev
counter <- counter + 1L
# equal length replacement ====
for(iType in seq_along(x.data)) {
x <- x.data[[iType]]
expected <- out <- vector("list", n)
counter <- 1L
for(iF in seq_along(list_fromto)) {
for(iT in seq_along(list_fromto)) {
for(iB in seq_along(list_by)) {
from = list_fromto[[iF]]
to = list_fromto[[iT]]
by = list_by[[iB]]
expected[[counter]] <- tempfun1(x, from, to, by, rev)
out[[counter]] <- tempfun2(x, from, to, by, rev)
counter <- counter + 1L
enumerate <- enumerate + 1L
}
}
}
expect_equal(expected, out) |> errorfun()
x <- data.table::copy(x.data[[iType]])
y <- x
expect_equal(x, y)
}
# set-up ====
enumerate <- 0
sys.source(file.path(getwd(), "source", "functions4testing.R"), envir = environment())
tempfun1 <- function(x, from = NULL, to = NULL, by = 1L, tf) {
myslice <- cp_seq(x, 0L, from, to, by)
start <- myslice$start
end <- myslice$end
by <- myslice$by
ind <- seq(start, end, by)
x[ind] <- tf(x[ind])
return(x)
}
tempfun2 <- function(x, from = NULL, to = NULL, by = 1L, tf) {
x <- data.table::copy(x)
slice_set(x, from, to, by, tf = tf)
return(x)
}
list_fromto <- list(
1, -1i, 2, -2i, 10, -10i, 100, -100i, 99, -99i, 98, -98i
)
list_by <- list(
1, 2, 3, 100, -1, -2, -3, -100
)
x.data <- list(
sample(c(TRUE, FALSE, NA), 100, TRUE),
sample(c(1:98, NA, NA)),
rnorm(100),
sample(c(NA, NaN, -Inf, Inf, 0), 100, TRUE),
sample(c(letters, LETTERS, NA, NA), 100, TRUE),
as.complex(c(1:99, NA)),
as.raw(0:99),
rep(NA, 100)
)
x.data <- lapply(x.data, as.mutable_atomic)
n <- length(list_fromto) * length(list_fromto) * length(list_by)
# equal length replacement ====
for(iType in seq_along(x.data)) {
x <- x.data[[iType]]
expected <- out <- vector("list", n)
counter <- 1L
for(iF in seq_along(list_fromto)) {
for(iT in seq_along(list_fromto)) {
for(iB in seq_along(list_by)) {
from = list_fromto[[iF]]
to = list_fromto[[iT]]
by = list_by[[iB]]
expected[[counter]] <- tempfun1(x, from, to, by, rev)
out[[counter]] <- tempfun2(x, from, to, by, rev)
counter <- counter + 1L
}
}
}
expect_equal(expected, out) |> errorfun()
x <- data.table::copy(x.data[[iType]])
y <- x
expect_equal(x, y)
enumerate <- enumerate + n + 1
}
# singular replacement ====
for(iType in seq_along(x.data)) {
x <- x.data[[iType]]
expected <- out <- vector("list", n)
counter <- 1L
for(iF in seq_along(list_fromto)) {
for(iT in seq_along(list_fromto)) {
for(iB in seq_along(list_by)) {
from = list_fromto[[iF]]
to = list_fromto[[iT]]
by = list_by[[iB]]
expected[[counter]] <- tempfun1(x, from, to, by, \(x)x[1])
out[[counter]] <- tempfun2(x, from, to, by, \(x)x[1])
counter <- counter + 1L
}
}
}
expect_equal(expected, out) |> errorfun()
x <- data.table::copy(x.data[[iType]])
y <- x
expect_equal(x, y)
enumerate <- enumerate + n + 1
}
# set-up ====
enumerate <- 0
sys.source(file.path(getwd(), "source", "functions4testing.R"), envir = environment())
tempfun1 <- function(x, from = NULL, to = NULL, by = 1L, tf) {
myslice <- cp_seq(x, 0L, from, to, by)
start <- myslice$start
end <- myslice$end
by <- myslice$by
ind <- seq(start, end, by)
x[ind] <- tf(x[ind])
return(x)
}
tempfun2 <- function(x, from = NULL, to = NULL, by = 1L, tf) {
x <- data.table::copy(x)
slice_set(x, from, to, by, tf = tf)
return(x)
}
list_fromto <- list(
1, -1i, 2, -2i, 10, -10i, 100, -100i, 99, -99i, 98, -98i
)
list_by <- list(
1, 2, 3, 100, -1, -2, -3, -100
)
x.data <- list(
sample(c(TRUE, FALSE, NA), 100, TRUE),
sample(c(1:98, NA, NA)),
rnorm(100),
sample(c(NA, NaN, -Inf, Inf, 0), 100, TRUE),
sample(c(letters, LETTERS, NA, NA), 100, TRUE),
as.complex(c(1:99, NA)),
as.raw(0:99),
rep(NA, 100)
)
x.data <- lapply(x.data, as.mutable_atomic)
n <- length(list_fromto) * length(list_fromto) * length(list_by)
# equal length replacement ====
for(iType in seq_along(x.data)) {
x <- x.data[[iType]]
expected <- out <- vector("list", n)
counter <- 1L
for(iF in seq_along(list_fromto)) {
for(iT in seq_along(list_fromto)) {
for(iB in seq_along(list_by)) {
from = list_fromto[[iF]]
to = list_fromto[[iT]]
by = list_by[[iB]]
expected[[counter]] <- tempfun1(x, from, to, by, rev)
out[[counter]] <- tempfun2(x, from, to, by, rev)
counter <- counter + 1L
}
}
}
expect_equal(expected, out) |> errorfun()
x <- data.table::copy(x.data[[iType]])
y <- x
expect_equal(x, y) |> errorfun()
enumerate <- enumerate + n + 1
}
# singular replacement ====
for(iType in seq_along(x.data)) {
x <- x.data[[iType]]
expected <- out <- vector("list", n)
counter <- 1L
for(iF in seq_along(list_fromto)) {
for(iT in seq_along(list_fromto)) {
for(iB in seq_along(list_by)) {
from = list_fromto[[iF]]
to = list_fromto[[iT]]
by = list_by[[iB]]
expected[[counter]] <- tempfun1(x, from, to, by, \(x)x[1])
out[[counter]] <- tempfun2(x, from, to, by, \(x)x[1])
counter <- counter + 1L
}
}
}
expect_equal(expected, out) |> errorfun()
x <- data.table::copy(x.data[[iType]])
y <- x
expect_equal(x, y) |> errorfun()
enumerate <- enumerate + n + 1
}
