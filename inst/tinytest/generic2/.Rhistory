if(dim_diff == -1) {
x.dim <- rep(1, length(dim(y)))
x.dim[-margin] <- dim(x)
dim(x) <- x.dim
}
if((margin - length(dim(x))) > 1) {
dim(x) <- c(dim(x), 1)
dim(y) <- c(dim(y), 1)
}
if((margin - length(dim(x))) > 1) {
stop(simpleError("incompatible margin given", call = abortcall))
}
# error handling:
check_dims <- dim(x)[-margin] == dim(y)[-margin]
if(!all(check_dims)) {
stop(simpleError("incompatible dimensions", call = abortcall))
}
# creating list to be filled ( "filler" )
new_dims <- dim(x)
new_dims[margin] <- dim(x)[margin] + dim(y)[margin]
new_len <- prod(new_dims)
filler <- array(as.list(seq_len(new_len)), dim = new_dims)
# fill filler with x:
dim_args1 <- squarebrackets:::.rcpp_seq_mlen(dim(x))
elements <- sub2ind(dim_args1, new_dims, checks = FALSE)
collapse::setv(filler, elements, x, vind1 = TRUE, xlist = TRUE)
# fill filler with y:
dim_args2 <- squarebrackets:::.rcpp_seq_mlen(new_dims)
rem_margin <- seq_len(dim(x)[margin])
dim_args2[[margin]] <- dim_args2[[margin]][-rem_margin]
elements <- sub2ind(dim_args2, new_dims, checks = FALSE)
collapse::setv(filler, elements, y, vind1 = TRUE, xlist = TRUE)
# return filler:
return(filler)
}
#' @keywords internal
#' @noRd
.sb_in_dimlist_before <- function(x, margin, pos, new, .attr, abortcall) {
n.x <- dim(x)[[margin]]
if(squarebrackets:::.is_prepend(pos, n.x)) {
out <- abind.recursive(new, x, margin, abortcall)
out <- squarebrackets:::.fix_attr(out, .attr)
return(out)
}
out <- abind.recursive(
abind::asub(x, idx = seq_len(pos-1), dims = margin),
new,
margin, abortcall
)
out <- abind.recursive(
out,
abind::asub(x, idx = seq.int(pos, n.x), dims = margin),
margin, abortcall
)
out <- squarebrackets:::.fix_attr(out, .attr)
return(out)
}
#' @keywords internal
#' @noRd
.sb_in_dimlist_after <- function(x, margin, pos, new, .attr, abortcall) {
n.x <- dim(x)[[margin]]
if(squarebrackets:::.is_postpend(pos, n.x)) {
out <- abind.recursive(x, new, margin, abortcall)
out <- squarebrackets:::.fix_attr(out, .attr)
return(out)
}
out <- abind.recursive(
abind::asub(x, idx = seq_len(pos), dims = margin),
new,
margin, abortcall
)
out <- abind.recursive(
out,
abind::asub(x, idx = seq.int(pos+1, n.x), dims = margin),
margin, abortcall
)
out <- squarebrackets:::.fix_attr(out, .attr)
return(out)
}
sb2_before.array <- function(x, new, margin, pos = 1, .attr = NULL, ...) {
if(length(margin)>1 || !is.numeric(margin)) {
stop("`margin` must be a single integer scalar")
}
n <- dim(x)[[margin]]
squarebrackets:::.check_in(pos, n, abortcall = sys.call())
return(.sb_in_dimlist_before(x, margin, pos, new, .attr, abortcall = sys.call()))
}
sb2_after.array <- function(x, new, margin, pos = dim(x)[margin], .attr = NULL, ...) {
if(length(margin)>1 || !is.numeric(margin)) {
stop("`margin` must be a single integer scalar")
}
n <- dim(x)[[margin]]
squarebrackets:::.check_in(pos, n, abortcall = sys.call())
return(.sb_in_dimlist_after(x, margin, pos, new, .attr, abortcall = sys.call()))
}
abind.atomic <- function(x, y, margin, abortcall = sys.call()) {
if(margin < 1) {
stop("`margin` must be a strictly positive number")
}
# fix dims:
dim_diff <- length(dim(x)) - length(dim(y))
if(abs(dim_diff) > 1) {
stop(simpleError("incompatible dimensions", call = abortcall))
}
if(dim_diff == 1) {
dim(y) <- c(dim(y), 1)
}
if(dim_diff == -1) {
dim(x) <- c(dim(x), 1)
}
if((margin - length(dim(x))) > 1) {
dim(x) <- c(dim(x), 1)
dim(y) <- c(dim(y), 1)
}
if((margin - length(dim(x))) > 1) {
stop(simpleError("incompatible margin given", call = abortcall))
}
# error handling:
check_dims <- dim(x)[-margin] == dim(y)[-margin]
if(!all(check_dims)) {
stop(simpleError("incompatible dimensions", call = abortcall))
}
# creating list to be filled ( "filler" )
new_dims <- dim(x)
new_dims[margin] <- dim(x)[margin] + dim(y)[margin]
new_len <- prod(new_dims)
new_ndim <- length(new_dims)
filler <- array(seq_len(new_len), dim = new_dims)
# fill filler with x:
dim_args1 <- squarebrackets:::.rcpp_seq_mlen(dim(x))
elements <- sub2ind(dim_args1, new_dims, checks = FALSE)
# collapse::setv(filler, elements, x, vind1 = TRUE, xlist = FALSE)
# fill filler with y:
dim_args2 <- squarebrackets:::.rcpp_seq_mlen(new_dims)
rem_margin <- seq_len(dim(x)[margin])
dim_args2[[margin]] <- dim_args2[[margin]][-rem_margin]
elements <- sub2ind(dim_args2, new_dims, checks = FALSE)
# collapse::setv(filler, elements, y, vind1 = TRUE, xlist = FALSE)
# return filler:
return(filler)
}
out <- sb2_after.array(yl, newl, margin)
dims <- c(4,4,4)
dims[margin] <- 1
ya <- array(1:64, c(4,4,4))
yl <- array(as.list(1:64), c(4,4,4))
newa <- array(1:16, dim = dims)
newl <- array(as.list(1:16), dim = dims)
out <- sb2_after.array(yl, newl, margin)
expected <- array(as.list(.abind(ya, newa, along = margin)), dim = dim(out))
expected <- array(as.list(abind(ya, newa, along = margin)), dim = dim(out))
expect_equivalent(
out, expected
) |> errorfun()
errorfun <- function(tt) {
if(isTRUE(tt)) print(tt)
if(isFALSE(tt)) stop(print(tt))
}
# set-up ====
library(squarebrackets)
library(abind)
library(listarrays)
errorfun <- function(tt) {
if(isTRUE(tt)) print(tt)
if(isFALSE(tt)) stop(print(tt))
}
################################################################################
# define functions ====
abind.recursive <- function(x, y, margin, abortcall = sys.call()) {
if(margin < 1) {
stop(simpleError("`margin` must be a strictly positive number", call = abortcall))
}
# fix dims:
dim_diff <- length(dim(x)) - length(dim(y))
if(abs(dim_diff) > 1) {
stop(simpleError("incompatible dimensions", call = abortcall))
}
if(dim_diff == 1) {
y.dim <- rep(1, length(dim(x)))
y.dim[-margin] <- dim(y)
dim(y) <- y.dim
}
if(dim_diff == -1) {
x.dim <- rep(1, length(dim(y)))
x.dim[-margin] <- dim(x)
dim(x) <- x.dim
}
if((margin - length(dim(x))) > 1) {
dim(x) <- c(dim(x), 1)
dim(y) <- c(dim(y), 1)
}
if((margin - length(dim(x))) > 1) {
stop(simpleError("incompatible margin given", call = abortcall))
}
# error handling:
check_dims <- dim(x)[-margin] == dim(y)[-margin]
if(!all(check_dims)) {
stop(simpleError("incompatible dimensions", call = abortcall))
}
# creating list to be filled ( "filler" )
new_dims <- dim(x)
new_dims[margin] <- dim(x)[margin] + dim(y)[margin]
new_len <- prod(new_dims)
filler <- array(as.list(seq_len(new_len)), dim = new_dims)
# fill filler with x:
dim_args1 <- squarebrackets:::.rcpp_seq_mlen(dim(x))
elements <- sub2ind(dim_args1, new_dims, checks = FALSE)
collapse::setv(filler, elements, x, vind1 = TRUE, xlist = TRUE)
# fill filler with y:
dim_args2 <- squarebrackets:::.rcpp_seq_mlen(new_dims)
rem_margin <- seq_len(dim(x)[margin])
dim_args2[[margin]] <- dim_args2[[margin]][-rem_margin]
elements <- sub2ind(dim_args2, new_dims, checks = FALSE)
collapse::setv(filler, elements, y, vind1 = TRUE, xlist = TRUE)
# return filler:
return(filler)
}
#' @keywords internal
#' @noRd
.sb_in_dimlist_before <- function(x, margin, pos, new, .attr, abortcall) {
n.x <- dim(x)[[margin]]
if(squarebrackets:::.is_prepend(pos, n.x)) {
out <- abind.recursive(new, x, margin, abortcall)
out <- squarebrackets:::.fix_attr(out, .attr)
return(out)
}
out <- abind.recursive(
abind::asub(x, idx = seq_len(pos-1), dims = margin),
new,
margin, abortcall
)
out <- abind.recursive(
out,
abind::asub(x, idx = seq.int(pos, n.x), dims = margin),
margin, abortcall
)
out <- squarebrackets:::.fix_attr(out, .attr)
return(out)
}
#' @keywords internal
#' @noRd
.sb_in_dimlist_after <- function(x, margin, pos, new, .attr, abortcall) {
n.x <- dim(x)[[margin]]
if(squarebrackets:::.is_postpend(pos, n.x)) {
out <- abind.recursive(x, new, margin, abortcall)
out <- squarebrackets:::.fix_attr(out, .attr)
return(out)
}
out <- abind.recursive(
abind::asub(x, idx = seq_len(pos), dims = margin),
new,
margin, abortcall
)
out <- abind.recursive(
out,
abind::asub(x, idx = seq.int(pos+1, n.x), dims = margin),
margin, abortcall
)
out <- squarebrackets:::.fix_attr(out, .attr)
return(out)
}
sb2_before.array <- function(x, new, margin, pos = 1, .attr = NULL, ...) {
if(length(margin)>1 || !is.numeric(margin)) {
stop("`margin` must be a single integer scalar")
}
n <- dim(x)[[margin]]
squarebrackets:::.check_in(pos, n, abortcall = sys.call())
return(.sb_in_dimlist_before(x, margin, pos, new, .attr, abortcall = sys.call()))
}
sb2_after.array <- function(x, new, margin, pos = dim(x)[margin], .attr = NULL, ...) {
if(length(margin)>1 || !is.numeric(margin)) {
stop("`margin` must be a single integer scalar")
}
n <- dim(x)[[margin]]
squarebrackets:::.check_in(pos, n, abortcall = sys.call())
return(.sb_in_dimlist_after(x, margin, pos, new, .attr, abortcall = sys.call()))
}
abind.atomic <- function(x, y, margin, abortcall = sys.call()) {
if(margin < 1) {
stop("`margin` must be a strictly positive number")
}
# fix dims:
dim_diff <- length(dim(x)) - length(dim(y))
if(abs(dim_diff) > 1) {
stop(simpleError("incompatible dimensions", call = abortcall))
}
if(dim_diff == 1) {
dim(y) <- c(dim(y), 1)
}
if(dim_diff == -1) {
dim(x) <- c(dim(x), 1)
}
if((margin - length(dim(x))) > 1) {
dim(x) <- c(dim(x), 1)
dim(y) <- c(dim(y), 1)
}
if((margin - length(dim(x))) > 1) {
stop(simpleError("incompatible margin given", call = abortcall))
}
# error handling:
check_dims <- dim(x)[-margin] == dim(y)[-margin]
if(!all(check_dims)) {
stop(simpleError("incompatible dimensions", call = abortcall))
}
# creating list to be filled ( "filler" )
new_dims <- dim(x)
new_dims[margin] <- dim(x)[margin] + dim(y)[margin]
new_len <- prod(new_dims)
new_ndim <- length(new_dims)
filler <- array(seq_len(new_len), dim = new_dims)
# fill filler with x:
dim_args1 <- squarebrackets:::.rcpp_seq_mlen(dim(x))
elements <- sub2ind(dim_args1, new_dims, checks = FALSE)
# collapse::setv(filler, elements, x, vind1 = TRUE, xlist = FALSE)
# fill filler with y:
dim_args2 <- squarebrackets:::.rcpp_seq_mlen(new_dims)
rem_margin <- seq_len(dim(x)[margin])
dim_args2[[margin]] <- dim_args2[[margin]][-rem_margin]
elements <- sub2ind(dim_args2, new_dims, checks = FALSE)
# collapse::setv(filler, elements, y, vind1 = TRUE, xlist = FALSE)
# return filler:
return(filler)
}
dims <- c(4,4,4)
dims[margin] <- 1
ya <- array(1:64, c(4,4,4))
yl <- array(as.list(1:64), c(4,4,4))
newa <- array(1:16, dim = dims)
newl <- array(as.list(1:16), dim = dims)
out <- sb2_after.array(yl, newl, margin)
expected <- array(as.list(abind(ya, newa, along = margin)), dim = dim(out))
expect_equivalent(
out, expected
) |> errorfun()
library(tinytest)
dims <- c(4,4,4)
dims[margin] <- 1
ya <- array(1:64, c(4,4,4))
yl <- array(as.list(1:64), c(4,4,4))
newa <- array(1:16, dim = dims)
newl <- array(as.list(1:16), dim = dims)
out <- sb2_after.array(yl, newl, margin)
expected <- array(as.list(abind(ya, newa, along = margin)), dim = dim(out))
expect_equivalent(
out, expected
) |> errorfun()
out <- sb2_before(yl, newl, margin)
expected <- array(as.list(.abind(newa, ya, along = margin)), dim = dim(out))
out <- sb2_before(yl, newl, margin)
expected <- array(as.list(abind(newa, ya, along = margin)), dim = dim(out))
expect_equivalent(
out, expected
) |> errorfun()
out <- sb2_before(yl, newl, margin, 4)
expected <- abind(
asub(ya, 1:3, dims = margin),
newa,
asub(ya, 4:dim(ya)[margin], dims = margin), along = margin
)
expected <- array(as.list(expected), dim = dim(out))
expect_equivalent(
out, expected
) |> errorfun()
expect_equivalent(
sb_before(y, new, margin, 4),
abind(
asub(y, 1:3, dims = margin),
new,
asub(y, 4:dim(y)[margin], dims = margin), along = margin
)
) |> errorfun()
out <- sb2_after(yl, newl, margin, 4)
out <- sb2_after(yl, newl, margin, 4)
expected <- abind(
asub(ya, 1:2, dims = margin),
newa,
asub(ya, 3:dim(ya)[margin], dims = margin), along = margin
)
expected <- array(as.list(expected), dim = dim(out))
expect_equivalent(
out, expected
) |> errorfun()
out <- sb2_after(yl, newl, margin, 3)
expected <- abind(
asub(ya, 1:2, dims = margin),
newa,
asub(ya, 3:dim(ya)[margin], dims = margin), along = margin
)
expected <- array(as.list(expected), dim = dim(out))
expect_equivalent(
out, expected
) |> errorfun()
out <- sb2_after(yl, newl, margin, 2)
expected <- abind(
asub(ya, 1:2, dims = margin),
newa,
asub(ya, 3:dim(ya)[margin], dims = margin), along = margin
)
expected <- array(as.list(expected), dim = dim(out))
expect_equivalent(
out, expected
) |> errorfun()
for(margin in 1:3) {
dims <- c(4,4,4)
dims[margin] <- 1
ya <- array(1:64, c(4,4,4))
yl <- array(as.list(1:64), c(4,4,4))
newa <- array(1:16, dim = dims)
newl <- array(as.list(1:16), dim = dims)
out <- sb2_after.array(yl, newl, margin)
expected <- array(as.list(abind(ya, newa, along = margin)), dim = dim(out))
expect_equivalent(
out, expected
) |> errorfun()
out <- sb2_before(yl, newl, margin)
expected <- array(as.list(abind(newa, ya, along = margin)), dim = dim(out))
expect_equivalent(
out, expected
) |> errorfun()
out <- sb2_before(yl, newl, margin, 4)
expected <- abind(
asub(ya, 1:3, dims = margin),
newa,
asub(ya, 4:dim(ya)[margin], dims = margin), along = margin
)
expected <- array(as.list(expected), dim = dim(out))
expect_equivalent(
out, expected
) |> errorfun()
out <- sb2_after(yl, newl, margin, 2)
expected <- abind(
asub(ya, 1:2, dims = margin),
newa,
asub(ya, 3:dim(ya)[margin], dims = margin), along = margin
)
expected <- array(as.list(expected), dim = dim(out))
expect_equivalent(
out, expected
) |> errorfun()
enumerate <- enumerate + 4
}
# perform tests ====
enumerate <- 0
for(margin in 1:3) {
dims <- c(4,4,4)
dims[margin] <- 1
ya <- array(1:64, c(4,4,4))
yl <- array(as.list(1:64), c(4,4,4))
newa <- array(1:16, dim = dims)
newl <- array(as.list(1:16), dim = dims)
out <- sb2_after.array(yl, newl, margin)
expected <- array(as.list(abind(ya, newa, along = margin)), dim = dim(out))
expect_equivalent(
out, expected
) |> errorfun()
out <- sb2_before(yl, newl, margin)
expected <- array(as.list(abind(newa, ya, along = margin)), dim = dim(out))
expect_equivalent(
out, expected
) |> errorfun()
out <- sb2_before(yl, newl, margin, 4)
expected <- abind(
asub(ya, 1:3, dims = margin),
newa,
asub(ya, 4:dim(ya)[margin], dims = margin), along = margin
)
expected <- array(as.list(expected), dim = dim(out))
expect_equivalent(
out, expected
) |> errorfun()
out <- sb2_after(yl, newl, margin, 2)
expected <- abind(
asub(ya, 1:2, dims = margin),
newa,
asub(ya, 3:dim(ya)[margin], dims = margin), along = margin
)
expected <- array(as.list(expected), dim = dim(out))
expect_equivalent(
out, expected
) |> errorfun()
enumerate <- enumerate + 4
}
x <- array(as.list(sample(letters, 60, TRUE)), dim = c(5, 4, 3))
y <- array(as.list(40:1), dim = c(1, 4, 3))
out <- abind.recursive(asub(x, 1:2, 1), y, 1)
abind.recursive(out, asub(x, 3:4, 1), 1)
x <- array(1:1e6, dim = c(100,100, 100))
y <- array(-1e6:-1, dim =c(100,100, 100))
abind.atomic(x, y, 3)
# NOTE: squarebrackets needs to be properly installed,
# otherwise speed comparisons will WILDLY off
foo <- bench::mark(
abind::abind(x, y, along = 3),
abind.atomic(x, y, 3),
bind_on_dim(list(x, y), 3),
check = FALSE,
min_iterations = 250
)
foo
ggplot2::autoplot(foo)
x <- array(as.list(1:1e5), dim = c(100,100, 10))
y <- array(as.list(-1e6:-1), dim =c(100,100, 100))
abind.recursive(x, y)
x <- array(as.list(1:1e5), dim = c(100,100, 10))
y <- array(as.list(-1e6:-1), dim =c(100,100, 100))
foo <- bench::mark(
abind.recursive(x, y, 3),
bind_on_dim(list(x, y), 3),
min_iterations = 100
)
foo
ggplot2::autoplot(foo)
