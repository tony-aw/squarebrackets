temp.fun.arbitrary <- function(x, i, j, l) {
if(is.atomic(x)) x <- as.mutable_atomic(x)
tf <- mean
i <- indx_rm(i, x, rownames(x), nrow(x))
j <- indx_rm(j, x, colnames(x), ncol(x))
l <- indx_rm(l, x, dimnames(x)[4], dim(x)[4])
x[i, j, , l] <- tf(x[i, j, , l])
return(x)
}
sys.source(file.path(getwd(), "source", "sourcetest-dims.R"), envir = environment())
# test arbitrary dimensions ====
subset_arr <- function(x, i, j, l, tf) {
i <- indx_rm(i, x, rownames(x), nrow(x))
j <- indx_rm(j, x, colnames(x), ncol(x))
l <- indx_rm(l, x, dimnames(x)[4], dim(x)[4])
x[i, j, , l] <- tf(x[i, j, , l, drop = FALSE])
return(x)
}
x <- as.mutable_atomic(array(seq_len(10^4), dim = c(10, 10, 10, 10)))
rownames(x) <- c(letters[1:8], "a", NA)
tf <- function(x) -x
sub <- list(c("a"), c(1:3), c(rep(TRUE, 5), rep(FALSE, 5)))
dims <- c(1,2,4)
expect_equal(
sb_set2(x, sub, dims, tf = tf),
subset_arr(x, sub[[1]], sub[[2]], sub[[3]], tf)
)
sub <- list(c("a"), logical(0), c(rep(TRUE, 5), rep(FALSE, 5)))
dims <- c(1,2,4)
expect_equal(
sb_set2(x, sub, dims, tf = tf),
subset_arr(x, sub[[1]], sub[[2]], sub[[3]], tf)
)
sub <- list(c("a"), c(1:4), rep(FALSE, 10))
dims <- c(1,2,4)
expect_equal(
sb_set2(x, sub, dims, tf = tf),
subset_arr(x, sub[[1]], sub[[2]], sub[[3]], tf)
)
enumerate <- enumerate + 3
# test errors ====
sb_test <- function(x, ...) {
x <- data.table::copy(x)
sb_set(x, ..., tf = \(x)x[1])
return(x)
}
sys.source(file.path(getwd(), "source", "sourcetest-errors.R"), envir = environment())
x <- as.mutable_atomic(x)
expect_error(
sb_set(x, i = 1, tf = "foo"),
pattern = "`tf` must be a function"
)
enumerate <- enumerate + 1
# report number of tests
enumerate <- enumerate * 2 # pass-by-reference mechanism was also tested simultaneously
print(enumerate)
# set-up ====
enumerate <- 0 # to count number of tests in loops
source(file.path(getwd(), "source", "functions4testing.R"))
test_allow_duplicates <- FALSE
test_use_factors <- FALSE
test_PassByReference <- TRUE
sb_set2 <- function(x, ...) {
x <- data.table::copy(x)
if(is.atomic(x)) x <- as.mutable_atomic(x)
x2 <- x
sb_set(x, ...)
expect_equal(x, x2) |> errorfun()
return(x)
}
sb_set2.array <- function(x, ...) {
x <- data.table::copy(x)
if(is.atomic(x)) x <- as.mutable_atomic(x)
x2 <- x
sb_set.array(x, ...)
expect_equal(x, x2) |> errorfun()
return(x)
}
# test missing arguments (NULL) ====
temp.fun <- function(x) {
tempfun <- function(x) {
x <- as.mutable_atomic(x)
x[] <- x[1]
return(x)
}
expect_equal(
sb_set2(x, tf = \(x)x[1]),
tempfun(x)
) |> errorfun()
}
sys.source(file.path(getwd(), "source", "sourcetest-missingargs.R"), envir = environment())
# test elements ====
test_sb <- function(x, i) {
if(is.atomic(x)) x <- as.mutable_atomic(x)
i <- indx_x(i, x, names(x), length(x))
if(length(i) == 0) return(x)
x[i] <- min(x[i])
return(x)
}
temp.fun <- function(x, elements) {
for (i in 1:length(elements)) {
expect_equal(
sb_set2(x, i = elements[[i]], tf = min),
test_sb(x, i = elements[[i]])
) |> errorfun()
assign("enumerate", enumerate + 1, envir = parent.frame(n = 1))
}
}
sys.source(file.path(getwd(), "source", "sourcetest-elements.R"), envir = environment())
# test matrix & array ====
rep3.bind <- function(x, dim) {
if(is.atomic(x)) x <- as.mutable_atomic(x)
return(abind::abind(x, x, x, along = dim))
}
subset_mat <- function(x, row = NULL, col = NULL) {
if(is.atomic(x)) x <- as.mutable_atomic(x)
tf <- mean
if(!is.null(row)) row <- indx_x(row, x, rownames(x), nrow(x))
if(!is.null(col)) col <- indx_x(col, x, colnames(x), ncol(x))
if(any_empty_indices(row, col)) {
return(x)
}
if(is.null(row)) row <- seq_len(nrow(x))
if(is.null(col)) col <- seq_len(ncol(x))
x[row, col] <- tf(x[row, col])
return(x)
}
temp.fun.matrix <- function(x, row, col) {
for(i in 1:length(row)) {
for(j in 1:length(col)) {
expect_equal(
sb_set2(x, row = row[[i]], col = col[[j]], tf = mean),
subset_mat(x, row[[i]], col[[j]])
) |> errorfun()
expect_true(sb_set2(x, row = row[[i]], col = col[[j]], tf = mean) |>
is.matrix()) |> errorfun()
assign("enumerate", enumerate + 2, envir = parent.frame(n = 1))
}
}
}
subset_1d <- function(x, i) {
if(is.atomic(x)) x <- as.mutable_atomic(x)
tf <- mean
i <- indx_x(i, x, dimnames(x)[[1]], length(x))
x[i] <- tf(x[i])
return(x)
}
temp.fun.1d <- function(x, row) {
for(i in 1:length(row)) {
expect_equal(
sb_set2(x, row[[i]], 1, tf = mean),
subset_1d(x, row[[i]])
) |> errorfun()
expect_true(sb_set2(x, row[[i]], 1, tf = mean) |>
is.array()) |> errorfun()
assign("enumerate", enumerate + 2, envir = parent.frame(n = 1))
}
}
temp.fun.2d <- function(x, row, col) {
for(i in 1:length(row)) {
for(j in 1:length(col)) {
sub <- n(row[[i]], col[[j]])
dims <- 1:2
rem <- which(vapply(sub, is.null, logical(1L)))
if(length(rem) > 0L) {
sub <- sub[-rem]
dims <- dims[-rem]
}
expect_equal(
sb_set2.array(x, sub, dims, tf = mean),
subset_mat(x, row[[i]], col[[j]])
) |> errorfun()
expect_true(sb_set2.array(x, sub, dims, tf = mean) |>
is.array()) |> errorfun()
assign("enumerate", enumerate + 2, envir = parent.frame(n = 1))
}
}
}
sb_test <- function(...) sb_set2.array(..., tf = mean)
temp.fun.arbitrary <- function(x, i, j, l) {
if(is.atomic(x)) x <- as.mutable_atomic(x)
tf <- mean
i <- indx_x(i, x, rownames(x), nrow(x))
j <- indx_x(j, x, colnames(x), ncol(x))
l <- indx_x(l, x, dimnames(x)[4], dim(x)[4])
x[i, j, , l] <- tf(x[i, j, , l])
return(x)
}
sys.source(file.path(getwd(), "source", "sourcetest-dims.R"), envir = environment())
# test errors ====
sb_test <- function(x, ...) {
x <- as.mutable_atomic(x)
sb_set.array(x, ..., tf = \(x)x[1])
return(x)
}
sys.source(file.path(getwd(), "source", "sourcetest-errors.R"), envir = environment())
sb_test <- function(x, ...) {
x <- as.mutable_atomic(x)
sb_set(x, ..., tf = \(x)x[1])
return(x)
}
sys.source(file.path(getwd(), "source", "sourcetest-errors.R"), envir = environment())
# set-up ====
setwd("D:/D Desktop/Publications/R package squarebrackets")
sessionInfo()
pkgs <- c("devtools", "roxygen2", "usethis", "rcmdcheck", "spelling", "tinytex",
"tinytest",
"Rcpp", "pkgdown", "tinytest")
for(i in pkgs) if(!requireNamespace(i))install.packages(i)
library(tinytest)
# install(file.path("D:/D Desktop/Publications/ImageMagick-7.1.0-62-Q16-HDRI-x64-dll"))
# tinytex::install_tinytex()
# tinytex::tlmgr_install("unfonts-extra")
# tinytex::tlmgr_install("makeindex")
#  create("squarebrackets")
# Rcpp::Rcpp.package.skeleton("squarebrackets")
# set version ====
package_tarname <- "squarebrackets_0.0.0.9.tar.gz"
# document ====
Rcpp::compileAttributes("squarebrackets")
devtools::document("./squarebrackets")
tinytest::run_test_dir("./squarebrackets/inst/tinytest/generic")
tinytest::run_test_dir("./squarebrackets/inst/tinytest/generic")
# set-up ====
enumerate <- 0 # to count number of tests in loops
source(file.path(getwd(), "source", "functions4testing.R"))
setwd("D:/D Desktop/Publications/R package squarebrackets/squarebrackets/inst/tinytest/generic")
# set-up ====
enumerate <- 0 # to count number of tests in loops
source(file.path(getwd(), "source", "functions4testing.R"))
test_allow_duplicates <- FALSE
test_use_factors <- FALSE
test_PassByReference <- TRUE
sb_set2 <- function(x, ...) {
x <- data.table::copy(x)
if(is.atomic(x)) x <- as.mutable_atomic(x)
x2 <- x
sb_set(x, ...)
expect_equal(x, x2) |> errorfun()
return(x)
}
sb_set2.array <- function(x, ...) {
x <- data.table::copy(x)
if(is.atomic(x)) x <- as.mutable_atomic(x)
x2 <- x
sb_set.array(x, ...)
expect_equal(x, x2) |> errorfun()
return(x)
}
# test missing arguments (NULL) ====
temp.fun <- function(x) {
tempfun <- function(x) {
x <- as.mutable_atomic(x)
x[] <- x[1]
return(x)
}
expect_equal(
sb_set2(x, rp = x[1]),
tempfun(x)
) |> errorfun()
}
sys.source(file.path(getwd(), "source", "sourcetest-missingargs.R"), envir = environment())
# test elements ====
test_sb <- function(x, i, rp) {
if(is.atomic(x)) x <- as.mutable_atomic(x)
i <- indx_x(i, x, names(x), length(x))
if(length(i) == 0) return(x)
x[i] <- rp
return(x)
}
temp.fun <- function(x, elements) {
for (i in 1:length(elements)) {
rp1 <- rp2 <- rep(1L, length(indx_x(elements[[i]], x, names(x), length(x))))
if(is.list(x)) rp1 <- as.list(rp1)
if(is.list(x) && length(rep) != 1) rp2 <- as.list(rp)
expect_equal(
sb_set2(x, i = elements[[i]], rp = rp1),
test_sb(x, i = elements[[i]], rp = rp2)
) |> errorfun()
assign("enumerate", enumerate + 1, envir = parent.frame(n = 1))
}
}
sys.source(file.path(getwd(), "source", "sourcetest-elements.R"), envir = environment())
# test matrix & array ====
rep3.bind <- function(x, dim) {
return(abind::abind(x, x, x, along = dim))
}
pre_subset_mat <- function(x, row = NULL, col = NULL) {
if(!is.null(row)) row <- indx_x(row, x, rownames(x), nrow(x))
if(!is.null(col)) col <- indx_x(col, x, colnames(x), ncol(x))
if(any_empty_indices(row, col)) {
return(x)
}
if(is.null(row)) row <- seq_len(nrow(x))
if(is.null(col)) col <- seq_len(ncol(x))
return(x[row, col])
}
subset_mat <- function(x, row = NULL, col = NULL, rp) {
if(is.atomic(x)) x <- as.mutable_atomic(x)
if(!is.null(row)) row <- indx_x(row, x, rownames(x), nrow(x))
if(!is.null(col)) col <- indx_x(col, x, colnames(x), ncol(x))
if(any_empty_indices(row, col)) {
return(x)
}
if(is.null(row)) row <- seq_len(nrow(x))
if(is.null(col)) col <- seq_len(ncol(x))
x[row, col] <- rp
return(x)
}
temp.fun.matrix <- function(x, row, col) {
for(i in 1:length(row)) {
for(j in 1:length(col)) {
len <- length(pre_subset_mat(x, row[[i]], col[[j]]))
rp <- sample(c(seq_len(len), NA), size = len)
expect_equal(
sb_set2(x, row = row[[i]], col = col[[j]], rp = rp),
subset_mat(x, row[[i]], col[[j]], rp = rp)
) |> errorfun()
expect_true(sb_set2(x, row = row[[i]], col = col[[j]], rp = rp) |>
is.matrix()) |> errorfun()
rp <- NA
expect_equal(
sb_set2(x, row = row[[i]], col = col[[j]], rp = rp),
subset_mat(x, row[[i]], col[[j]], rp = rp)
) |> errorfun()
expect_true(sb_set2(x, row = row[[i]], col = col[[j]], rp = rp) |>
is.matrix()) |> errorfun()
assign("enumerate", enumerate + 4, envir = parent.frame(n = 1))
}
}
}
subset_1d <- function(x, i, rp) {
if(is.atomic(x)) x <- as.mutable_atomic(x)
i <- indx_x(i, x, dimnames(x)[[1]], length(x))
if(any_empty_indices(i)) {
return(x)
}
x[i] <- rp
return(x)
}
temp.fun.1d <- function(x, row) {
for(i in 1:length(row)) {
rp <- seq_along(indx_x(row[[i]], x, dimnames(x)[[1]], length(x)))
expect_equal(
sb_set2(x, row[[i]], 1, rp = rp),
subset_1d(x, row[[i]], rp = rp)
) |> errorfun()
expect_true(sb_set2(x, row[[i]], 1, rp = rp) |>
is.array()) |> errorfun()
rp <- NA
expect_equal(
sb_set2(x, row[[i]], 1, rp = rp),
subset_1d(x, row[[i]], rp = rp)
) |> errorfun()
expect_true(sb_set2(x, row[[i]], 1, rp = rp) |>
is.array()) |> errorfun()
assign("enumerate", enumerate + 4, envir = parent.frame(n = 1))
}
}
temp.fun.2d <- function(x, row, col) {
for(i in 1:length(row)) {
for(j in 1:length(col)) {
len <- length(pre_subset_mat(x, row[[i]], col[[j]]))
rp <- sample(c(seq_len(len), NA), size = len)
sub <- n(row[[i]], col[[j]])
dims <- 1:2
rem <- which(vapply(sub, is.null, logical(1L)))
if(length(rem) > 0L) {
sub <- sub[-rem]
dims <- dims[-rem]
}
expect_equal(
sb_set2.array(x, sub, dims, rp = rp),
subset_mat(x, row[[i]], col[[j]], rp = rp)
) |> errorfun()
expect_true(sb_set2.array(x, sub, dims, rp = rp) |>
is.array()) |> errorfun()
rp <- NA
expect_equal(
sb_set2.array(x, sub, dims, rp = rp),
subset_mat(x, row[[i]], col[[j]], rp = rp)
) |> errorfun()
expect_true(sb_set2.array(x, sub, dims, rp = rp) |>
is.array()) |> errorfun()
assign("enumerate", enumerate + 4, envir = parent.frame(n = 1))
}
}
}
sb_test <- function(x, ...) {
x <- as.mutable_atomic(x)
rp <- sb_x.array(x, ...) * -1
sb_set.array(x, ..., rp = rp)
return(x)
}
temp.fun.arbitrary <- function(x, i, j, l) {
if(is.atomic(x)) x <- as.mutable_atomic(x)
tf <- mean
i <- indx_x(i, x, rownames(x), nrow(x))
j <- indx_x(j, x, colnames(x), ncol(x))
l <- indx_x(l, x, dimnames(x)[4], dim(x)[4])
rp <- x[i, j, , l] * -1
x[i, j, , l] <- rp
return(x)
}
sys.source(file.path(getwd(), "source", "sourcetest-dims.R"), envir = environment())
# test arbitrary dimensions with NA ====
subset_arr <- function(x, i, j, l, rp) {
i <- indx_x(i, x, rownames(x), nrow(x))
j <- indx_x(j, x, colnames(x), ncol(x))
l <- indx_x(l, x, dimnames(x)[4], dim(x)[4])
x[i, j, , l] <- rp
return(x)
}
make_rp <- function(len) {
return(sample(as.integer(c(seq_len(len)*-1, NA)), size = len))
}
x <- mutable_atomic(seq_len(10^4), dim = c(10, 10, 10, 10))
rownames(x) <- c(letters[1:8], "a", NA)
sub <- list(c("b", "a"), c(1:3), c(rep(TRUE, 5), rep(FALSE, 5)))
dims <- c(1,2,4)
len <- length(sb_x(x, sub, dims))
rp <- make_rp(len)
expect_equal(
sb_set2(x, sub, dims, rp = rp),
subset_arr(x, sub[[1]], sub[[2]], sub[[3]], rp)
)
rp <- NA
expect_equal(
sb_set2(x, sub, dims, rp = rp),
subset_arr(x, sub[[1]], sub[[2]], sub[[3]], rp)
)
sub <- list(c("b", "a"), logical(0), c(rep(TRUE, 5), rep(FALSE, 5)))
dims <- c(1,2,4)
len <- length(sb_x(x, sub, dims))
rp <- make_rp(len)
expect_equal(
sb_set2(x, sub, dims, rp = rp),
subset_arr(x, sub[[1]], sub[[2]], sub[[3]], rp)
)
rp <- NA
expect_equal(
sb_set2(x, sub, dims, rp = rp),
subset_arr(x, sub[[1]], sub[[2]], sub[[3]], rp)
)
sub <- list(c("b", "a"), c(1:4), rep(FALSE, 10))
dims <- c(1,2,4)
len <- length(sb_x(x, sub, dims))
rp <- make_rp(len)
expect_equal(
sb_set2(x, sub, dims, rp = rp),
subset_arr(x, sub[[1]], sub[[2]], sub[[3]], rp)
)
rp <- NA
expect_equal(
sb_set2(x, sub, dims, rp = rp),
subset_arr(x, sub[[1]], sub[[2]], sub[[3]], rp)
)
enumerate <- enumerate + 6
# test errors ====
sb_test <- function(x, ...) {
x <- as.mutable_atomic(x)
rp <- sb_x.array(x, ...) * -1
sb_set(x, ..., rp = rp)
return(x)
}
sys.source(file.path(getwd(), "source", "sourcetest-errors.R"), envir = environment())
sb_test <- function(x, ...) {
x <- as.mutable_atomic(x)
rp <- sb_set(x, ...) * -1
sb_set(x, ..., rp = rp)
return(x)
}
sys.source(file.path(getwd(), "source", "sourcetest-errors.R"), envir = environment())
sb_test <- function(x, ...) {
x <- as.mutable_atomic(x)
rp <- sb_set(x, ...) * -1
sb_set(x, ...)
return(x)
}
sys.source(file.path(getwd(), "source", "sourcetest-errors.R"), envir = environment())
sb_test <- function(x, ...) {
x <- as.mutable_atomic(x)
sb_set(x, ...)
return(x)
}
sys.source(file.path(getwd(), "source", "sourcetest-errors.R"), envir = environment())
rlang::last_trace()
sb_test <- function(x, ...) {
x <- as.mutable_atomic(x)
sb_set(x, ..., rp = 1)
return(x)
}
sys.source(file.path(getwd(), "source", "sourcetest-errors.R"), envir = environment())
sb_test <- function(x, ...) {
x <- as.mutable_atomic(x)
sb_set(x, ..., inv = TRUE, rp = 1)
return(x)
}
sys.source(file.path(getwd(), "source", "sourcetest-errors.R"), envir = environment())
sb_test <- function(x, ...) {
x <- as.mutable_atomic(x)
sb_set(x, ..., tf = \(x)x[1])
return(x)
}
sys.source(file.path(getwd(), "source", "sourcetest-errors.R"), envir = environment())
# test errors ====
sb_test <- function(x, ...) {
x <- data.table::copy(x)
sb_set(x, ..., tf = \(x)x[1])
return(x)
}
sys.source(file.path(getwd(), "source", "sourcetest-errors.R"), envir = environment())
